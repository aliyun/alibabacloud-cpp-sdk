// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_EMR20160408_H_
#define ALIBABACLOUD_EMR20160408_H_

#include <alibabacloud/open_api.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Emr20160408 {
class AddClusterServiceRequestService : public Darabonba::Model {
public:
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceVersion{};

  AddClusterServiceRequestService() {}

  explicit AddClusterServiceRequestService(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (serviceVersion) {
      res["ServiceVersion"] = boost::any(*serviceVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServiceVersion") != m.end() && !m["ServiceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["ServiceVersion"]));
    }
  }


  virtual ~AddClusterServiceRequestService() = default;
};
class AddClusterServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> comment{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<AddClusterServiceRequestService>> service{};

  AddClusterServiceRequest() {}

  explicit AddClusterServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (service) {
      vector<boost::any> temp1;
      for(auto item1:*service){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Service"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Service") != m.end() && !m["Service"].empty()) {
      if (typeid(vector<boost::any>) == m["Service"].type()) {
        vector<AddClusterServiceRequestService> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Service"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddClusterServiceRequestService model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        service = make_shared<vector<AddClusterServiceRequestService>>(expect1);
      }
    }
  }


  virtual ~AddClusterServiceRequest() = default;
};
class AddClusterServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddClusterServiceResponseBody() {}

  explicit AddClusterServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddClusterServiceResponseBody() = default;
};
class AddClusterServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddClusterServiceResponseBody> body{};

  AddClusterServiceResponse() {}

  explicit AddClusterServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddClusterServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddClusterServiceResponseBody>(model1);
      }
    }
  }


  virtual ~AddClusterServiceResponse() = default;
};
class AddScalingConfigItemV2Request : public Darabonba::Model {
public:
  shared_ptr<string> configItemInformation{};
  shared_ptr<string> configItemType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingGroupBizId{};

  AddScalingConfigItemV2Request() {}

  explicit AddScalingConfigItemV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configItemInformation) {
      res["ConfigItemInformation"] = boost::any(*configItemInformation);
    }
    if (configItemType) {
      res["ConfigItemType"] = boost::any(*configItemType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigItemInformation") != m.end() && !m["ConfigItemInformation"].empty()) {
      configItemInformation = make_shared<string>(boost::any_cast<string>(m["ConfigItemInformation"]));
    }
    if (m.find("ConfigItemType") != m.end() && !m["ConfigItemType"].empty()) {
      configItemType = make_shared<string>(boost::any_cast<string>(m["ConfigItemType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
  }


  virtual ~AddScalingConfigItemV2Request() = default;
};
class AddScalingConfigItemV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  AddScalingConfigItemV2ResponseBody() {}

  explicit AddScalingConfigItemV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddScalingConfigItemV2ResponseBody() = default;
};
class AddScalingConfigItemV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddScalingConfigItemV2ResponseBody> body{};

  AddScalingConfigItemV2Response() {}

  explicit AddScalingConfigItemV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddScalingConfigItemV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddScalingConfigItemV2ResponseBody>(model1);
      }
    }
  }


  virtual ~AddScalingConfigItemV2Response() = default;
};
class CloneFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  CloneFlowRequest() {}

  explicit CloneFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CloneFlowRequest() = default;
};
class CloneFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  CloneFlowResponseBody() {}

  explicit CloneFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CloneFlowResponseBody() = default;
};
class CloneFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CloneFlowResponseBody> body{};

  CloneFlowResponse() {}

  explicit CloneFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CloneFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CloneFlowResponseBody>(model1);
      }
    }
  }


  virtual ~CloneFlowResponse() = default;
};
class CloneFlowJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  CloneFlowJobRequest() {}

  explicit CloneFlowJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CloneFlowJobRequest() = default;
};
class CloneFlowJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  CloneFlowJobResponseBody() {}

  explicit CloneFlowJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CloneFlowJobResponseBody() = default;
};
class CloneFlowJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CloneFlowJobResponseBody> body{};

  CloneFlowJobResponse() {}

  explicit CloneFlowJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CloneFlowJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CloneFlowJobResponseBody>(model1);
      }
    }
  }


  virtual ~CloneFlowJobResponse() = default;
};
class CreateClusterHostGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> comment{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<string> hostGroupParams{};
  shared_ptr<string> hostGroupType{};
  shared_ptr<string> payType{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> vswitchId{};

  CreateClusterHostGroupRequest() {}

  explicit CreateClusterHostGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (hostGroupParams) {
      res["HostGroupParams"] = boost::any(*hostGroupParams);
    }
    if (hostGroupType) {
      res["HostGroupType"] = boost::any(*hostGroupType);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("HostGroupParams") != m.end() && !m["HostGroupParams"].empty()) {
      hostGroupParams = make_shared<string>(boost::any_cast<string>(m["HostGroupParams"]));
    }
    if (m.find("HostGroupType") != m.end() && !m["HostGroupType"].empty()) {
      hostGroupType = make_shared<string>(boost::any_cast<string>(m["HostGroupType"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~CreateClusterHostGroupRequest() = default;
};
class CreateClusterHostGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> requestId{};

  CreateClusterHostGroupResponseBody() {}

  explicit CreateClusterHostGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateClusterHostGroupResponseBody() = default;
};
class CreateClusterHostGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateClusterHostGroupResponseBody> body{};

  CreateClusterHostGroupResponse() {}

  explicit CreateClusterHostGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateClusterHostGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateClusterHostGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateClusterHostGroupResponse() = default;
};
class CreateClusterTemplateRequestBootstrapAction : public Darabonba::Model {
public:
  shared_ptr<string> arg{};
  shared_ptr<string> executionFailStrategy{};
  shared_ptr<string> executionMoment{};
  shared_ptr<string> executionTarget{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};

  CreateClusterTemplateRequestBootstrapAction() {}

  explicit CreateClusterTemplateRequestBootstrapAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arg) {
      res["Arg"] = boost::any(*arg);
    }
    if (executionFailStrategy) {
      res["ExecutionFailStrategy"] = boost::any(*executionFailStrategy);
    }
    if (executionMoment) {
      res["ExecutionMoment"] = boost::any(*executionMoment);
    }
    if (executionTarget) {
      res["ExecutionTarget"] = boost::any(*executionTarget);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arg") != m.end() && !m["Arg"].empty()) {
      arg = make_shared<string>(boost::any_cast<string>(m["Arg"]));
    }
    if (m.find("ExecutionFailStrategy") != m.end() && !m["ExecutionFailStrategy"].empty()) {
      executionFailStrategy = make_shared<string>(boost::any_cast<string>(m["ExecutionFailStrategy"]));
    }
    if (m.find("ExecutionMoment") != m.end() && !m["ExecutionMoment"].empty()) {
      executionMoment = make_shared<string>(boost::any_cast<string>(m["ExecutionMoment"]));
    }
    if (m.find("ExecutionTarget") != m.end() && !m["ExecutionTarget"].empty()) {
      executionTarget = make_shared<string>(boost::any_cast<string>(m["ExecutionTarget"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~CreateClusterTemplateRequestBootstrapAction() = default;
};
class CreateClusterTemplateRequestConfig : public Darabonba::Model {
public:
  shared_ptr<string> configKey{};
  shared_ptr<string> configValue{};
  shared_ptr<string> encrypt{};
  shared_ptr<string> fileName{};
  shared_ptr<string> replace{};
  shared_ptr<string> serviceName{};

  CreateClusterTemplateRequestConfig() {}

  explicit CreateClusterTemplateRequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configKey) {
      res["ConfigKey"] = boost::any(*configKey);
    }
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (encrypt) {
      res["Encrypt"] = boost::any(*encrypt);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (replace) {
      res["Replace"] = boost::any(*replace);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigKey") != m.end() && !m["ConfigKey"].empty()) {
      configKey = make_shared<string>(boost::any_cast<string>(m["ConfigKey"]));
    }
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("Encrypt") != m.end() && !m["Encrypt"].empty()) {
      encrypt = make_shared<string>(boost::any_cast<string>(m["Encrypt"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Replace") != m.end() && !m["Replace"].empty()) {
      replace = make_shared<string>(boost::any_cast<string>(m["Replace"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~CreateClusterTemplateRequestConfig() = default;
};
class CreateClusterTemplateRequestHostGroup : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> comment{};
  shared_ptr<string> createType{};
  shared_ptr<long> diskCapacity{};
  shared_ptr<long> diskCount{};
  shared_ptr<string> diskType{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<string> hostGroupType{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> multiInstanceTypes{};
  shared_ptr<long> nodeCount{};
  shared_ptr<long> period{};
  shared_ptr<string> privatePoolOptionsId{};
  shared_ptr<string> privatePoolOptionsMatchCriteria{};
  shared_ptr<long> sysDiskCapacity{};
  shared_ptr<string> sysDiskType{};
  shared_ptr<string> vSwitchId{};

  CreateClusterTemplateRequestHostGroup() {}

  explicit CreateClusterTemplateRequestHostGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (createType) {
      res["CreateType"] = boost::any(*createType);
    }
    if (diskCapacity) {
      res["DiskCapacity"] = boost::any(*diskCapacity);
    }
    if (diskCount) {
      res["DiskCount"] = boost::any(*diskCount);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (hostGroupType) {
      res["HostGroupType"] = boost::any(*hostGroupType);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (multiInstanceTypes) {
      res["MultiInstanceTypes"] = boost::any(*multiInstanceTypes);
    }
    if (nodeCount) {
      res["NodeCount"] = boost::any(*nodeCount);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (privatePoolOptionsId) {
      res["PrivatePoolOptionsId"] = boost::any(*privatePoolOptionsId);
    }
    if (privatePoolOptionsMatchCriteria) {
      res["PrivatePoolOptionsMatchCriteria"] = boost::any(*privatePoolOptionsMatchCriteria);
    }
    if (sysDiskCapacity) {
      res["SysDiskCapacity"] = boost::any(*sysDiskCapacity);
    }
    if (sysDiskType) {
      res["SysDiskType"] = boost::any(*sysDiskType);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreateType") != m.end() && !m["CreateType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["CreateType"]));
    }
    if (m.find("DiskCapacity") != m.end() && !m["DiskCapacity"].empty()) {
      diskCapacity = make_shared<long>(boost::any_cast<long>(m["DiskCapacity"]));
    }
    if (m.find("DiskCount") != m.end() && !m["DiskCount"].empty()) {
      diskCount = make_shared<long>(boost::any_cast<long>(m["DiskCount"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("HostGroupType") != m.end() && !m["HostGroupType"].empty()) {
      hostGroupType = make_shared<string>(boost::any_cast<string>(m["HostGroupType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("MultiInstanceTypes") != m.end() && !m["MultiInstanceTypes"].empty()) {
      multiInstanceTypes = make_shared<string>(boost::any_cast<string>(m["MultiInstanceTypes"]));
    }
    if (m.find("NodeCount") != m.end() && !m["NodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["NodeCount"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PrivatePoolOptionsId") != m.end() && !m["PrivatePoolOptionsId"].empty()) {
      privatePoolOptionsId = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptionsId"]));
    }
    if (m.find("PrivatePoolOptionsMatchCriteria") != m.end() && !m["PrivatePoolOptionsMatchCriteria"].empty()) {
      privatePoolOptionsMatchCriteria = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptionsMatchCriteria"]));
    }
    if (m.find("SysDiskCapacity") != m.end() && !m["SysDiskCapacity"].empty()) {
      sysDiskCapacity = make_shared<long>(boost::any_cast<long>(m["SysDiskCapacity"]));
    }
    if (m.find("SysDiskType") != m.end() && !m["SysDiskType"].empty()) {
      sysDiskType = make_shared<string>(boost::any_cast<string>(m["SysDiskType"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~CreateClusterTemplateRequestHostGroup() = default;
};
class CreateClusterTemplateRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateClusterTemplateRequestTag() {}

  explicit CreateClusterTemplateRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateClusterTemplateRequestTag() = default;
};
class CreateClusterTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<vector<CreateClusterTemplateRequestBootstrapAction>> bootstrapAction{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> clusterType{};
  shared_ptr<vector<CreateClusterTemplateRequestConfig>> config{};
  shared_ptr<string> configurations{};
  shared_ptr<bool> dataDiskEncrypted{};
  shared_ptr<string> dataDiskKMSKeyId{};
  shared_ptr<string> depositType{};
  shared_ptr<bool> easEnable{};
  shared_ptr<string> emrVer{};
  shared_ptr<bool> highAvailabilityEnable{};
  shared_ptr<vector<CreateClusterTemplateRequestHostGroup>> hostGroup{};
  shared_ptr<bool> initCustomHiveMetaDb{};
  shared_ptr<string> instanceGeneration{};
  shared_ptr<bool> ioOptimized{};
  shared_ptr<bool> isOpenPublicIp{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> logPath{};
  shared_ptr<string> machineType{};
  shared_ptr<string> masterPwd{};
  shared_ptr<string> metaStoreConf{};
  shared_ptr<string> metaStoreType{};
  shared_ptr<string> netType{};
  shared_ptr<vector<string>> optionSoftWareList{};
  shared_ptr<long> period{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> securityGroupName{};
  shared_ptr<bool> sshEnable{};
  shared_ptr<vector<CreateClusterTemplateRequestTag>> tag{};
  shared_ptr<string> templateName{};
  shared_ptr<bool> useCustomHiveMetaDb{};
  shared_ptr<bool> useLocalMetaDb{};
  shared_ptr<string> userDefinedEmrEcsRole{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};

  CreateClusterTemplateRequest() {}

  explicit CreateClusterTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (bootstrapAction) {
      vector<boost::any> temp1;
      for(auto item1:*bootstrapAction){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BootstrapAction"] = boost::any(temp1);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (config) {
      vector<boost::any> temp1;
      for(auto item1:*config){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Config"] = boost::any(temp1);
    }
    if (configurations) {
      res["Configurations"] = boost::any(*configurations);
    }
    if (dataDiskEncrypted) {
      res["DataDiskEncrypted"] = boost::any(*dataDiskEncrypted);
    }
    if (dataDiskKMSKeyId) {
      res["DataDiskKMSKeyId"] = boost::any(*dataDiskKMSKeyId);
    }
    if (depositType) {
      res["DepositType"] = boost::any(*depositType);
    }
    if (easEnable) {
      res["EasEnable"] = boost::any(*easEnable);
    }
    if (emrVer) {
      res["EmrVer"] = boost::any(*emrVer);
    }
    if (highAvailabilityEnable) {
      res["HighAvailabilityEnable"] = boost::any(*highAvailabilityEnable);
    }
    if (hostGroup) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostGroup"] = boost::any(temp1);
    }
    if (initCustomHiveMetaDb) {
      res["InitCustomHiveMetaDb"] = boost::any(*initCustomHiveMetaDb);
    }
    if (instanceGeneration) {
      res["InstanceGeneration"] = boost::any(*instanceGeneration);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (isOpenPublicIp) {
      res["IsOpenPublicIp"] = boost::any(*isOpenPublicIp);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (machineType) {
      res["MachineType"] = boost::any(*machineType);
    }
    if (masterPwd) {
      res["MasterPwd"] = boost::any(*masterPwd);
    }
    if (metaStoreConf) {
      res["MetaStoreConf"] = boost::any(*metaStoreConf);
    }
    if (metaStoreType) {
      res["MetaStoreType"] = boost::any(*metaStoreType);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (optionSoftWareList) {
      res["OptionSoftWareList"] = boost::any(*optionSoftWareList);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    if (sshEnable) {
      res["SshEnable"] = boost::any(*sshEnable);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (useCustomHiveMetaDb) {
      res["UseCustomHiveMetaDb"] = boost::any(*useCustomHiveMetaDb);
    }
    if (useLocalMetaDb) {
      res["UseLocalMetaDb"] = boost::any(*useLocalMetaDb);
    }
    if (userDefinedEmrEcsRole) {
      res["UserDefinedEmrEcsRole"] = boost::any(*userDefinedEmrEcsRole);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("BootstrapAction") != m.end() && !m["BootstrapAction"].empty()) {
      if (typeid(vector<boost::any>) == m["BootstrapAction"].type()) {
        vector<CreateClusterTemplateRequestBootstrapAction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BootstrapAction"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterTemplateRequestBootstrapAction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bootstrapAction = make_shared<vector<CreateClusterTemplateRequestBootstrapAction>>(expect1);
      }
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(vector<boost::any>) == m["Config"].type()) {
        vector<CreateClusterTemplateRequestConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Config"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterTemplateRequestConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        config = make_shared<vector<CreateClusterTemplateRequestConfig>>(expect1);
      }
    }
    if (m.find("Configurations") != m.end() && !m["Configurations"].empty()) {
      configurations = make_shared<string>(boost::any_cast<string>(m["Configurations"]));
    }
    if (m.find("DataDiskEncrypted") != m.end() && !m["DataDiskEncrypted"].empty()) {
      dataDiskEncrypted = make_shared<bool>(boost::any_cast<bool>(m["DataDiskEncrypted"]));
    }
    if (m.find("DataDiskKMSKeyId") != m.end() && !m["DataDiskKMSKeyId"].empty()) {
      dataDiskKMSKeyId = make_shared<string>(boost::any_cast<string>(m["DataDiskKMSKeyId"]));
    }
    if (m.find("DepositType") != m.end() && !m["DepositType"].empty()) {
      depositType = make_shared<string>(boost::any_cast<string>(m["DepositType"]));
    }
    if (m.find("EasEnable") != m.end() && !m["EasEnable"].empty()) {
      easEnable = make_shared<bool>(boost::any_cast<bool>(m["EasEnable"]));
    }
    if (m.find("EmrVer") != m.end() && !m["EmrVer"].empty()) {
      emrVer = make_shared<string>(boost::any_cast<string>(m["EmrVer"]));
    }
    if (m.find("HighAvailabilityEnable") != m.end() && !m["HighAvailabilityEnable"].empty()) {
      highAvailabilityEnable = make_shared<bool>(boost::any_cast<bool>(m["HighAvailabilityEnable"]));
    }
    if (m.find("HostGroup") != m.end() && !m["HostGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["HostGroup"].type()) {
        vector<CreateClusterTemplateRequestHostGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterTemplateRequestHostGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroup = make_shared<vector<CreateClusterTemplateRequestHostGroup>>(expect1);
      }
    }
    if (m.find("InitCustomHiveMetaDb") != m.end() && !m["InitCustomHiveMetaDb"].empty()) {
      initCustomHiveMetaDb = make_shared<bool>(boost::any_cast<bool>(m["InitCustomHiveMetaDb"]));
    }
    if (m.find("InstanceGeneration") != m.end() && !m["InstanceGeneration"].empty()) {
      instanceGeneration = make_shared<string>(boost::any_cast<string>(m["InstanceGeneration"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<bool>(boost::any_cast<bool>(m["IoOptimized"]));
    }
    if (m.find("IsOpenPublicIp") != m.end() && !m["IsOpenPublicIp"].empty()) {
      isOpenPublicIp = make_shared<bool>(boost::any_cast<bool>(m["IsOpenPublicIp"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("MachineType") != m.end() && !m["MachineType"].empty()) {
      machineType = make_shared<string>(boost::any_cast<string>(m["MachineType"]));
    }
    if (m.find("MasterPwd") != m.end() && !m["MasterPwd"].empty()) {
      masterPwd = make_shared<string>(boost::any_cast<string>(m["MasterPwd"]));
    }
    if (m.find("MetaStoreConf") != m.end() && !m["MetaStoreConf"].empty()) {
      metaStoreConf = make_shared<string>(boost::any_cast<string>(m["MetaStoreConf"]));
    }
    if (m.find("MetaStoreType") != m.end() && !m["MetaStoreType"].empty()) {
      metaStoreType = make_shared<string>(boost::any_cast<string>(m["MetaStoreType"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("OptionSoftWareList") != m.end() && !m["OptionSoftWareList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OptionSoftWareList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OptionSoftWareList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      optionSoftWareList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
    if (m.find("SshEnable") != m.end() && !m["SshEnable"].empty()) {
      sshEnable = make_shared<bool>(boost::any_cast<bool>(m["SshEnable"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateClusterTemplateRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterTemplateRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateClusterTemplateRequestTag>>(expect1);
      }
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("UseCustomHiveMetaDb") != m.end() && !m["UseCustomHiveMetaDb"].empty()) {
      useCustomHiveMetaDb = make_shared<bool>(boost::any_cast<bool>(m["UseCustomHiveMetaDb"]));
    }
    if (m.find("UseLocalMetaDb") != m.end() && !m["UseLocalMetaDb"].empty()) {
      useLocalMetaDb = make_shared<bool>(boost::any_cast<bool>(m["UseLocalMetaDb"]));
    }
    if (m.find("UserDefinedEmrEcsRole") != m.end() && !m["UserDefinedEmrEcsRole"].empty()) {
      userDefinedEmrEcsRole = make_shared<string>(boost::any_cast<string>(m["UserDefinedEmrEcsRole"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateClusterTemplateRequest() = default;
};
class CreateClusterTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterTemplateId{};
  shared_ptr<string> requestId{};

  CreateClusterTemplateResponseBody() {}

  explicit CreateClusterTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterTemplateId) {
      res["ClusterTemplateId"] = boost::any(*clusterTemplateId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterTemplateId") != m.end() && !m["ClusterTemplateId"].empty()) {
      clusterTemplateId = make_shared<string>(boost::any_cast<string>(m["ClusterTemplateId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateClusterTemplateResponseBody() = default;
};
class CreateClusterTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateClusterTemplateResponseBody> body{};

  CreateClusterTemplateResponse() {}

  explicit CreateClusterTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateClusterTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateClusterTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateClusterTemplateResponse() = default;
};
class CreateClusterV2RequestBootstrapAction : public Darabonba::Model {
public:
  shared_ptr<string> arg{};
  shared_ptr<string> executionFailStrategy{};
  shared_ptr<string> executionMoment{};
  shared_ptr<string> executionTarget{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};

  CreateClusterV2RequestBootstrapAction() {}

  explicit CreateClusterV2RequestBootstrapAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arg) {
      res["Arg"] = boost::any(*arg);
    }
    if (executionFailStrategy) {
      res["ExecutionFailStrategy"] = boost::any(*executionFailStrategy);
    }
    if (executionMoment) {
      res["ExecutionMoment"] = boost::any(*executionMoment);
    }
    if (executionTarget) {
      res["ExecutionTarget"] = boost::any(*executionTarget);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arg") != m.end() && !m["Arg"].empty()) {
      arg = make_shared<string>(boost::any_cast<string>(m["Arg"]));
    }
    if (m.find("ExecutionFailStrategy") != m.end() && !m["ExecutionFailStrategy"].empty()) {
      executionFailStrategy = make_shared<string>(boost::any_cast<string>(m["ExecutionFailStrategy"]));
    }
    if (m.find("ExecutionMoment") != m.end() && !m["ExecutionMoment"].empty()) {
      executionMoment = make_shared<string>(boost::any_cast<string>(m["ExecutionMoment"]));
    }
    if (m.find("ExecutionTarget") != m.end() && !m["ExecutionTarget"].empty()) {
      executionTarget = make_shared<string>(boost::any_cast<string>(m["ExecutionTarget"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~CreateClusterV2RequestBootstrapAction() = default;
};
class CreateClusterV2RequestConfig : public Darabonba::Model {
public:
  shared_ptr<string> configKey{};
  shared_ptr<string> configValue{};
  shared_ptr<string> encrypt{};
  shared_ptr<string> fileName{};
  shared_ptr<string> replace{};
  shared_ptr<string> serviceName{};

  CreateClusterV2RequestConfig() {}

  explicit CreateClusterV2RequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configKey) {
      res["ConfigKey"] = boost::any(*configKey);
    }
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (encrypt) {
      res["Encrypt"] = boost::any(*encrypt);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (replace) {
      res["Replace"] = boost::any(*replace);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigKey") != m.end() && !m["ConfigKey"].empty()) {
      configKey = make_shared<string>(boost::any_cast<string>(m["ConfigKey"]));
    }
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("Encrypt") != m.end() && !m["Encrypt"].empty()) {
      encrypt = make_shared<string>(boost::any_cast<string>(m["Encrypt"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Replace") != m.end() && !m["Replace"].empty()) {
      replace = make_shared<string>(boost::any_cast<string>(m["Replace"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~CreateClusterV2RequestConfig() = default;
};
class CreateClusterV2RequestHostComponentInfo : public Darabonba::Model {
public:
  shared_ptr<vector<string>> componentNameList{};
  shared_ptr<string> hostName{};
  shared_ptr<string> serviceName{};

  CreateClusterV2RequestHostComponentInfo() {}

  explicit CreateClusterV2RequestHostComponentInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentNameList) {
      res["ComponentNameList"] = boost::any(*componentNameList);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentNameList") != m.end() && !m["ComponentNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~CreateClusterV2RequestHostComponentInfo() = default;
};
class CreateClusterV2RequestHostGroup : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> comment{};
  shared_ptr<string> createType{};
  shared_ptr<long> diskCapacity{};
  shared_ptr<long> diskCount{};
  shared_ptr<string> diskType{};
  shared_ptr<string> gpuDriver{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<string> hostGroupType{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> nodeCount{};
  shared_ptr<long> period{};
  shared_ptr<string> privatePoolOptionsId{};
  shared_ptr<string> privatePoolOptionsMatchCriteria{};
  shared_ptr<long> sysDiskCapacity{};
  shared_ptr<string> sysDiskType{};
  shared_ptr<string> vSwitchId{};

  CreateClusterV2RequestHostGroup() {}

  explicit CreateClusterV2RequestHostGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (createType) {
      res["CreateType"] = boost::any(*createType);
    }
    if (diskCapacity) {
      res["DiskCapacity"] = boost::any(*diskCapacity);
    }
    if (diskCount) {
      res["DiskCount"] = boost::any(*diskCount);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (gpuDriver) {
      res["GpuDriver"] = boost::any(*gpuDriver);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (hostGroupType) {
      res["HostGroupType"] = boost::any(*hostGroupType);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (nodeCount) {
      res["NodeCount"] = boost::any(*nodeCount);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (privatePoolOptionsId) {
      res["PrivatePoolOptionsId"] = boost::any(*privatePoolOptionsId);
    }
    if (privatePoolOptionsMatchCriteria) {
      res["PrivatePoolOptionsMatchCriteria"] = boost::any(*privatePoolOptionsMatchCriteria);
    }
    if (sysDiskCapacity) {
      res["SysDiskCapacity"] = boost::any(*sysDiskCapacity);
    }
    if (sysDiskType) {
      res["SysDiskType"] = boost::any(*sysDiskType);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreateType") != m.end() && !m["CreateType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["CreateType"]));
    }
    if (m.find("DiskCapacity") != m.end() && !m["DiskCapacity"].empty()) {
      diskCapacity = make_shared<long>(boost::any_cast<long>(m["DiskCapacity"]));
    }
    if (m.find("DiskCount") != m.end() && !m["DiskCount"].empty()) {
      diskCount = make_shared<long>(boost::any_cast<long>(m["DiskCount"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("GpuDriver") != m.end() && !m["GpuDriver"].empty()) {
      gpuDriver = make_shared<string>(boost::any_cast<string>(m["GpuDriver"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("HostGroupType") != m.end() && !m["HostGroupType"].empty()) {
      hostGroupType = make_shared<string>(boost::any_cast<string>(m["HostGroupType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("NodeCount") != m.end() && !m["NodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["NodeCount"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PrivatePoolOptionsId") != m.end() && !m["PrivatePoolOptionsId"].empty()) {
      privatePoolOptionsId = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptionsId"]));
    }
    if (m.find("PrivatePoolOptionsMatchCriteria") != m.end() && !m["PrivatePoolOptionsMatchCriteria"].empty()) {
      privatePoolOptionsMatchCriteria = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptionsMatchCriteria"]));
    }
    if (m.find("SysDiskCapacity") != m.end() && !m["SysDiskCapacity"].empty()) {
      sysDiskCapacity = make_shared<long>(boost::any_cast<long>(m["SysDiskCapacity"]));
    }
    if (m.find("SysDiskType") != m.end() && !m["SysDiskType"].empty()) {
      sysDiskType = make_shared<string>(boost::any_cast<string>(m["SysDiskType"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~CreateClusterV2RequestHostGroup() = default;
};
class CreateClusterV2RequestPromotionInfo : public Darabonba::Model {
public:
  shared_ptr<string> productCode{};
  shared_ptr<string> promotionOptionCode{};
  shared_ptr<string> promotionOptionNo{};

  CreateClusterV2RequestPromotionInfo() {}

  explicit CreateClusterV2RequestPromotionInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (promotionOptionCode) {
      res["PromotionOptionCode"] = boost::any(*promotionOptionCode);
    }
    if (promotionOptionNo) {
      res["PromotionOptionNo"] = boost::any(*promotionOptionNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("PromotionOptionCode") != m.end() && !m["PromotionOptionCode"].empty()) {
      promotionOptionCode = make_shared<string>(boost::any_cast<string>(m["PromotionOptionCode"]));
    }
    if (m.find("PromotionOptionNo") != m.end() && !m["PromotionOptionNo"].empty()) {
      promotionOptionNo = make_shared<string>(boost::any_cast<string>(m["PromotionOptionNo"]));
    }
  }


  virtual ~CreateClusterV2RequestPromotionInfo() = default;
};
class CreateClusterV2RequestServiceInfo : public Darabonba::Model {
public:
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceVersion{};

  CreateClusterV2RequestServiceInfo() {}

  explicit CreateClusterV2RequestServiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (serviceVersion) {
      res["ServiceVersion"] = boost::any(*serviceVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServiceVersion") != m.end() && !m["ServiceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["ServiceVersion"]));
    }
  }


  virtual ~CreateClusterV2RequestServiceInfo() = default;
};
class CreateClusterV2RequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateClusterV2RequestTag() {}

  explicit CreateClusterV2RequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateClusterV2RequestTag() = default;
};
class CreateClusterV2RequestUserInfo : public Darabonba::Model {
public:
  shared_ptr<string> password{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  CreateClusterV2RequestUserInfo() {}

  explicit CreateClusterV2RequestUserInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~CreateClusterV2RequestUserInfo() = default;
};
class CreateClusterV2Request : public Darabonba::Model {
public:
  shared_ptr<string> authorizeContent{};
  shared_ptr<bool> autoPayOrder{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<vector<CreateClusterV2RequestBootstrapAction>> bootstrapAction{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> clickHouseConf{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> clusterType{};
  shared_ptr<vector<CreateClusterV2RequestConfig>> config{};
  shared_ptr<string> configurations{};
  shared_ptr<bool> dataDiskEncrypted{};
  shared_ptr<string> dataDiskKMSKeyId{};
  shared_ptr<string> depositType{};
  shared_ptr<bool> easEnable{};
  shared_ptr<string> emrVer{};
  shared_ptr<string> extraAttributes{};
  shared_ptr<bool> highAvailabilityEnable{};
  shared_ptr<vector<CreateClusterV2RequestHostComponentInfo>> hostComponentInfo{};
  shared_ptr<vector<CreateClusterV2RequestHostGroup>> hostGroup{};
  shared_ptr<bool> initCustomHiveMetaDB{};
  shared_ptr<string> instanceGeneration{};
  shared_ptr<bool> ioOptimized{};
  shared_ptr<bool> isOpenPublicIp{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> logPath{};
  shared_ptr<string> machineType{};
  shared_ptr<string> masterPwd{};
  shared_ptr<string> metaStoreConf{};
  shared_ptr<string> metaStoreType{};
  shared_ptr<string> name{};
  shared_ptr<string> netType{};
  shared_ptr<vector<string>> optionSoftWareList{};
  shared_ptr<long> period{};
  shared_ptr<vector<CreateClusterV2RequestPromotionInfo>> promotionInfo{};
  shared_ptr<string> regionId{};
  shared_ptr<string> relatedClusterId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> securityGroupName{};
  shared_ptr<vector<CreateClusterV2RequestServiceInfo>> serviceInfo{};
  shared_ptr<bool> sshEnable{};
  shared_ptr<vector<CreateClusterV2RequestTag>> tag{};
  shared_ptr<bool> useCustomHiveMetaDB{};
  shared_ptr<bool> useLocalMetaDb{};
  shared_ptr<string> userDefinedEmrEcsRole{};
  shared_ptr<vector<CreateClusterV2RequestUserInfo>> userInfo{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> whiteListType{};
  shared_ptr<string> zoneId{};

  CreateClusterV2Request() {}

  explicit CreateClusterV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizeContent) {
      res["AuthorizeContent"] = boost::any(*authorizeContent);
    }
    if (autoPayOrder) {
      res["AutoPayOrder"] = boost::any(*autoPayOrder);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (bootstrapAction) {
      vector<boost::any> temp1;
      for(auto item1:*bootstrapAction){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BootstrapAction"] = boost::any(temp1);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clickHouseConf) {
      res["ClickHouseConf"] = boost::any(*clickHouseConf);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (config) {
      vector<boost::any> temp1;
      for(auto item1:*config){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Config"] = boost::any(temp1);
    }
    if (configurations) {
      res["Configurations"] = boost::any(*configurations);
    }
    if (dataDiskEncrypted) {
      res["DataDiskEncrypted"] = boost::any(*dataDiskEncrypted);
    }
    if (dataDiskKMSKeyId) {
      res["DataDiskKMSKeyId"] = boost::any(*dataDiskKMSKeyId);
    }
    if (depositType) {
      res["DepositType"] = boost::any(*depositType);
    }
    if (easEnable) {
      res["EasEnable"] = boost::any(*easEnable);
    }
    if (emrVer) {
      res["EmrVer"] = boost::any(*emrVer);
    }
    if (extraAttributes) {
      res["ExtraAttributes"] = boost::any(*extraAttributes);
    }
    if (highAvailabilityEnable) {
      res["HighAvailabilityEnable"] = boost::any(*highAvailabilityEnable);
    }
    if (hostComponentInfo) {
      vector<boost::any> temp1;
      for(auto item1:*hostComponentInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostComponentInfo"] = boost::any(temp1);
    }
    if (hostGroup) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostGroup"] = boost::any(temp1);
    }
    if (initCustomHiveMetaDB) {
      res["InitCustomHiveMetaDB"] = boost::any(*initCustomHiveMetaDB);
    }
    if (instanceGeneration) {
      res["InstanceGeneration"] = boost::any(*instanceGeneration);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (isOpenPublicIp) {
      res["IsOpenPublicIp"] = boost::any(*isOpenPublicIp);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (machineType) {
      res["MachineType"] = boost::any(*machineType);
    }
    if (masterPwd) {
      res["MasterPwd"] = boost::any(*masterPwd);
    }
    if (metaStoreConf) {
      res["MetaStoreConf"] = boost::any(*metaStoreConf);
    }
    if (metaStoreType) {
      res["MetaStoreType"] = boost::any(*metaStoreType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (optionSoftWareList) {
      res["OptionSoftWareList"] = boost::any(*optionSoftWareList);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (promotionInfo) {
      vector<boost::any> temp1;
      for(auto item1:*promotionInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PromotionInfo"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (relatedClusterId) {
      res["RelatedClusterId"] = boost::any(*relatedClusterId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    if (serviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*serviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceInfo"] = boost::any(temp1);
    }
    if (sshEnable) {
      res["SshEnable"] = boost::any(*sshEnable);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (useCustomHiveMetaDB) {
      res["UseCustomHiveMetaDB"] = boost::any(*useCustomHiveMetaDB);
    }
    if (useLocalMetaDb) {
      res["UseLocalMetaDb"] = boost::any(*useLocalMetaDb);
    }
    if (userDefinedEmrEcsRole) {
      res["UserDefinedEmrEcsRole"] = boost::any(*userDefinedEmrEcsRole);
    }
    if (userInfo) {
      vector<boost::any> temp1;
      for(auto item1:*userInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserInfo"] = boost::any(temp1);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (whiteListType) {
      res["WhiteListType"] = boost::any(*whiteListType);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizeContent") != m.end() && !m["AuthorizeContent"].empty()) {
      authorizeContent = make_shared<string>(boost::any_cast<string>(m["AuthorizeContent"]));
    }
    if (m.find("AutoPayOrder") != m.end() && !m["AutoPayOrder"].empty()) {
      autoPayOrder = make_shared<bool>(boost::any_cast<bool>(m["AutoPayOrder"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("BootstrapAction") != m.end() && !m["BootstrapAction"].empty()) {
      if (typeid(vector<boost::any>) == m["BootstrapAction"].type()) {
        vector<CreateClusterV2RequestBootstrapAction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BootstrapAction"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterV2RequestBootstrapAction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bootstrapAction = make_shared<vector<CreateClusterV2RequestBootstrapAction>>(expect1);
      }
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClickHouseConf") != m.end() && !m["ClickHouseConf"].empty()) {
      clickHouseConf = make_shared<string>(boost::any_cast<string>(m["ClickHouseConf"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(vector<boost::any>) == m["Config"].type()) {
        vector<CreateClusterV2RequestConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Config"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterV2RequestConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        config = make_shared<vector<CreateClusterV2RequestConfig>>(expect1);
      }
    }
    if (m.find("Configurations") != m.end() && !m["Configurations"].empty()) {
      configurations = make_shared<string>(boost::any_cast<string>(m["Configurations"]));
    }
    if (m.find("DataDiskEncrypted") != m.end() && !m["DataDiskEncrypted"].empty()) {
      dataDiskEncrypted = make_shared<bool>(boost::any_cast<bool>(m["DataDiskEncrypted"]));
    }
    if (m.find("DataDiskKMSKeyId") != m.end() && !m["DataDiskKMSKeyId"].empty()) {
      dataDiskKMSKeyId = make_shared<string>(boost::any_cast<string>(m["DataDiskKMSKeyId"]));
    }
    if (m.find("DepositType") != m.end() && !m["DepositType"].empty()) {
      depositType = make_shared<string>(boost::any_cast<string>(m["DepositType"]));
    }
    if (m.find("EasEnable") != m.end() && !m["EasEnable"].empty()) {
      easEnable = make_shared<bool>(boost::any_cast<bool>(m["EasEnable"]));
    }
    if (m.find("EmrVer") != m.end() && !m["EmrVer"].empty()) {
      emrVer = make_shared<string>(boost::any_cast<string>(m["EmrVer"]));
    }
    if (m.find("ExtraAttributes") != m.end() && !m["ExtraAttributes"].empty()) {
      extraAttributes = make_shared<string>(boost::any_cast<string>(m["ExtraAttributes"]));
    }
    if (m.find("HighAvailabilityEnable") != m.end() && !m["HighAvailabilityEnable"].empty()) {
      highAvailabilityEnable = make_shared<bool>(boost::any_cast<bool>(m["HighAvailabilityEnable"]));
    }
    if (m.find("HostComponentInfo") != m.end() && !m["HostComponentInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["HostComponentInfo"].type()) {
        vector<CreateClusterV2RequestHostComponentInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostComponentInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterV2RequestHostComponentInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostComponentInfo = make_shared<vector<CreateClusterV2RequestHostComponentInfo>>(expect1);
      }
    }
    if (m.find("HostGroup") != m.end() && !m["HostGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["HostGroup"].type()) {
        vector<CreateClusterV2RequestHostGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterV2RequestHostGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroup = make_shared<vector<CreateClusterV2RequestHostGroup>>(expect1);
      }
    }
    if (m.find("InitCustomHiveMetaDB") != m.end() && !m["InitCustomHiveMetaDB"].empty()) {
      initCustomHiveMetaDB = make_shared<bool>(boost::any_cast<bool>(m["InitCustomHiveMetaDB"]));
    }
    if (m.find("InstanceGeneration") != m.end() && !m["InstanceGeneration"].empty()) {
      instanceGeneration = make_shared<string>(boost::any_cast<string>(m["InstanceGeneration"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<bool>(boost::any_cast<bool>(m["IoOptimized"]));
    }
    if (m.find("IsOpenPublicIp") != m.end() && !m["IsOpenPublicIp"].empty()) {
      isOpenPublicIp = make_shared<bool>(boost::any_cast<bool>(m["IsOpenPublicIp"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("MachineType") != m.end() && !m["MachineType"].empty()) {
      machineType = make_shared<string>(boost::any_cast<string>(m["MachineType"]));
    }
    if (m.find("MasterPwd") != m.end() && !m["MasterPwd"].empty()) {
      masterPwd = make_shared<string>(boost::any_cast<string>(m["MasterPwd"]));
    }
    if (m.find("MetaStoreConf") != m.end() && !m["MetaStoreConf"].empty()) {
      metaStoreConf = make_shared<string>(boost::any_cast<string>(m["MetaStoreConf"]));
    }
    if (m.find("MetaStoreType") != m.end() && !m["MetaStoreType"].empty()) {
      metaStoreType = make_shared<string>(boost::any_cast<string>(m["MetaStoreType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("OptionSoftWareList") != m.end() && !m["OptionSoftWareList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OptionSoftWareList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OptionSoftWareList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      optionSoftWareList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PromotionInfo") != m.end() && !m["PromotionInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PromotionInfo"].type()) {
        vector<CreateClusterV2RequestPromotionInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PromotionInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterV2RequestPromotionInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        promotionInfo = make_shared<vector<CreateClusterV2RequestPromotionInfo>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RelatedClusterId") != m.end() && !m["RelatedClusterId"].empty()) {
      relatedClusterId = make_shared<string>(boost::any_cast<string>(m["RelatedClusterId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
    if (m.find("ServiceInfo") != m.end() && !m["ServiceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceInfo"].type()) {
        vector<CreateClusterV2RequestServiceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterV2RequestServiceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceInfo = make_shared<vector<CreateClusterV2RequestServiceInfo>>(expect1);
      }
    }
    if (m.find("SshEnable") != m.end() && !m["SshEnable"].empty()) {
      sshEnable = make_shared<bool>(boost::any_cast<bool>(m["SshEnable"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateClusterV2RequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterV2RequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateClusterV2RequestTag>>(expect1);
      }
    }
    if (m.find("UseCustomHiveMetaDB") != m.end() && !m["UseCustomHiveMetaDB"].empty()) {
      useCustomHiveMetaDB = make_shared<bool>(boost::any_cast<bool>(m["UseCustomHiveMetaDB"]));
    }
    if (m.find("UseLocalMetaDb") != m.end() && !m["UseLocalMetaDb"].empty()) {
      useLocalMetaDb = make_shared<bool>(boost::any_cast<bool>(m["UseLocalMetaDb"]));
    }
    if (m.find("UserDefinedEmrEcsRole") != m.end() && !m["UserDefinedEmrEcsRole"].empty()) {
      userDefinedEmrEcsRole = make_shared<string>(boost::any_cast<string>(m["UserDefinedEmrEcsRole"]));
    }
    if (m.find("UserInfo") != m.end() && !m["UserInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["UserInfo"].type()) {
        vector<CreateClusterV2RequestUserInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterV2RequestUserInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userInfo = make_shared<vector<CreateClusterV2RequestUserInfo>>(expect1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("WhiteListType") != m.end() && !m["WhiteListType"].empty()) {
      whiteListType = make_shared<string>(boost::any_cast<string>(m["WhiteListType"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateClusterV2Request() = default;
};
class CreateClusterV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> coreOrderId{};
  shared_ptr<string> emrOrderId{};
  shared_ptr<string> masterOrderId{};
  shared_ptr<string> requestId{};

  CreateClusterV2ResponseBody() {}

  explicit CreateClusterV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (coreOrderId) {
      res["CoreOrderId"] = boost::any(*coreOrderId);
    }
    if (emrOrderId) {
      res["EmrOrderId"] = boost::any(*emrOrderId);
    }
    if (masterOrderId) {
      res["MasterOrderId"] = boost::any(*masterOrderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CoreOrderId") != m.end() && !m["CoreOrderId"].empty()) {
      coreOrderId = make_shared<string>(boost::any_cast<string>(m["CoreOrderId"]));
    }
    if (m.find("EmrOrderId") != m.end() && !m["EmrOrderId"].empty()) {
      emrOrderId = make_shared<string>(boost::any_cast<string>(m["EmrOrderId"]));
    }
    if (m.find("MasterOrderId") != m.end() && !m["MasterOrderId"].empty()) {
      masterOrderId = make_shared<string>(boost::any_cast<string>(m["MasterOrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateClusterV2ResponseBody() = default;
};
class CreateClusterV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateClusterV2ResponseBody> body{};

  CreateClusterV2Response() {}

  explicit CreateClusterV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateClusterV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateClusterV2ResponseBody>(model1);
      }
    }
  }


  virtual ~CreateClusterV2Response() = default;
};
class CreateClusterWithTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateBizId{};
  shared_ptr<string> uniqueTag{};

  CreateClusterWithTemplateRequest() {}

  explicit CreateClusterWithTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateBizId) {
      res["TemplateBizId"] = boost::any(*templateBizId);
    }
    if (uniqueTag) {
      res["UniqueTag"] = boost::any(*uniqueTag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateBizId") != m.end() && !m["TemplateBizId"].empty()) {
      templateBizId = make_shared<string>(boost::any_cast<string>(m["TemplateBizId"]));
    }
    if (m.find("UniqueTag") != m.end() && !m["UniqueTag"].empty()) {
      uniqueTag = make_shared<string>(boost::any_cast<string>(m["UniqueTag"]));
    }
  }


  virtual ~CreateClusterWithTemplateRequest() = default;
};
class CreateClusterWithTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> coreOrderId{};
  shared_ptr<string> emrOrderId{};
  shared_ptr<string> masterOrderId{};
  shared_ptr<string> requestId{};

  CreateClusterWithTemplateResponseBody() {}

  explicit CreateClusterWithTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (coreOrderId) {
      res["CoreOrderId"] = boost::any(*coreOrderId);
    }
    if (emrOrderId) {
      res["EmrOrderId"] = boost::any(*emrOrderId);
    }
    if (masterOrderId) {
      res["MasterOrderId"] = boost::any(*masterOrderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CoreOrderId") != m.end() && !m["CoreOrderId"].empty()) {
      coreOrderId = make_shared<string>(boost::any_cast<string>(m["CoreOrderId"]));
    }
    if (m.find("EmrOrderId") != m.end() && !m["EmrOrderId"].empty()) {
      emrOrderId = make_shared<string>(boost::any_cast<string>(m["EmrOrderId"]));
    }
    if (m.find("MasterOrderId") != m.end() && !m["MasterOrderId"].empty()) {
      masterOrderId = make_shared<string>(boost::any_cast<string>(m["MasterOrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateClusterWithTemplateResponseBody() = default;
};
class CreateClusterWithTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateClusterWithTemplateResponseBody> body{};

  CreateClusterWithTemplateResponse() {}

  explicit CreateClusterWithTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateClusterWithTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateClusterWithTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateClusterWithTemplateResponse() = default;
};
class CreateFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertConf{};
  shared_ptr<string> alertDingDingGroupBizId{};
  shared_ptr<string> alertUserGroupBizId{};
  shared_ptr<string> application{};
  shared_ptr<string> clusterId{};
  shared_ptr<bool> createCluster{};
  shared_ptr<string> cronExpr{};
  shared_ptr<string> description{};
  shared_ptr<long> endSchedule{};
  shared_ptr<string> hostName{};
  shared_ptr<string> lifecycle{};
  shared_ptr<string> logArchiveLocation{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> parentCategory{};
  shared_ptr<string> parentFlowList{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startSchedule{};

  CreateFlowRequest() {}

  explicit CreateFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertConf) {
      res["AlertConf"] = boost::any(*alertConf);
    }
    if (alertDingDingGroupBizId) {
      res["AlertDingDingGroupBizId"] = boost::any(*alertDingDingGroupBizId);
    }
    if (alertUserGroupBizId) {
      res["AlertUserGroupBizId"] = boost::any(*alertUserGroupBizId);
    }
    if (application) {
      res["Application"] = boost::any(*application);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (createCluster) {
      res["CreateCluster"] = boost::any(*createCluster);
    }
    if (cronExpr) {
      res["CronExpr"] = boost::any(*cronExpr);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endSchedule) {
      res["EndSchedule"] = boost::any(*endSchedule);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (lifecycle) {
      res["Lifecycle"] = boost::any(*lifecycle);
    }
    if (logArchiveLocation) {
      res["LogArchiveLocation"] = boost::any(*logArchiveLocation);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (parentCategory) {
      res["ParentCategory"] = boost::any(*parentCategory);
    }
    if (parentFlowList) {
      res["ParentFlowList"] = boost::any(*parentFlowList);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startSchedule) {
      res["StartSchedule"] = boost::any(*startSchedule);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertConf") != m.end() && !m["AlertConf"].empty()) {
      alertConf = make_shared<string>(boost::any_cast<string>(m["AlertConf"]));
    }
    if (m.find("AlertDingDingGroupBizId") != m.end() && !m["AlertDingDingGroupBizId"].empty()) {
      alertDingDingGroupBizId = make_shared<string>(boost::any_cast<string>(m["AlertDingDingGroupBizId"]));
    }
    if (m.find("AlertUserGroupBizId") != m.end() && !m["AlertUserGroupBizId"].empty()) {
      alertUserGroupBizId = make_shared<string>(boost::any_cast<string>(m["AlertUserGroupBizId"]));
    }
    if (m.find("Application") != m.end() && !m["Application"].empty()) {
      application = make_shared<string>(boost::any_cast<string>(m["Application"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CreateCluster") != m.end() && !m["CreateCluster"].empty()) {
      createCluster = make_shared<bool>(boost::any_cast<bool>(m["CreateCluster"]));
    }
    if (m.find("CronExpr") != m.end() && !m["CronExpr"].empty()) {
      cronExpr = make_shared<string>(boost::any_cast<string>(m["CronExpr"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndSchedule") != m.end() && !m["EndSchedule"].empty()) {
      endSchedule = make_shared<long>(boost::any_cast<long>(m["EndSchedule"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Lifecycle") != m.end() && !m["Lifecycle"].empty()) {
      lifecycle = make_shared<string>(boost::any_cast<string>(m["Lifecycle"]));
    }
    if (m.find("LogArchiveLocation") != m.end() && !m["LogArchiveLocation"].empty()) {
      logArchiveLocation = make_shared<string>(boost::any_cast<string>(m["LogArchiveLocation"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("ParentCategory") != m.end() && !m["ParentCategory"].empty()) {
      parentCategory = make_shared<string>(boost::any_cast<string>(m["ParentCategory"]));
    }
    if (m.find("ParentFlowList") != m.end() && !m["ParentFlowList"].empty()) {
      parentFlowList = make_shared<string>(boost::any_cast<string>(m["ParentFlowList"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartSchedule") != m.end() && !m["StartSchedule"].empty()) {
      startSchedule = make_shared<long>(boost::any_cast<long>(m["StartSchedule"]));
    }
  }


  virtual ~CreateFlowRequest() = default;
};
class CreateFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  CreateFlowResponseBody() {}

  explicit CreateFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateFlowResponseBody() = default;
};
class CreateFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFlowResponseBody> body{};

  CreateFlowResponse() {}

  explicit CreateFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFlowResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFlowResponse() = default;
};
class CreateFlowCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> parentId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  CreateFlowCategoryRequest() {}

  explicit CreateFlowCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateFlowCategoryRequest() = default;
};
class CreateFlowCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  CreateFlowCategoryResponseBody() {}

  explicit CreateFlowCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateFlowCategoryResponseBody() = default;
};
class CreateFlowCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFlowCategoryResponseBody> body{};

  CreateFlowCategoryResponse() {}

  explicit CreateFlowCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFlowCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFlowCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFlowCategoryResponse() = default;
};
class CreateFlowForWebRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertConf{};
  shared_ptr<string> alertDingDingGroupBizId{};
  shared_ptr<string> alertUserGroupBizId{};
  shared_ptr<string> clusterId{};
  shared_ptr<bool> createCluster{};
  shared_ptr<string> cronExpr{};
  shared_ptr<string> description{};
  shared_ptr<long> endSchedule{};
  shared_ptr<string> graph{};
  shared_ptr<string> hostName{};
  shared_ptr<string> lifecycle{};
  shared_ptr<string> logArchiveLocation{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> parentCategory{};
  shared_ptr<string> parentFlowList{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startSchedule{};

  CreateFlowForWebRequest() {}

  explicit CreateFlowForWebRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertConf) {
      res["AlertConf"] = boost::any(*alertConf);
    }
    if (alertDingDingGroupBizId) {
      res["AlertDingDingGroupBizId"] = boost::any(*alertDingDingGroupBizId);
    }
    if (alertUserGroupBizId) {
      res["AlertUserGroupBizId"] = boost::any(*alertUserGroupBizId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (createCluster) {
      res["CreateCluster"] = boost::any(*createCluster);
    }
    if (cronExpr) {
      res["CronExpr"] = boost::any(*cronExpr);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endSchedule) {
      res["EndSchedule"] = boost::any(*endSchedule);
    }
    if (graph) {
      res["Graph"] = boost::any(*graph);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (lifecycle) {
      res["Lifecycle"] = boost::any(*lifecycle);
    }
    if (logArchiveLocation) {
      res["LogArchiveLocation"] = boost::any(*logArchiveLocation);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (parentCategory) {
      res["ParentCategory"] = boost::any(*parentCategory);
    }
    if (parentFlowList) {
      res["ParentFlowList"] = boost::any(*parentFlowList);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startSchedule) {
      res["StartSchedule"] = boost::any(*startSchedule);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertConf") != m.end() && !m["AlertConf"].empty()) {
      alertConf = make_shared<string>(boost::any_cast<string>(m["AlertConf"]));
    }
    if (m.find("AlertDingDingGroupBizId") != m.end() && !m["AlertDingDingGroupBizId"].empty()) {
      alertDingDingGroupBizId = make_shared<string>(boost::any_cast<string>(m["AlertDingDingGroupBizId"]));
    }
    if (m.find("AlertUserGroupBizId") != m.end() && !m["AlertUserGroupBizId"].empty()) {
      alertUserGroupBizId = make_shared<string>(boost::any_cast<string>(m["AlertUserGroupBizId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CreateCluster") != m.end() && !m["CreateCluster"].empty()) {
      createCluster = make_shared<bool>(boost::any_cast<bool>(m["CreateCluster"]));
    }
    if (m.find("CronExpr") != m.end() && !m["CronExpr"].empty()) {
      cronExpr = make_shared<string>(boost::any_cast<string>(m["CronExpr"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndSchedule") != m.end() && !m["EndSchedule"].empty()) {
      endSchedule = make_shared<long>(boost::any_cast<long>(m["EndSchedule"]));
    }
    if (m.find("Graph") != m.end() && !m["Graph"].empty()) {
      graph = make_shared<string>(boost::any_cast<string>(m["Graph"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Lifecycle") != m.end() && !m["Lifecycle"].empty()) {
      lifecycle = make_shared<string>(boost::any_cast<string>(m["Lifecycle"]));
    }
    if (m.find("LogArchiveLocation") != m.end() && !m["LogArchiveLocation"].empty()) {
      logArchiveLocation = make_shared<string>(boost::any_cast<string>(m["LogArchiveLocation"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("ParentCategory") != m.end() && !m["ParentCategory"].empty()) {
      parentCategory = make_shared<string>(boost::any_cast<string>(m["ParentCategory"]));
    }
    if (m.find("ParentFlowList") != m.end() && !m["ParentFlowList"].empty()) {
      parentFlowList = make_shared<string>(boost::any_cast<string>(m["ParentFlowList"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartSchedule") != m.end() && !m["StartSchedule"].empty()) {
      startSchedule = make_shared<long>(boost::any_cast<long>(m["StartSchedule"]));
    }
  }


  virtual ~CreateFlowForWebRequest() = default;
};
class CreateFlowForWebResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  CreateFlowForWebResponseBody() {}

  explicit CreateFlowForWebResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateFlowForWebResponseBody() = default;
};
class CreateFlowForWebResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFlowForWebResponseBody> body{};

  CreateFlowForWebResponse() {}

  explicit CreateFlowForWebResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFlowForWebResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFlowForWebResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFlowForWebResponse() = default;
};
class CreateFlowJobRequestResourceList : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> path{};

  CreateFlowJobRequestResourceList() {}

  explicit CreateFlowJobRequestResourceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~CreateFlowJobRequestResourceList() = default;
};
class CreateFlowJobRequest : public Darabonba::Model {
public:
  shared_ptr<bool> adhoc{};
  shared_ptr<string> alertConf{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> customVariables{};
  shared_ptr<string> description{};
  shared_ptr<string> envConf{};
  shared_ptr<string> failAct{};
  shared_ptr<long> maxRetry{};
  shared_ptr<long> maxRunningTimeSec{};
  shared_ptr<string> mode{};
  shared_ptr<string> monitorConf{};
  shared_ptr<string> name{};
  shared_ptr<string> paramConf{};
  shared_ptr<string> params{};
  shared_ptr<string> parentCategory{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<CreateFlowJobRequestResourceList>> resourceList{};
  shared_ptr<long> retryInterval{};
  shared_ptr<string> retryPolicy{};
  shared_ptr<string> runConf{};
  shared_ptr<string> type{};

  CreateFlowJobRequest() {}

  explicit CreateFlowJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adhoc) {
      res["Adhoc"] = boost::any(*adhoc);
    }
    if (alertConf) {
      res["AlertConf"] = boost::any(*alertConf);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (customVariables) {
      res["CustomVariables"] = boost::any(*customVariables);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envConf) {
      res["EnvConf"] = boost::any(*envConf);
    }
    if (failAct) {
      res["FailAct"] = boost::any(*failAct);
    }
    if (maxRetry) {
      res["MaxRetry"] = boost::any(*maxRetry);
    }
    if (maxRunningTimeSec) {
      res["MaxRunningTimeSec"] = boost::any(*maxRunningTimeSec);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (monitorConf) {
      res["MonitorConf"] = boost::any(*monitorConf);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (paramConf) {
      res["ParamConf"] = boost::any(*paramConf);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (parentCategory) {
      res["ParentCategory"] = boost::any(*parentCategory);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceList) {
      vector<boost::any> temp1;
      for(auto item1:*resourceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceList"] = boost::any(temp1);
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (retryPolicy) {
      res["RetryPolicy"] = boost::any(*retryPolicy);
    }
    if (runConf) {
      res["RunConf"] = boost::any(*runConf);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Adhoc") != m.end() && !m["Adhoc"].empty()) {
      adhoc = make_shared<bool>(boost::any_cast<bool>(m["Adhoc"]));
    }
    if (m.find("AlertConf") != m.end() && !m["AlertConf"].empty()) {
      alertConf = make_shared<string>(boost::any_cast<string>(m["AlertConf"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CustomVariables") != m.end() && !m["CustomVariables"].empty()) {
      customVariables = make_shared<string>(boost::any_cast<string>(m["CustomVariables"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvConf") != m.end() && !m["EnvConf"].empty()) {
      envConf = make_shared<string>(boost::any_cast<string>(m["EnvConf"]));
    }
    if (m.find("FailAct") != m.end() && !m["FailAct"].empty()) {
      failAct = make_shared<string>(boost::any_cast<string>(m["FailAct"]));
    }
    if (m.find("MaxRetry") != m.end() && !m["MaxRetry"].empty()) {
      maxRetry = make_shared<long>(boost::any_cast<long>(m["MaxRetry"]));
    }
    if (m.find("MaxRunningTimeSec") != m.end() && !m["MaxRunningTimeSec"].empty()) {
      maxRunningTimeSec = make_shared<long>(boost::any_cast<long>(m["MaxRunningTimeSec"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("MonitorConf") != m.end() && !m["MonitorConf"].empty()) {
      monitorConf = make_shared<string>(boost::any_cast<string>(m["MonitorConf"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParamConf") != m.end() && !m["ParamConf"].empty()) {
      paramConf = make_shared<string>(boost::any_cast<string>(m["ParamConf"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("ParentCategory") != m.end() && !m["ParentCategory"].empty()) {
      parentCategory = make_shared<string>(boost::any_cast<string>(m["ParentCategory"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceList") != m.end() && !m["ResourceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceList"].type()) {
        vector<CreateFlowJobRequestResourceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateFlowJobRequestResourceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceList = make_shared<vector<CreateFlowJobRequestResourceList>>(expect1);
      }
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<long>(boost::any_cast<long>(m["RetryInterval"]));
    }
    if (m.find("RetryPolicy") != m.end() && !m["RetryPolicy"].empty()) {
      retryPolicy = make_shared<string>(boost::any_cast<string>(m["RetryPolicy"]));
    }
    if (m.find("RunConf") != m.end() && !m["RunConf"].empty()) {
      runConf = make_shared<string>(boost::any_cast<string>(m["RunConf"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateFlowJobRequest() = default;
};
class CreateFlowJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  CreateFlowJobResponseBody() {}

  explicit CreateFlowJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateFlowJobResponseBody() = default;
};
class CreateFlowJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFlowJobResponseBody> body{};

  CreateFlowJobResponse() {}

  explicit CreateFlowJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFlowJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFlowJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFlowJobResponse() = default;
};
class CreateFlowProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> productType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};

  CreateFlowProjectRequest() {}

  explicit CreateFlowProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~CreateFlowProjectRequest() = default;
};
class CreateFlowProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  CreateFlowProjectResponseBody() {}

  explicit CreateFlowProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateFlowProjectResponseBody() = default;
};
class CreateFlowProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFlowProjectResponseBody> body{};

  CreateFlowProjectResponse() {}

  explicit CreateFlowProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFlowProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFlowProjectResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFlowProjectResponse() = default;
};
class CreateFlowProjectClusterSettingRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> defaultQueue{};
  shared_ptr<string> defaultUser{};
  shared_ptr<vector<string>> hostList{};
  shared_ptr<string> projectId{};
  shared_ptr<vector<string>> queueList{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> userList{};

  CreateFlowProjectClusterSettingRequest() {}

  explicit CreateFlowProjectClusterSettingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (defaultQueue) {
      res["DefaultQueue"] = boost::any(*defaultQueue);
    }
    if (defaultUser) {
      res["DefaultUser"] = boost::any(*defaultUser);
    }
    if (hostList) {
      res["HostList"] = boost::any(*hostList);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (queueList) {
      res["QueueList"] = boost::any(*queueList);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userList) {
      res["UserList"] = boost::any(*userList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DefaultQueue") != m.end() && !m["DefaultQueue"].empty()) {
      defaultQueue = make_shared<string>(boost::any_cast<string>(m["DefaultQueue"]));
    }
    if (m.find("DefaultUser") != m.end() && !m["DefaultUser"].empty()) {
      defaultUser = make_shared<string>(boost::any_cast<string>(m["DefaultUser"]));
    }
    if (m.find("HostList") != m.end() && !m["HostList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HostList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HostList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("QueueList") != m.end() && !m["QueueList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["QueueList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["QueueList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      queueList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateFlowProjectClusterSettingRequest() = default;
};
class CreateFlowProjectClusterSettingResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  CreateFlowProjectClusterSettingResponseBody() {}

  explicit CreateFlowProjectClusterSettingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateFlowProjectClusterSettingResponseBody() = default;
};
class CreateFlowProjectClusterSettingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFlowProjectClusterSettingResponseBody> body{};

  CreateFlowProjectClusterSettingResponse() {}

  explicit CreateFlowProjectClusterSettingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFlowProjectClusterSettingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFlowProjectClusterSettingResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFlowProjectClusterSettingResponse() = default;
};
class CreateFlowProjectUserRequestUser : public Darabonba::Model {
public:
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};

  CreateFlowProjectUserRequestUser() {}

  explicit CreateFlowProjectUserRequestUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~CreateFlowProjectUserRequestUser() = default;
};
class CreateFlowProjectUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<CreateFlowProjectUserRequestUser>> user{};

  CreateFlowProjectUserRequest() {}

  explicit CreateFlowProjectUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (user) {
      vector<boost::any> temp1;
      for(auto item1:*user){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["User"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(vector<boost::any>) == m["User"].type()) {
        vector<CreateFlowProjectUserRequestUser> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["User"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateFlowProjectUserRequestUser model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        user = make_shared<vector<CreateFlowProjectUserRequestUser>>(expect1);
      }
    }
  }


  virtual ~CreateFlowProjectUserRequest() = default;
};
class CreateFlowProjectUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  CreateFlowProjectUserResponseBody() {}

  explicit CreateFlowProjectUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateFlowProjectUserResponseBody() = default;
};
class CreateFlowProjectUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFlowProjectUserResponseBody> body{};

  CreateFlowProjectUserResponse() {}

  explicit CreateFlowProjectUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFlowProjectUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFlowProjectUserResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFlowProjectUserResponse() = default;
};
class CreateResourcePoolRequestConfig : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> configKey{};
  shared_ptr<string> configValue{};
  shared_ptr<string> note{};
  shared_ptr<string> targetId{};
  shared_ptr<string> configType{};

  CreateResourcePoolRequestConfig() {}

  explicit CreateResourcePoolRequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (configKey) {
      res["ConfigKey"] = boost::any(*configKey);
    }
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    if (configType) {
      res["configType"] = boost::any(*configType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("ConfigKey") != m.end() && !m["ConfigKey"].empty()) {
      configKey = make_shared<string>(boost::any_cast<string>(m["ConfigKey"]));
    }
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      targetId = make_shared<string>(boost::any_cast<string>(m["TargetId"]));
    }
    if (m.find("configType") != m.end() && !m["configType"].empty()) {
      configType = make_shared<string>(boost::any_cast<string>(m["configType"]));
    }
  }


  virtual ~CreateResourcePoolRequestConfig() = default;
};
class CreateResourcePoolRequest : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<string> clusterId{};
  shared_ptr<vector<CreateResourcePoolRequestConfig>> config{};
  shared_ptr<string> name{};
  shared_ptr<string> note{};
  shared_ptr<string> poolType{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> yarnSiteConfig{};

  CreateResourcePoolRequest() {}

  explicit CreateResourcePoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (config) {
      vector<boost::any> temp1;
      for(auto item1:*config){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Config"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (poolType) {
      res["PoolType"] = boost::any(*poolType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (yarnSiteConfig) {
      res["YarnSiteConfig"] = boost::any(*yarnSiteConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(vector<boost::any>) == m["Config"].type()) {
        vector<CreateResourcePoolRequestConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Config"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateResourcePoolRequestConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        config = make_shared<vector<CreateResourcePoolRequestConfig>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("PoolType") != m.end() && !m["PoolType"].empty()) {
      poolType = make_shared<string>(boost::any_cast<string>(m["PoolType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("YarnSiteConfig") != m.end() && !m["YarnSiteConfig"].empty()) {
      yarnSiteConfig = make_shared<string>(boost::any_cast<string>(m["YarnSiteConfig"]));
    }
  }


  virtual ~CreateResourcePoolRequest() = default;
};
class CreateResourcePoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateResourcePoolResponseBody() {}

  explicit CreateResourcePoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateResourcePoolResponseBody() = default;
};
class CreateResourcePoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateResourcePoolResponseBody> body{};

  CreateResourcePoolResponse() {}

  explicit CreateResourcePoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateResourcePoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateResourcePoolResponseBody>(model1);
      }
    }
  }


  virtual ~CreateResourcePoolResponse() = default;
};
class CreateResourceQueueRequestConfig : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> configKey{};
  shared_ptr<string> configValue{};
  shared_ptr<string> note{};

  CreateResourceQueueRequestConfig() {}

  explicit CreateResourceQueueRequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (configKey) {
      res["ConfigKey"] = boost::any(*configKey);
    }
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("ConfigKey") != m.end() && !m["ConfigKey"].empty()) {
      configKey = make_shared<string>(boost::any_cast<string>(m["ConfigKey"]));
    }
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
  }


  virtual ~CreateResourceQueueRequestConfig() = default;
};
class CreateResourceQueueRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<vector<CreateResourceQueueRequestConfig>> config{};
  shared_ptr<bool> leaf{};
  shared_ptr<string> name{};
  shared_ptr<long> parentQueueId{};
  shared_ptr<string> qualifiedName{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> resourcePoolId{};

  CreateResourceQueueRequest() {}

  explicit CreateResourceQueueRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (config) {
      vector<boost::any> temp1;
      for(auto item1:*config){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Config"] = boost::any(temp1);
    }
    if (leaf) {
      res["Leaf"] = boost::any(*leaf);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentQueueId) {
      res["ParentQueueId"] = boost::any(*parentQueueId);
    }
    if (qualifiedName) {
      res["QualifiedName"] = boost::any(*qualifiedName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourcePoolId) {
      res["ResourcePoolId"] = boost::any(*resourcePoolId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(vector<boost::any>) == m["Config"].type()) {
        vector<CreateResourceQueueRequestConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Config"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateResourceQueueRequestConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        config = make_shared<vector<CreateResourceQueueRequestConfig>>(expect1);
      }
    }
    if (m.find("Leaf") != m.end() && !m["Leaf"].empty()) {
      leaf = make_shared<bool>(boost::any_cast<bool>(m["Leaf"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentQueueId") != m.end() && !m["ParentQueueId"].empty()) {
      parentQueueId = make_shared<long>(boost::any_cast<long>(m["ParentQueueId"]));
    }
    if (m.find("QualifiedName") != m.end() && !m["QualifiedName"].empty()) {
      qualifiedName = make_shared<string>(boost::any_cast<string>(m["QualifiedName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourcePoolId") != m.end() && !m["ResourcePoolId"].empty()) {
      resourcePoolId = make_shared<long>(boost::any_cast<long>(m["ResourcePoolId"]));
    }
  }


  virtual ~CreateResourceQueueRequest() = default;
};
class CreateResourceQueueResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateResourceQueueResponseBody() {}

  explicit CreateResourceQueueResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateResourceQueueResponseBody() = default;
};
class CreateResourceQueueResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateResourceQueueResponseBody> body{};

  CreateResourceQueueResponse() {}

  explicit CreateResourceQueueResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateResourceQueueResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateResourceQueueResponseBody>(model1);
      }
    }
  }


  virtual ~CreateResourceQueueResponse() = default;
};
class CreateScalingGroupV2Request : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};

  CreateScalingGroupV2Request() {}

  explicit CreateScalingGroupV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateScalingGroupV2Request() = default;
};
class CreateScalingGroupV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  CreateScalingGroupV2ResponseBody() {}

  explicit CreateScalingGroupV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateScalingGroupV2ResponseBody() = default;
};
class CreateScalingGroupV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateScalingGroupV2ResponseBody> body{};

  CreateScalingGroupV2Response() {}

  explicit CreateScalingGroupV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateScalingGroupV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateScalingGroupV2ResponseBody>(model1);
      }
    }
  }


  virtual ~CreateScalingGroupV2Response() = default;
};
class DeleteClusterTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};

  DeleteClusterTemplateRequest() {}

  explicit DeleteClusterTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteClusterTemplateRequest() = default;
};
class DeleteClusterTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteClusterTemplateResponseBody() {}

  explicit DeleteClusterTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteClusterTemplateResponseBody() = default;
};
class DeleteClusterTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteClusterTemplateResponseBody> body{};

  DeleteClusterTemplateResponse() {}

  explicit DeleteClusterTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteClusterTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteClusterTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteClusterTemplateResponse() = default;
};
class DeleteFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  DeleteFlowRequest() {}

  explicit DeleteFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteFlowRequest() = default;
};
class DeleteFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  DeleteFlowResponseBody() {}

  explicit DeleteFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteFlowResponseBody() = default;
};
class DeleteFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFlowResponseBody> body{};

  DeleteFlowResponse() {}

  explicit DeleteFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFlowResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFlowResponse() = default;
};
class DeleteFlowCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  DeleteFlowCategoryRequest() {}

  explicit DeleteFlowCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteFlowCategoryRequest() = default;
};
class DeleteFlowCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  DeleteFlowCategoryResponseBody() {}

  explicit DeleteFlowCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteFlowCategoryResponseBody() = default;
};
class DeleteFlowCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFlowCategoryResponseBody> body{};

  DeleteFlowCategoryResponse() {}

  explicit DeleteFlowCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFlowCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFlowCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFlowCategoryResponse() = default;
};
class DeleteFlowJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  DeleteFlowJobRequest() {}

  explicit DeleteFlowJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteFlowJobRequest() = default;
};
class DeleteFlowJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  DeleteFlowJobResponseBody() {}

  explicit DeleteFlowJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteFlowJobResponseBody() = default;
};
class DeleteFlowJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFlowJobResponseBody> body{};

  DeleteFlowJobResponse() {}

  explicit DeleteFlowJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFlowJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFlowJobResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFlowJobResponse() = default;
};
class DeleteFlowProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  DeleteFlowProjectRequest() {}

  explicit DeleteFlowProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteFlowProjectRequest() = default;
};
class DeleteFlowProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  DeleteFlowProjectResponseBody() {}

  explicit DeleteFlowProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteFlowProjectResponseBody() = default;
};
class DeleteFlowProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFlowProjectResponseBody> body{};

  DeleteFlowProjectResponse() {}

  explicit DeleteFlowProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFlowProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFlowProjectResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFlowProjectResponse() = default;
};
class DeleteFlowProjectClusterSettingRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  DeleteFlowProjectClusterSettingRequest() {}

  explicit DeleteFlowProjectClusterSettingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteFlowProjectClusterSettingRequest() = default;
};
class DeleteFlowProjectClusterSettingResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  DeleteFlowProjectClusterSettingResponseBody() {}

  explicit DeleteFlowProjectClusterSettingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteFlowProjectClusterSettingResponseBody() = default;
};
class DeleteFlowProjectClusterSettingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFlowProjectClusterSettingResponseBody> body{};

  DeleteFlowProjectClusterSettingResponse() {}

  explicit DeleteFlowProjectClusterSettingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFlowProjectClusterSettingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFlowProjectClusterSettingResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFlowProjectClusterSettingResponse() = default;
};
class DeleteFlowProjectUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userName{};

  DeleteFlowProjectUserRequest() {}

  explicit DeleteFlowProjectUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DeleteFlowProjectUserRequest() = default;
};
class DeleteFlowProjectUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  DeleteFlowProjectUserResponseBody() {}

  explicit DeleteFlowProjectUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteFlowProjectUserResponseBody() = default;
};
class DeleteFlowProjectUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFlowProjectUserResponseBody> body{};

  DeleteFlowProjectUserResponse() {}

  explicit DeleteFlowProjectUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFlowProjectUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFlowProjectUserResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFlowProjectUserResponse() = default;
};
class DeleteResourcePoolRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourcePoolId{};

  DeleteResourcePoolRequest() {}

  explicit DeleteResourcePoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourcePoolId) {
      res["ResourcePoolId"] = boost::any(*resourcePoolId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourcePoolId") != m.end() && !m["ResourcePoolId"].empty()) {
      resourcePoolId = make_shared<string>(boost::any_cast<string>(m["ResourcePoolId"]));
    }
  }


  virtual ~DeleteResourcePoolRequest() = default;
};
class DeleteResourcePoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteResourcePoolResponseBody() {}

  explicit DeleteResourcePoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteResourcePoolResponseBody() = default;
};
class DeleteResourcePoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteResourcePoolResponseBody> body{};

  DeleteResourcePoolResponse() {}

  explicit DeleteResourcePoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteResourcePoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteResourcePoolResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteResourcePoolResponse() = default;
};
class DeleteResourceQueueRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceQueueId{};

  DeleteResourceQueueRequest() {}

  explicit DeleteResourceQueueRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceQueueId) {
      res["ResourceQueueId"] = boost::any(*resourceQueueId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceQueueId") != m.end() && !m["ResourceQueueId"].empty()) {
      resourceQueueId = make_shared<string>(boost::any_cast<string>(m["ResourceQueueId"]));
    }
  }


  virtual ~DeleteResourceQueueRequest() = default;
};
class DeleteResourceQueueResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteResourceQueueResponseBody() {}

  explicit DeleteResourceQueueResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteResourceQueueResponseBody() = default;
};
class DeleteResourceQueueResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteResourceQueueResponseBody> body{};

  DeleteResourceQueueResponse() {}

  explicit DeleteResourceQueueResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteResourceQueueResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteResourceQueueResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteResourceQueueResponse() = default;
};
class DescribeClusterBasicInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};

  DescribeClusterBasicInfoRequest() {}

  explicit DescribeClusterBasicInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeClusterBasicInfoRequest() = default;
};
class DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfoZKLinksZKLink : public Darabonba::Model {
public:
  shared_ptr<string> link{};
  shared_ptr<string> port{};

  DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfoZKLinksZKLink() {}

  explicit DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfoZKLinksZKLink(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (link) {
      res["Link"] = boost::any(*link);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Link") != m.end() && !m["Link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["Link"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
  }


  virtual ~DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfoZKLinksZKLink() = default;
};
class DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfoZKLinks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfoZKLinksZKLink>> ZKLink{};

  DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfoZKLinks() {}

  explicit DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfoZKLinks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ZKLink) {
      vector<boost::any> temp1;
      for(auto item1:*ZKLink){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ZKLink"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ZKLink") != m.end() && !m["ZKLink"].empty()) {
      if (typeid(vector<boost::any>) == m["ZKLink"].type()) {
        vector<DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfoZKLinksZKLink> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ZKLink"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfoZKLinksZKLink model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ZKLink = make_shared<vector<DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfoZKLinksZKLink>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfoZKLinks() = default;
};
class DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfo : public Darabonba::Model {
public:
  shared_ptr<DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfoZKLinks> ZKLinks{};

  DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfo() {}

  explicit DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ZKLinks) {
      res["ZKLinks"] = ZKLinks ? boost::any(ZKLinks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ZKLinks") != m.end() && !m["ZKLinks"].empty()) {
      if (typeid(map<string, boost::any>) == m["ZKLinks"].type()) {
        DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfoZKLinks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ZKLinks"]));
        ZKLinks = make_shared<DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfoZKLinks>(model1);
      }
    }
  }


  virtual ~DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfo() = default;
};
class DescribeClusterBasicInfoResponseBodyClusterInfoBootstrapActionListBootstrapAction : public Darabonba::Model {
public:
  shared_ptr<string> arg{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};

  DescribeClusterBasicInfoResponseBodyClusterInfoBootstrapActionListBootstrapAction() {}

  explicit DescribeClusterBasicInfoResponseBodyClusterInfoBootstrapActionListBootstrapAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arg) {
      res["Arg"] = boost::any(*arg);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arg") != m.end() && !m["Arg"].empty()) {
      arg = make_shared<string>(boost::any_cast<string>(m["Arg"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~DescribeClusterBasicInfoResponseBodyClusterInfoBootstrapActionListBootstrapAction() = default;
};
class DescribeClusterBasicInfoResponseBodyClusterInfoBootstrapActionList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterBasicInfoResponseBodyClusterInfoBootstrapActionListBootstrapAction>> bootstrapAction{};

  DescribeClusterBasicInfoResponseBodyClusterInfoBootstrapActionList() {}

  explicit DescribeClusterBasicInfoResponseBodyClusterInfoBootstrapActionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bootstrapAction) {
      vector<boost::any> temp1;
      for(auto item1:*bootstrapAction){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BootstrapAction"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BootstrapAction") != m.end() && !m["BootstrapAction"].empty()) {
      if (typeid(vector<boost::any>) == m["BootstrapAction"].type()) {
        vector<DescribeClusterBasicInfoResponseBodyClusterInfoBootstrapActionListBootstrapAction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BootstrapAction"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterBasicInfoResponseBodyClusterInfoBootstrapActionListBootstrapAction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bootstrapAction = make_shared<vector<DescribeClusterBasicInfoResponseBodyClusterInfoBootstrapActionListBootstrapAction>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterBasicInfoResponseBodyClusterInfoBootstrapActionList() = default;
};
class DescribeClusterBasicInfoResponseBodyClusterInfoFailReason : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};

  DescribeClusterBasicInfoResponseBodyClusterInfoFailReason() {}

  explicit DescribeClusterBasicInfoResponseBodyClusterInfoFailReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeClusterBasicInfoResponseBodyClusterInfoFailReason() = default;
};
class DescribeClusterBasicInfoResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> status{};

  DescribeClusterBasicInfoResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo() {}

  explicit DescribeClusterBasicInfoResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeClusterBasicInfoResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo() = default;
};
class DescribeClusterBasicInfoResponseBodyClusterInfoGatewayClusterInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterBasicInfoResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo>> gatewayClusterInfo{};

  DescribeClusterBasicInfoResponseBodyClusterInfoGatewayClusterInfoList() {}

  explicit DescribeClusterBasicInfoResponseBodyClusterInfoGatewayClusterInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayClusterInfo) {
      vector<boost::any> temp1;
      for(auto item1:*gatewayClusterInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GatewayClusterInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayClusterInfo") != m.end() && !m["GatewayClusterInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["GatewayClusterInfo"].type()) {
        vector<DescribeClusterBasicInfoResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GatewayClusterInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterBasicInfoResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        gatewayClusterInfo = make_shared<vector<DescribeClusterBasicInfoResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterBasicInfoResponseBodyClusterInfoGatewayClusterInfoList() = default;
};
class DescribeClusterBasicInfoResponseBodyClusterInfoHostPoolInfo : public Darabonba::Model {
public:
  shared_ptr<string> hpBizId{};
  shared_ptr<string> hpName{};

  DescribeClusterBasicInfoResponseBodyClusterInfoHostPoolInfo() {}

  explicit DescribeClusterBasicInfoResponseBodyClusterInfoHostPoolInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hpBizId) {
      res["HpBizId"] = boost::any(*hpBizId);
    }
    if (hpName) {
      res["HpName"] = boost::any(*hpName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HpBizId") != m.end() && !m["HpBizId"].empty()) {
      hpBizId = make_shared<string>(boost::any_cast<string>(m["HpBizId"]));
    }
    if (m.find("HpName") != m.end() && !m["HpName"].empty()) {
      hpName = make_shared<string>(boost::any_cast<string>(m["HpName"]));
    }
  }


  virtual ~DescribeClusterBasicInfoResponseBodyClusterInfoHostPoolInfo() = default;
};
class DescribeClusterBasicInfoResponseBodyClusterInfoRelateClusterInfo : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> status{};

  DescribeClusterBasicInfoResponseBodyClusterInfoRelateClusterInfo() {}

  explicit DescribeClusterBasicInfoResponseBodyClusterInfoRelateClusterInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeClusterBasicInfoResponseBodyClusterInfoRelateClusterInfo() = default;
};
class DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> name{};
  shared_ptr<bool> onlyDisplay{};
  shared_ptr<long> startTpe{};
  shared_ptr<string> version{};

  DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware() {}

  explicit DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (onlyDisplay) {
      res["OnlyDisplay"] = boost::any(*onlyDisplay);
    }
    if (startTpe) {
      res["StartTpe"] = boost::any(*startTpe);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OnlyDisplay") != m.end() && !m["OnlyDisplay"].empty()) {
      onlyDisplay = make_shared<bool>(boost::any_cast<bool>(m["OnlyDisplay"]));
    }
    if (m.find("StartTpe") != m.end() && !m["StartTpe"].empty()) {
      startTpe = make_shared<long>(boost::any_cast<long>(m["StartTpe"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware() = default;
};
class DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfoSoftwares : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware>> software{};

  DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfoSoftwares() {}

  explicit DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfoSoftwares(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (software) {
      vector<boost::any> temp1;
      for(auto item1:*software){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Software"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Software") != m.end() && !m["Software"].empty()) {
      if (typeid(vector<boost::any>) == m["Software"].type()) {
        vector<DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Software"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        software = make_shared<vector<DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfoSoftwares() = default;
};
class DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfo : public Darabonba::Model {
public:
  shared_ptr<string> clusterType{};
  shared_ptr<string> emrVer{};
  shared_ptr<DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfoSoftwares> softwares{};

  DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfo() {}

  explicit DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (emrVer) {
      res["EmrVer"] = boost::any(*emrVer);
    }
    if (softwares) {
      res["Softwares"] = softwares ? boost::any(softwares->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("EmrVer") != m.end() && !m["EmrVer"].empty()) {
      emrVer = make_shared<string>(boost::any_cast<string>(m["EmrVer"]));
    }
    if (m.find("Softwares") != m.end() && !m["Softwares"].empty()) {
      if (typeid(map<string, boost::any>) == m["Softwares"].type()) {
        DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfoSoftwares model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Softwares"]));
        softwares = make_shared<DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfoSoftwares>(model1);
      }
    }
  }


  virtual ~DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfo() = default;
};
class DescribeClusterBasicInfoResponseBodyClusterInfo : public Darabonba::Model {
public:
  shared_ptr<DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfo> accessInfo{};
  shared_ptr<bool> autoScalingAllowed{};
  shared_ptr<bool> autoScalingByLoadAllowed{};
  shared_ptr<bool> autoScalingEnable{};
  shared_ptr<bool> autoScalingSpotWithLimitAllowed{};
  shared_ptr<string> autoScalingVersion{};
  shared_ptr<bool> autoScalingWithGraceAllowed{};
  shared_ptr<DescribeClusterBasicInfoResponseBodyClusterInfoBootstrapActionList> bootstrapActionList{};
  shared_ptr<bool> bootstrapFailed{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> clickhouseConf{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> configurations{};
  shared_ptr<long> coreNodeInService{};
  shared_ptr<long> coreNodeTotal{};
  shared_ptr<string> createResource{};
  shared_ptr<string> createType{};
  shared_ptr<bool> dataDiskEncrypted{};
  shared_ptr<string> dataDiskKMSKeyId{};
  shared_ptr<string> depositType{};
  shared_ptr<bool> easEnable{};
  shared_ptr<long> expiredTime{};
  shared_ptr<string> extraInfo{};
  shared_ptr<DescribeClusterBasicInfoResponseBodyClusterInfoFailReason> failReason{};
  shared_ptr<string> gatewayClusterIds{};
  shared_ptr<DescribeClusterBasicInfoResponseBodyClusterInfoGatewayClusterInfoList> gatewayClusterInfoList{};
  shared_ptr<bool> highAvailabilityEnable{};
  shared_ptr<DescribeClusterBasicInfoResponseBodyClusterInfoHostPoolInfo> hostPoolInfo{};
  shared_ptr<string> imageId{};
  shared_ptr<string> instanceGeneration{};
  shared_ptr<bool> ioOptimized{};
  shared_ptr<string> k8sClusterId{};
  shared_ptr<bool> localMetaDb{};
  shared_ptr<bool> logEnable{};
  shared_ptr<string> logPath{};
  shared_ptr<string> machineType{};
  shared_ptr<long> masterNodeInService{};
  shared_ptr<long> masterNodeTotal{};
  shared_ptr<string> metaStoreType{};
  shared_ptr<string> name{};
  shared_ptr<string> netType{};
  shared_ptr<string> operationId{};
  shared_ptr<long> period{};
  shared_ptr<string> regionId{};
  shared_ptr<string> relateClusterId{};
  shared_ptr<DescribeClusterBasicInfoResponseBodyClusterInfoRelateClusterInfo> relateClusterInfo{};
  shared_ptr<bool> resizeClusterEnable{};
  shared_ptr<bool> resizeDiskEnable{};
  shared_ptr<long> runningTime{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> securityGroupName{};
  shared_ptr<bool> showSoftwareInterface{};
  shared_ptr<DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfo> softwareInfo{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<long> stopTime{};
  shared_ptr<long> taskNodeInService{};
  shared_ptr<long> taskNodeTotal{};
  shared_ptr<string> userDefinedEmrEcsRole{};
  shared_ptr<string> userId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};

  DescribeClusterBasicInfoResponseBodyClusterInfo() {}

  explicit DescribeClusterBasicInfoResponseBodyClusterInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessInfo) {
      res["AccessInfo"] = accessInfo ? boost::any(accessInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (autoScalingAllowed) {
      res["AutoScalingAllowed"] = boost::any(*autoScalingAllowed);
    }
    if (autoScalingByLoadAllowed) {
      res["AutoScalingByLoadAllowed"] = boost::any(*autoScalingByLoadAllowed);
    }
    if (autoScalingEnable) {
      res["AutoScalingEnable"] = boost::any(*autoScalingEnable);
    }
    if (autoScalingSpotWithLimitAllowed) {
      res["AutoScalingSpotWithLimitAllowed"] = boost::any(*autoScalingSpotWithLimitAllowed);
    }
    if (autoScalingVersion) {
      res["AutoScalingVersion"] = boost::any(*autoScalingVersion);
    }
    if (autoScalingWithGraceAllowed) {
      res["AutoScalingWithGraceAllowed"] = boost::any(*autoScalingWithGraceAllowed);
    }
    if (bootstrapActionList) {
      res["BootstrapActionList"] = bootstrapActionList ? boost::any(bootstrapActionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bootstrapFailed) {
      res["BootstrapFailed"] = boost::any(*bootstrapFailed);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clickhouseConf) {
      res["ClickhouseConf"] = boost::any(*clickhouseConf);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (configurations) {
      res["Configurations"] = boost::any(*configurations);
    }
    if (coreNodeInService) {
      res["CoreNodeInService"] = boost::any(*coreNodeInService);
    }
    if (coreNodeTotal) {
      res["CoreNodeTotal"] = boost::any(*coreNodeTotal);
    }
    if (createResource) {
      res["CreateResource"] = boost::any(*createResource);
    }
    if (createType) {
      res["CreateType"] = boost::any(*createType);
    }
    if (dataDiskEncrypted) {
      res["DataDiskEncrypted"] = boost::any(*dataDiskEncrypted);
    }
    if (dataDiskKMSKeyId) {
      res["DataDiskKMSKeyId"] = boost::any(*dataDiskKMSKeyId);
    }
    if (depositType) {
      res["DepositType"] = boost::any(*depositType);
    }
    if (easEnable) {
      res["EasEnable"] = boost::any(*easEnable);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (extraInfo) {
      res["ExtraInfo"] = boost::any(*extraInfo);
    }
    if (failReason) {
      res["FailReason"] = failReason ? boost::any(failReason->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gatewayClusterIds) {
      res["GatewayClusterIds"] = boost::any(*gatewayClusterIds);
    }
    if (gatewayClusterInfoList) {
      res["GatewayClusterInfoList"] = gatewayClusterInfoList ? boost::any(gatewayClusterInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (highAvailabilityEnable) {
      res["HighAvailabilityEnable"] = boost::any(*highAvailabilityEnable);
    }
    if (hostPoolInfo) {
      res["HostPoolInfo"] = hostPoolInfo ? boost::any(hostPoolInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (instanceGeneration) {
      res["InstanceGeneration"] = boost::any(*instanceGeneration);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (k8sClusterId) {
      res["K8sClusterId"] = boost::any(*k8sClusterId);
    }
    if (localMetaDb) {
      res["LocalMetaDb"] = boost::any(*localMetaDb);
    }
    if (logEnable) {
      res["LogEnable"] = boost::any(*logEnable);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (machineType) {
      res["MachineType"] = boost::any(*machineType);
    }
    if (masterNodeInService) {
      res["MasterNodeInService"] = boost::any(*masterNodeInService);
    }
    if (masterNodeTotal) {
      res["MasterNodeTotal"] = boost::any(*masterNodeTotal);
    }
    if (metaStoreType) {
      res["MetaStoreType"] = boost::any(*metaStoreType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (relateClusterId) {
      res["RelateClusterId"] = boost::any(*relateClusterId);
    }
    if (relateClusterInfo) {
      res["RelateClusterInfo"] = relateClusterInfo ? boost::any(relateClusterInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resizeClusterEnable) {
      res["ResizeClusterEnable"] = boost::any(*resizeClusterEnable);
    }
    if (resizeDiskEnable) {
      res["ResizeDiskEnable"] = boost::any(*resizeDiskEnable);
    }
    if (runningTime) {
      res["RunningTime"] = boost::any(*runningTime);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    if (showSoftwareInterface) {
      res["ShowSoftwareInterface"] = boost::any(*showSoftwareInterface);
    }
    if (softwareInfo) {
      res["SoftwareInfo"] = softwareInfo ? boost::any(softwareInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    if (taskNodeInService) {
      res["TaskNodeInService"] = boost::any(*taskNodeInService);
    }
    if (taskNodeTotal) {
      res["TaskNodeTotal"] = boost::any(*taskNodeTotal);
    }
    if (userDefinedEmrEcsRole) {
      res["UserDefinedEmrEcsRole"] = boost::any(*userDefinedEmrEcsRole);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessInfo") != m.end() && !m["AccessInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccessInfo"].type()) {
        DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccessInfo"]));
        accessInfo = make_shared<DescribeClusterBasicInfoResponseBodyClusterInfoAccessInfo>(model1);
      }
    }
    if (m.find("AutoScalingAllowed") != m.end() && !m["AutoScalingAllowed"].empty()) {
      autoScalingAllowed = make_shared<bool>(boost::any_cast<bool>(m["AutoScalingAllowed"]));
    }
    if (m.find("AutoScalingByLoadAllowed") != m.end() && !m["AutoScalingByLoadAllowed"].empty()) {
      autoScalingByLoadAllowed = make_shared<bool>(boost::any_cast<bool>(m["AutoScalingByLoadAllowed"]));
    }
    if (m.find("AutoScalingEnable") != m.end() && !m["AutoScalingEnable"].empty()) {
      autoScalingEnable = make_shared<bool>(boost::any_cast<bool>(m["AutoScalingEnable"]));
    }
    if (m.find("AutoScalingSpotWithLimitAllowed") != m.end() && !m["AutoScalingSpotWithLimitAllowed"].empty()) {
      autoScalingSpotWithLimitAllowed = make_shared<bool>(boost::any_cast<bool>(m["AutoScalingSpotWithLimitAllowed"]));
    }
    if (m.find("AutoScalingVersion") != m.end() && !m["AutoScalingVersion"].empty()) {
      autoScalingVersion = make_shared<string>(boost::any_cast<string>(m["AutoScalingVersion"]));
    }
    if (m.find("AutoScalingWithGraceAllowed") != m.end() && !m["AutoScalingWithGraceAllowed"].empty()) {
      autoScalingWithGraceAllowed = make_shared<bool>(boost::any_cast<bool>(m["AutoScalingWithGraceAllowed"]));
    }
    if (m.find("BootstrapActionList") != m.end() && !m["BootstrapActionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["BootstrapActionList"].type()) {
        DescribeClusterBasicInfoResponseBodyClusterInfoBootstrapActionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BootstrapActionList"]));
        bootstrapActionList = make_shared<DescribeClusterBasicInfoResponseBodyClusterInfoBootstrapActionList>(model1);
      }
    }
    if (m.find("BootstrapFailed") != m.end() && !m["BootstrapFailed"].empty()) {
      bootstrapFailed = make_shared<bool>(boost::any_cast<bool>(m["BootstrapFailed"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClickhouseConf") != m.end() && !m["ClickhouseConf"].empty()) {
      clickhouseConf = make_shared<string>(boost::any_cast<string>(m["ClickhouseConf"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Configurations") != m.end() && !m["Configurations"].empty()) {
      configurations = make_shared<string>(boost::any_cast<string>(m["Configurations"]));
    }
    if (m.find("CoreNodeInService") != m.end() && !m["CoreNodeInService"].empty()) {
      coreNodeInService = make_shared<long>(boost::any_cast<long>(m["CoreNodeInService"]));
    }
    if (m.find("CoreNodeTotal") != m.end() && !m["CoreNodeTotal"].empty()) {
      coreNodeTotal = make_shared<long>(boost::any_cast<long>(m["CoreNodeTotal"]));
    }
    if (m.find("CreateResource") != m.end() && !m["CreateResource"].empty()) {
      createResource = make_shared<string>(boost::any_cast<string>(m["CreateResource"]));
    }
    if (m.find("CreateType") != m.end() && !m["CreateType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["CreateType"]));
    }
    if (m.find("DataDiskEncrypted") != m.end() && !m["DataDiskEncrypted"].empty()) {
      dataDiskEncrypted = make_shared<bool>(boost::any_cast<bool>(m["DataDiskEncrypted"]));
    }
    if (m.find("DataDiskKMSKeyId") != m.end() && !m["DataDiskKMSKeyId"].empty()) {
      dataDiskKMSKeyId = make_shared<string>(boost::any_cast<string>(m["DataDiskKMSKeyId"]));
    }
    if (m.find("DepositType") != m.end() && !m["DepositType"].empty()) {
      depositType = make_shared<string>(boost::any_cast<string>(m["DepositType"]));
    }
    if (m.find("EasEnable") != m.end() && !m["EasEnable"].empty()) {
      easEnable = make_shared<bool>(boost::any_cast<bool>(m["EasEnable"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      extraInfo = make_shared<string>(boost::any_cast<string>(m["ExtraInfo"]));
    }
    if (m.find("FailReason") != m.end() && !m["FailReason"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailReason"].type()) {
        DescribeClusterBasicInfoResponseBodyClusterInfoFailReason model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailReason"]));
        failReason = make_shared<DescribeClusterBasicInfoResponseBodyClusterInfoFailReason>(model1);
      }
    }
    if (m.find("GatewayClusterIds") != m.end() && !m["GatewayClusterIds"].empty()) {
      gatewayClusterIds = make_shared<string>(boost::any_cast<string>(m["GatewayClusterIds"]));
    }
    if (m.find("GatewayClusterInfoList") != m.end() && !m["GatewayClusterInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["GatewayClusterInfoList"].type()) {
        DescribeClusterBasicInfoResponseBodyClusterInfoGatewayClusterInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GatewayClusterInfoList"]));
        gatewayClusterInfoList = make_shared<DescribeClusterBasicInfoResponseBodyClusterInfoGatewayClusterInfoList>(model1);
      }
    }
    if (m.find("HighAvailabilityEnable") != m.end() && !m["HighAvailabilityEnable"].empty()) {
      highAvailabilityEnable = make_shared<bool>(boost::any_cast<bool>(m["HighAvailabilityEnable"]));
    }
    if (m.find("HostPoolInfo") != m.end() && !m["HostPoolInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostPoolInfo"].type()) {
        DescribeClusterBasicInfoResponseBodyClusterInfoHostPoolInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostPoolInfo"]));
        hostPoolInfo = make_shared<DescribeClusterBasicInfoResponseBodyClusterInfoHostPoolInfo>(model1);
      }
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InstanceGeneration") != m.end() && !m["InstanceGeneration"].empty()) {
      instanceGeneration = make_shared<string>(boost::any_cast<string>(m["InstanceGeneration"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<bool>(boost::any_cast<bool>(m["IoOptimized"]));
    }
    if (m.find("K8sClusterId") != m.end() && !m["K8sClusterId"].empty()) {
      k8sClusterId = make_shared<string>(boost::any_cast<string>(m["K8sClusterId"]));
    }
    if (m.find("LocalMetaDb") != m.end() && !m["LocalMetaDb"].empty()) {
      localMetaDb = make_shared<bool>(boost::any_cast<bool>(m["LocalMetaDb"]));
    }
    if (m.find("LogEnable") != m.end() && !m["LogEnable"].empty()) {
      logEnable = make_shared<bool>(boost::any_cast<bool>(m["LogEnable"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("MachineType") != m.end() && !m["MachineType"].empty()) {
      machineType = make_shared<string>(boost::any_cast<string>(m["MachineType"]));
    }
    if (m.find("MasterNodeInService") != m.end() && !m["MasterNodeInService"].empty()) {
      masterNodeInService = make_shared<long>(boost::any_cast<long>(m["MasterNodeInService"]));
    }
    if (m.find("MasterNodeTotal") != m.end() && !m["MasterNodeTotal"].empty()) {
      masterNodeTotal = make_shared<long>(boost::any_cast<long>(m["MasterNodeTotal"]));
    }
    if (m.find("MetaStoreType") != m.end() && !m["MetaStoreType"].empty()) {
      metaStoreType = make_shared<string>(boost::any_cast<string>(m["MetaStoreType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RelateClusterId") != m.end() && !m["RelateClusterId"].empty()) {
      relateClusterId = make_shared<string>(boost::any_cast<string>(m["RelateClusterId"]));
    }
    if (m.find("RelateClusterInfo") != m.end() && !m["RelateClusterInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["RelateClusterInfo"].type()) {
        DescribeClusterBasicInfoResponseBodyClusterInfoRelateClusterInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RelateClusterInfo"]));
        relateClusterInfo = make_shared<DescribeClusterBasicInfoResponseBodyClusterInfoRelateClusterInfo>(model1);
      }
    }
    if (m.find("ResizeClusterEnable") != m.end() && !m["ResizeClusterEnable"].empty()) {
      resizeClusterEnable = make_shared<bool>(boost::any_cast<bool>(m["ResizeClusterEnable"]));
    }
    if (m.find("ResizeDiskEnable") != m.end() && !m["ResizeDiskEnable"].empty()) {
      resizeDiskEnable = make_shared<bool>(boost::any_cast<bool>(m["ResizeDiskEnable"]));
    }
    if (m.find("RunningTime") != m.end() && !m["RunningTime"].empty()) {
      runningTime = make_shared<long>(boost::any_cast<long>(m["RunningTime"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
    if (m.find("ShowSoftwareInterface") != m.end() && !m["ShowSoftwareInterface"].empty()) {
      showSoftwareInterface = make_shared<bool>(boost::any_cast<bool>(m["ShowSoftwareInterface"]));
    }
    if (m.find("SoftwareInfo") != m.end() && !m["SoftwareInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SoftwareInfo"].type()) {
        DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SoftwareInfo"]));
        softwareInfo = make_shared<DescribeClusterBasicInfoResponseBodyClusterInfoSoftwareInfo>(model1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<long>(boost::any_cast<long>(m["StopTime"]));
    }
    if (m.find("TaskNodeInService") != m.end() && !m["TaskNodeInService"].empty()) {
      taskNodeInService = make_shared<long>(boost::any_cast<long>(m["TaskNodeInService"]));
    }
    if (m.find("TaskNodeTotal") != m.end() && !m["TaskNodeTotal"].empty()) {
      taskNodeTotal = make_shared<long>(boost::any_cast<long>(m["TaskNodeTotal"]));
    }
    if (m.find("UserDefinedEmrEcsRole") != m.end() && !m["UserDefinedEmrEcsRole"].empty()) {
      userDefinedEmrEcsRole = make_shared<string>(boost::any_cast<string>(m["UserDefinedEmrEcsRole"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeClusterBasicInfoResponseBodyClusterInfo() = default;
};
class DescribeClusterBasicInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeClusterBasicInfoResponseBodyClusterInfo> clusterInfo{};
  shared_ptr<string> requestId{};

  DescribeClusterBasicInfoResponseBody() {}

  explicit DescribeClusterBasicInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterInfo) {
      res["ClusterInfo"] = clusterInfo ? boost::any(clusterInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterInfo") != m.end() && !m["ClusterInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterInfo"].type()) {
        DescribeClusterBasicInfoResponseBodyClusterInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterInfo"]));
        clusterInfo = make_shared<DescribeClusterBasicInfoResponseBodyClusterInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeClusterBasicInfoResponseBody() = default;
};
class DescribeClusterBasicInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterBasicInfoResponseBody> body{};

  DescribeClusterBasicInfoResponse() {}

  explicit DescribeClusterBasicInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterBasicInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterBasicInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterBasicInfoResponse() = default;
};
class DescribeClusterOperationHostTaskLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> hostId{};
  shared_ptr<string> operationId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};

  DescribeClusterOperationHostTaskLogRequest() {}

  explicit DescribeClusterOperationHostTaskLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeClusterOperationHostTaskLogRequest() = default;
};
class DescribeClusterOperationHostTaskLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> stderr{};
  shared_ptr<string> stdout{};

  DescribeClusterOperationHostTaskLogResponseBody() {}

  explicit DescribeClusterOperationHostTaskLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (stderr) {
      res["Stderr"] = boost::any(*stderr);
    }
    if (stdout) {
      res["Stdout"] = boost::any(*stdout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Stderr") != m.end() && !m["Stderr"].empty()) {
      stderr = make_shared<string>(boost::any_cast<string>(m["Stderr"]));
    }
    if (m.find("Stdout") != m.end() && !m["Stdout"].empty()) {
      stdout = make_shared<string>(boost::any_cast<string>(m["Stdout"]));
    }
  }


  virtual ~DescribeClusterOperationHostTaskLogResponseBody() = default;
};
class DescribeClusterOperationHostTaskLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterOperationHostTaskLogResponseBody> body{};

  DescribeClusterOperationHostTaskLogResponse() {}

  explicit DescribeClusterOperationHostTaskLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterOperationHostTaskLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterOperationHostTaskLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterOperationHostTaskLogResponse() = default;
};
class DescribeClusterResourcePoolSchedulerTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};

  DescribeClusterResourcePoolSchedulerTypeRequest() {}

  explicit DescribeClusterResourcePoolSchedulerTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeClusterResourcePoolSchedulerTypeRequest() = default;
};
class DescribeClusterResourcePoolSchedulerTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> currentSchedulerType{};
  shared_ptr<string> defaultSchedulerType{};
  shared_ptr<string> requestId{};
  shared_ptr<string> supportSchedulerType{};

  DescribeClusterResourcePoolSchedulerTypeResponseBody() {}

  explicit DescribeClusterResourcePoolSchedulerTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentSchedulerType) {
      res["CurrentSchedulerType"] = boost::any(*currentSchedulerType);
    }
    if (defaultSchedulerType) {
      res["DefaultSchedulerType"] = boost::any(*defaultSchedulerType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (supportSchedulerType) {
      res["SupportSchedulerType"] = boost::any(*supportSchedulerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentSchedulerType") != m.end() && !m["CurrentSchedulerType"].empty()) {
      currentSchedulerType = make_shared<string>(boost::any_cast<string>(m["CurrentSchedulerType"]));
    }
    if (m.find("DefaultSchedulerType") != m.end() && !m["DefaultSchedulerType"].empty()) {
      defaultSchedulerType = make_shared<string>(boost::any_cast<string>(m["DefaultSchedulerType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SupportSchedulerType") != m.end() && !m["SupportSchedulerType"].empty()) {
      supportSchedulerType = make_shared<string>(boost::any_cast<string>(m["SupportSchedulerType"]));
    }
  }


  virtual ~DescribeClusterResourcePoolSchedulerTypeResponseBody() = default;
};
class DescribeClusterResourcePoolSchedulerTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterResourcePoolSchedulerTypeResponseBody> body{};

  DescribeClusterResourcePoolSchedulerTypeResponse() {}

  explicit DescribeClusterResourcePoolSchedulerTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterResourcePoolSchedulerTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterResourcePoolSchedulerTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterResourcePoolSchedulerTypeResponse() = default;
};
class DescribeClusterServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> serviceName{};

  DescribeClusterServiceRequest() {}

  explicit DescribeClusterServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~DescribeClusterServiceRequest() = default;
};
class DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryListClusterServiceSummary : public Darabonba::Model {
public:
  shared_ptr<string> alertInfo{};
  shared_ptr<string> category{};
  shared_ptr<long> desiredStoppedValue{};
  shared_ptr<string> displayName{};
  shared_ptr<string> key{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryListClusterServiceSummary() {}

  explicit DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryListClusterServiceSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertInfo) {
      res["AlertInfo"] = boost::any(*alertInfo);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (desiredStoppedValue) {
      res["DesiredStoppedValue"] = boost::any(*desiredStoppedValue);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertInfo") != m.end() && !m["AlertInfo"].empty()) {
      alertInfo = make_shared<string>(boost::any_cast<string>(m["AlertInfo"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("DesiredStoppedValue") != m.end() && !m["DesiredStoppedValue"].empty()) {
      desiredStoppedValue = make_shared<long>(boost::any_cast<long>(m["DesiredStoppedValue"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryListClusterServiceSummary() = default;
};
class DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryListClusterServiceSummary>> clusterServiceSummary{};

  DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryList() {}

  explicit DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterServiceSummary) {
      vector<boost::any> temp1;
      for(auto item1:*clusterServiceSummary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterServiceSummary"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterServiceSummary") != m.end() && !m["ClusterServiceSummary"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterServiceSummary"].type()) {
        vector<DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryListClusterServiceSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterServiceSummary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryListClusterServiceSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterServiceSummary = make_shared<vector<DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryListClusterServiceSummary>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryList() = default;
};
class DescribeClusterServiceResponseBodyServiceInfoNeedRestartComponentNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> service{};

  DescribeClusterServiceResponseBodyServiceInfoNeedRestartComponentNameList() {}

  explicit DescribeClusterServiceResponseBodyServiceInfoNeedRestartComponentNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (service) {
      res["Service"] = boost::any(*service);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Service") != m.end() && !m["Service"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Service"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Service"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      service = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeClusterServiceResponseBodyServiceInfoNeedRestartComponentNameList() = default;
};
class DescribeClusterServiceResponseBodyServiceInfoNeedRestartHostIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> service{};

  DescribeClusterServiceResponseBodyServiceInfoNeedRestartHostIdList() {}

  explicit DescribeClusterServiceResponseBodyServiceInfoNeedRestartHostIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (service) {
      res["Service"] = boost::any(*service);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Service") != m.end() && !m["Service"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Service"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Service"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      service = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeClusterServiceResponseBodyServiceInfoNeedRestartHostIdList() = default;
};
class DescribeClusterServiceResponseBodyServiceInfoServiceActionListServiceAction : public Darabonba::Model {
public:
  shared_ptr<string> actionName{};
  shared_ptr<string> command{};
  shared_ptr<string> componentName{};
  shared_ptr<string> displayName{};
  shared_ptr<string> serviceName{};

  DescribeClusterServiceResponseBodyServiceInfoServiceActionListServiceAction() {}

  explicit DescribeClusterServiceResponseBodyServiceInfoServiceActionListServiceAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionName) {
      res["ActionName"] = boost::any(*actionName);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionName") != m.end() && !m["ActionName"].empty()) {
      actionName = make_shared<string>(boost::any_cast<string>(m["ActionName"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~DescribeClusterServiceResponseBodyServiceInfoServiceActionListServiceAction() = default;
};
class DescribeClusterServiceResponseBodyServiceInfoServiceActionList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterServiceResponseBodyServiceInfoServiceActionListServiceAction>> serviceAction{};

  DescribeClusterServiceResponseBodyServiceInfoServiceActionList() {}

  explicit DescribeClusterServiceResponseBodyServiceInfoServiceActionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceAction) {
      vector<boost::any> temp1;
      for(auto item1:*serviceAction){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceAction"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceAction") != m.end() && !m["ServiceAction"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceAction"].type()) {
        vector<DescribeClusterServiceResponseBodyServiceInfoServiceActionListServiceAction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceAction"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterServiceResponseBodyServiceInfoServiceActionListServiceAction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceAction = make_shared<vector<DescribeClusterServiceResponseBodyServiceInfoServiceActionListServiceAction>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterServiceResponseBodyServiceInfoServiceActionList() = default;
};
class DescribeClusterServiceResponseBodyServiceInfo : public Darabonba::Model {
public:
  shared_ptr<DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryList> clusterServiceSummaryList{};
  shared_ptr<DescribeClusterServiceResponseBodyServiceInfoNeedRestartComponentNameList> needRestartComponentNameList{};
  shared_ptr<DescribeClusterServiceResponseBodyServiceInfoNeedRestartHostIdList> needRestartHostIdList{};
  shared_ptr<string> needRestartInfo{};
  shared_ptr<long> needRestartNum{};
  shared_ptr<DescribeClusterServiceResponseBodyServiceInfoServiceActionList> serviceActionList{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceStatus{};
  shared_ptr<string> serviceVersion{};

  DescribeClusterServiceResponseBodyServiceInfo() {}

  explicit DescribeClusterServiceResponseBodyServiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterServiceSummaryList) {
      res["ClusterServiceSummaryList"] = clusterServiceSummaryList ? boost::any(clusterServiceSummaryList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (needRestartComponentNameList) {
      res["NeedRestartComponentNameList"] = needRestartComponentNameList ? boost::any(needRestartComponentNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (needRestartHostIdList) {
      res["NeedRestartHostIdList"] = needRestartHostIdList ? boost::any(needRestartHostIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (needRestartInfo) {
      res["NeedRestartInfo"] = boost::any(*needRestartInfo);
    }
    if (needRestartNum) {
      res["NeedRestartNum"] = boost::any(*needRestartNum);
    }
    if (serviceActionList) {
      res["ServiceActionList"] = serviceActionList ? boost::any(serviceActionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (serviceStatus) {
      res["ServiceStatus"] = boost::any(*serviceStatus);
    }
    if (serviceVersion) {
      res["ServiceVersion"] = boost::any(*serviceVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterServiceSummaryList") != m.end() && !m["ClusterServiceSummaryList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterServiceSummaryList"].type()) {
        DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterServiceSummaryList"]));
        clusterServiceSummaryList = make_shared<DescribeClusterServiceResponseBodyServiceInfoClusterServiceSummaryList>(model1);
      }
    }
    if (m.find("NeedRestartComponentNameList") != m.end() && !m["NeedRestartComponentNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["NeedRestartComponentNameList"].type()) {
        DescribeClusterServiceResponseBodyServiceInfoNeedRestartComponentNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NeedRestartComponentNameList"]));
        needRestartComponentNameList = make_shared<DescribeClusterServiceResponseBodyServiceInfoNeedRestartComponentNameList>(model1);
      }
    }
    if (m.find("NeedRestartHostIdList") != m.end() && !m["NeedRestartHostIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["NeedRestartHostIdList"].type()) {
        DescribeClusterServiceResponseBodyServiceInfoNeedRestartHostIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NeedRestartHostIdList"]));
        needRestartHostIdList = make_shared<DescribeClusterServiceResponseBodyServiceInfoNeedRestartHostIdList>(model1);
      }
    }
    if (m.find("NeedRestartInfo") != m.end() && !m["NeedRestartInfo"].empty()) {
      needRestartInfo = make_shared<string>(boost::any_cast<string>(m["NeedRestartInfo"]));
    }
    if (m.find("NeedRestartNum") != m.end() && !m["NeedRestartNum"].empty()) {
      needRestartNum = make_shared<long>(boost::any_cast<long>(m["NeedRestartNum"]));
    }
    if (m.find("ServiceActionList") != m.end() && !m["ServiceActionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceActionList"].type()) {
        DescribeClusterServiceResponseBodyServiceInfoServiceActionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceActionList"]));
        serviceActionList = make_shared<DescribeClusterServiceResponseBodyServiceInfoServiceActionList>(model1);
      }
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServiceStatus") != m.end() && !m["ServiceStatus"].empty()) {
      serviceStatus = make_shared<string>(boost::any_cast<string>(m["ServiceStatus"]));
    }
    if (m.find("ServiceVersion") != m.end() && !m["ServiceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["ServiceVersion"]));
    }
  }


  virtual ~DescribeClusterServiceResponseBodyServiceInfo() = default;
};
class DescribeClusterServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeClusterServiceResponseBodyServiceInfo> serviceInfo{};

  DescribeClusterServiceResponseBody() {}

  explicit DescribeClusterServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (serviceInfo) {
      res["ServiceInfo"] = serviceInfo ? boost::any(serviceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ServiceInfo") != m.end() && !m["ServiceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceInfo"].type()) {
        DescribeClusterServiceResponseBodyServiceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceInfo"]));
        serviceInfo = make_shared<DescribeClusterServiceResponseBodyServiceInfo>(model1);
      }
    }
  }


  virtual ~DescribeClusterServiceResponseBody() = default;
};
class DescribeClusterServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterServiceResponseBody> body{};

  DescribeClusterServiceResponse() {}

  explicit DescribeClusterServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterServiceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterServiceResponse() = default;
};
class DescribeClusterServiceConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> configVersion{};
  shared_ptr<string> groupId{};
  shared_ptr<string> hostInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> tagValue{};

  DescribeClusterServiceConfigRequest() {}

  explicit DescribeClusterServiceConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (configVersion) {
      res["ConfigVersion"] = boost::any(*configVersion);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (hostInstanceId) {
      res["HostInstanceId"] = boost::any(*hostInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ConfigVersion") != m.end() && !m["ConfigVersion"].empty()) {
      configVersion = make_shared<string>(boost::any_cast<string>(m["ConfigVersion"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HostInstanceId") != m.end() && !m["HostInstanceId"].empty()) {
      hostInstanceId = make_shared<string>(boost::any_cast<string>(m["HostInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeClusterServiceConfigRequest() = default;
};
class DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueListConfigItemValue : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<bool> isCustom{};
  shared_ptr<string> itemName{};
  shared_ptr<string> value{};
  shared_ptr<string> valueScope{};

  DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueListConfigItemValue() {}

  explicit DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueListConfigItemValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (isCustom) {
      res["IsCustom"] = boost::any(*isCustom);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (valueScope) {
      res["ValueScope"] = boost::any(*valueScope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IsCustom") != m.end() && !m["IsCustom"].empty()) {
      isCustom = make_shared<bool>(boost::any_cast<bool>(m["IsCustom"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("ValueScope") != m.end() && !m["ValueScope"].empty()) {
      valueScope = make_shared<string>(boost::any_cast<string>(m["ValueScope"]));
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueListConfigItemValue() = default;
};
class DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueListConfigItemValue>> configItemValue{};

  DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueList() {}

  explicit DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configItemValue) {
      vector<boost::any> temp1;
      for(auto item1:*configItemValue){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigItemValue"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigItemValue") != m.end() && !m["ConfigItemValue"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigItemValue"].type()) {
        vector<DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueListConfigItemValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigItemValue"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueListConfigItemValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configItemValue = make_shared<vector<DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueListConfigItemValue>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueList() = default;
};
class DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValue : public Darabonba::Model {
public:
  shared_ptr<bool> allowCustom{};
  shared_ptr<DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueList> configItemValueList{};
  shared_ptr<string> configName{};
  shared_ptr<string> scope{};
  shared_ptr<long> scopeId{};

  DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValue() {}

  explicit DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowCustom) {
      res["AllowCustom"] = boost::any(*allowCustom);
    }
    if (configItemValueList) {
      res["ConfigItemValueList"] = configItemValueList ? boost::any(configItemValueList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (configName) {
      res["ConfigName"] = boost::any(*configName);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (scopeId) {
      res["ScopeId"] = boost::any(*scopeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowCustom") != m.end() && !m["AllowCustom"].empty()) {
      allowCustom = make_shared<bool>(boost::any_cast<bool>(m["AllowCustom"]));
    }
    if (m.find("ConfigItemValueList") != m.end() && !m["ConfigItemValueList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigItemValueList"].type()) {
        DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigItemValueList"]));
        configItemValueList = make_shared<DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValueConfigItemValueList>(model1);
      }
    }
    if (m.find("ConfigName") != m.end() && !m["ConfigName"].empty()) {
      configName = make_shared<string>(boost::any_cast<string>(m["ConfigName"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("ScopeId") != m.end() && !m["ScopeId"].empty()) {
      scopeId = make_shared<long>(boost::any_cast<long>(m["ScopeId"]));
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValue() = default;
};
class DescribeClusterServiceConfigResponseBodyConfigConfigValueList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValue>> configValue{};

  DescribeClusterServiceConfigResponseBodyConfigConfigValueList() {}

  explicit DescribeClusterServiceConfigResponseBodyConfigConfigValueList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configValue) {
      vector<boost::any> temp1;
      for(auto item1:*configValue){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigValue"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigValue"].type()) {
        vector<DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigValue"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configValue = make_shared<vector<DescribeClusterServiceConfigResponseBodyConfigConfigValueListConfigValue>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfigConfigValueList() = default;
};
class DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoEffectWay : public Darabonba::Model {
public:
  shared_ptr<string> effectType{};
  shared_ptr<string> invokeServiceName{};

  DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoEffectWay() {}

  explicit DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoEffectWay(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effectType) {
      res["EffectType"] = boost::any(*effectType);
    }
    if (invokeServiceName) {
      res["InvokeServiceName"] = boost::any(*invokeServiceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EffectType") != m.end() && !m["EffectType"].empty()) {
      effectType = make_shared<string>(boost::any_cast<string>(m["EffectType"]));
    }
    if (m.find("InvokeServiceName") != m.end() && !m["InvokeServiceName"].empty()) {
      invokeServiceName = make_shared<string>(boost::any_cast<string>(m["InvokeServiceName"]));
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoEffectWay() = default;
};
class DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyTypes : public Darabonba::Model {
public:
  shared_ptr<vector<string>> propertyType{};

  DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyTypes() {}

  explicit DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyType) {
      res["propertyType"] = boost::any(*propertyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("propertyType") != m.end() && !m["propertyType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["propertyType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["propertyType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      propertyType = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyTypes() = default;
};
class DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntriesValueEntryInfo : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> label{};
  shared_ptr<string> value{};

  DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntriesValueEntryInfo() {}

  explicit DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntriesValueEntryInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntriesValueEntryInfo() = default;
};
class DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntriesValueEntryInfo>> valueEntryInfo{};

  DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntries() {}

  explicit DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (valueEntryInfo) {
      vector<boost::any> temp1;
      for(auto item1:*valueEntryInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ValueEntryInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ValueEntryInfo") != m.end() && !m["ValueEntryInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ValueEntryInfo"].type()) {
        vector<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntriesValueEntryInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ValueEntryInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntriesValueEntryInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        valueEntryInfo = make_shared<vector<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntriesValueEntryInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntries() = default;
};
class DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributes : public Darabonba::Model {
public:
  shared_ptr<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntries> entries{};
  shared_ptr<bool> hidden{};
  shared_ptr<string> incrememtStep{};
  shared_ptr<string> maximum{};
  shared_ptr<string> mimimum{};
  shared_ptr<bool> readOnly{};
  shared_ptr<string> type{};
  shared_ptr<string> unit{};

  DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributes() {}

  explicit DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entries) {
      res["Entries"] = entries ? boost::any(entries->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hidden) {
      res["Hidden"] = boost::any(*hidden);
    }
    if (incrememtStep) {
      res["IncrememtStep"] = boost::any(*incrememtStep);
    }
    if (maximum) {
      res["Maximum"] = boost::any(*maximum);
    }
    if (mimimum) {
      res["Mimimum"] = boost::any(*mimimum);
    }
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Entries") != m.end() && !m["Entries"].empty()) {
      if (typeid(map<string, boost::any>) == m["Entries"].type()) {
        DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntries model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Entries"]));
        entries = make_shared<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributesEntries>(model1);
      }
    }
    if (m.find("Hidden") != m.end() && !m["Hidden"].empty()) {
      hidden = make_shared<bool>(boost::any_cast<bool>(m["Hidden"]));
    }
    if (m.find("IncrememtStep") != m.end() && !m["IncrememtStep"].empty()) {
      incrememtStep = make_shared<string>(boost::any_cast<string>(m["IncrememtStep"]));
    }
    if (m.find("Maximum") != m.end() && !m["Maximum"].empty()) {
      maximum = make_shared<string>(boost::any_cast<string>(m["Maximum"]));
    }
    if (m.find("Mimimum") != m.end() && !m["Mimimum"].empty()) {
      mimimum = make_shared<string>(boost::any_cast<string>(m["Mimimum"]));
    }
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributes() = default;
};
class DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfo : public Darabonba::Model {
public:
  shared_ptr<string> component{};
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoEffectWay> effectWay{};
  shared_ptr<string> fileName{};
  shared_ptr<string> name{};
  shared_ptr<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyTypes> propertyTypes{};
  shared_ptr<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributes> propertyValueAttributes{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> value{};

  DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfo() {}

  explicit DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (component) {
      res["Component"] = boost::any(*component);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (effectWay) {
      res["EffectWay"] = effectWay ? boost::any(effectWay->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (propertyTypes) {
      res["PropertyTypes"] = propertyTypes ? boost::any(propertyTypes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertyValueAttributes) {
      res["PropertyValueAttributes"] = propertyValueAttributes ? boost::any(propertyValueAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Component") != m.end() && !m["Component"].empty()) {
      component = make_shared<string>(boost::any_cast<string>(m["Component"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("EffectWay") != m.end() && !m["EffectWay"].empty()) {
      if (typeid(map<string, boost::any>) == m["EffectWay"].type()) {
        DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoEffectWay model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EffectWay"]));
        effectWay = make_shared<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoEffectWay>(model1);
      }
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PropertyTypes") != m.end() && !m["PropertyTypes"].empty()) {
      if (typeid(map<string, boost::any>) == m["PropertyTypes"].type()) {
        DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyTypes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PropertyTypes"]));
        propertyTypes = make_shared<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyTypes>(model1);
      }
    }
    if (m.find("PropertyValueAttributes") != m.end() && !m["PropertyValueAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["PropertyValueAttributes"].type()) {
        DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PropertyValueAttributes"]));
        propertyValueAttributes = make_shared<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfoPropertyValueAttributes>(model1);
      }
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfo() = default;
};
class DescribeClusterServiceConfigResponseBodyConfigPropertyInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfo>> propertyInfo{};

  DescribeClusterServiceConfigResponseBodyConfigPropertyInfoList() {}

  explicit DescribeClusterServiceConfigResponseBodyConfigPropertyInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyInfo) {
      vector<boost::any> temp1;
      for(auto item1:*propertyInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyInfo") != m.end() && !m["PropertyInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyInfo"].type()) {
        vector<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyInfo = make_shared<vector<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoListPropertyInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfigPropertyInfoList() = default;
};
class DescribeClusterServiceConfigResponseBodyConfig : public Darabonba::Model {
public:
  shared_ptr<string> applied{};
  shared_ptr<string> author{};
  shared_ptr<string> comment{};
  shared_ptr<DescribeClusterServiceConfigResponseBodyConfigConfigValueList> configValueList{};
  shared_ptr<string> configVersion{};
  shared_ptr<string> createTime{};
  shared_ptr<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoList> propertyInfoList{};
  shared_ptr<string> serviceName{};

  DescribeClusterServiceConfigResponseBodyConfig() {}

  explicit DescribeClusterServiceConfigResponseBodyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applied) {
      res["Applied"] = boost::any(*applied);
    }
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (configValueList) {
      res["ConfigValueList"] = configValueList ? boost::any(configValueList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (configVersion) {
      res["ConfigVersion"] = boost::any(*configVersion);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (propertyInfoList) {
      res["PropertyInfoList"] = propertyInfoList ? boost::any(propertyInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Applied") != m.end() && !m["Applied"].empty()) {
      applied = make_shared<string>(boost::any_cast<string>(m["Applied"]));
    }
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ConfigValueList") != m.end() && !m["ConfigValueList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigValueList"].type()) {
        DescribeClusterServiceConfigResponseBodyConfigConfigValueList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigValueList"]));
        configValueList = make_shared<DescribeClusterServiceConfigResponseBodyConfigConfigValueList>(model1);
      }
    }
    if (m.find("ConfigVersion") != m.end() && !m["ConfigVersion"].empty()) {
      configVersion = make_shared<string>(boost::any_cast<string>(m["ConfigVersion"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("PropertyInfoList") != m.end() && !m["PropertyInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PropertyInfoList"].type()) {
        DescribeClusterServiceConfigResponseBodyConfigPropertyInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PropertyInfoList"]));
        propertyInfoList = make_shared<DescribeClusterServiceConfigResponseBodyConfigPropertyInfoList>(model1);
      }
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBodyConfig() = default;
};
class DescribeClusterServiceConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeClusterServiceConfigResponseBodyConfig> config{};
  shared_ptr<string> requestId{};

  DescribeClusterServiceConfigResponseBody() {}

  explicit DescribeClusterServiceConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        DescribeClusterServiceConfigResponseBodyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<DescribeClusterServiceConfigResponseBodyConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeClusterServiceConfigResponseBody() = default;
};
class DescribeClusterServiceConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterServiceConfigResponseBody> body{};

  DescribeClusterServiceConfigResponse() {}

  explicit DescribeClusterServiceConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterServiceConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterServiceConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterServiceConfigResponse() = default;
};
class DescribeClusterServiceConfigTagRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> configTag{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> serviceName{};

  DescribeClusterServiceConfigTagRequest() {}

  explicit DescribeClusterServiceConfigTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (configTag) {
      res["ConfigTag"] = boost::any(*configTag);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ConfigTag") != m.end() && !m["ConfigTag"].empty()) {
      configTag = make_shared<string>(boost::any_cast<string>(m["ConfigTag"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~DescribeClusterServiceConfigTagRequest() = default;
};
class DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTagValueListValue : public Darabonba::Model {
public:
  shared_ptr<string> value{};
  shared_ptr<string> valueDesc{};

  DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTagValueListValue() {}

  explicit DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTagValueListValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (valueDesc) {
      res["ValueDesc"] = boost::any(*valueDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("ValueDesc") != m.end() && !m["ValueDesc"].empty()) {
      valueDesc = make_shared<string>(boost::any_cast<string>(m["ValueDesc"]));
    }
  }


  virtual ~DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTagValueListValue() = default;
};
class DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTagValueList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTagValueListValue>> value{};

  DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTagValueList() {}

  explicit DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTagValueList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      vector<boost::any> temp1;
      for(auto item1:*value){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Value"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTagValueListValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Value"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTagValueListValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        value = make_shared<vector<DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTagValueListValue>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTagValueList() = default;
};
class DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTag : public Darabonba::Model {
public:
  shared_ptr<string> tag{};
  shared_ptr<string> tagDesc{};
  shared_ptr<DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTagValueList> valueList{};

  DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTag() {}

  explicit DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (tagDesc) {
      res["TagDesc"] = boost::any(*tagDesc);
    }
    if (valueList) {
      res["ValueList"] = valueList ? boost::any(valueList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("TagDesc") != m.end() && !m["TagDesc"].empty()) {
      tagDesc = make_shared<string>(boost::any_cast<string>(m["TagDesc"]));
    }
    if (m.find("ValueList") != m.end() && !m["ValueList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ValueList"].type()) {
        DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTagValueList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ValueList"]));
        valueList = make_shared<DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTagValueList>(model1);
      }
    }
  }


  virtual ~DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTag() = default;
};
class DescribeClusterServiceConfigTagResponseBodyConfigTagList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTag>> configTag{};

  DescribeClusterServiceConfigTagResponseBodyConfigTagList() {}

  explicit DescribeClusterServiceConfigTagResponseBodyConfigTagList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configTag) {
      vector<boost::any> temp1;
      for(auto item1:*configTag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigTag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigTag") != m.end() && !m["ConfigTag"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigTag"].type()) {
        vector<DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigTag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configTag = make_shared<vector<DescribeClusterServiceConfigTagResponseBodyConfigTagListConfigTag>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterServiceConfigTagResponseBodyConfigTagList() = default;
};
class DescribeClusterServiceConfigTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeClusterServiceConfigTagResponseBodyConfigTagList> configTagList{};
  shared_ptr<string> requestId{};

  DescribeClusterServiceConfigTagResponseBody() {}

  explicit DescribeClusterServiceConfigTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configTagList) {
      res["ConfigTagList"] = configTagList ? boost::any(configTagList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigTagList") != m.end() && !m["ConfigTagList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigTagList"].type()) {
        DescribeClusterServiceConfigTagResponseBodyConfigTagList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigTagList"]));
        configTagList = make_shared<DescribeClusterServiceConfigTagResponseBodyConfigTagList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeClusterServiceConfigTagResponseBody() = default;
};
class DescribeClusterServiceConfigTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterServiceConfigTagResponseBody> body{};

  DescribeClusterServiceConfigTagResponse() {}

  explicit DescribeClusterServiceConfigTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterServiceConfigTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterServiceConfigTagResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterServiceConfigTagResponse() = default;
};
class DescribeClusterTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};

  DescribeClusterTemplateRequest() {}

  explicit DescribeClusterTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeClusterTemplateRequest() = default;
};
class DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionListBootstrapAction : public Darabonba::Model {
public:
  shared_ptr<string> arg{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};

  DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionListBootstrapAction() {}

  explicit DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionListBootstrapAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arg) {
      res["Arg"] = boost::any(*arg);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arg") != m.end() && !m["Arg"].empty()) {
      arg = make_shared<string>(boost::any_cast<string>(m["Arg"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionListBootstrapAction() = default;
};
class DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionListBootstrapAction>> bootstrapAction{};

  DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionList() {}

  explicit DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bootstrapAction) {
      vector<boost::any> temp1;
      for(auto item1:*bootstrapAction){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BootstrapAction"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BootstrapAction") != m.end() && !m["BootstrapAction"].empty()) {
      if (typeid(vector<boost::any>) == m["BootstrapAction"].type()) {
        vector<DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionListBootstrapAction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BootstrapAction"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionListBootstrapAction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bootstrapAction = make_shared<vector<DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionListBootstrapAction>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionList() = default;
};
class DescribeClusterTemplateResponseBodyTemplateInfoConfigListConfig : public Darabonba::Model {
public:
  shared_ptr<string> configKey{};
  shared_ptr<string> configValue{};
  shared_ptr<string> encrypt{};
  shared_ptr<string> fileName{};
  shared_ptr<string> replace{};
  shared_ptr<string> serviceName{};

  DescribeClusterTemplateResponseBodyTemplateInfoConfigListConfig() {}

  explicit DescribeClusterTemplateResponseBodyTemplateInfoConfigListConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configKey) {
      res["ConfigKey"] = boost::any(*configKey);
    }
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (encrypt) {
      res["Encrypt"] = boost::any(*encrypt);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (replace) {
      res["Replace"] = boost::any(*replace);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigKey") != m.end() && !m["ConfigKey"].empty()) {
      configKey = make_shared<string>(boost::any_cast<string>(m["ConfigKey"]));
    }
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("Encrypt") != m.end() && !m["Encrypt"].empty()) {
      encrypt = make_shared<string>(boost::any_cast<string>(m["Encrypt"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Replace") != m.end() && !m["Replace"].empty()) {
      replace = make_shared<string>(boost::any_cast<string>(m["Replace"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~DescribeClusterTemplateResponseBodyTemplateInfoConfigListConfig() = default;
};
class DescribeClusterTemplateResponseBodyTemplateInfoConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterTemplateResponseBodyTemplateInfoConfigListConfig>> config{};

  DescribeClusterTemplateResponseBodyTemplateInfoConfigList() {}

  explicit DescribeClusterTemplateResponseBodyTemplateInfoConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      vector<boost::any> temp1;
      for(auto item1:*config){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Config"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(vector<boost::any>) == m["Config"].type()) {
        vector<DescribeClusterTemplateResponseBodyTemplateInfoConfigListConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Config"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterTemplateResponseBodyTemplateInfoConfigListConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        config = make_shared<vector<DescribeClusterTemplateResponseBodyTemplateInfoConfigListConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterTemplateResponseBodyTemplateInfoConfigList() = default;
};
class DescribeClusterTemplateResponseBodyTemplateInfoHostGroupListHostGroup : public Darabonba::Model {
public:
  shared_ptr<string> chargeType{};
  shared_ptr<long> diskCapacity{};
  shared_ptr<long> diskCount{};
  shared_ptr<string> diskType{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<string> hostGroupType{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> multiInstanceTypes{};
  shared_ptr<long> nodeCount{};
  shared_ptr<string> period{};
  shared_ptr<long> sysDiskCapacity{};
  shared_ptr<string> sysDiskType{};

  DescribeClusterTemplateResponseBodyTemplateInfoHostGroupListHostGroup() {}

  explicit DescribeClusterTemplateResponseBodyTemplateInfoHostGroupListHostGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (diskCapacity) {
      res["DiskCapacity"] = boost::any(*diskCapacity);
    }
    if (diskCount) {
      res["DiskCount"] = boost::any(*diskCount);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (hostGroupType) {
      res["HostGroupType"] = boost::any(*hostGroupType);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (multiInstanceTypes) {
      res["MultiInstanceTypes"] = boost::any(*multiInstanceTypes);
    }
    if (nodeCount) {
      res["NodeCount"] = boost::any(*nodeCount);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (sysDiskCapacity) {
      res["SysDiskCapacity"] = boost::any(*sysDiskCapacity);
    }
    if (sysDiskType) {
      res["SysDiskType"] = boost::any(*sysDiskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("DiskCapacity") != m.end() && !m["DiskCapacity"].empty()) {
      diskCapacity = make_shared<long>(boost::any_cast<long>(m["DiskCapacity"]));
    }
    if (m.find("DiskCount") != m.end() && !m["DiskCount"].empty()) {
      diskCount = make_shared<long>(boost::any_cast<long>(m["DiskCount"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("HostGroupType") != m.end() && !m["HostGroupType"].empty()) {
      hostGroupType = make_shared<string>(boost::any_cast<string>(m["HostGroupType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("MultiInstanceTypes") != m.end() && !m["MultiInstanceTypes"].empty()) {
      multiInstanceTypes = make_shared<string>(boost::any_cast<string>(m["MultiInstanceTypes"]));
    }
    if (m.find("NodeCount") != m.end() && !m["NodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["NodeCount"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("SysDiskCapacity") != m.end() && !m["SysDiskCapacity"].empty()) {
      sysDiskCapacity = make_shared<long>(boost::any_cast<long>(m["SysDiskCapacity"]));
    }
    if (m.find("SysDiskType") != m.end() && !m["SysDiskType"].empty()) {
      sysDiskType = make_shared<string>(boost::any_cast<string>(m["SysDiskType"]));
    }
  }


  virtual ~DescribeClusterTemplateResponseBodyTemplateInfoHostGroupListHostGroup() = default;
};
class DescribeClusterTemplateResponseBodyTemplateInfoHostGroupList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterTemplateResponseBodyTemplateInfoHostGroupListHostGroup>> hostGroup{};

  DescribeClusterTemplateResponseBodyTemplateInfoHostGroupList() {}

  explicit DescribeClusterTemplateResponseBodyTemplateInfoHostGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroup) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroup") != m.end() && !m["HostGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["HostGroup"].type()) {
        vector<DescribeClusterTemplateResponseBodyTemplateInfoHostGroupListHostGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterTemplateResponseBodyTemplateInfoHostGroupListHostGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroup = make_shared<vector<DescribeClusterTemplateResponseBodyTemplateInfoHostGroupListHostGroup>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterTemplateResponseBodyTemplateInfoHostGroupList() = default;
};
class DescribeClusterTemplateResponseBodyTemplateInfoSoftwareInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> softwareInfo{};

  DescribeClusterTemplateResponseBodyTemplateInfoSoftwareInfoList() {}

  explicit DescribeClusterTemplateResponseBodyTemplateInfoSoftwareInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (softwareInfo) {
      res["SoftwareInfo"] = boost::any(*softwareInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SoftwareInfo") != m.end() && !m["SoftwareInfo"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SoftwareInfo"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SoftwareInfo"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      softwareInfo = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeClusterTemplateResponseBodyTemplateInfoSoftwareInfoList() = default;
};
class DescribeClusterTemplateResponseBodyTemplateInfoTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  DescribeClusterTemplateResponseBodyTemplateInfoTagsTag() {}

  explicit DescribeClusterTemplateResponseBodyTemplateInfoTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeClusterTemplateResponseBodyTemplateInfoTagsTag() = default;
};
class DescribeClusterTemplateResponseBodyTemplateInfoTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterTemplateResponseBodyTemplateInfoTagsTag>> tag{};

  DescribeClusterTemplateResponseBodyTemplateInfoTags() {}

  explicit DescribeClusterTemplateResponseBodyTemplateInfoTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeClusterTemplateResponseBodyTemplateInfoTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterTemplateResponseBodyTemplateInfoTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeClusterTemplateResponseBodyTemplateInfoTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterTemplateResponseBodyTemplateInfoTags() = default;
};
class DescribeClusterTemplateResponseBodyTemplateInfo : public Darabonba::Model {
public:
  shared_ptr<bool> allowNotebook{};
  shared_ptr<DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionList> bootstrapActionList{};
  shared_ptr<string> clusterType{};
  shared_ptr<DescribeClusterTemplateResponseBodyTemplateInfoConfigList> configList{};
  shared_ptr<string> configurations{};
  shared_ptr<string> createSource{};
  shared_ptr<bool> dataDiskEncrypted{};
  shared_ptr<string> dataDiskKMSKeyId{};
  shared_ptr<string> depositType{};
  shared_ptr<bool> easEnable{};
  shared_ptr<string> emrVer{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<bool> highAvailabilityEnable{};
  shared_ptr<DescribeClusterTemplateResponseBodyTemplateInfoHostGroupList> hostGroupList{};
  shared_ptr<string> id{};
  shared_ptr<bool> initCustomHiveMetaDb{};
  shared_ptr<string> instanceGeneration{};
  shared_ptr<bool> ioOptimized{};
  shared_ptr<bool> isOpenPublicIp{};
  shared_ptr<string> keyPairName{};
  shared_ptr<bool> logEnable{};
  shared_ptr<string> logPath{};
  shared_ptr<string> machineType{};
  shared_ptr<long> masterNodeTotal{};
  shared_ptr<string> masterPwd{};
  shared_ptr<string> metaStoreConf{};
  shared_ptr<string> metaStoreType{};
  shared_ptr<string> netType{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> securityGroupName{};
  shared_ptr<DescribeClusterTemplateResponseBodyTemplateInfoSoftwareInfoList> softwareInfoList{};
  shared_ptr<bool> sshEnable{};
  shared_ptr<DescribeClusterTemplateResponseBodyTemplateInfoTags> tags{};
  shared_ptr<string> templateName{};
  shared_ptr<bool> useCustomHiveMetaDb{};
  shared_ptr<bool> useLocalMetaDb{};
  shared_ptr<string> userDefinedEmrEcsRole{};
  shared_ptr<string> userId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};

  DescribeClusterTemplateResponseBodyTemplateInfo() {}

  explicit DescribeClusterTemplateResponseBodyTemplateInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowNotebook) {
      res["AllowNotebook"] = boost::any(*allowNotebook);
    }
    if (bootstrapActionList) {
      res["BootstrapActionList"] = bootstrapActionList ? boost::any(bootstrapActionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (configList) {
      res["ConfigList"] = configList ? boost::any(configList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (configurations) {
      res["Configurations"] = boost::any(*configurations);
    }
    if (createSource) {
      res["CreateSource"] = boost::any(*createSource);
    }
    if (dataDiskEncrypted) {
      res["DataDiskEncrypted"] = boost::any(*dataDiskEncrypted);
    }
    if (dataDiskKMSKeyId) {
      res["DataDiskKMSKeyId"] = boost::any(*dataDiskKMSKeyId);
    }
    if (depositType) {
      res["DepositType"] = boost::any(*depositType);
    }
    if (easEnable) {
      res["EasEnable"] = boost::any(*easEnable);
    }
    if (emrVer) {
      res["EmrVer"] = boost::any(*emrVer);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (highAvailabilityEnable) {
      res["HighAvailabilityEnable"] = boost::any(*highAvailabilityEnable);
    }
    if (hostGroupList) {
      res["HostGroupList"] = hostGroupList ? boost::any(hostGroupList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (initCustomHiveMetaDb) {
      res["InitCustomHiveMetaDb"] = boost::any(*initCustomHiveMetaDb);
    }
    if (instanceGeneration) {
      res["InstanceGeneration"] = boost::any(*instanceGeneration);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (isOpenPublicIp) {
      res["IsOpenPublicIp"] = boost::any(*isOpenPublicIp);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (logEnable) {
      res["LogEnable"] = boost::any(*logEnable);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (machineType) {
      res["MachineType"] = boost::any(*machineType);
    }
    if (masterNodeTotal) {
      res["MasterNodeTotal"] = boost::any(*masterNodeTotal);
    }
    if (masterPwd) {
      res["MasterPwd"] = boost::any(*masterPwd);
    }
    if (metaStoreConf) {
      res["MetaStoreConf"] = boost::any(*metaStoreConf);
    }
    if (metaStoreType) {
      res["MetaStoreType"] = boost::any(*metaStoreType);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    if (softwareInfoList) {
      res["SoftwareInfoList"] = softwareInfoList ? boost::any(softwareInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sshEnable) {
      res["SshEnable"] = boost::any(*sshEnable);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (useCustomHiveMetaDb) {
      res["UseCustomHiveMetaDb"] = boost::any(*useCustomHiveMetaDb);
    }
    if (useLocalMetaDb) {
      res["UseLocalMetaDb"] = boost::any(*useLocalMetaDb);
    }
    if (userDefinedEmrEcsRole) {
      res["UserDefinedEmrEcsRole"] = boost::any(*userDefinedEmrEcsRole);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowNotebook") != m.end() && !m["AllowNotebook"].empty()) {
      allowNotebook = make_shared<bool>(boost::any_cast<bool>(m["AllowNotebook"]));
    }
    if (m.find("BootstrapActionList") != m.end() && !m["BootstrapActionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["BootstrapActionList"].type()) {
        DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BootstrapActionList"]));
        bootstrapActionList = make_shared<DescribeClusterTemplateResponseBodyTemplateInfoBootstrapActionList>(model1);
      }
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("ConfigList") != m.end() && !m["ConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigList"].type()) {
        DescribeClusterTemplateResponseBodyTemplateInfoConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigList"]));
        configList = make_shared<DescribeClusterTemplateResponseBodyTemplateInfoConfigList>(model1);
      }
    }
    if (m.find("Configurations") != m.end() && !m["Configurations"].empty()) {
      configurations = make_shared<string>(boost::any_cast<string>(m["Configurations"]));
    }
    if (m.find("CreateSource") != m.end() && !m["CreateSource"].empty()) {
      createSource = make_shared<string>(boost::any_cast<string>(m["CreateSource"]));
    }
    if (m.find("DataDiskEncrypted") != m.end() && !m["DataDiskEncrypted"].empty()) {
      dataDiskEncrypted = make_shared<bool>(boost::any_cast<bool>(m["DataDiskEncrypted"]));
    }
    if (m.find("DataDiskKMSKeyId") != m.end() && !m["DataDiskKMSKeyId"].empty()) {
      dataDiskKMSKeyId = make_shared<string>(boost::any_cast<string>(m["DataDiskKMSKeyId"]));
    }
    if (m.find("DepositType") != m.end() && !m["DepositType"].empty()) {
      depositType = make_shared<string>(boost::any_cast<string>(m["DepositType"]));
    }
    if (m.find("EasEnable") != m.end() && !m["EasEnable"].empty()) {
      easEnable = make_shared<bool>(boost::any_cast<bool>(m["EasEnable"]));
    }
    if (m.find("EmrVer") != m.end() && !m["EmrVer"].empty()) {
      emrVer = make_shared<string>(boost::any_cast<string>(m["EmrVer"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("HighAvailabilityEnable") != m.end() && !m["HighAvailabilityEnable"].empty()) {
      highAvailabilityEnable = make_shared<bool>(boost::any_cast<bool>(m["HighAvailabilityEnable"]));
    }
    if (m.find("HostGroupList") != m.end() && !m["HostGroupList"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostGroupList"].type()) {
        DescribeClusterTemplateResponseBodyTemplateInfoHostGroupList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostGroupList"]));
        hostGroupList = make_shared<DescribeClusterTemplateResponseBodyTemplateInfoHostGroupList>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InitCustomHiveMetaDb") != m.end() && !m["InitCustomHiveMetaDb"].empty()) {
      initCustomHiveMetaDb = make_shared<bool>(boost::any_cast<bool>(m["InitCustomHiveMetaDb"]));
    }
    if (m.find("InstanceGeneration") != m.end() && !m["InstanceGeneration"].empty()) {
      instanceGeneration = make_shared<string>(boost::any_cast<string>(m["InstanceGeneration"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<bool>(boost::any_cast<bool>(m["IoOptimized"]));
    }
    if (m.find("IsOpenPublicIp") != m.end() && !m["IsOpenPublicIp"].empty()) {
      isOpenPublicIp = make_shared<bool>(boost::any_cast<bool>(m["IsOpenPublicIp"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("LogEnable") != m.end() && !m["LogEnable"].empty()) {
      logEnable = make_shared<bool>(boost::any_cast<bool>(m["LogEnable"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("MachineType") != m.end() && !m["MachineType"].empty()) {
      machineType = make_shared<string>(boost::any_cast<string>(m["MachineType"]));
    }
    if (m.find("MasterNodeTotal") != m.end() && !m["MasterNodeTotal"].empty()) {
      masterNodeTotal = make_shared<long>(boost::any_cast<long>(m["MasterNodeTotal"]));
    }
    if (m.find("MasterPwd") != m.end() && !m["MasterPwd"].empty()) {
      masterPwd = make_shared<string>(boost::any_cast<string>(m["MasterPwd"]));
    }
    if (m.find("MetaStoreConf") != m.end() && !m["MetaStoreConf"].empty()) {
      metaStoreConf = make_shared<string>(boost::any_cast<string>(m["MetaStoreConf"]));
    }
    if (m.find("MetaStoreType") != m.end() && !m["MetaStoreType"].empty()) {
      metaStoreType = make_shared<string>(boost::any_cast<string>(m["MetaStoreType"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
    if (m.find("SoftwareInfoList") != m.end() && !m["SoftwareInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SoftwareInfoList"].type()) {
        DescribeClusterTemplateResponseBodyTemplateInfoSoftwareInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SoftwareInfoList"]));
        softwareInfoList = make_shared<DescribeClusterTemplateResponseBodyTemplateInfoSoftwareInfoList>(model1);
      }
    }
    if (m.find("SshEnable") != m.end() && !m["SshEnable"].empty()) {
      sshEnable = make_shared<bool>(boost::any_cast<bool>(m["SshEnable"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeClusterTemplateResponseBodyTemplateInfoTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeClusterTemplateResponseBodyTemplateInfoTags>(model1);
      }
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("UseCustomHiveMetaDb") != m.end() && !m["UseCustomHiveMetaDb"].empty()) {
      useCustomHiveMetaDb = make_shared<bool>(boost::any_cast<bool>(m["UseCustomHiveMetaDb"]));
    }
    if (m.find("UseLocalMetaDb") != m.end() && !m["UseLocalMetaDb"].empty()) {
      useLocalMetaDb = make_shared<bool>(boost::any_cast<bool>(m["UseLocalMetaDb"]));
    }
    if (m.find("UserDefinedEmrEcsRole") != m.end() && !m["UserDefinedEmrEcsRole"].empty()) {
      userDefinedEmrEcsRole = make_shared<string>(boost::any_cast<string>(m["UserDefinedEmrEcsRole"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeClusterTemplateResponseBodyTemplateInfo() = default;
};
class DescribeClusterTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeClusterTemplateResponseBodyTemplateInfo> templateInfo{};

  DescribeClusterTemplateResponseBody() {}

  explicit DescribeClusterTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateInfo) {
      res["TemplateInfo"] = templateInfo ? boost::any(templateInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateInfo") != m.end() && !m["TemplateInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateInfo"].type()) {
        DescribeClusterTemplateResponseBodyTemplateInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateInfo"]));
        templateInfo = make_shared<DescribeClusterTemplateResponseBodyTemplateInfo>(model1);
      }
    }
  }


  virtual ~DescribeClusterTemplateResponseBody() = default;
};
class DescribeClusterTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterTemplateResponseBody> body{};

  DescribeClusterTemplateResponse() {}

  explicit DescribeClusterTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterTemplateResponse() = default;
};
class DescribeClusterV2Request : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};

  DescribeClusterV2Request() {}

  explicit DescribeClusterV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeClusterV2Request() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinksZKLink : public Darabonba::Model {
public:
  shared_ptr<string> link{};
  shared_ptr<string> port{};

  DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinksZKLink() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinksZKLink(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (link) {
      res["Link"] = boost::any(*link);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Link") != m.end() && !m["Link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["Link"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinksZKLink() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinksZKLink>> ZKLink{};

  DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinks() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ZKLink) {
      vector<boost::any> temp1;
      for(auto item1:*ZKLink){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ZKLink"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ZKLink") != m.end() && !m["ZKLink"].empty()) {
      if (typeid(vector<boost::any>) == m["ZKLink"].type()) {
        vector<DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinksZKLink> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ZKLink"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinksZKLink model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ZKLink = make_shared<vector<DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinksZKLink>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinks() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoAccessInfo : public Darabonba::Model {
public:
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinks> ZKLinks{};

  DescribeClusterV2ResponseBodyClusterInfoAccessInfo() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoAccessInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ZKLinks) {
      res["ZKLinks"] = ZKLinks ? boost::any(ZKLinks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ZKLinks") != m.end() && !m["ZKLinks"].empty()) {
      if (typeid(map<string, boost::any>) == m["ZKLinks"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ZKLinks"]));
        ZKLinks = make_shared<DescribeClusterV2ResponseBodyClusterInfoAccessInfoZKLinks>(model1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoAccessInfo() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoBootstrapActionListBootstrapAction : public Darabonba::Model {
public:
  shared_ptr<string> arg{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};

  DescribeClusterV2ResponseBodyClusterInfoBootstrapActionListBootstrapAction() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoBootstrapActionListBootstrapAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arg) {
      res["Arg"] = boost::any(*arg);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arg") != m.end() && !m["Arg"].empty()) {
      arg = make_shared<string>(boost::any_cast<string>(m["Arg"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoBootstrapActionListBootstrapAction() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoBootstrapActionList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterV2ResponseBodyClusterInfoBootstrapActionListBootstrapAction>> bootstrapAction{};

  DescribeClusterV2ResponseBodyClusterInfoBootstrapActionList() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoBootstrapActionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bootstrapAction) {
      vector<boost::any> temp1;
      for(auto item1:*bootstrapAction){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BootstrapAction"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BootstrapAction") != m.end() && !m["BootstrapAction"].empty()) {
      if (typeid(vector<boost::any>) == m["BootstrapAction"].type()) {
        vector<DescribeClusterV2ResponseBodyClusterInfoBootstrapActionListBootstrapAction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BootstrapAction"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterV2ResponseBodyClusterInfoBootstrapActionListBootstrapAction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bootstrapAction = make_shared<vector<DescribeClusterV2ResponseBodyClusterInfoBootstrapActionListBootstrapAction>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoBootstrapActionList() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoFailReason : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};

  DescribeClusterV2ResponseBodyClusterInfoFailReason() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoFailReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoFailReason() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> status{};

  DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo>> gatewayClusterInfo{};

  DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoList() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayClusterInfo) {
      vector<boost::any> temp1;
      for(auto item1:*gatewayClusterInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GatewayClusterInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayClusterInfo") != m.end() && !m["GatewayClusterInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["GatewayClusterInfo"].type()) {
        vector<DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GatewayClusterInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        gatewayClusterInfo = make_shared<vector<DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoListGatewayClusterInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoList() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfosDaemonInfo : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfosDaemonInfo() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfosDaemonInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfosDaemonInfo() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfosDaemonInfo>> daemonInfo{};

  DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfos() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (daemonInfo) {
      vector<boost::any> temp1;
      for(auto item1:*daemonInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DaemonInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DaemonInfo") != m.end() && !m["DaemonInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DaemonInfo"].type()) {
        vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfosDaemonInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DaemonInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfosDaemonInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        daemonInfo = make_shared<vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfosDaemonInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfos() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfosDiskInfo : public Darabonba::Model {
public:
  shared_ptr<string> device{};
  shared_ptr<string> diskId{};
  shared_ptr<string> diskName{};
  shared_ptr<long> size{};
  shared_ptr<string> type{};

  DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfosDiskInfo() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfosDiskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (diskName) {
      res["DiskName"] = boost::any(*diskName);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("DiskName") != m.end() && !m["DiskName"].empty()) {
      diskName = make_shared<string>(boost::any_cast<string>(m["DiskName"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfosDiskInfo() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfosDiskInfo>> diskInfo{};

  DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfos() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskInfo) {
      vector<boost::any> temp1;
      for(auto item1:*diskInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiskInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskInfo") != m.end() && !m["DiskInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DiskInfo"].type()) {
        vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfosDiskInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiskInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfosDiskInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diskInfo = make_shared<vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfosDiskInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfos() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNode : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfos> daemonInfos{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfos> diskInfos{};
  shared_ptr<string> emrExpiredTime{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> innerIp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> pubIp{};
  shared_ptr<string> status{};
  shared_ptr<bool> supportIpV6{};
  shared_ptr<string> zoneId{};

  DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNode() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (daemonInfos) {
      res["DaemonInfos"] = daemonInfos ? boost::any(daemonInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (diskInfos) {
      res["DiskInfos"] = diskInfos ? boost::any(diskInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emrExpiredTime) {
      res["EmrExpiredTime"] = boost::any(*emrExpiredTime);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (innerIp) {
      res["InnerIp"] = boost::any(*innerIp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pubIp) {
      res["PubIp"] = boost::any(*pubIp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (supportIpV6) {
      res["SupportIpV6"] = boost::any(*supportIpV6);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DaemonInfos") != m.end() && !m["DaemonInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["DaemonInfos"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DaemonInfos"]));
        daemonInfos = make_shared<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDaemonInfos>(model1);
      }
    }
    if (m.find("DiskInfos") != m.end() && !m["DiskInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskInfos"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskInfos"]));
        diskInfos = make_shared<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNodeDiskInfos>(model1);
      }
    }
    if (m.find("EmrExpiredTime") != m.end() && !m["EmrExpiredTime"].empty()) {
      emrExpiredTime = make_shared<string>(boost::any_cast<string>(m["EmrExpiredTime"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("InnerIp") != m.end() && !m["InnerIp"].empty()) {
      innerIp = make_shared<string>(boost::any_cast<string>(m["InnerIp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PubIp") != m.end() && !m["PubIp"].empty()) {
      pubIp = make_shared<string>(boost::any_cast<string>(m["PubIp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SupportIpV6") != m.end() && !m["SupportIpV6"].empty()) {
      supportIpV6 = make_shared<bool>(boost::any_cast<bool>(m["SupportIpV6"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNode() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNode>> node{};

  DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodes() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (node) {
      vector<boost::any> temp1;
      for(auto item1:*node){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Node"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Node") != m.end() && !m["Node"].empty()) {
      if (typeid(vector<boost::any>) == m["Node"].type()) {
        vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Node"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        node = make_shared<vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodesNode>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodes() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroup : public Darabonba::Model {
public:
  shared_ptr<string> bandWidth{};
  shared_ptr<string> chargeType{};
  shared_ptr<long> cpuCore{};
  shared_ptr<long> diskCapacity{};
  shared_ptr<long> diskCount{};
  shared_ptr<string> diskType{};
  shared_ptr<string> hostGroupChangeStatus{};
  shared_ptr<string> hostGroupChangeType{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<string> hostGroupSubType{};
  shared_ptr<string> hostGroupType{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> lockReason{};
  shared_ptr<string> lockType{};
  shared_ptr<long> memoryCapacity{};
  shared_ptr<long> nodeCount{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodes> nodes{};
  shared_ptr<string> period{};

  DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroup() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandWidth) {
      res["BandWidth"] = boost::any(*bandWidth);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (cpuCore) {
      res["CpuCore"] = boost::any(*cpuCore);
    }
    if (diskCapacity) {
      res["DiskCapacity"] = boost::any(*diskCapacity);
    }
    if (diskCount) {
      res["DiskCount"] = boost::any(*diskCount);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (hostGroupChangeStatus) {
      res["HostGroupChangeStatus"] = boost::any(*hostGroupChangeStatus);
    }
    if (hostGroupChangeType) {
      res["HostGroupChangeType"] = boost::any(*hostGroupChangeType);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (hostGroupSubType) {
      res["HostGroupSubType"] = boost::any(*hostGroupSubType);
    }
    if (hostGroupType) {
      res["HostGroupType"] = boost::any(*hostGroupType);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    if (lockType) {
      res["LockType"] = boost::any(*lockType);
    }
    if (memoryCapacity) {
      res["MemoryCapacity"] = boost::any(*memoryCapacity);
    }
    if (nodeCount) {
      res["NodeCount"] = boost::any(*nodeCount);
    }
    if (nodes) {
      res["Nodes"] = nodes ? boost::any(nodes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandWidth") != m.end() && !m["BandWidth"].empty()) {
      bandWidth = make_shared<string>(boost::any_cast<string>(m["BandWidth"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("CpuCore") != m.end() && !m["CpuCore"].empty()) {
      cpuCore = make_shared<long>(boost::any_cast<long>(m["CpuCore"]));
    }
    if (m.find("DiskCapacity") != m.end() && !m["DiskCapacity"].empty()) {
      diskCapacity = make_shared<long>(boost::any_cast<long>(m["DiskCapacity"]));
    }
    if (m.find("DiskCount") != m.end() && !m["DiskCount"].empty()) {
      diskCount = make_shared<long>(boost::any_cast<long>(m["DiskCount"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("HostGroupChangeStatus") != m.end() && !m["HostGroupChangeStatus"].empty()) {
      hostGroupChangeStatus = make_shared<string>(boost::any_cast<string>(m["HostGroupChangeStatus"]));
    }
    if (m.find("HostGroupChangeType") != m.end() && !m["HostGroupChangeType"].empty()) {
      hostGroupChangeType = make_shared<string>(boost::any_cast<string>(m["HostGroupChangeType"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("HostGroupSubType") != m.end() && !m["HostGroupSubType"].empty()) {
      hostGroupSubType = make_shared<string>(boost::any_cast<string>(m["HostGroupSubType"]));
    }
    if (m.find("HostGroupType") != m.end() && !m["HostGroupType"].empty()) {
      hostGroupType = make_shared<string>(boost::any_cast<string>(m["HostGroupType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
    if (m.find("LockType") != m.end() && !m["LockType"].empty()) {
      lockType = make_shared<string>(boost::any_cast<string>(m["LockType"]));
    }
    if (m.find("MemoryCapacity") != m.end() && !m["MemoryCapacity"].empty()) {
      memoryCapacity = make_shared<long>(boost::any_cast<long>(m["MemoryCapacity"]));
    }
    if (m.find("NodeCount") != m.end() && !m["NodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["NodeCount"]));
    }
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      if (typeid(map<string, boost::any>) == m["Nodes"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Nodes"]));
        nodes = make_shared<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroupNodes>(model1);
      }
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroup() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoHostGroupList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroup>> hostGroup{};

  DescribeClusterV2ResponseBodyClusterInfoHostGroupList() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoHostGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroup) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroup") != m.end() && !m["HostGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["HostGroup"].type()) {
        vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroup = make_shared<vector<DescribeClusterV2ResponseBodyClusterInfoHostGroupListHostGroup>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoHostGroupList() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoHostPoolInfo : public Darabonba::Model {
public:
  shared_ptr<string> hpBizId{};
  shared_ptr<string> hpName{};

  DescribeClusterV2ResponseBodyClusterInfoHostPoolInfo() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoHostPoolInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hpBizId) {
      res["HpBizId"] = boost::any(*hpBizId);
    }
    if (hpName) {
      res["HpName"] = boost::any(*hpName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HpBizId") != m.end() && !m["HpBizId"].empty()) {
      hpBizId = make_shared<string>(boost::any_cast<string>(m["HpBizId"]));
    }
    if (m.find("HpName") != m.end() && !m["HpName"].empty()) {
      hpName = make_shared<string>(boost::any_cast<string>(m["HpName"]));
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoHostPoolInfo() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoRelateClusterInfo : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> status{};

  DescribeClusterV2ResponseBodyClusterInfoRelateClusterInfo() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoRelateClusterInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoRelateClusterInfo() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> name{};
  shared_ptr<bool> onlyDisplay{};
  shared_ptr<long> startTpe{};
  shared_ptr<string> version{};

  DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (onlyDisplay) {
      res["OnlyDisplay"] = boost::any(*onlyDisplay);
    }
    if (startTpe) {
      res["StartTpe"] = boost::any(*startTpe);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OnlyDisplay") != m.end() && !m["OnlyDisplay"].empty()) {
      onlyDisplay = make_shared<bool>(boost::any_cast<bool>(m["OnlyDisplay"]));
    }
    if (m.find("StartTpe") != m.end() && !m["StartTpe"].empty()) {
      startTpe = make_shared<long>(boost::any_cast<long>(m["StartTpe"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwares : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware>> software{};

  DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwares() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwares(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (software) {
      vector<boost::any> temp1;
      for(auto item1:*software){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Software"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Software") != m.end() && !m["Software"].empty()) {
      if (typeid(vector<boost::any>) == m["Software"].type()) {
        vector<DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Software"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        software = make_shared<vector<DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwaresSoftware>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwares() = default;
};
class DescribeClusterV2ResponseBodyClusterInfoSoftwareInfo : public Darabonba::Model {
public:
  shared_ptr<string> clusterType{};
  shared_ptr<string> emrVer{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwares> softwares{};

  DescribeClusterV2ResponseBodyClusterInfoSoftwareInfo() {}

  explicit DescribeClusterV2ResponseBodyClusterInfoSoftwareInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (emrVer) {
      res["EmrVer"] = boost::any(*emrVer);
    }
    if (softwares) {
      res["Softwares"] = softwares ? boost::any(softwares->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("EmrVer") != m.end() && !m["EmrVer"].empty()) {
      emrVer = make_shared<string>(boost::any_cast<string>(m["EmrVer"]));
    }
    if (m.find("Softwares") != m.end() && !m["Softwares"].empty()) {
      if (typeid(map<string, boost::any>) == m["Softwares"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwares model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Softwares"]));
        softwares = make_shared<DescribeClusterV2ResponseBodyClusterInfoSoftwareInfoSoftwares>(model1);
      }
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfoSoftwareInfo() = default;
};
class DescribeClusterV2ResponseBodyClusterInfo : public Darabonba::Model {
public:
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoAccessInfo> accessInfo{};
  shared_ptr<bool> autoScalingAllowed{};
  shared_ptr<bool> autoScalingByLoadAllowed{};
  shared_ptr<bool> autoScalingEnable{};
  shared_ptr<bool> autoScalingSpotWithLimitAllowed{};
  shared_ptr<string> autoScalingVersion{};
  shared_ptr<bool> autoScalingWithGraceAllowed{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoBootstrapActionList> bootstrapActionList{};
  shared_ptr<bool> bootstrapFailed{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> configurations{};
  shared_ptr<long> coreNodeInService{};
  shared_ptr<long> coreNodeTotal{};
  shared_ptr<string> createResource{};
  shared_ptr<string> createType{};
  shared_ptr<bool> dataDiskEncrypted{};
  shared_ptr<string> dataDiskKMSKeyId{};
  shared_ptr<string> depositType{};
  shared_ptr<bool> easEnable{};
  shared_ptr<long> expiredTime{};
  shared_ptr<string> extraInfo{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoFailReason> failReason{};
  shared_ptr<string> gatewayClusterIds{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoList> gatewayClusterInfoList{};
  shared_ptr<bool> highAvailabilityEnable{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoHostGroupList> hostGroupList{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoHostPoolInfo> hostPoolInfo{};
  shared_ptr<string> id{};
  shared_ptr<string> imageId{};
  shared_ptr<string> instanceGeneration{};
  shared_ptr<bool> ioOptimized{};
  shared_ptr<string> k8sClusterId{};
  shared_ptr<bool> localMetaDb{};
  shared_ptr<bool> logEnable{};
  shared_ptr<string> logPath{};
  shared_ptr<string> machineType{};
  shared_ptr<long> masterNodeInService{};
  shared_ptr<long> masterNodeTotal{};
  shared_ptr<string> metaStoreType{};
  shared_ptr<string> name{};
  shared_ptr<string> netType{};
  shared_ptr<long> period{};
  shared_ptr<string> regionId{};
  shared_ptr<string> relateClusterId{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoRelateClusterInfo> relateClusterInfo{};
  shared_ptr<bool> resizeDiskEnable{};
  shared_ptr<long> runningTime{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> securityGroupName{};
  shared_ptr<bool> showSoftwareInterface{};
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfoSoftwareInfo> softwareInfo{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<long> stopTime{};
  shared_ptr<long> taskNodeInService{};
  shared_ptr<long> taskNodeTotal{};
  shared_ptr<string> userDefinedEmrEcsRole{};
  shared_ptr<string> userId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};

  DescribeClusterV2ResponseBodyClusterInfo() {}

  explicit DescribeClusterV2ResponseBodyClusterInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessInfo) {
      res["AccessInfo"] = accessInfo ? boost::any(accessInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (autoScalingAllowed) {
      res["AutoScalingAllowed"] = boost::any(*autoScalingAllowed);
    }
    if (autoScalingByLoadAllowed) {
      res["AutoScalingByLoadAllowed"] = boost::any(*autoScalingByLoadAllowed);
    }
    if (autoScalingEnable) {
      res["AutoScalingEnable"] = boost::any(*autoScalingEnable);
    }
    if (autoScalingSpotWithLimitAllowed) {
      res["AutoScalingSpotWithLimitAllowed"] = boost::any(*autoScalingSpotWithLimitAllowed);
    }
    if (autoScalingVersion) {
      res["AutoScalingVersion"] = boost::any(*autoScalingVersion);
    }
    if (autoScalingWithGraceAllowed) {
      res["AutoScalingWithGraceAllowed"] = boost::any(*autoScalingWithGraceAllowed);
    }
    if (bootstrapActionList) {
      res["BootstrapActionList"] = bootstrapActionList ? boost::any(bootstrapActionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bootstrapFailed) {
      res["BootstrapFailed"] = boost::any(*bootstrapFailed);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (configurations) {
      res["Configurations"] = boost::any(*configurations);
    }
    if (coreNodeInService) {
      res["CoreNodeInService"] = boost::any(*coreNodeInService);
    }
    if (coreNodeTotal) {
      res["CoreNodeTotal"] = boost::any(*coreNodeTotal);
    }
    if (createResource) {
      res["CreateResource"] = boost::any(*createResource);
    }
    if (createType) {
      res["CreateType"] = boost::any(*createType);
    }
    if (dataDiskEncrypted) {
      res["DataDiskEncrypted"] = boost::any(*dataDiskEncrypted);
    }
    if (dataDiskKMSKeyId) {
      res["DataDiskKMSKeyId"] = boost::any(*dataDiskKMSKeyId);
    }
    if (depositType) {
      res["DepositType"] = boost::any(*depositType);
    }
    if (easEnable) {
      res["EasEnable"] = boost::any(*easEnable);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (extraInfo) {
      res["ExtraInfo"] = boost::any(*extraInfo);
    }
    if (failReason) {
      res["FailReason"] = failReason ? boost::any(failReason->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gatewayClusterIds) {
      res["GatewayClusterIds"] = boost::any(*gatewayClusterIds);
    }
    if (gatewayClusterInfoList) {
      res["GatewayClusterInfoList"] = gatewayClusterInfoList ? boost::any(gatewayClusterInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (highAvailabilityEnable) {
      res["HighAvailabilityEnable"] = boost::any(*highAvailabilityEnable);
    }
    if (hostGroupList) {
      res["HostGroupList"] = hostGroupList ? boost::any(hostGroupList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hostPoolInfo) {
      res["HostPoolInfo"] = hostPoolInfo ? boost::any(hostPoolInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (instanceGeneration) {
      res["InstanceGeneration"] = boost::any(*instanceGeneration);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (k8sClusterId) {
      res["K8sClusterId"] = boost::any(*k8sClusterId);
    }
    if (localMetaDb) {
      res["LocalMetaDb"] = boost::any(*localMetaDb);
    }
    if (logEnable) {
      res["LogEnable"] = boost::any(*logEnable);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (machineType) {
      res["MachineType"] = boost::any(*machineType);
    }
    if (masterNodeInService) {
      res["MasterNodeInService"] = boost::any(*masterNodeInService);
    }
    if (masterNodeTotal) {
      res["MasterNodeTotal"] = boost::any(*masterNodeTotal);
    }
    if (metaStoreType) {
      res["MetaStoreType"] = boost::any(*metaStoreType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (relateClusterId) {
      res["RelateClusterId"] = boost::any(*relateClusterId);
    }
    if (relateClusterInfo) {
      res["RelateClusterInfo"] = relateClusterInfo ? boost::any(relateClusterInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resizeDiskEnable) {
      res["ResizeDiskEnable"] = boost::any(*resizeDiskEnable);
    }
    if (runningTime) {
      res["RunningTime"] = boost::any(*runningTime);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    if (showSoftwareInterface) {
      res["ShowSoftwareInterface"] = boost::any(*showSoftwareInterface);
    }
    if (softwareInfo) {
      res["SoftwareInfo"] = softwareInfo ? boost::any(softwareInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    if (taskNodeInService) {
      res["TaskNodeInService"] = boost::any(*taskNodeInService);
    }
    if (taskNodeTotal) {
      res["TaskNodeTotal"] = boost::any(*taskNodeTotal);
    }
    if (userDefinedEmrEcsRole) {
      res["UserDefinedEmrEcsRole"] = boost::any(*userDefinedEmrEcsRole);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessInfo") != m.end() && !m["AccessInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccessInfo"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoAccessInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccessInfo"]));
        accessInfo = make_shared<DescribeClusterV2ResponseBodyClusterInfoAccessInfo>(model1);
      }
    }
    if (m.find("AutoScalingAllowed") != m.end() && !m["AutoScalingAllowed"].empty()) {
      autoScalingAllowed = make_shared<bool>(boost::any_cast<bool>(m["AutoScalingAllowed"]));
    }
    if (m.find("AutoScalingByLoadAllowed") != m.end() && !m["AutoScalingByLoadAllowed"].empty()) {
      autoScalingByLoadAllowed = make_shared<bool>(boost::any_cast<bool>(m["AutoScalingByLoadAllowed"]));
    }
    if (m.find("AutoScalingEnable") != m.end() && !m["AutoScalingEnable"].empty()) {
      autoScalingEnable = make_shared<bool>(boost::any_cast<bool>(m["AutoScalingEnable"]));
    }
    if (m.find("AutoScalingSpotWithLimitAllowed") != m.end() && !m["AutoScalingSpotWithLimitAllowed"].empty()) {
      autoScalingSpotWithLimitAllowed = make_shared<bool>(boost::any_cast<bool>(m["AutoScalingSpotWithLimitAllowed"]));
    }
    if (m.find("AutoScalingVersion") != m.end() && !m["AutoScalingVersion"].empty()) {
      autoScalingVersion = make_shared<string>(boost::any_cast<string>(m["AutoScalingVersion"]));
    }
    if (m.find("AutoScalingWithGraceAllowed") != m.end() && !m["AutoScalingWithGraceAllowed"].empty()) {
      autoScalingWithGraceAllowed = make_shared<bool>(boost::any_cast<bool>(m["AutoScalingWithGraceAllowed"]));
    }
    if (m.find("BootstrapActionList") != m.end() && !m["BootstrapActionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["BootstrapActionList"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoBootstrapActionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BootstrapActionList"]));
        bootstrapActionList = make_shared<DescribeClusterV2ResponseBodyClusterInfoBootstrapActionList>(model1);
      }
    }
    if (m.find("BootstrapFailed") != m.end() && !m["BootstrapFailed"].empty()) {
      bootstrapFailed = make_shared<bool>(boost::any_cast<bool>(m["BootstrapFailed"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("Configurations") != m.end() && !m["Configurations"].empty()) {
      configurations = make_shared<string>(boost::any_cast<string>(m["Configurations"]));
    }
    if (m.find("CoreNodeInService") != m.end() && !m["CoreNodeInService"].empty()) {
      coreNodeInService = make_shared<long>(boost::any_cast<long>(m["CoreNodeInService"]));
    }
    if (m.find("CoreNodeTotal") != m.end() && !m["CoreNodeTotal"].empty()) {
      coreNodeTotal = make_shared<long>(boost::any_cast<long>(m["CoreNodeTotal"]));
    }
    if (m.find("CreateResource") != m.end() && !m["CreateResource"].empty()) {
      createResource = make_shared<string>(boost::any_cast<string>(m["CreateResource"]));
    }
    if (m.find("CreateType") != m.end() && !m["CreateType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["CreateType"]));
    }
    if (m.find("DataDiskEncrypted") != m.end() && !m["DataDiskEncrypted"].empty()) {
      dataDiskEncrypted = make_shared<bool>(boost::any_cast<bool>(m["DataDiskEncrypted"]));
    }
    if (m.find("DataDiskKMSKeyId") != m.end() && !m["DataDiskKMSKeyId"].empty()) {
      dataDiskKMSKeyId = make_shared<string>(boost::any_cast<string>(m["DataDiskKMSKeyId"]));
    }
    if (m.find("DepositType") != m.end() && !m["DepositType"].empty()) {
      depositType = make_shared<string>(boost::any_cast<string>(m["DepositType"]));
    }
    if (m.find("EasEnable") != m.end() && !m["EasEnable"].empty()) {
      easEnable = make_shared<bool>(boost::any_cast<bool>(m["EasEnable"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      extraInfo = make_shared<string>(boost::any_cast<string>(m["ExtraInfo"]));
    }
    if (m.find("FailReason") != m.end() && !m["FailReason"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailReason"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoFailReason model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailReason"]));
        failReason = make_shared<DescribeClusterV2ResponseBodyClusterInfoFailReason>(model1);
      }
    }
    if (m.find("GatewayClusterIds") != m.end() && !m["GatewayClusterIds"].empty()) {
      gatewayClusterIds = make_shared<string>(boost::any_cast<string>(m["GatewayClusterIds"]));
    }
    if (m.find("GatewayClusterInfoList") != m.end() && !m["GatewayClusterInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["GatewayClusterInfoList"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GatewayClusterInfoList"]));
        gatewayClusterInfoList = make_shared<DescribeClusterV2ResponseBodyClusterInfoGatewayClusterInfoList>(model1);
      }
    }
    if (m.find("HighAvailabilityEnable") != m.end() && !m["HighAvailabilityEnable"].empty()) {
      highAvailabilityEnable = make_shared<bool>(boost::any_cast<bool>(m["HighAvailabilityEnable"]));
    }
    if (m.find("HostGroupList") != m.end() && !m["HostGroupList"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostGroupList"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoHostGroupList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostGroupList"]));
        hostGroupList = make_shared<DescribeClusterV2ResponseBodyClusterInfoHostGroupList>(model1);
      }
    }
    if (m.find("HostPoolInfo") != m.end() && !m["HostPoolInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostPoolInfo"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoHostPoolInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostPoolInfo"]));
        hostPoolInfo = make_shared<DescribeClusterV2ResponseBodyClusterInfoHostPoolInfo>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InstanceGeneration") != m.end() && !m["InstanceGeneration"].empty()) {
      instanceGeneration = make_shared<string>(boost::any_cast<string>(m["InstanceGeneration"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<bool>(boost::any_cast<bool>(m["IoOptimized"]));
    }
    if (m.find("K8sClusterId") != m.end() && !m["K8sClusterId"].empty()) {
      k8sClusterId = make_shared<string>(boost::any_cast<string>(m["K8sClusterId"]));
    }
    if (m.find("LocalMetaDb") != m.end() && !m["LocalMetaDb"].empty()) {
      localMetaDb = make_shared<bool>(boost::any_cast<bool>(m["LocalMetaDb"]));
    }
    if (m.find("LogEnable") != m.end() && !m["LogEnable"].empty()) {
      logEnable = make_shared<bool>(boost::any_cast<bool>(m["LogEnable"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("MachineType") != m.end() && !m["MachineType"].empty()) {
      machineType = make_shared<string>(boost::any_cast<string>(m["MachineType"]));
    }
    if (m.find("MasterNodeInService") != m.end() && !m["MasterNodeInService"].empty()) {
      masterNodeInService = make_shared<long>(boost::any_cast<long>(m["MasterNodeInService"]));
    }
    if (m.find("MasterNodeTotal") != m.end() && !m["MasterNodeTotal"].empty()) {
      masterNodeTotal = make_shared<long>(boost::any_cast<long>(m["MasterNodeTotal"]));
    }
    if (m.find("MetaStoreType") != m.end() && !m["MetaStoreType"].empty()) {
      metaStoreType = make_shared<string>(boost::any_cast<string>(m["MetaStoreType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RelateClusterId") != m.end() && !m["RelateClusterId"].empty()) {
      relateClusterId = make_shared<string>(boost::any_cast<string>(m["RelateClusterId"]));
    }
    if (m.find("RelateClusterInfo") != m.end() && !m["RelateClusterInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["RelateClusterInfo"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoRelateClusterInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RelateClusterInfo"]));
        relateClusterInfo = make_shared<DescribeClusterV2ResponseBodyClusterInfoRelateClusterInfo>(model1);
      }
    }
    if (m.find("ResizeDiskEnable") != m.end() && !m["ResizeDiskEnable"].empty()) {
      resizeDiskEnable = make_shared<bool>(boost::any_cast<bool>(m["ResizeDiskEnable"]));
    }
    if (m.find("RunningTime") != m.end() && !m["RunningTime"].empty()) {
      runningTime = make_shared<long>(boost::any_cast<long>(m["RunningTime"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
    if (m.find("ShowSoftwareInterface") != m.end() && !m["ShowSoftwareInterface"].empty()) {
      showSoftwareInterface = make_shared<bool>(boost::any_cast<bool>(m["ShowSoftwareInterface"]));
    }
    if (m.find("SoftwareInfo") != m.end() && !m["SoftwareInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SoftwareInfo"].type()) {
        DescribeClusterV2ResponseBodyClusterInfoSoftwareInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SoftwareInfo"]));
        softwareInfo = make_shared<DescribeClusterV2ResponseBodyClusterInfoSoftwareInfo>(model1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<long>(boost::any_cast<long>(m["StopTime"]));
    }
    if (m.find("TaskNodeInService") != m.end() && !m["TaskNodeInService"].empty()) {
      taskNodeInService = make_shared<long>(boost::any_cast<long>(m["TaskNodeInService"]));
    }
    if (m.find("TaskNodeTotal") != m.end() && !m["TaskNodeTotal"].empty()) {
      taskNodeTotal = make_shared<long>(boost::any_cast<long>(m["TaskNodeTotal"]));
    }
    if (m.find("UserDefinedEmrEcsRole") != m.end() && !m["UserDefinedEmrEcsRole"].empty()) {
      userDefinedEmrEcsRole = make_shared<string>(boost::any_cast<string>(m["UserDefinedEmrEcsRole"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeClusterV2ResponseBodyClusterInfo() = default;
};
class DescribeClusterV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeClusterV2ResponseBodyClusterInfo> clusterInfo{};
  shared_ptr<string> requestId{};

  DescribeClusterV2ResponseBody() {}

  explicit DescribeClusterV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterInfo) {
      res["ClusterInfo"] = clusterInfo ? boost::any(clusterInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterInfo") != m.end() && !m["ClusterInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterInfo"].type()) {
        DescribeClusterV2ResponseBodyClusterInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterInfo"]));
        clusterInfo = make_shared<DescribeClusterV2ResponseBodyClusterInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeClusterV2ResponseBody() = default;
};
class DescribeClusterV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterV2ResponseBody> body{};

  DescribeClusterV2Response() {}

  explicit DescribeClusterV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterV2Response() = default;
};
class DescribeFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  DescribeFlowRequest() {}

  explicit DescribeFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeFlowRequest() = default;
};
class DescribeFlowResponseBodyParentFlowListParentFlow : public Darabonba::Model {
public:
  shared_ptr<string> parentFlowId{};
  shared_ptr<string> parentFlowName{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectName{};

  DescribeFlowResponseBodyParentFlowListParentFlow() {}

  explicit DescribeFlowResponseBodyParentFlowListParentFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parentFlowId) {
      res["ParentFlowId"] = boost::any(*parentFlowId);
    }
    if (parentFlowName) {
      res["ParentFlowName"] = boost::any(*parentFlowName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParentFlowId") != m.end() && !m["ParentFlowId"].empty()) {
      parentFlowId = make_shared<string>(boost::any_cast<string>(m["ParentFlowId"]));
    }
    if (m.find("ParentFlowName") != m.end() && !m["ParentFlowName"].empty()) {
      parentFlowName = make_shared<string>(boost::any_cast<string>(m["ParentFlowName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~DescribeFlowResponseBodyParentFlowListParentFlow() = default;
};
class DescribeFlowResponseBodyParentFlowList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFlowResponseBodyParentFlowListParentFlow>> parentFlow{};

  DescribeFlowResponseBodyParentFlowList() {}

  explicit DescribeFlowResponseBodyParentFlowList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parentFlow) {
      vector<boost::any> temp1;
      for(auto item1:*parentFlow){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParentFlow"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParentFlow") != m.end() && !m["ParentFlow"].empty()) {
      if (typeid(vector<boost::any>) == m["ParentFlow"].type()) {
        vector<DescribeFlowResponseBodyParentFlowListParentFlow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParentFlow"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFlowResponseBodyParentFlowListParentFlow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parentFlow = make_shared<vector<DescribeFlowResponseBodyParentFlowListParentFlow>>(expect1);
      }
    }
  }


  virtual ~DescribeFlowResponseBodyParentFlowList() = default;
};
class DescribeFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> alertConf{};
  shared_ptr<string> alertDingDingGroupBizId{};
  shared_ptr<string> alertUserGroupBizId{};
  shared_ptr<string> application{};
  shared_ptr<string> categoryId{};
  shared_ptr<string> clusterId{};
  shared_ptr<bool> createCluster{};
  shared_ptr<string> cronExpr{};
  shared_ptr<string> description{};
  shared_ptr<string> editLockDetail{};
  shared_ptr<long> endSchedule{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> graph{};
  shared_ptr<string> hostName{};
  shared_ptr<string> id{};
  shared_ptr<string> lifecycle{};
  shared_ptr<string> logArchiveLocation{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<DescribeFlowResponseBodyParentFlowList> parentFlowList{};
  shared_ptr<bool> periodic{};
  shared_ptr<string> requestId{};
  shared_ptr<long> startSchedule{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  DescribeFlowResponseBody() {}

  explicit DescribeFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertConf) {
      res["AlertConf"] = boost::any(*alertConf);
    }
    if (alertDingDingGroupBizId) {
      res["AlertDingDingGroupBizId"] = boost::any(*alertDingDingGroupBizId);
    }
    if (alertUserGroupBizId) {
      res["AlertUserGroupBizId"] = boost::any(*alertUserGroupBizId);
    }
    if (application) {
      res["Application"] = boost::any(*application);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (createCluster) {
      res["CreateCluster"] = boost::any(*createCluster);
    }
    if (cronExpr) {
      res["CronExpr"] = boost::any(*cronExpr);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (editLockDetail) {
      res["EditLockDetail"] = boost::any(*editLockDetail);
    }
    if (endSchedule) {
      res["EndSchedule"] = boost::any(*endSchedule);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (graph) {
      res["Graph"] = boost::any(*graph);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lifecycle) {
      res["Lifecycle"] = boost::any(*lifecycle);
    }
    if (logArchiveLocation) {
      res["LogArchiveLocation"] = boost::any(*logArchiveLocation);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (parentFlowList) {
      res["ParentFlowList"] = parentFlowList ? boost::any(parentFlowList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (periodic) {
      res["Periodic"] = boost::any(*periodic);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startSchedule) {
      res["StartSchedule"] = boost::any(*startSchedule);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertConf") != m.end() && !m["AlertConf"].empty()) {
      alertConf = make_shared<string>(boost::any_cast<string>(m["AlertConf"]));
    }
    if (m.find("AlertDingDingGroupBizId") != m.end() && !m["AlertDingDingGroupBizId"].empty()) {
      alertDingDingGroupBizId = make_shared<string>(boost::any_cast<string>(m["AlertDingDingGroupBizId"]));
    }
    if (m.find("AlertUserGroupBizId") != m.end() && !m["AlertUserGroupBizId"].empty()) {
      alertUserGroupBizId = make_shared<string>(boost::any_cast<string>(m["AlertUserGroupBizId"]));
    }
    if (m.find("Application") != m.end() && !m["Application"].empty()) {
      application = make_shared<string>(boost::any_cast<string>(m["Application"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CreateCluster") != m.end() && !m["CreateCluster"].empty()) {
      createCluster = make_shared<bool>(boost::any_cast<bool>(m["CreateCluster"]));
    }
    if (m.find("CronExpr") != m.end() && !m["CronExpr"].empty()) {
      cronExpr = make_shared<string>(boost::any_cast<string>(m["CronExpr"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EditLockDetail") != m.end() && !m["EditLockDetail"].empty()) {
      editLockDetail = make_shared<string>(boost::any_cast<string>(m["EditLockDetail"]));
    }
    if (m.find("EndSchedule") != m.end() && !m["EndSchedule"].empty()) {
      endSchedule = make_shared<long>(boost::any_cast<long>(m["EndSchedule"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Graph") != m.end() && !m["Graph"].empty()) {
      graph = make_shared<string>(boost::any_cast<string>(m["Graph"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Lifecycle") != m.end() && !m["Lifecycle"].empty()) {
      lifecycle = make_shared<string>(boost::any_cast<string>(m["Lifecycle"]));
    }
    if (m.find("LogArchiveLocation") != m.end() && !m["LogArchiveLocation"].empty()) {
      logArchiveLocation = make_shared<string>(boost::any_cast<string>(m["LogArchiveLocation"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("ParentFlowList") != m.end() && !m["ParentFlowList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ParentFlowList"].type()) {
        DescribeFlowResponseBodyParentFlowList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ParentFlowList"]));
        parentFlowList = make_shared<DescribeFlowResponseBodyParentFlowList>(model1);
      }
    }
    if (m.find("Periodic") != m.end() && !m["Periodic"].empty()) {
      periodic = make_shared<bool>(boost::any_cast<bool>(m["Periodic"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartSchedule") != m.end() && !m["StartSchedule"].empty()) {
      startSchedule = make_shared<long>(boost::any_cast<long>(m["StartSchedule"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeFlowResponseBody() = default;
};
class DescribeFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFlowResponseBody> body{};

  DescribeFlowResponse() {}

  explicit DescribeFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowResponse() = default;
};
class DescribeFlowCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  DescribeFlowCategoryRequest() {}

  explicit DescribeFlowCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeFlowCategoryRequest() = default;
};
class DescribeFlowCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> categoryType{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> objectId{};
  shared_ptr<string> objectType{};
  shared_ptr<string> parentId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> type{};

  DescribeFlowCategoryResponseBody() {}

  explicit DescribeFlowCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryType) {
      res["CategoryType"] = boost::any(*categoryType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryType") != m.end() && !m["CategoryType"].empty()) {
      categoryType = make_shared<string>(boost::any_cast<string>(m["CategoryType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeFlowCategoryResponseBody() = default;
};
class DescribeFlowCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFlowCategoryResponseBody> body{};

  DescribeFlowCategoryResponse() {}

  explicit DescribeFlowCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowCategoryResponse() = default;
};
class DescribeFlowCategoryTreeRequest : public Darabonba::Model {
public:
  shared_ptr<string> categoryId{};
  shared_ptr<string> keyword{};
  shared_ptr<string> mode{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  DescribeFlowCategoryTreeRequest() {}

  explicit DescribeFlowCategoryTreeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeFlowCategoryTreeRequest() = default;
};
class DescribeFlowCategoryTreeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  DescribeFlowCategoryTreeResponseBody() {}

  explicit DescribeFlowCategoryTreeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeFlowCategoryTreeResponseBody() = default;
};
class DescribeFlowCategoryTreeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFlowCategoryTreeResponseBody> body{};

  DescribeFlowCategoryTreeResponse() {}

  explicit DescribeFlowCategoryTreeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowCategoryTreeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowCategoryTreeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowCategoryTreeResponse() = default;
};
class DescribeFlowInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  DescribeFlowInstanceRequest() {}

  explicit DescribeFlowInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeFlowInstanceRequest() = default;
};
class DescribeFlowInstanceResponseBodyDependencyFlowListParentFlow : public Darabonba::Model {
public:
  shared_ptr<long> bizDate{};
  shared_ptr<string> dependencyFlowId{};
  shared_ptr<string> dependencyInstanceId{};
  shared_ptr<string> flowId{};
  shared_ptr<string> flowInstanceId{};
  shared_ptr<bool> meet{};
  shared_ptr<string> projectId{};
  shared_ptr<string> scheduleKey{};

  DescribeFlowInstanceResponseBodyDependencyFlowListParentFlow() {}

  explicit DescribeFlowInstanceResponseBodyDependencyFlowListParentFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (dependencyFlowId) {
      res["DependencyFlowId"] = boost::any(*dependencyFlowId);
    }
    if (dependencyInstanceId) {
      res["DependencyInstanceId"] = boost::any(*dependencyInstanceId);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (flowInstanceId) {
      res["FlowInstanceId"] = boost::any(*flowInstanceId);
    }
    if (meet) {
      res["Meet"] = boost::any(*meet);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (scheduleKey) {
      res["ScheduleKey"] = boost::any(*scheduleKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("DependencyFlowId") != m.end() && !m["DependencyFlowId"].empty()) {
      dependencyFlowId = make_shared<string>(boost::any_cast<string>(m["DependencyFlowId"]));
    }
    if (m.find("DependencyInstanceId") != m.end() && !m["DependencyInstanceId"].empty()) {
      dependencyInstanceId = make_shared<string>(boost::any_cast<string>(m["DependencyInstanceId"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("FlowInstanceId") != m.end() && !m["FlowInstanceId"].empty()) {
      flowInstanceId = make_shared<string>(boost::any_cast<string>(m["FlowInstanceId"]));
    }
    if (m.find("Meet") != m.end() && !m["Meet"].empty()) {
      meet = make_shared<bool>(boost::any_cast<bool>(m["Meet"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ScheduleKey") != m.end() && !m["ScheduleKey"].empty()) {
      scheduleKey = make_shared<string>(boost::any_cast<string>(m["ScheduleKey"]));
    }
  }


  virtual ~DescribeFlowInstanceResponseBodyDependencyFlowListParentFlow() = default;
};
class DescribeFlowInstanceResponseBodyDependencyFlowList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFlowInstanceResponseBodyDependencyFlowListParentFlow>> parentFlow{};

  DescribeFlowInstanceResponseBodyDependencyFlowList() {}

  explicit DescribeFlowInstanceResponseBodyDependencyFlowList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parentFlow) {
      vector<boost::any> temp1;
      for(auto item1:*parentFlow){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParentFlow"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParentFlow") != m.end() && !m["ParentFlow"].empty()) {
      if (typeid(vector<boost::any>) == m["ParentFlow"].type()) {
        vector<DescribeFlowInstanceResponseBodyDependencyFlowListParentFlow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParentFlow"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFlowInstanceResponseBodyDependencyFlowListParentFlow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parentFlow = make_shared<vector<DescribeFlowInstanceResponseBodyDependencyFlowListParentFlow>>(expect1);
      }
    }
  }


  virtual ~DescribeFlowInstanceResponseBodyDependencyFlowList() = default;
};
class DescribeFlowInstanceResponseBodyNodeInstanceNodeInstance : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> duration{};
  shared_ptr<long> endTime{};
  shared_ptr<string> externalId{};
  shared_ptr<string> externalInfo{};
  shared_ptr<string> externalStatus{};
  shared_ptr<string> failAct{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> hostName{};
  shared_ptr<string> id{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<string> jobType{};
  shared_ptr<string> maxRetry{};
  shared_ptr<string> nodeName{};
  shared_ptr<bool> pending{};
  shared_ptr<string> projectId{};
  shared_ptr<long> retries{};
  shared_ptr<string> retryInterval{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  DescribeFlowInstanceResponseBodyNodeInstanceNodeInstance() {}

  explicit DescribeFlowInstanceResponseBodyNodeInstanceNodeInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (externalId) {
      res["ExternalId"] = boost::any(*externalId);
    }
    if (externalInfo) {
      res["ExternalInfo"] = boost::any(*externalInfo);
    }
    if (externalStatus) {
      res["ExternalStatus"] = boost::any(*externalStatus);
    }
    if (failAct) {
      res["FailAct"] = boost::any(*failAct);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (maxRetry) {
      res["MaxRetry"] = boost::any(*maxRetry);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (pending) {
      res["Pending"] = boost::any(*pending);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (retries) {
      res["Retries"] = boost::any(*retries);
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ExternalId") != m.end() && !m["ExternalId"].empty()) {
      externalId = make_shared<string>(boost::any_cast<string>(m["ExternalId"]));
    }
    if (m.find("ExternalInfo") != m.end() && !m["ExternalInfo"].empty()) {
      externalInfo = make_shared<string>(boost::any_cast<string>(m["ExternalInfo"]));
    }
    if (m.find("ExternalStatus") != m.end() && !m["ExternalStatus"].empty()) {
      externalStatus = make_shared<string>(boost::any_cast<string>(m["ExternalStatus"]));
    }
    if (m.find("FailAct") != m.end() && !m["FailAct"].empty()) {
      failAct = make_shared<string>(boost::any_cast<string>(m["FailAct"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("MaxRetry") != m.end() && !m["MaxRetry"].empty()) {
      maxRetry = make_shared<string>(boost::any_cast<string>(m["MaxRetry"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Pending") != m.end() && !m["Pending"].empty()) {
      pending = make_shared<bool>(boost::any_cast<bool>(m["Pending"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Retries") != m.end() && !m["Retries"].empty()) {
      retries = make_shared<long>(boost::any_cast<long>(m["Retries"]));
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<string>(boost::any_cast<string>(m["RetryInterval"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeFlowInstanceResponseBodyNodeInstanceNodeInstance() = default;
};
class DescribeFlowInstanceResponseBodyNodeInstance : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFlowInstanceResponseBodyNodeInstanceNodeInstance>> nodeInstance{};

  DescribeFlowInstanceResponseBodyNodeInstance() {}

  explicit DescribeFlowInstanceResponseBodyNodeInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeInstance) {
      vector<boost::any> temp1;
      for(auto item1:*nodeInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeInstance") != m.end() && !m["NodeInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeInstance"].type()) {
        vector<DescribeFlowInstanceResponseBodyNodeInstanceNodeInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFlowInstanceResponseBodyNodeInstanceNodeInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeInstance = make_shared<vector<DescribeFlowInstanceResponseBodyNodeInstanceNodeInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeFlowInstanceResponseBodyNodeInstance() = default;
};
class DescribeFlowInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> cronExpression{};
  shared_ptr<DescribeFlowInstanceResponseBodyDependencyFlowList> dependencyFlowList{};
  shared_ptr<long> duration{};
  shared_ptr<long> endTime{};
  shared_ptr<string> flowId{};
  shared_ptr<string> flowName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> graph{};
  shared_ptr<bool> hasNodeFailed{};
  shared_ptr<string> id{};
  shared_ptr<string> lifecycle{};
  shared_ptr<string> logArchiveLocation{};
  shared_ptr<string> namespace_{};
  shared_ptr<DescribeFlowInstanceResponseBodyNodeInstance> nodeInstance{};
  shared_ptr<string> projectId{};
  shared_ptr<string> requestId{};
  shared_ptr<long> scheduleTime{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};

  DescribeFlowInstanceResponseBody() {}

  explicit DescribeFlowInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (cronExpression) {
      res["CronExpression"] = boost::any(*cronExpression);
    }
    if (dependencyFlowList) {
      res["DependencyFlowList"] = dependencyFlowList ? boost::any(dependencyFlowList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (flowName) {
      res["FlowName"] = boost::any(*flowName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (graph) {
      res["Graph"] = boost::any(*graph);
    }
    if (hasNodeFailed) {
      res["HasNodeFailed"] = boost::any(*hasNodeFailed);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lifecycle) {
      res["Lifecycle"] = boost::any(*lifecycle);
    }
    if (logArchiveLocation) {
      res["LogArchiveLocation"] = boost::any(*logArchiveLocation);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (nodeInstance) {
      res["NodeInstance"] = nodeInstance ? boost::any(nodeInstance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduleTime) {
      res["ScheduleTime"] = boost::any(*scheduleTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CronExpression") != m.end() && !m["CronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["CronExpression"]));
    }
    if (m.find("DependencyFlowList") != m.end() && !m["DependencyFlowList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DependencyFlowList"].type()) {
        DescribeFlowInstanceResponseBodyDependencyFlowList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DependencyFlowList"]));
        dependencyFlowList = make_shared<DescribeFlowInstanceResponseBodyDependencyFlowList>(model1);
      }
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("FlowName") != m.end() && !m["FlowName"].empty()) {
      flowName = make_shared<string>(boost::any_cast<string>(m["FlowName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Graph") != m.end() && !m["Graph"].empty()) {
      graph = make_shared<string>(boost::any_cast<string>(m["Graph"]));
    }
    if (m.find("HasNodeFailed") != m.end() && !m["HasNodeFailed"].empty()) {
      hasNodeFailed = make_shared<bool>(boost::any_cast<bool>(m["HasNodeFailed"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Lifecycle") != m.end() && !m["Lifecycle"].empty()) {
      lifecycle = make_shared<string>(boost::any_cast<string>(m["Lifecycle"]));
    }
    if (m.find("LogArchiveLocation") != m.end() && !m["LogArchiveLocation"].empty()) {
      logArchiveLocation = make_shared<string>(boost::any_cast<string>(m["LogArchiveLocation"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NodeInstance") != m.end() && !m["NodeInstance"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeInstance"].type()) {
        DescribeFlowInstanceResponseBodyNodeInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeInstance"]));
        nodeInstance = make_shared<DescribeFlowInstanceResponseBodyNodeInstance>(model1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduleTime") != m.end() && !m["ScheduleTime"].empty()) {
      scheduleTime = make_shared<long>(boost::any_cast<long>(m["ScheduleTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeFlowInstanceResponseBody() = default;
};
class DescribeFlowInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFlowInstanceResponseBody> body{};

  DescribeFlowInstanceResponse() {}

  explicit DescribeFlowInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowInstanceResponse() = default;
};
class DescribeFlowJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  DescribeFlowJobRequest() {}

  explicit DescribeFlowJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeFlowJobRequest() = default;
};
class DescribeFlowJobResponseBodyResourceListResource : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> path{};

  DescribeFlowJobResponseBodyResourceListResource() {}

  explicit DescribeFlowJobResponseBodyResourceListResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~DescribeFlowJobResponseBodyResourceListResource() = default;
};
class DescribeFlowJobResponseBodyResourceList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFlowJobResponseBodyResourceListResource>> resource{};

  DescribeFlowJobResponseBodyResourceList() {}

  explicit DescribeFlowJobResponseBodyResourceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resource) {
      vector<boost::any> temp1;
      for(auto item1:*resource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(vector<boost::any>) == m["Resource"].type()) {
        vector<DescribeFlowJobResponseBodyResourceListResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFlowJobResponseBodyResourceListResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resource = make_shared<vector<DescribeFlowJobResponseBodyResourceListResource>>(expect1);
      }
    }
  }


  virtual ~DescribeFlowJobResponseBodyResourceList() = default;
};
class DescribeFlowJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> adhoc{};
  shared_ptr<string> alertConf{};
  shared_ptr<string> categoryId{};
  shared_ptr<string> customVariables{};
  shared_ptr<string> description{};
  shared_ptr<string> editLockDetail{};
  shared_ptr<string> envConf{};
  shared_ptr<string> failAct{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> id{};
  shared_ptr<string> lastInstanceId{};
  shared_ptr<long> maxRetry{};
  shared_ptr<long> maxRunningTimeSec{};
  shared_ptr<string> monitorConf{};
  shared_ptr<string> name{};
  shared_ptr<string> paramConf{};
  shared_ptr<string> params{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeFlowJobResponseBodyResourceList> resourceList{};
  shared_ptr<long> retryInterval{};
  shared_ptr<string> retryPolicy{};
  shared_ptr<string> runConf{};
  shared_ptr<string> type{};
  shared_ptr<string> mode{};

  DescribeFlowJobResponseBody() {}

  explicit DescribeFlowJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adhoc) {
      res["Adhoc"] = boost::any(*adhoc);
    }
    if (alertConf) {
      res["AlertConf"] = boost::any(*alertConf);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (customVariables) {
      res["CustomVariables"] = boost::any(*customVariables);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (editLockDetail) {
      res["EditLockDetail"] = boost::any(*editLockDetail);
    }
    if (envConf) {
      res["EnvConf"] = boost::any(*envConf);
    }
    if (failAct) {
      res["FailAct"] = boost::any(*failAct);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastInstanceId) {
      res["LastInstanceId"] = boost::any(*lastInstanceId);
    }
    if (maxRetry) {
      res["MaxRetry"] = boost::any(*maxRetry);
    }
    if (maxRunningTimeSec) {
      res["MaxRunningTimeSec"] = boost::any(*maxRunningTimeSec);
    }
    if (monitorConf) {
      res["MonitorConf"] = boost::any(*monitorConf);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (paramConf) {
      res["ParamConf"] = boost::any(*paramConf);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceList) {
      res["ResourceList"] = resourceList ? boost::any(resourceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (retryPolicy) {
      res["RetryPolicy"] = boost::any(*retryPolicy);
    }
    if (runConf) {
      res["RunConf"] = boost::any(*runConf);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (mode) {
      res["mode"] = boost::any(*mode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Adhoc") != m.end() && !m["Adhoc"].empty()) {
      adhoc = make_shared<string>(boost::any_cast<string>(m["Adhoc"]));
    }
    if (m.find("AlertConf") != m.end() && !m["AlertConf"].empty()) {
      alertConf = make_shared<string>(boost::any_cast<string>(m["AlertConf"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("CustomVariables") != m.end() && !m["CustomVariables"].empty()) {
      customVariables = make_shared<string>(boost::any_cast<string>(m["CustomVariables"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EditLockDetail") != m.end() && !m["EditLockDetail"].empty()) {
      editLockDetail = make_shared<string>(boost::any_cast<string>(m["EditLockDetail"]));
    }
    if (m.find("EnvConf") != m.end() && !m["EnvConf"].empty()) {
      envConf = make_shared<string>(boost::any_cast<string>(m["EnvConf"]));
    }
    if (m.find("FailAct") != m.end() && !m["FailAct"].empty()) {
      failAct = make_shared<string>(boost::any_cast<string>(m["FailAct"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LastInstanceId") != m.end() && !m["LastInstanceId"].empty()) {
      lastInstanceId = make_shared<string>(boost::any_cast<string>(m["LastInstanceId"]));
    }
    if (m.find("MaxRetry") != m.end() && !m["MaxRetry"].empty()) {
      maxRetry = make_shared<long>(boost::any_cast<long>(m["MaxRetry"]));
    }
    if (m.find("MaxRunningTimeSec") != m.end() && !m["MaxRunningTimeSec"].empty()) {
      maxRunningTimeSec = make_shared<long>(boost::any_cast<long>(m["MaxRunningTimeSec"]));
    }
    if (m.find("MonitorConf") != m.end() && !m["MonitorConf"].empty()) {
      monitorConf = make_shared<string>(boost::any_cast<string>(m["MonitorConf"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParamConf") != m.end() && !m["ParamConf"].empty()) {
      paramConf = make_shared<string>(boost::any_cast<string>(m["ParamConf"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceList") != m.end() && !m["ResourceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceList"].type()) {
        DescribeFlowJobResponseBodyResourceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceList"]));
        resourceList = make_shared<DescribeFlowJobResponseBodyResourceList>(model1);
      }
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<long>(boost::any_cast<long>(m["RetryInterval"]));
    }
    if (m.find("RetryPolicy") != m.end() && !m["RetryPolicy"].empty()) {
      retryPolicy = make_shared<string>(boost::any_cast<string>(m["RetryPolicy"]));
    }
    if (m.find("RunConf") != m.end() && !m["RunConf"].empty()) {
      runConf = make_shared<string>(boost::any_cast<string>(m["RunConf"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("mode") != m.end() && !m["mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["mode"]));
    }
  }


  virtual ~DescribeFlowJobResponseBody() = default;
};
class DescribeFlowJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFlowJobResponseBody> body{};

  DescribeFlowJobResponse() {}

  explicit DescribeFlowJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowJobResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowJobResponse() = default;
};
class DescribeFlowNodeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  DescribeFlowNodeInstanceRequest() {}

  explicit DescribeFlowNodeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeFlowNodeInstanceRequest() = default;
};
class DescribeFlowNodeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> adhoc{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<long> duration{};
  shared_ptr<long> endTime{};
  shared_ptr<string> envConf{};
  shared_ptr<string> externalChildIds{};
  shared_ptr<string> externalId{};
  shared_ptr<string> externalInfo{};
  shared_ptr<string> externalStatus{};
  shared_ptr<string> externalSubId{};
  shared_ptr<string> failAct{};
  shared_ptr<string> flowId{};
  shared_ptr<string> flowInstanceId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> hostName{};
  shared_ptr<string> id{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<string> jobParams{};
  shared_ptr<string> jobType{};
  shared_ptr<string> maxRetry{};
  shared_ptr<string> mode{};
  shared_ptr<string> monitorConf{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> paramConf{};
  shared_ptr<bool> pending{};
  shared_ptr<string> projectId{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retries{};
  shared_ptr<string> retryInterval{};
  shared_ptr<string> retryPolicy{};
  shared_ptr<string> runConf{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  DescribeFlowNodeInstanceResponseBody() {}

  explicit DescribeFlowNodeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adhoc) {
      res["Adhoc"] = boost::any(*adhoc);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (envConf) {
      res["EnvConf"] = boost::any(*envConf);
    }
    if (externalChildIds) {
      res["ExternalChildIds"] = boost::any(*externalChildIds);
    }
    if (externalId) {
      res["ExternalId"] = boost::any(*externalId);
    }
    if (externalInfo) {
      res["ExternalInfo"] = boost::any(*externalInfo);
    }
    if (externalStatus) {
      res["ExternalStatus"] = boost::any(*externalStatus);
    }
    if (externalSubId) {
      res["ExternalSubId"] = boost::any(*externalSubId);
    }
    if (failAct) {
      res["FailAct"] = boost::any(*failAct);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (flowInstanceId) {
      res["FlowInstanceId"] = boost::any(*flowInstanceId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (jobParams) {
      res["JobParams"] = boost::any(*jobParams);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (maxRetry) {
      res["MaxRetry"] = boost::any(*maxRetry);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (monitorConf) {
      res["MonitorConf"] = boost::any(*monitorConf);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (paramConf) {
      res["ParamConf"] = boost::any(*paramConf);
    }
    if (pending) {
      res["Pending"] = boost::any(*pending);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retries) {
      res["Retries"] = boost::any(*retries);
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (retryPolicy) {
      res["RetryPolicy"] = boost::any(*retryPolicy);
    }
    if (runConf) {
      res["RunConf"] = boost::any(*runConf);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Adhoc") != m.end() && !m["Adhoc"].empty()) {
      adhoc = make_shared<bool>(boost::any_cast<bool>(m["Adhoc"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("EnvConf") != m.end() && !m["EnvConf"].empty()) {
      envConf = make_shared<string>(boost::any_cast<string>(m["EnvConf"]));
    }
    if (m.find("ExternalChildIds") != m.end() && !m["ExternalChildIds"].empty()) {
      externalChildIds = make_shared<string>(boost::any_cast<string>(m["ExternalChildIds"]));
    }
    if (m.find("ExternalId") != m.end() && !m["ExternalId"].empty()) {
      externalId = make_shared<string>(boost::any_cast<string>(m["ExternalId"]));
    }
    if (m.find("ExternalInfo") != m.end() && !m["ExternalInfo"].empty()) {
      externalInfo = make_shared<string>(boost::any_cast<string>(m["ExternalInfo"]));
    }
    if (m.find("ExternalStatus") != m.end() && !m["ExternalStatus"].empty()) {
      externalStatus = make_shared<string>(boost::any_cast<string>(m["ExternalStatus"]));
    }
    if (m.find("ExternalSubId") != m.end() && !m["ExternalSubId"].empty()) {
      externalSubId = make_shared<string>(boost::any_cast<string>(m["ExternalSubId"]));
    }
    if (m.find("FailAct") != m.end() && !m["FailAct"].empty()) {
      failAct = make_shared<string>(boost::any_cast<string>(m["FailAct"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("FlowInstanceId") != m.end() && !m["FlowInstanceId"].empty()) {
      flowInstanceId = make_shared<string>(boost::any_cast<string>(m["FlowInstanceId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("JobParams") != m.end() && !m["JobParams"].empty()) {
      jobParams = make_shared<string>(boost::any_cast<string>(m["JobParams"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("MaxRetry") != m.end() && !m["MaxRetry"].empty()) {
      maxRetry = make_shared<string>(boost::any_cast<string>(m["MaxRetry"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("MonitorConf") != m.end() && !m["MonitorConf"].empty()) {
      monitorConf = make_shared<string>(boost::any_cast<string>(m["MonitorConf"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("ParamConf") != m.end() && !m["ParamConf"].empty()) {
      paramConf = make_shared<string>(boost::any_cast<string>(m["ParamConf"]));
    }
    if (m.find("Pending") != m.end() && !m["Pending"].empty()) {
      pending = make_shared<bool>(boost::any_cast<bool>(m["Pending"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Retries") != m.end() && !m["Retries"].empty()) {
      retries = make_shared<long>(boost::any_cast<long>(m["Retries"]));
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<string>(boost::any_cast<string>(m["RetryInterval"]));
    }
    if (m.find("RetryPolicy") != m.end() && !m["RetryPolicy"].empty()) {
      retryPolicy = make_shared<string>(boost::any_cast<string>(m["RetryPolicy"]));
    }
    if (m.find("RunConf") != m.end() && !m["RunConf"].empty()) {
      runConf = make_shared<string>(boost::any_cast<string>(m["RunConf"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeFlowNodeInstanceResponseBody() = default;
};
class DescribeFlowNodeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFlowNodeInstanceResponseBody> body{};

  DescribeFlowNodeInstanceResponse() {}

  explicit DescribeFlowNodeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowNodeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowNodeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowNodeInstanceResponse() = default;
};
class DescribeFlowNodeInstanceContainerLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> containerId{};
  shared_ptr<long> length{};
  shared_ptr<string> logName{};
  shared_ptr<string> nodeInstanceId{};
  shared_ptr<long> offset{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  DescribeFlowNodeInstanceContainerLogRequest() {}

  explicit DescribeFlowNodeInstanceContainerLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (logName) {
      res["LogName"] = boost::any(*logName);
    }
    if (nodeInstanceId) {
      res["NodeInstanceId"] = boost::any(*nodeInstanceId);
    }
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<string>(boost::any_cast<string>(m["ContainerId"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("LogName") != m.end() && !m["LogName"].empty()) {
      logName = make_shared<string>(boost::any_cast<string>(m["LogName"]));
    }
    if (m.find("NodeInstanceId") != m.end() && !m["NodeInstanceId"].empty()) {
      nodeInstanceId = make_shared<string>(boost::any_cast<string>(m["NodeInstanceId"]));
    }
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeFlowNodeInstanceContainerLogRequest() = default;
};
class DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrysLogEntry : public Darabonba::Model {
public:
  shared_ptr<string> content{};

  DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrysLogEntry() {}

  explicit DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrysLogEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrysLogEntry() = default;
};
class DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrysLogEntry>> logEntry{};

  DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrys() {}

  explicit DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logEntry) {
      vector<boost::any> temp1;
      for(auto item1:*logEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogEntry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogEntry") != m.end() && !m["LogEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["LogEntry"].type()) {
        vector<DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrysLogEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrysLogEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logEntry = make_shared<vector<DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrysLogEntry>>(expect1);
      }
    }
  }


  virtual ~DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrys() = default;
};
class DescribeFlowNodeInstanceContainerLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> logEnd{};
  shared_ptr<DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrys> logEntrys{};
  shared_ptr<string> requestId{};

  DescribeFlowNodeInstanceContainerLogResponseBody() {}

  explicit DescribeFlowNodeInstanceContainerLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logEnd) {
      res["LogEnd"] = boost::any(*logEnd);
    }
    if (logEntrys) {
      res["LogEntrys"] = logEntrys ? boost::any(logEntrys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogEnd") != m.end() && !m["LogEnd"].empty()) {
      logEnd = make_shared<bool>(boost::any_cast<bool>(m["LogEnd"]));
    }
    if (m.find("LogEntrys") != m.end() && !m["LogEntrys"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogEntrys"].type()) {
        DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogEntrys"]));
        logEntrys = make_shared<DescribeFlowNodeInstanceContainerLogResponseBodyLogEntrys>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeFlowNodeInstanceContainerLogResponseBody() = default;
};
class DescribeFlowNodeInstanceContainerLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFlowNodeInstanceContainerLogResponseBody> body{};

  DescribeFlowNodeInstanceContainerLogResponse() {}

  explicit DescribeFlowNodeInstanceContainerLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowNodeInstanceContainerLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowNodeInstanceContainerLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowNodeInstanceContainerLogResponse() = default;
};
class DescribeFlowNodeInstanceLauncherLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> length{};
  shared_ptr<long> lines{};
  shared_ptr<string> nodeInstanceId{};
  shared_ptr<long> offset{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> reverse{};
  shared_ptr<long> start{};
  shared_ptr<long> startTime{};

  DescribeFlowNodeInstanceLauncherLogRequest() {}

  explicit DescribeFlowNodeInstanceLauncherLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (lines) {
      res["Lines"] = boost::any(*lines);
    }
    if (nodeInstanceId) {
      res["NodeInstanceId"] = boost::any(*nodeInstanceId);
    }
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reverse) {
      res["Reverse"] = boost::any(*reverse);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      lines = make_shared<long>(boost::any_cast<long>(m["Lines"]));
    }
    if (m.find("NodeInstanceId") != m.end() && !m["NodeInstanceId"].empty()) {
      nodeInstanceId = make_shared<string>(boost::any_cast<string>(m["NodeInstanceId"]));
    }
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Reverse") != m.end() && !m["Reverse"].empty()) {
      reverse = make_shared<bool>(boost::any_cast<bool>(m["Reverse"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeFlowNodeInstanceLauncherLogRequest() = default;
};
class DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrysLogEntry : public Darabonba::Model {
public:
  shared_ptr<string> content{};

  DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrysLogEntry() {}

  explicit DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrysLogEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrysLogEntry() = default;
};
class DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrysLogEntry>> logEntry{};

  DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrys() {}

  explicit DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logEntry) {
      vector<boost::any> temp1;
      for(auto item1:*logEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogEntry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogEntry") != m.end() && !m["LogEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["LogEntry"].type()) {
        vector<DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrysLogEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrysLogEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logEntry = make_shared<vector<DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrysLogEntry>>(expect1);
      }
    }
  }


  virtual ~DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrys() = default;
};
class DescribeFlowNodeInstanceLauncherLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> logEnd{};
  shared_ptr<DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrys> logEntrys{};
  shared_ptr<string> requestId{};

  DescribeFlowNodeInstanceLauncherLogResponseBody() {}

  explicit DescribeFlowNodeInstanceLauncherLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logEnd) {
      res["LogEnd"] = boost::any(*logEnd);
    }
    if (logEntrys) {
      res["LogEntrys"] = logEntrys ? boost::any(logEntrys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogEnd") != m.end() && !m["LogEnd"].empty()) {
      logEnd = make_shared<bool>(boost::any_cast<bool>(m["LogEnd"]));
    }
    if (m.find("LogEntrys") != m.end() && !m["LogEntrys"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogEntrys"].type()) {
        DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogEntrys"]));
        logEntrys = make_shared<DescribeFlowNodeInstanceLauncherLogResponseBodyLogEntrys>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeFlowNodeInstanceLauncherLogResponseBody() = default;
};
class DescribeFlowNodeInstanceLauncherLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFlowNodeInstanceLauncherLogResponseBody> body{};

  DescribeFlowNodeInstanceLauncherLogResponse() {}

  explicit DescribeFlowNodeInstanceLauncherLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowNodeInstanceLauncherLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowNodeInstanceLauncherLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowNodeInstanceLauncherLogResponse() = default;
};
class DescribeFlowProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  DescribeFlowProjectRequest() {}

  explicit DescribeFlowProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeFlowProjectRequest() = default;
};
class DescribeFlowProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> userId{};

  DescribeFlowProjectResponseBody() {}

  explicit DescribeFlowProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~DescribeFlowProjectResponseBody() = default;
};
class DescribeFlowProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFlowProjectResponseBody> body{};

  DescribeFlowProjectResponse() {}

  explicit DescribeFlowProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowProjectResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowProjectResponse() = default;
};
class DescribeFlowProjectClusterSettingRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  DescribeFlowProjectClusterSettingRequest() {}

  explicit DescribeFlowProjectClusterSettingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeFlowProjectClusterSettingRequest() = default;
};
class DescribeFlowProjectClusterSettingResponseBodyHostList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> host{};

  DescribeFlowProjectClusterSettingResponseBodyHostList() {}

  explicit DescribeFlowProjectClusterSettingResponseBodyHostList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Host"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Host"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      host = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeFlowProjectClusterSettingResponseBodyHostList() = default;
};
class DescribeFlowProjectClusterSettingResponseBodyQueueList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> queue{};

  DescribeFlowProjectClusterSettingResponseBodyQueueList() {}

  explicit DescribeFlowProjectClusterSettingResponseBodyQueueList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Queue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Queue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      queue = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeFlowProjectClusterSettingResponseBodyQueueList() = default;
};
class DescribeFlowProjectClusterSettingResponseBodyUserList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> user{};

  DescribeFlowProjectClusterSettingResponseBodyUserList() {}

  explicit DescribeFlowProjectClusterSettingResponseBodyUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("User") != m.end() && !m["User"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["User"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["User"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      user = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeFlowProjectClusterSettingResponseBodyUserList() = default;
};
class DescribeFlowProjectClusterSettingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> defaultQueue{};
  shared_ptr<string> defaultUser{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<DescribeFlowProjectClusterSettingResponseBodyHostList> hostList{};
  shared_ptr<string> k8sClusterId{};
  shared_ptr<string> projectId{};
  shared_ptr<DescribeFlowProjectClusterSettingResponseBodyQueueList> queueList{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeFlowProjectClusterSettingResponseBodyUserList> userList{};

  DescribeFlowProjectClusterSettingResponseBody() {}

  explicit DescribeFlowProjectClusterSettingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (defaultQueue) {
      res["DefaultQueue"] = boost::any(*defaultQueue);
    }
    if (defaultUser) {
      res["DefaultUser"] = boost::any(*defaultUser);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (hostList) {
      res["HostList"] = hostList ? boost::any(hostList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (k8sClusterId) {
      res["K8sClusterId"] = boost::any(*k8sClusterId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (queueList) {
      res["QueueList"] = queueList ? boost::any(queueList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userList) {
      res["UserList"] = userList ? boost::any(userList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DefaultQueue") != m.end() && !m["DefaultQueue"].empty()) {
      defaultQueue = make_shared<string>(boost::any_cast<string>(m["DefaultQueue"]));
    }
    if (m.find("DefaultUser") != m.end() && !m["DefaultUser"].empty()) {
      defaultUser = make_shared<string>(boost::any_cast<string>(m["DefaultUser"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("HostList") != m.end() && !m["HostList"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostList"].type()) {
        DescribeFlowProjectClusterSettingResponseBodyHostList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostList"]));
        hostList = make_shared<DescribeFlowProjectClusterSettingResponseBodyHostList>(model1);
      }
    }
    if (m.find("K8sClusterId") != m.end() && !m["K8sClusterId"].empty()) {
      k8sClusterId = make_shared<string>(boost::any_cast<string>(m["K8sClusterId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("QueueList") != m.end() && !m["QueueList"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueueList"].type()) {
        DescribeFlowProjectClusterSettingResponseBodyQueueList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QueueList"]));
        queueList = make_shared<DescribeFlowProjectClusterSettingResponseBodyQueueList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserList"].type()) {
        DescribeFlowProjectClusterSettingResponseBodyUserList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserList"]));
        userList = make_shared<DescribeFlowProjectClusterSettingResponseBodyUserList>(model1);
      }
    }
  }


  virtual ~DescribeFlowProjectClusterSettingResponseBody() = default;
};
class DescribeFlowProjectClusterSettingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFlowProjectClusterSettingResponseBody> body{};

  DescribeFlowProjectClusterSettingResponse() {}

  explicit DescribeFlowProjectClusterSettingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowProjectClusterSettingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowProjectClusterSettingResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowProjectClusterSettingResponse() = default;
};
class DescribeScalingConfigItemV2Request : public Darabonba::Model {
public:
  shared_ptr<string> configItemType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingConfigItemId{};
  shared_ptr<string> scalingGroupBizId{};

  DescribeScalingConfigItemV2Request() {}

  explicit DescribeScalingConfigItemV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configItemType) {
      res["ConfigItemType"] = boost::any(*configItemType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingConfigItemId) {
      res["ScalingConfigItemId"] = boost::any(*scalingConfigItemId);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigItemType") != m.end() && !m["ConfigItemType"].empty()) {
      configItemType = make_shared<string>(boost::any_cast<string>(m["ConfigItemType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingConfigItemId") != m.end() && !m["ScalingConfigItemId"].empty()) {
      scalingConfigItemId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigItemId"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
  }


  virtual ~DescribeScalingConfigItemV2Request() = default;
};
class DescribeScalingConfigItemV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> configItemInformation{};
  shared_ptr<string> configItemType{};
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingConfigItemBizId{};
  shared_ptr<string> scalingGroupBizId{};

  DescribeScalingConfigItemV2ResponseBody() {}

  explicit DescribeScalingConfigItemV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configItemInformation) {
      res["ConfigItemInformation"] = boost::any(*configItemInformation);
    }
    if (configItemType) {
      res["ConfigItemType"] = boost::any(*configItemType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingConfigItemBizId) {
      res["ScalingConfigItemBizId"] = boost::any(*scalingConfigItemBizId);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigItemInformation") != m.end() && !m["ConfigItemInformation"].empty()) {
      configItemInformation = make_shared<string>(boost::any_cast<string>(m["ConfigItemInformation"]));
    }
    if (m.find("ConfigItemType") != m.end() && !m["ConfigItemType"].empty()) {
      configItemType = make_shared<string>(boost::any_cast<string>(m["ConfigItemType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingConfigItemBizId") != m.end() && !m["ScalingConfigItemBizId"].empty()) {
      scalingConfigItemBizId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigItemBizId"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
  }


  virtual ~DescribeScalingConfigItemV2ResponseBody() = default;
};
class DescribeScalingConfigItemV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeScalingConfigItemV2ResponseBody> body{};

  DescribeScalingConfigItemV2Response() {}

  explicit DescribeScalingConfigItemV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScalingConfigItemV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScalingConfigItemV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScalingConfigItemV2Response() = default;
};
class DescribeScalingGroupInstanceV2Request : public Darabonba::Model {
public:
  shared_ptr<string> hostGroupBizId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingGroupBizId{};

  DescribeScalingGroupInstanceV2Request() {}

  explicit DescribeScalingGroupInstanceV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroupBizId) {
      res["HostGroupBizId"] = boost::any(*hostGroupBizId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroupBizId") != m.end() && !m["HostGroupBizId"].empty()) {
      hostGroupBizId = make_shared<string>(boost::any_cast<string>(m["HostGroupBizId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
  }


  virtual ~DescribeScalingGroupInstanceV2Request() = default;
};
class DescribeScalingGroupInstanceV2ResponseBodyScalingConfigInstanceTypeList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceType{};

  DescribeScalingGroupInstanceV2ResponseBodyScalingConfigInstanceTypeList() {}

  explicit DescribeScalingGroupInstanceV2ResponseBodyScalingConfigInstanceTypeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceType = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeScalingGroupInstanceV2ResponseBodyScalingConfigInstanceTypeList() = default;
};
class DescribeScalingGroupInstanceV2ResponseBodyScalingConfigSpotPriceLimitsSpotPriceLimit : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};
  shared_ptr<double> priceLimit{};

  DescribeScalingGroupInstanceV2ResponseBodyScalingConfigSpotPriceLimitsSpotPriceLimit() {}

  explicit DescribeScalingGroupInstanceV2ResponseBodyScalingConfigSpotPriceLimitsSpotPriceLimit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (priceLimit) {
      res["PriceLimit"] = boost::any(*priceLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("PriceLimit") != m.end() && !m["PriceLimit"].empty()) {
      priceLimit = make_shared<double>(boost::any_cast<double>(m["PriceLimit"]));
    }
  }


  virtual ~DescribeScalingGroupInstanceV2ResponseBodyScalingConfigSpotPriceLimitsSpotPriceLimit() = default;
};
class DescribeScalingGroupInstanceV2ResponseBodyScalingConfigSpotPriceLimits : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeScalingGroupInstanceV2ResponseBodyScalingConfigSpotPriceLimitsSpotPriceLimit>> spotPriceLimit{};

  DescribeScalingGroupInstanceV2ResponseBodyScalingConfigSpotPriceLimits() {}

  explicit DescribeScalingGroupInstanceV2ResponseBodyScalingConfigSpotPriceLimits(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (spotPriceLimit) {
      vector<boost::any> temp1;
      for(auto item1:*spotPriceLimit){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpotPriceLimit"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpotPriceLimit") != m.end() && !m["SpotPriceLimit"].empty()) {
      if (typeid(vector<boost::any>) == m["SpotPriceLimit"].type()) {
        vector<DescribeScalingGroupInstanceV2ResponseBodyScalingConfigSpotPriceLimitsSpotPriceLimit> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpotPriceLimit"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingGroupInstanceV2ResponseBodyScalingConfigSpotPriceLimitsSpotPriceLimit model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spotPriceLimit = make_shared<vector<DescribeScalingGroupInstanceV2ResponseBodyScalingConfigSpotPriceLimitsSpotPriceLimit>>(expect1);
      }
    }
  }


  virtual ~DescribeScalingGroupInstanceV2ResponseBodyScalingConfigSpotPriceLimits() = default;
};
class DescribeScalingGroupInstanceV2ResponseBodyScalingConfig : public Darabonba::Model {
public:
  shared_ptr<string> dataDiskCategory{};
  shared_ptr<long> dataDiskCount{};
  shared_ptr<long> dataDiskSize{};
  shared_ptr<DescribeScalingGroupInstanceV2ResponseBodyScalingConfigInstanceTypeList> instanceTypeList{};
  shared_ptr<string> payType{};
  shared_ptr<DescribeScalingGroupInstanceV2ResponseBodyScalingConfigSpotPriceLimits> spotPriceLimits{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<string> sysDiskCategory{};
  shared_ptr<long> sysDiskSize{};

  DescribeScalingGroupInstanceV2ResponseBodyScalingConfig() {}

  explicit DescribeScalingGroupInstanceV2ResponseBodyScalingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDiskCategory) {
      res["DataDiskCategory"] = boost::any(*dataDiskCategory);
    }
    if (dataDiskCount) {
      res["DataDiskCount"] = boost::any(*dataDiskCount);
    }
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    if (instanceTypeList) {
      res["InstanceTypeList"] = instanceTypeList ? boost::any(instanceTypeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (spotPriceLimits) {
      res["SpotPriceLimits"] = spotPriceLimits ? boost::any(spotPriceLimits->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (sysDiskCategory) {
      res["SysDiskCategory"] = boost::any(*sysDiskCategory);
    }
    if (sysDiskSize) {
      res["SysDiskSize"] = boost::any(*sysDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDiskCategory") != m.end() && !m["DataDiskCategory"].empty()) {
      dataDiskCategory = make_shared<string>(boost::any_cast<string>(m["DataDiskCategory"]));
    }
    if (m.find("DataDiskCount") != m.end() && !m["DataDiskCount"].empty()) {
      dataDiskCount = make_shared<long>(boost::any_cast<long>(m["DataDiskCount"]));
    }
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      dataDiskSize = make_shared<long>(boost::any_cast<long>(m["DataDiskSize"]));
    }
    if (m.find("InstanceTypeList") != m.end() && !m["InstanceTypeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTypeList"].type()) {
        DescribeScalingGroupInstanceV2ResponseBodyScalingConfigInstanceTypeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTypeList"]));
        instanceTypeList = make_shared<DescribeScalingGroupInstanceV2ResponseBodyScalingConfigInstanceTypeList>(model1);
      }
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("SpotPriceLimits") != m.end() && !m["SpotPriceLimits"].empty()) {
      if (typeid(map<string, boost::any>) == m["SpotPriceLimits"].type()) {
        DescribeScalingGroupInstanceV2ResponseBodyScalingConfigSpotPriceLimits model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SpotPriceLimits"]));
        spotPriceLimits = make_shared<DescribeScalingGroupInstanceV2ResponseBodyScalingConfigSpotPriceLimits>(model1);
      }
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("SysDiskCategory") != m.end() && !m["SysDiskCategory"].empty()) {
      sysDiskCategory = make_shared<string>(boost::any_cast<string>(m["SysDiskCategory"]));
    }
    if (m.find("SysDiskSize") != m.end() && !m["SysDiskSize"].empty()) {
      sysDiskSize = make_shared<long>(boost::any_cast<long>(m["SysDiskSize"]));
    }
  }


  virtual ~DescribeScalingGroupInstanceV2ResponseBodyScalingConfig() = default;
};
class DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRuleCloudWatchTrigger : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> evaluationCount{};
  shared_ptr<string> metricDisplayName{};
  shared_ptr<string> metricName{};
  shared_ptr<long> period{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<string> unit{};

  DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRuleCloudWatchTrigger() {}

  explicit DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRuleCloudWatchTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (metricDisplayName) {
      res["MetricDisplayName"] = boost::any(*metricDisplayName);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<string>(boost::any_cast<string>(m["EvaluationCount"]));
    }
    if (m.find("MetricDisplayName") != m.end() && !m["MetricDisplayName"].empty()) {
      metricDisplayName = make_shared<string>(boost::any_cast<string>(m["MetricDisplayName"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
  }


  virtual ~DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRuleCloudWatchTrigger() = default;
};
class DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRuleSchedulerTrigger : public Darabonba::Model {
public:
  shared_ptr<long> launchExpirationTime{};
  shared_ptr<long> launchTime{};
  shared_ptr<long> recurrenceEndTime{};
  shared_ptr<string> recurrenceType{};
  shared_ptr<string> recurrenceValue{};

  DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRuleSchedulerTrigger() {}

  explicit DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRuleSchedulerTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (launchExpirationTime) {
      res["LaunchExpirationTime"] = boost::any(*launchExpirationTime);
    }
    if (launchTime) {
      res["LaunchTime"] = boost::any(*launchTime);
    }
    if (recurrenceEndTime) {
      res["RecurrenceEndTime"] = boost::any(*recurrenceEndTime);
    }
    if (recurrenceType) {
      res["RecurrenceType"] = boost::any(*recurrenceType);
    }
    if (recurrenceValue) {
      res["RecurrenceValue"] = boost::any(*recurrenceValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LaunchExpirationTime") != m.end() && !m["LaunchExpirationTime"].empty()) {
      launchExpirationTime = make_shared<long>(boost::any_cast<long>(m["LaunchExpirationTime"]));
    }
    if (m.find("LaunchTime") != m.end() && !m["LaunchTime"].empty()) {
      launchTime = make_shared<long>(boost::any_cast<long>(m["LaunchTime"]));
    }
    if (m.find("RecurrenceEndTime") != m.end() && !m["RecurrenceEndTime"].empty()) {
      recurrenceEndTime = make_shared<long>(boost::any_cast<long>(m["RecurrenceEndTime"]));
    }
    if (m.find("RecurrenceType") != m.end() && !m["RecurrenceType"].empty()) {
      recurrenceType = make_shared<string>(boost::any_cast<string>(m["RecurrenceType"]));
    }
    if (m.find("RecurrenceValue") != m.end() && !m["RecurrenceValue"].empty()) {
      recurrenceValue = make_shared<string>(boost::any_cast<string>(m["RecurrenceValue"]));
    }
  }


  virtual ~DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRuleSchedulerTrigger() = default;
};
class DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRule : public Darabonba::Model {
public:
  shared_ptr<string> adjustmentType{};
  shared_ptr<long> adjustmentValue{};
  shared_ptr<DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRuleCloudWatchTrigger> cloudWatchTrigger{};
  shared_ptr<long> cooldown{};
  shared_ptr<string> essScalingRuleId{};
  shared_ptr<long> launchExpirationTime{};
  shared_ptr<string> launchTime{};
  shared_ptr<string> recurrenceEndTime{};
  shared_ptr<string> recurrenceType{};
  shared_ptr<string> recurrenceValue{};
  shared_ptr<string> ruleCategory{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> scalingGroupId{};
  shared_ptr<DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRuleSchedulerTrigger> schedulerTrigger{};
  shared_ptr<string> status{};
  shared_ptr<long> timeoutWithGrace{};
  shared_ptr<bool> withGrace{};

  DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRule() {}

  explicit DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjustmentType) {
      res["AdjustmentType"] = boost::any(*adjustmentType);
    }
    if (adjustmentValue) {
      res["AdjustmentValue"] = boost::any(*adjustmentValue);
    }
    if (cloudWatchTrigger) {
      res["CloudWatchTrigger"] = cloudWatchTrigger ? boost::any(cloudWatchTrigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cooldown) {
      res["Cooldown"] = boost::any(*cooldown);
    }
    if (essScalingRuleId) {
      res["EssScalingRuleId"] = boost::any(*essScalingRuleId);
    }
    if (launchExpirationTime) {
      res["LaunchExpirationTime"] = boost::any(*launchExpirationTime);
    }
    if (launchTime) {
      res["LaunchTime"] = boost::any(*launchTime);
    }
    if (recurrenceEndTime) {
      res["RecurrenceEndTime"] = boost::any(*recurrenceEndTime);
    }
    if (recurrenceType) {
      res["RecurrenceType"] = boost::any(*recurrenceType);
    }
    if (recurrenceValue) {
      res["RecurrenceValue"] = boost::any(*recurrenceValue);
    }
    if (ruleCategory) {
      res["RuleCategory"] = boost::any(*ruleCategory);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (schedulerTrigger) {
      res["SchedulerTrigger"] = schedulerTrigger ? boost::any(schedulerTrigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (timeoutWithGrace) {
      res["TimeoutWithGrace"] = boost::any(*timeoutWithGrace);
    }
    if (withGrace) {
      res["WithGrace"] = boost::any(*withGrace);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjustmentType") != m.end() && !m["AdjustmentType"].empty()) {
      adjustmentType = make_shared<string>(boost::any_cast<string>(m["AdjustmentType"]));
    }
    if (m.find("AdjustmentValue") != m.end() && !m["AdjustmentValue"].empty()) {
      adjustmentValue = make_shared<long>(boost::any_cast<long>(m["AdjustmentValue"]));
    }
    if (m.find("CloudWatchTrigger") != m.end() && !m["CloudWatchTrigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["CloudWatchTrigger"].type()) {
        DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRuleCloudWatchTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CloudWatchTrigger"]));
        cloudWatchTrigger = make_shared<DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRuleCloudWatchTrigger>(model1);
      }
    }
    if (m.find("Cooldown") != m.end() && !m["Cooldown"].empty()) {
      cooldown = make_shared<long>(boost::any_cast<long>(m["Cooldown"]));
    }
    if (m.find("EssScalingRuleId") != m.end() && !m["EssScalingRuleId"].empty()) {
      essScalingRuleId = make_shared<string>(boost::any_cast<string>(m["EssScalingRuleId"]));
    }
    if (m.find("LaunchExpirationTime") != m.end() && !m["LaunchExpirationTime"].empty()) {
      launchExpirationTime = make_shared<long>(boost::any_cast<long>(m["LaunchExpirationTime"]));
    }
    if (m.find("LaunchTime") != m.end() && !m["LaunchTime"].empty()) {
      launchTime = make_shared<string>(boost::any_cast<string>(m["LaunchTime"]));
    }
    if (m.find("RecurrenceEndTime") != m.end() && !m["RecurrenceEndTime"].empty()) {
      recurrenceEndTime = make_shared<string>(boost::any_cast<string>(m["RecurrenceEndTime"]));
    }
    if (m.find("RecurrenceType") != m.end() && !m["RecurrenceType"].empty()) {
      recurrenceType = make_shared<string>(boost::any_cast<string>(m["RecurrenceType"]));
    }
    if (m.find("RecurrenceValue") != m.end() && !m["RecurrenceValue"].empty()) {
      recurrenceValue = make_shared<string>(boost::any_cast<string>(m["RecurrenceValue"]));
    }
    if (m.find("RuleCategory") != m.end() && !m["RuleCategory"].empty()) {
      ruleCategory = make_shared<string>(boost::any_cast<string>(m["RuleCategory"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<long>(boost::any_cast<long>(m["ScalingGroupId"]));
    }
    if (m.find("SchedulerTrigger") != m.end() && !m["SchedulerTrigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["SchedulerTrigger"].type()) {
        DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRuleSchedulerTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SchedulerTrigger"]));
        schedulerTrigger = make_shared<DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRuleSchedulerTrigger>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TimeoutWithGrace") != m.end() && !m["TimeoutWithGrace"].empty()) {
      timeoutWithGrace = make_shared<long>(boost::any_cast<long>(m["TimeoutWithGrace"]));
    }
    if (m.find("WithGrace") != m.end() && !m["WithGrace"].empty()) {
      withGrace = make_shared<bool>(boost::any_cast<bool>(m["WithGrace"]));
    }
  }


  virtual ~DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRule() = default;
};
class DescribeScalingGroupInstanceV2ResponseBodyScalingRuleList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRule>> scalingRule{};

  DescribeScalingGroupInstanceV2ResponseBodyScalingRuleList() {}

  explicit DescribeScalingGroupInstanceV2ResponseBodyScalingRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scalingRule) {
      vector<boost::any> temp1;
      for(auto item1:*scalingRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScalingRule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScalingRule") != m.end() && !m["ScalingRule"].empty()) {
      if (typeid(vector<boost::any>) == m["ScalingRule"].type()) {
        vector<DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScalingRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scalingRule = make_shared<vector<DescribeScalingGroupInstanceV2ResponseBodyScalingRuleListScalingRule>>(expect1);
      }
    }
  }


  virtual ~DescribeScalingGroupInstanceV2ResponseBodyScalingRuleList() = default;
};
class DescribeScalingGroupInstanceV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> activeRuleCategory{};
  shared_ptr<long> defaultCooldown{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<long> maxSize{};
  shared_ptr<long> minSize{};
  shared_ptr<string> multiAvailablePolicy{};
  shared_ptr<string> multiAvailablePolicyParam{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeScalingGroupInstanceV2ResponseBodyScalingConfig> scalingConfig{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<DescribeScalingGroupInstanceV2ResponseBodyScalingRuleList> scalingRuleList{};
  shared_ptr<long> timeoutWithGrace{};
  shared_ptr<bool> withGrace{};

  DescribeScalingGroupInstanceV2ResponseBody() {}

  explicit DescribeScalingGroupInstanceV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeRuleCategory) {
      res["ActiveRuleCategory"] = boost::any(*activeRuleCategory);
    }
    if (defaultCooldown) {
      res["DefaultCooldown"] = boost::any(*defaultCooldown);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (maxSize) {
      res["MaxSize"] = boost::any(*maxSize);
    }
    if (minSize) {
      res["MinSize"] = boost::any(*minSize);
    }
    if (multiAvailablePolicy) {
      res["MultiAvailablePolicy"] = boost::any(*multiAvailablePolicy);
    }
    if (multiAvailablePolicyParam) {
      res["MultiAvailablePolicyParam"] = boost::any(*multiAvailablePolicyParam);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingConfig) {
      res["ScalingConfig"] = scalingConfig ? boost::any(scalingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (scalingRuleList) {
      res["ScalingRuleList"] = scalingRuleList ? boost::any(scalingRuleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeoutWithGrace) {
      res["TimeoutWithGrace"] = boost::any(*timeoutWithGrace);
    }
    if (withGrace) {
      res["WithGrace"] = boost::any(*withGrace);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveRuleCategory") != m.end() && !m["ActiveRuleCategory"].empty()) {
      activeRuleCategory = make_shared<string>(boost::any_cast<string>(m["ActiveRuleCategory"]));
    }
    if (m.find("DefaultCooldown") != m.end() && !m["DefaultCooldown"].empty()) {
      defaultCooldown = make_shared<long>(boost::any_cast<long>(m["DefaultCooldown"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("MaxSize") != m.end() && !m["MaxSize"].empty()) {
      maxSize = make_shared<long>(boost::any_cast<long>(m["MaxSize"]));
    }
    if (m.find("MinSize") != m.end() && !m["MinSize"].empty()) {
      minSize = make_shared<long>(boost::any_cast<long>(m["MinSize"]));
    }
    if (m.find("MultiAvailablePolicy") != m.end() && !m["MultiAvailablePolicy"].empty()) {
      multiAvailablePolicy = make_shared<string>(boost::any_cast<string>(m["MultiAvailablePolicy"]));
    }
    if (m.find("MultiAvailablePolicyParam") != m.end() && !m["MultiAvailablePolicyParam"].empty()) {
      multiAvailablePolicyParam = make_shared<string>(boost::any_cast<string>(m["MultiAvailablePolicyParam"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingConfig") != m.end() && !m["ScalingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScalingConfig"].type()) {
        DescribeScalingGroupInstanceV2ResponseBodyScalingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScalingConfig"]));
        scalingConfig = make_shared<DescribeScalingGroupInstanceV2ResponseBodyScalingConfig>(model1);
      }
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("ScalingRuleList") != m.end() && !m["ScalingRuleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScalingRuleList"].type()) {
        DescribeScalingGroupInstanceV2ResponseBodyScalingRuleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScalingRuleList"]));
        scalingRuleList = make_shared<DescribeScalingGroupInstanceV2ResponseBodyScalingRuleList>(model1);
      }
    }
    if (m.find("TimeoutWithGrace") != m.end() && !m["TimeoutWithGrace"].empty()) {
      timeoutWithGrace = make_shared<long>(boost::any_cast<long>(m["TimeoutWithGrace"]));
    }
    if (m.find("WithGrace") != m.end() && !m["WithGrace"].empty()) {
      withGrace = make_shared<bool>(boost::any_cast<bool>(m["WithGrace"]));
    }
  }


  virtual ~DescribeScalingGroupInstanceV2ResponseBody() = default;
};
class DescribeScalingGroupInstanceV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeScalingGroupInstanceV2ResponseBody> body{};

  DescribeScalingGroupInstanceV2Response() {}

  explicit DescribeScalingGroupInstanceV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScalingGroupInstanceV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScalingGroupInstanceV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScalingGroupInstanceV2Response() = default;
};
class DescribeScalingGroupV2Request : public Darabonba::Model {
public:
  shared_ptr<string> hostGroupBizId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingGroupBizId{};

  DescribeScalingGroupV2Request() {}

  explicit DescribeScalingGroupV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroupBizId) {
      res["HostGroupBizId"] = boost::any(*hostGroupBizId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroupBizId") != m.end() && !m["HostGroupBizId"].empty()) {
      hostGroupBizId = make_shared<string>(boost::any_cast<string>(m["HostGroupBizId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
  }


  virtual ~DescribeScalingGroupV2Request() = default;
};
class DescribeScalingGroupV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> activeStatus{};
  shared_ptr<string> configState{};
  shared_ptr<string> description{};
  shared_ptr<string> hostGroupBizId{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> scalingInMode{};
  shared_ptr<long> scalingMaxSize{};
  shared_ptr<long> scalingMinSize{};

  DescribeScalingGroupV2ResponseBody() {}

  explicit DescribeScalingGroupV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeStatus) {
      res["ActiveStatus"] = boost::any(*activeStatus);
    }
    if (configState) {
      res["ConfigState"] = boost::any(*configState);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hostGroupBizId) {
      res["HostGroupBizId"] = boost::any(*hostGroupBizId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (scalingInMode) {
      res["ScalingInMode"] = boost::any(*scalingInMode);
    }
    if (scalingMaxSize) {
      res["ScalingMaxSize"] = boost::any(*scalingMaxSize);
    }
    if (scalingMinSize) {
      res["ScalingMinSize"] = boost::any(*scalingMinSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveStatus") != m.end() && !m["ActiveStatus"].empty()) {
      activeStatus = make_shared<string>(boost::any_cast<string>(m["ActiveStatus"]));
    }
    if (m.find("ConfigState") != m.end() && !m["ConfigState"].empty()) {
      configState = make_shared<string>(boost::any_cast<string>(m["ConfigState"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HostGroupBizId") != m.end() && !m["HostGroupBizId"].empty()) {
      hostGroupBizId = make_shared<string>(boost::any_cast<string>(m["HostGroupBizId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("ScalingInMode") != m.end() && !m["ScalingInMode"].empty()) {
      scalingInMode = make_shared<string>(boost::any_cast<string>(m["ScalingInMode"]));
    }
    if (m.find("ScalingMaxSize") != m.end() && !m["ScalingMaxSize"].empty()) {
      scalingMaxSize = make_shared<long>(boost::any_cast<long>(m["ScalingMaxSize"]));
    }
    if (m.find("ScalingMinSize") != m.end() && !m["ScalingMinSize"].empty()) {
      scalingMinSize = make_shared<long>(boost::any_cast<long>(m["ScalingMinSize"]));
    }
  }


  virtual ~DescribeScalingGroupV2ResponseBody() = default;
};
class DescribeScalingGroupV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeScalingGroupV2ResponseBody> body{};

  DescribeScalingGroupV2Response() {}

  explicit DescribeScalingGroupV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScalingGroupV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScalingGroupV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScalingGroupV2Response() = default;
};
class JoinResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};

  JoinResourceGroupRequest() {}

  explicit JoinResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~JoinResourceGroupRequest() = default;
};
class JoinResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  JoinResourceGroupResponseBody() {}

  explicit JoinResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~JoinResourceGroupResponseBody() = default;
};
class JoinResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<JoinResourceGroupResponseBody> body{};

  JoinResourceGroupResponse() {}

  explicit JoinResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        JoinResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<JoinResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~JoinResourceGroupResponse() = default;
};
class KillFlowJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobInstanceId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  KillFlowJobRequest() {}

  explicit KillFlowJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobInstanceId) {
      res["JobInstanceId"] = boost::any(*jobInstanceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobInstanceId") != m.end() && !m["JobInstanceId"].empty()) {
      jobInstanceId = make_shared<string>(boost::any_cast<string>(m["JobInstanceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~KillFlowJobRequest() = default;
};
class KillFlowJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  KillFlowJobResponseBody() {}

  explicit KillFlowJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~KillFlowJobResponseBody() = default;
};
class KillFlowJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<KillFlowJobResponseBody> body{};

  KillFlowJobResponse() {}

  explicit KillFlowJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        KillFlowJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<KillFlowJobResponseBody>(model1);
      }
    }
  }


  virtual ~KillFlowJobResponse() = default;
};
class ListClusterHostRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> componentName{};
  shared_ptr<string> groupType{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostInstanceId{};
  shared_ptr<string> hostName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> privateIp{};
  shared_ptr<string> publicIp{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<string>> statusList{};

  ListClusterHostRequest() {}

  explicit ListClusterHostRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostInstanceId) {
      res["HostInstanceId"] = boost::any(*hostInstanceId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (privateIp) {
      res["PrivateIp"] = boost::any(*privateIp);
    }
    if (publicIp) {
      res["PublicIp"] = boost::any(*publicIp);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostInstanceId") != m.end() && !m["HostInstanceId"].empty()) {
      hostInstanceId = make_shared<string>(boost::any_cast<string>(m["HostInstanceId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PrivateIp") != m.end() && !m["PrivateIp"].empty()) {
      privateIp = make_shared<string>(boost::any_cast<string>(m["PrivateIp"]));
    }
    if (m.find("PublicIp") != m.end() && !m["PublicIp"].empty()) {
      publicIp = make_shared<string>(boost::any_cast<string>(m["PublicIp"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statusList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListClusterHostRequest() = default;
};
class ListClusterHostResponseBodyHostListHostDiskListDisk : public Darabonba::Model {
public:
  shared_ptr<string> blockMountPoint{};
  shared_ptr<string> device{};
  shared_ptr<string> diskId{};
  shared_ptr<string> diskMountPoint{};
  shared_ptr<long> diskSize{};
  shared_ptr<string> diskType{};
  shared_ptr<string> event{};
  shared_ptr<string> type{};

  ListClusterHostResponseBodyHostListHostDiskListDisk() {}

  explicit ListClusterHostResponseBodyHostListHostDiskListDisk(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockMountPoint) {
      res["BlockMountPoint"] = boost::any(*blockMountPoint);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (diskId) {
      res["DiskId"] = boost::any(*diskId);
    }
    if (diskMountPoint) {
      res["DiskMountPoint"] = boost::any(*diskMountPoint);
    }
    if (diskSize) {
      res["DiskSize"] = boost::any(*diskSize);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockMountPoint") != m.end() && !m["BlockMountPoint"].empty()) {
      blockMountPoint = make_shared<string>(boost::any_cast<string>(m["BlockMountPoint"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("DiskId") != m.end() && !m["DiskId"].empty()) {
      diskId = make_shared<string>(boost::any_cast<string>(m["DiskId"]));
    }
    if (m.find("DiskMountPoint") != m.end() && !m["DiskMountPoint"].empty()) {
      diskMountPoint = make_shared<string>(boost::any_cast<string>(m["DiskMountPoint"]));
    }
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      diskSize = make_shared<long>(boost::any_cast<long>(m["DiskSize"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListClusterHostResponseBodyHostListHostDiskListDisk() = default;
};
class ListClusterHostResponseBodyHostListHostDiskList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterHostResponseBodyHostListHostDiskListDisk>> disk{};

  ListClusterHostResponseBodyHostListHostDiskList() {}

  explicit ListClusterHostResponseBodyHostListHostDiskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disk) {
      vector<boost::any> temp1;
      for(auto item1:*disk){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Disk"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Disk") != m.end() && !m["Disk"].empty()) {
      if (typeid(vector<boost::any>) == m["Disk"].type()) {
        vector<ListClusterHostResponseBodyHostListHostDiskListDisk> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Disk"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterHostResponseBodyHostListHostDiskListDisk model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        disk = make_shared<vector<ListClusterHostResponseBodyHostListHostDiskListDisk>>(expect1);
      }
    }
  }


  virtual ~ListClusterHostResponseBodyHostListHostDiskList() = default;
};
class ListClusterHostResponseBodyHostListHost : public Darabonba::Model {
public:
  shared_ptr<string> chargeType{};
  shared_ptr<long> cpu{};
  shared_ptr<string> createTime{};
  shared_ptr<ListClusterHostResponseBodyHostListHostDiskList> diskList{};
  shared_ptr<string> emrExpiredTime{};
  shared_ptr<long> expiredTime{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostInstanceId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceStatus{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> memory{};
  shared_ptr<string> privateIp{};
  shared_ptr<string> publicIp{};
  shared_ptr<string> role{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> status{};
  shared_ptr<bool> supportIpV6{};
  shared_ptr<string> type{};
  shared_ptr<string> zoneId{};

  ListClusterHostResponseBodyHostListHost() {}

  explicit ListClusterHostResponseBodyHostListHost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (diskList) {
      res["DiskList"] = diskList ? boost::any(diskList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emrExpiredTime) {
      res["EmrExpiredTime"] = boost::any(*emrExpiredTime);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostInstanceId) {
      res["HostInstanceId"] = boost::any(*hostInstanceId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceStatus) {
      res["InstanceStatus"] = boost::any(*instanceStatus);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (privateIp) {
      res["PrivateIp"] = boost::any(*privateIp);
    }
    if (publicIp) {
      res["PublicIp"] = boost::any(*publicIp);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (supportIpV6) {
      res["SupportIpV6"] = boost::any(*supportIpV6);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DiskList") != m.end() && !m["DiskList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskList"].type()) {
        ListClusterHostResponseBodyHostListHostDiskList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskList"]));
        diskList = make_shared<ListClusterHostResponseBodyHostListHostDiskList>(model1);
      }
    }
    if (m.find("EmrExpiredTime") != m.end() && !m["EmrExpiredTime"].empty()) {
      emrExpiredTime = make_shared<string>(boost::any_cast<string>(m["EmrExpiredTime"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostInstanceId") != m.end() && !m["HostInstanceId"].empty()) {
      hostInstanceId = make_shared<string>(boost::any_cast<string>(m["HostInstanceId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceStatus") != m.end() && !m["InstanceStatus"].empty()) {
      instanceStatus = make_shared<string>(boost::any_cast<string>(m["InstanceStatus"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("PrivateIp") != m.end() && !m["PrivateIp"].empty()) {
      privateIp = make_shared<string>(boost::any_cast<string>(m["PrivateIp"]));
    }
    if (m.find("PublicIp") != m.end() && !m["PublicIp"].empty()) {
      publicIp = make_shared<string>(boost::any_cast<string>(m["PublicIp"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SupportIpV6") != m.end() && !m["SupportIpV6"].empty()) {
      supportIpV6 = make_shared<bool>(boost::any_cast<bool>(m["SupportIpV6"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~ListClusterHostResponseBodyHostListHost() = default;
};
class ListClusterHostResponseBodyHostList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterHostResponseBodyHostListHost>> host{};

  ListClusterHostResponseBodyHostList() {}

  explicit ListClusterHostResponseBodyHostList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      vector<boost::any> temp1;
      for(auto item1:*host){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Host"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      if (typeid(vector<boost::any>) == m["Host"].type()) {
        vector<ListClusterHostResponseBodyHostListHost> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Host"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterHostResponseBodyHostListHost model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        host = make_shared<vector<ListClusterHostResponseBodyHostListHost>>(expect1);
      }
    }
  }


  virtual ~ListClusterHostResponseBodyHostList() = default;
};
class ListClusterHostResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListClusterHostResponseBodyHostList> hostList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  ListClusterHostResponseBody() {}

  explicit ListClusterHostResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostList) {
      res["HostList"] = hostList ? boost::any(hostList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostList") != m.end() && !m["HostList"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostList"].type()) {
        ListClusterHostResponseBodyHostList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostList"]));
        hostList = make_shared<ListClusterHostResponseBodyHostList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListClusterHostResponseBody() = default;
};
class ListClusterHostResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterHostResponseBody> body{};

  ListClusterHostResponse() {}

  explicit ListClusterHostResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterHostResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterHostResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterHostResponse() = default;
};
class ListClusterHostComponentRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> componentName{};
  shared_ptr<string> componentStatus{};
  shared_ptr<string> hostInstanceId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> hostRole{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> serviceName{};

  ListClusterHostComponentRequest() {}

  explicit ListClusterHostComponentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (componentStatus) {
      res["ComponentStatus"] = boost::any(*componentStatus);
    }
    if (hostInstanceId) {
      res["HostInstanceId"] = boost::any(*hostInstanceId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (hostRole) {
      res["HostRole"] = boost::any(*hostRole);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("ComponentStatus") != m.end() && !m["ComponentStatus"].empty()) {
      componentStatus = make_shared<string>(boost::any_cast<string>(m["ComponentStatus"]));
    }
    if (m.find("HostInstanceId") != m.end() && !m["HostInstanceId"].empty()) {
      hostInstanceId = make_shared<string>(boost::any_cast<string>(m["HostInstanceId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("HostRole") != m.end() && !m["HostRole"].empty()) {
      hostRole = make_shared<string>(boost::any_cast<string>(m["HostRole"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~ListClusterHostComponentRequest() = default;
};
class ListClusterHostComponentResponseBodyComponentListComponent : public Darabonba::Model {
public:
  shared_ptr<string> commissionStatus{};
  shared_ptr<string> componentDisplayName{};
  shared_ptr<string> componentName{};
  shared_ptr<long> cpu{};
  shared_ptr<long> healthReportTime{};
  shared_ptr<string> healthStatus{};
  shared_ptr<string> hostId{};
  shared_ptr<string> hostInstanceId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> memory{};
  shared_ptr<bool> needRestart{};
  shared_ptr<string> privateIp{};
  shared_ptr<string> publicIp{};
  shared_ptr<string> role{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> serverStatus{};
  shared_ptr<string> serviceDisplayName{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> state{};
  shared_ptr<string> status{};

  ListClusterHostComponentResponseBodyComponentListComponent() {}

  explicit ListClusterHostComponentResponseBodyComponentListComponent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commissionStatus) {
      res["CommissionStatus"] = boost::any(*commissionStatus);
    }
    if (componentDisplayName) {
      res["ComponentDisplayName"] = boost::any(*componentDisplayName);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (healthReportTime) {
      res["HealthReportTime"] = boost::any(*healthReportTime);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (hostInstanceId) {
      res["HostInstanceId"] = boost::any(*hostInstanceId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (needRestart) {
      res["NeedRestart"] = boost::any(*needRestart);
    }
    if (privateIp) {
      res["PrivateIp"] = boost::any(*privateIp);
    }
    if (publicIp) {
      res["PublicIp"] = boost::any(*publicIp);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (serverStatus) {
      res["ServerStatus"] = boost::any(*serverStatus);
    }
    if (serviceDisplayName) {
      res["ServiceDisplayName"] = boost::any(*serviceDisplayName);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommissionStatus") != m.end() && !m["CommissionStatus"].empty()) {
      commissionStatus = make_shared<string>(boost::any_cast<string>(m["CommissionStatus"]));
    }
    if (m.find("ComponentDisplayName") != m.end() && !m["ComponentDisplayName"].empty()) {
      componentDisplayName = make_shared<string>(boost::any_cast<string>(m["ComponentDisplayName"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("HealthReportTime") != m.end() && !m["HealthReportTime"].empty()) {
      healthReportTime = make_shared<long>(boost::any_cast<long>(m["HealthReportTime"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("HostInstanceId") != m.end() && !m["HostInstanceId"].empty()) {
      hostInstanceId = make_shared<string>(boost::any_cast<string>(m["HostInstanceId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("NeedRestart") != m.end() && !m["NeedRestart"].empty()) {
      needRestart = make_shared<bool>(boost::any_cast<bool>(m["NeedRestart"]));
    }
    if (m.find("PrivateIp") != m.end() && !m["PrivateIp"].empty()) {
      privateIp = make_shared<string>(boost::any_cast<string>(m["PrivateIp"]));
    }
    if (m.find("PublicIp") != m.end() && !m["PublicIp"].empty()) {
      publicIp = make_shared<string>(boost::any_cast<string>(m["PublicIp"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("ServerStatus") != m.end() && !m["ServerStatus"].empty()) {
      serverStatus = make_shared<string>(boost::any_cast<string>(m["ServerStatus"]));
    }
    if (m.find("ServiceDisplayName") != m.end() && !m["ServiceDisplayName"].empty()) {
      serviceDisplayName = make_shared<string>(boost::any_cast<string>(m["ServiceDisplayName"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListClusterHostComponentResponseBodyComponentListComponent() = default;
};
class ListClusterHostComponentResponseBodyComponentList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterHostComponentResponseBodyComponentListComponent>> component{};

  ListClusterHostComponentResponseBodyComponentList() {}

  explicit ListClusterHostComponentResponseBodyComponentList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (component) {
      vector<boost::any> temp1;
      for(auto item1:*component){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Component"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Component") != m.end() && !m["Component"].empty()) {
      if (typeid(vector<boost::any>) == m["Component"].type()) {
        vector<ListClusterHostComponentResponseBodyComponentListComponent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Component"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterHostComponentResponseBodyComponentListComponent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        component = make_shared<vector<ListClusterHostComponentResponseBodyComponentListComponent>>(expect1);
      }
    }
  }


  virtual ~ListClusterHostComponentResponseBodyComponentList() = default;
};
class ListClusterHostComponentResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListClusterHostComponentResponseBodyComponentList> componentList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  ListClusterHostComponentResponseBody() {}

  explicit ListClusterHostComponentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentList) {
      res["ComponentList"] = componentList ? boost::any(componentList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentList") != m.end() && !m["ComponentList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComponentList"].type()) {
        ListClusterHostComponentResponseBodyComponentList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComponentList"]));
        componentList = make_shared<ListClusterHostComponentResponseBodyComponentList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListClusterHostComponentResponseBody() = default;
};
class ListClusterHostComponentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterHostComponentResponseBody> body{};

  ListClusterHostComponentResponse() {}

  explicit ListClusterHostComponentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterHostComponentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterHostComponentResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterHostComponentResponse() = default;
};
class ListClusterHostGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<string> hostGroupType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<string>> statusList{};

  ListClusterHostGroupRequest() {}

  explicit ListClusterHostGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (hostGroupType) {
      res["HostGroupType"] = boost::any(*hostGroupType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("HostGroupType") != m.end() && !m["HostGroupType"].empty()) {
      hostGroupType = make_shared<string>(boost::any_cast<string>(m["HostGroupType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statusList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListClusterHostGroupRequest() = default;
};
class ListClusterHostGroupResponseBodyHostGroupListHostGroup : public Darabonba::Model {
public:
  shared_ptr<string> chargeType{};
  shared_ptr<string> comment{};
  shared_ptr<double> costSavingPercent{};
  shared_ptr<long> cpu{};
  shared_ptr<long> dataDiskCount{};
  shared_ptr<long> dataDiskSize{};
  shared_ptr<string> dataDiskType{};
  shared_ptr<string> hostGroupChangeStatus{};
  shared_ptr<string> hostGroupChangeType{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<string> hostGroupSubType{};
  shared_ptr<string> hostGroupType{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> lockReason{};
  shared_ptr<string> lockType{};
  shared_ptr<long> memory{};
  shared_ptr<long> nodeCount{};
  shared_ptr<string> payType{};
  shared_ptr<string> scalingGroupActiveStatus{};
  shared_ptr<string> scalingGroupBizId{};
  shared_ptr<string> scalingGroupConfigState{};
  shared_ptr<long> scalingGroupMaxNode{};
  shared_ptr<long> scalingGroupMinNode{};
  shared_ptr<string> scalingInMode{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> status{};
  shared_ptr<long> systemDiskCount{};
  shared_ptr<long> systemDiskSize{};
  shared_ptr<string> systemDiskType{};
  shared_ptr<string> vswitchId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};

  ListClusterHostGroupResponseBodyHostGroupListHostGroup() {}

  explicit ListClusterHostGroupResponseBodyHostGroupListHostGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (costSavingPercent) {
      res["CostSavingPercent"] = boost::any(*costSavingPercent);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (dataDiskCount) {
      res["DataDiskCount"] = boost::any(*dataDiskCount);
    }
    if (dataDiskSize) {
      res["DataDiskSize"] = boost::any(*dataDiskSize);
    }
    if (dataDiskType) {
      res["DataDiskType"] = boost::any(*dataDiskType);
    }
    if (hostGroupChangeStatus) {
      res["HostGroupChangeStatus"] = boost::any(*hostGroupChangeStatus);
    }
    if (hostGroupChangeType) {
      res["HostGroupChangeType"] = boost::any(*hostGroupChangeType);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (hostGroupSubType) {
      res["HostGroupSubType"] = boost::any(*hostGroupSubType);
    }
    if (hostGroupType) {
      res["HostGroupType"] = boost::any(*hostGroupType);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    if (lockType) {
      res["LockType"] = boost::any(*lockType);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (nodeCount) {
      res["NodeCount"] = boost::any(*nodeCount);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (scalingGroupActiveStatus) {
      res["ScalingGroupActiveStatus"] = boost::any(*scalingGroupActiveStatus);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    if (scalingGroupConfigState) {
      res["ScalingGroupConfigState"] = boost::any(*scalingGroupConfigState);
    }
    if (scalingGroupMaxNode) {
      res["ScalingGroupMaxNode"] = boost::any(*scalingGroupMaxNode);
    }
    if (scalingGroupMinNode) {
      res["ScalingGroupMinNode"] = boost::any(*scalingGroupMinNode);
    }
    if (scalingInMode) {
      res["ScalingInMode"] = boost::any(*scalingInMode);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (systemDiskCount) {
      res["SystemDiskCount"] = boost::any(*systemDiskCount);
    }
    if (systemDiskSize) {
      res["SystemDiskSize"] = boost::any(*systemDiskSize);
    }
    if (systemDiskType) {
      res["SystemDiskType"] = boost::any(*systemDiskType);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CostSavingPercent") != m.end() && !m["CostSavingPercent"].empty()) {
      costSavingPercent = make_shared<double>(boost::any_cast<double>(m["CostSavingPercent"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("DataDiskCount") != m.end() && !m["DataDiskCount"].empty()) {
      dataDiskCount = make_shared<long>(boost::any_cast<long>(m["DataDiskCount"]));
    }
    if (m.find("DataDiskSize") != m.end() && !m["DataDiskSize"].empty()) {
      dataDiskSize = make_shared<long>(boost::any_cast<long>(m["DataDiskSize"]));
    }
    if (m.find("DataDiskType") != m.end() && !m["DataDiskType"].empty()) {
      dataDiskType = make_shared<string>(boost::any_cast<string>(m["DataDiskType"]));
    }
    if (m.find("HostGroupChangeStatus") != m.end() && !m["HostGroupChangeStatus"].empty()) {
      hostGroupChangeStatus = make_shared<string>(boost::any_cast<string>(m["HostGroupChangeStatus"]));
    }
    if (m.find("HostGroupChangeType") != m.end() && !m["HostGroupChangeType"].empty()) {
      hostGroupChangeType = make_shared<string>(boost::any_cast<string>(m["HostGroupChangeType"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("HostGroupSubType") != m.end() && !m["HostGroupSubType"].empty()) {
      hostGroupSubType = make_shared<string>(boost::any_cast<string>(m["HostGroupSubType"]));
    }
    if (m.find("HostGroupType") != m.end() && !m["HostGroupType"].empty()) {
      hostGroupType = make_shared<string>(boost::any_cast<string>(m["HostGroupType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
    if (m.find("LockType") != m.end() && !m["LockType"].empty()) {
      lockType = make_shared<string>(boost::any_cast<string>(m["LockType"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("NodeCount") != m.end() && !m["NodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["NodeCount"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("ScalingGroupActiveStatus") != m.end() && !m["ScalingGroupActiveStatus"].empty()) {
      scalingGroupActiveStatus = make_shared<string>(boost::any_cast<string>(m["ScalingGroupActiveStatus"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
    if (m.find("ScalingGroupConfigState") != m.end() && !m["ScalingGroupConfigState"].empty()) {
      scalingGroupConfigState = make_shared<string>(boost::any_cast<string>(m["ScalingGroupConfigState"]));
    }
    if (m.find("ScalingGroupMaxNode") != m.end() && !m["ScalingGroupMaxNode"].empty()) {
      scalingGroupMaxNode = make_shared<long>(boost::any_cast<long>(m["ScalingGroupMaxNode"]));
    }
    if (m.find("ScalingGroupMinNode") != m.end() && !m["ScalingGroupMinNode"].empty()) {
      scalingGroupMinNode = make_shared<long>(boost::any_cast<long>(m["ScalingGroupMinNode"]));
    }
    if (m.find("ScalingInMode") != m.end() && !m["ScalingInMode"].empty()) {
      scalingInMode = make_shared<string>(boost::any_cast<string>(m["ScalingInMode"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SystemDiskCount") != m.end() && !m["SystemDiskCount"].empty()) {
      systemDiskCount = make_shared<long>(boost::any_cast<long>(m["SystemDiskCount"]));
    }
    if (m.find("SystemDiskSize") != m.end() && !m["SystemDiskSize"].empty()) {
      systemDiskSize = make_shared<long>(boost::any_cast<long>(m["SystemDiskSize"]));
    }
    if (m.find("SystemDiskType") != m.end() && !m["SystemDiskType"].empty()) {
      systemDiskType = make_shared<string>(boost::any_cast<string>(m["SystemDiskType"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmtModified"]));
    }
  }


  virtual ~ListClusterHostGroupResponseBodyHostGroupListHostGroup() = default;
};
class ListClusterHostGroupResponseBodyHostGroupList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterHostGroupResponseBodyHostGroupListHostGroup>> hostGroup{};

  ListClusterHostGroupResponseBodyHostGroupList() {}

  explicit ListClusterHostGroupResponseBodyHostGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroup) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroup") != m.end() && !m["HostGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["HostGroup"].type()) {
        vector<ListClusterHostGroupResponseBodyHostGroupListHostGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterHostGroupResponseBodyHostGroupListHostGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroup = make_shared<vector<ListClusterHostGroupResponseBodyHostGroupListHostGroup>>(expect1);
      }
    }
  }


  virtual ~ListClusterHostGroupResponseBodyHostGroupList() = default;
};
class ListClusterHostGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<ListClusterHostGroupResponseBodyHostGroupList> hostGroupList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  ListClusterHostGroupResponseBody() {}

  explicit ListClusterHostGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (hostGroupList) {
      res["HostGroupList"] = hostGroupList ? boost::any(hostGroupList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("HostGroupList") != m.end() && !m["HostGroupList"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostGroupList"].type()) {
        ListClusterHostGroupResponseBodyHostGroupList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostGroupList"]));
        hostGroupList = make_shared<ListClusterHostGroupResponseBodyHostGroupList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListClusterHostGroupResponseBody() = default;
};
class ListClusterHostGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterHostGroupResponseBody> body{};

  ListClusterHostGroupResponse() {}

  explicit ListClusterHostGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterHostGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterHostGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterHostGroupResponse() = default;
};
class ListClusterInstalledServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};

  ListClusterInstalledServiceRequest() {}

  explicit ListClusterInstalledServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListClusterInstalledServiceRequest() = default;
};
class ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionListServiceAction : public Darabonba::Model {
public:
  shared_ptr<string> actionName{};
  shared_ptr<string> command{};
  shared_ptr<string> componentName{};
  shared_ptr<string> displayName{};
  shared_ptr<string> serviceName{};

  ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionListServiceAction() {}

  explicit ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionListServiceAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionName) {
      res["ActionName"] = boost::any(*actionName);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionName") != m.end() && !m["ActionName"].empty()) {
      actionName = make_shared<string>(boost::any_cast<string>(m["ActionName"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionListServiceAction() = default;
};
class ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionListServiceAction>> serviceAction{};

  ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionList() {}

  explicit ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceAction) {
      vector<boost::any> temp1;
      for(auto item1:*serviceAction){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceAction"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceAction") != m.end() && !m["ServiceAction"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceAction"].type()) {
        vector<ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionListServiceAction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceAction"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionListServiceAction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceAction = make_shared<vector<ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionListServiceAction>>(expect1);
      }
    }
  }


  virtual ~ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionList() = default;
};
class ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledService : public Darabonba::Model {
public:
  shared_ptr<ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionList> serviceActionList{};
  shared_ptr<string> serviceDisplayName{};
  shared_ptr<string> serviceEcmVersion{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceVersion{};
  shared_ptr<string> state{};
  shared_ptr<long> abnormalNum{};
  shared_ptr<string> comment{};
  shared_ptr<long> needRestartNum{};
  shared_ptr<long> notStartedNum{};
  shared_ptr<bool> onlyClient{};
  shared_ptr<string> serviceStatus{};

  ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledService() {}

  explicit ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledService(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceActionList) {
      res["ServiceActionList"] = serviceActionList ? boost::any(serviceActionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceDisplayName) {
      res["ServiceDisplayName"] = boost::any(*serviceDisplayName);
    }
    if (serviceEcmVersion) {
      res["ServiceEcmVersion"] = boost::any(*serviceEcmVersion);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (serviceVersion) {
      res["ServiceVersion"] = boost::any(*serviceVersion);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (abnormalNum) {
      res["abnormalNum"] = boost::any(*abnormalNum);
    }
    if (comment) {
      res["comment"] = boost::any(*comment);
    }
    if (needRestartNum) {
      res["needRestartNum"] = boost::any(*needRestartNum);
    }
    if (notStartedNum) {
      res["notStartedNum"] = boost::any(*notStartedNum);
    }
    if (onlyClient) {
      res["onlyClient"] = boost::any(*onlyClient);
    }
    if (serviceStatus) {
      res["serviceStatus"] = boost::any(*serviceStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceActionList") != m.end() && !m["ServiceActionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceActionList"].type()) {
        ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceActionList"]));
        serviceActionList = make_shared<ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledServiceServiceActionList>(model1);
      }
    }
    if (m.find("ServiceDisplayName") != m.end() && !m["ServiceDisplayName"].empty()) {
      serviceDisplayName = make_shared<string>(boost::any_cast<string>(m["ServiceDisplayName"]));
    }
    if (m.find("ServiceEcmVersion") != m.end() && !m["ServiceEcmVersion"].empty()) {
      serviceEcmVersion = make_shared<string>(boost::any_cast<string>(m["ServiceEcmVersion"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServiceVersion") != m.end() && !m["ServiceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["ServiceVersion"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("abnormalNum") != m.end() && !m["abnormalNum"].empty()) {
      abnormalNum = make_shared<long>(boost::any_cast<long>(m["abnormalNum"]));
    }
    if (m.find("comment") != m.end() && !m["comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["comment"]));
    }
    if (m.find("needRestartNum") != m.end() && !m["needRestartNum"].empty()) {
      needRestartNum = make_shared<long>(boost::any_cast<long>(m["needRestartNum"]));
    }
    if (m.find("notStartedNum") != m.end() && !m["notStartedNum"].empty()) {
      notStartedNum = make_shared<long>(boost::any_cast<long>(m["notStartedNum"]));
    }
    if (m.find("onlyClient") != m.end() && !m["onlyClient"].empty()) {
      onlyClient = make_shared<bool>(boost::any_cast<bool>(m["onlyClient"]));
    }
    if (m.find("serviceStatus") != m.end() && !m["serviceStatus"].empty()) {
      serviceStatus = make_shared<string>(boost::any_cast<string>(m["serviceStatus"]));
    }
  }


  virtual ~ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledService() = default;
};
class ListClusterInstalledServiceResponseBodyClusterInstalledServiceList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledService>> clusterInstalledService{};

  ListClusterInstalledServiceResponseBodyClusterInstalledServiceList() {}

  explicit ListClusterInstalledServiceResponseBodyClusterInstalledServiceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterInstalledService) {
      vector<boost::any> temp1;
      for(auto item1:*clusterInstalledService){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterInstalledService"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterInstalledService") != m.end() && !m["ClusterInstalledService"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterInstalledService"].type()) {
        vector<ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledService> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterInstalledService"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledService model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterInstalledService = make_shared<vector<ListClusterInstalledServiceResponseBodyClusterInstalledServiceListClusterInstalledService>>(expect1);
      }
    }
  }


  virtual ~ListClusterInstalledServiceResponseBodyClusterInstalledServiceList() = default;
};
class ListClusterInstalledServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListClusterInstalledServiceResponseBodyClusterInstalledServiceList> clusterInstalledServiceList{};
  shared_ptr<string> requestId{};

  ListClusterInstalledServiceResponseBody() {}

  explicit ListClusterInstalledServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterInstalledServiceList) {
      res["ClusterInstalledServiceList"] = clusterInstalledServiceList ? boost::any(clusterInstalledServiceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterInstalledServiceList") != m.end() && !m["ClusterInstalledServiceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterInstalledServiceList"].type()) {
        ListClusterInstalledServiceResponseBodyClusterInstalledServiceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterInstalledServiceList"]));
        clusterInstalledServiceList = make_shared<ListClusterInstalledServiceResponseBodyClusterInstalledServiceList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListClusterInstalledServiceResponseBody() = default;
};
class ListClusterInstalledServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterInstalledServiceResponseBody> body{};

  ListClusterInstalledServiceResponse() {}

  explicit ListClusterInstalledServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterInstalledServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterInstalledServiceResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterInstalledServiceResponse() = default;
};
class ListClusterOperationRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> operationId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> status{};

  ListClusterOperationRequest() {}

  explicit ListClusterOperationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListClusterOperationRequest() = default;
};
class ListClusterOperationResponseBodyClusterOperationListClusterOperation : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> duration{};
  shared_ptr<string> operationId{};
  shared_ptr<string> operationName{};
  shared_ptr<string> percentage{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  ListClusterOperationResponseBodyClusterOperationListClusterOperation() {}

  explicit ListClusterOperationResponseBodyClusterOperationListClusterOperation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (operationName) {
      res["OperationName"] = boost::any(*operationName);
    }
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("OperationName") != m.end() && !m["OperationName"].empty()) {
      operationName = make_shared<string>(boost::any_cast<string>(m["OperationName"]));
    }
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<string>(boost::any_cast<string>(m["Percentage"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListClusterOperationResponseBodyClusterOperationListClusterOperation() = default;
};
class ListClusterOperationResponseBodyClusterOperationList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterOperationResponseBodyClusterOperationListClusterOperation>> clusterOperation{};

  ListClusterOperationResponseBodyClusterOperationList() {}

  explicit ListClusterOperationResponseBodyClusterOperationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterOperation) {
      vector<boost::any> temp1;
      for(auto item1:*clusterOperation){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterOperation"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterOperation") != m.end() && !m["ClusterOperation"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterOperation"].type()) {
        vector<ListClusterOperationResponseBodyClusterOperationListClusterOperation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterOperation"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterOperationResponseBodyClusterOperationListClusterOperation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterOperation = make_shared<vector<ListClusterOperationResponseBodyClusterOperationListClusterOperation>>(expect1);
      }
    }
  }


  virtual ~ListClusterOperationResponseBodyClusterOperationList() = default;
};
class ListClusterOperationResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListClusterOperationResponseBodyClusterOperationList> clusterOperationList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListClusterOperationResponseBody() {}

  explicit ListClusterOperationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterOperationList) {
      res["ClusterOperationList"] = clusterOperationList ? boost::any(clusterOperationList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterOperationList") != m.end() && !m["ClusterOperationList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterOperationList"].type()) {
        ListClusterOperationResponseBodyClusterOperationList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterOperationList"]));
        clusterOperationList = make_shared<ListClusterOperationResponseBodyClusterOperationList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListClusterOperationResponseBody() = default;
};
class ListClusterOperationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterOperationResponseBody> body{};

  ListClusterOperationResponse() {}

  explicit ListClusterOperationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterOperationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterOperationResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterOperationResponse() = default;
};
class ListClusterOperationHostRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> operationId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};

  ListClusterOperationHostRequest() {}

  explicit ListClusterOperationHostRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListClusterOperationHostRequest() = default;
};
class ListClusterOperationHostResponseBodyClusterOperationHostListClusterOperationHost : public Darabonba::Model {
public:
  shared_ptr<string> hostId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> percentage{};
  shared_ptr<string> status{};

  ListClusterOperationHostResponseBodyClusterOperationHostListClusterOperationHost() {}

  explicit ListClusterOperationHostResponseBodyClusterOperationHostListClusterOperationHost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<string>(boost::any_cast<string>(m["Percentage"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListClusterOperationHostResponseBodyClusterOperationHostListClusterOperationHost() = default;
};
class ListClusterOperationHostResponseBodyClusterOperationHostList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterOperationHostResponseBodyClusterOperationHostListClusterOperationHost>> clusterOperationHost{};

  ListClusterOperationHostResponseBodyClusterOperationHostList() {}

  explicit ListClusterOperationHostResponseBodyClusterOperationHostList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterOperationHost) {
      vector<boost::any> temp1;
      for(auto item1:*clusterOperationHost){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterOperationHost"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterOperationHost") != m.end() && !m["ClusterOperationHost"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterOperationHost"].type()) {
        vector<ListClusterOperationHostResponseBodyClusterOperationHostListClusterOperationHost> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterOperationHost"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterOperationHostResponseBodyClusterOperationHostListClusterOperationHost model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterOperationHost = make_shared<vector<ListClusterOperationHostResponseBodyClusterOperationHostListClusterOperationHost>>(expect1);
      }
    }
  }


  virtual ~ListClusterOperationHostResponseBodyClusterOperationHostList() = default;
};
class ListClusterOperationHostResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListClusterOperationHostResponseBodyClusterOperationHostList> clusterOperationHostList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListClusterOperationHostResponseBody() {}

  explicit ListClusterOperationHostResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterOperationHostList) {
      res["ClusterOperationHostList"] = clusterOperationHostList ? boost::any(clusterOperationHostList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterOperationHostList") != m.end() && !m["ClusterOperationHostList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterOperationHostList"].type()) {
        ListClusterOperationHostResponseBodyClusterOperationHostList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterOperationHostList"]));
        clusterOperationHostList = make_shared<ListClusterOperationHostResponseBodyClusterOperationHostList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListClusterOperationHostResponseBody() = default;
};
class ListClusterOperationHostResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterOperationHostResponseBody> body{};

  ListClusterOperationHostResponse() {}

  explicit ListClusterOperationHostResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterOperationHostResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterOperationHostResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterOperationHostResponse() = default;
};
class ListClusterOperationHostTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> hostId{};
  shared_ptr<string> operationId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};

  ListClusterOperationHostTaskRequest() {}

  explicit ListClusterOperationHostTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListClusterOperationHostTaskRequest() = default;
};
class ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskListClusterOperationHostTask : public Darabonba::Model {
public:
  shared_ptr<string> percentage{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};

  ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskListClusterOperationHostTask() {}

  explicit ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskListClusterOperationHostTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<string>(boost::any_cast<string>(m["Percentage"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskListClusterOperationHostTask() = default;
};
class ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskListClusterOperationHostTask>> clusterOperationHostTask{};

  ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskList() {}

  explicit ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterOperationHostTask) {
      vector<boost::any> temp1;
      for(auto item1:*clusterOperationHostTask){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterOperationHostTask"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterOperationHostTask") != m.end() && !m["ClusterOperationHostTask"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterOperationHostTask"].type()) {
        vector<ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskListClusterOperationHostTask> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterOperationHostTask"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskListClusterOperationHostTask model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterOperationHostTask = make_shared<vector<ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskListClusterOperationHostTask>>(expect1);
      }
    }
  }


  virtual ~ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskList() = default;
};
class ListClusterOperationHostTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskList> clusterOperationHostTaskList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListClusterOperationHostTaskResponseBody() {}

  explicit ListClusterOperationHostTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterOperationHostTaskList) {
      res["ClusterOperationHostTaskList"] = clusterOperationHostTaskList ? boost::any(clusterOperationHostTaskList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterOperationHostTaskList") != m.end() && !m["ClusterOperationHostTaskList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterOperationHostTaskList"].type()) {
        ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterOperationHostTaskList"]));
        clusterOperationHostTaskList = make_shared<ListClusterOperationHostTaskResponseBodyClusterOperationHostTaskList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListClusterOperationHostTaskResponseBody() = default;
};
class ListClusterOperationHostTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterOperationHostTaskResponseBody> body{};

  ListClusterOperationHostTaskResponse() {}

  explicit ListClusterOperationHostTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterOperationHostTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterOperationHostTaskResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterOperationHostTaskResponse() = default;
};
class ListClusterOperationTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> operationId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};

  ListClusterOperationTaskRequest() {}

  explicit ListClusterOperationTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListClusterOperationTaskRequest() = default;
};
class ListClusterOperationTaskResponseBodyClusterOperationTaskListClusterOperationTask : public Darabonba::Model {
public:
  shared_ptr<string> percentage{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};

  ListClusterOperationTaskResponseBodyClusterOperationTaskListClusterOperationTask() {}

  explicit ListClusterOperationTaskResponseBodyClusterOperationTaskListClusterOperationTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<string>(boost::any_cast<string>(m["Percentage"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~ListClusterOperationTaskResponseBodyClusterOperationTaskListClusterOperationTask() = default;
};
class ListClusterOperationTaskResponseBodyClusterOperationTaskList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterOperationTaskResponseBodyClusterOperationTaskListClusterOperationTask>> clusterOperationTask{};

  ListClusterOperationTaskResponseBodyClusterOperationTaskList() {}

  explicit ListClusterOperationTaskResponseBodyClusterOperationTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterOperationTask) {
      vector<boost::any> temp1;
      for(auto item1:*clusterOperationTask){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterOperationTask"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterOperationTask") != m.end() && !m["ClusterOperationTask"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterOperationTask"].type()) {
        vector<ListClusterOperationTaskResponseBodyClusterOperationTaskListClusterOperationTask> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterOperationTask"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterOperationTaskResponseBodyClusterOperationTaskListClusterOperationTask model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterOperationTask = make_shared<vector<ListClusterOperationTaskResponseBodyClusterOperationTaskListClusterOperationTask>>(expect1);
      }
    }
  }


  virtual ~ListClusterOperationTaskResponseBodyClusterOperationTaskList() = default;
};
class ListClusterOperationTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListClusterOperationTaskResponseBodyClusterOperationTaskList> clusterOperationTaskList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListClusterOperationTaskResponseBody() {}

  explicit ListClusterOperationTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterOperationTaskList) {
      res["ClusterOperationTaskList"] = clusterOperationTaskList ? boost::any(clusterOperationTaskList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterOperationTaskList") != m.end() && !m["ClusterOperationTaskList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterOperationTaskList"].type()) {
        ListClusterOperationTaskResponseBodyClusterOperationTaskList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterOperationTaskList"]));
        clusterOperationTaskList = make_shared<ListClusterOperationTaskResponseBodyClusterOperationTaskList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListClusterOperationTaskResponseBody() = default;
};
class ListClusterOperationTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterOperationTaskResponseBody> body{};

  ListClusterOperationTaskResponse() {}

  explicit ListClusterOperationTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterOperationTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterOperationTaskResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterOperationTaskResponse() = default;
};
class ListClusterServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};

  ListClusterServiceRequest() {}

  explicit ListClusterServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListClusterServiceRequest() = default;
};
class ListClusterServiceResponseBodyClusterServiceListClusterServiceServiceActionListServiceAction : public Darabonba::Model {
public:
  shared_ptr<string> actionName{};
  shared_ptr<string> command{};
  shared_ptr<string> componentName{};
  shared_ptr<string> displayName{};
  shared_ptr<string> serviceName{};

  ListClusterServiceResponseBodyClusterServiceListClusterServiceServiceActionListServiceAction() {}

  explicit ListClusterServiceResponseBodyClusterServiceListClusterServiceServiceActionListServiceAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionName) {
      res["ActionName"] = boost::any(*actionName);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionName") != m.end() && !m["ActionName"].empty()) {
      actionName = make_shared<string>(boost::any_cast<string>(m["ActionName"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~ListClusterServiceResponseBodyClusterServiceListClusterServiceServiceActionListServiceAction() = default;
};
class ListClusterServiceResponseBodyClusterServiceListClusterServiceServiceActionList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterServiceResponseBodyClusterServiceListClusterServiceServiceActionListServiceAction>> serviceAction{};

  ListClusterServiceResponseBodyClusterServiceListClusterServiceServiceActionList() {}

  explicit ListClusterServiceResponseBodyClusterServiceListClusterServiceServiceActionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceAction) {
      vector<boost::any> temp1;
      for(auto item1:*serviceAction){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceAction"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceAction") != m.end() && !m["ServiceAction"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceAction"].type()) {
        vector<ListClusterServiceResponseBodyClusterServiceListClusterServiceServiceActionListServiceAction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceAction"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterServiceResponseBodyClusterServiceListClusterServiceServiceActionListServiceAction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceAction = make_shared<vector<ListClusterServiceResponseBodyClusterServiceListClusterServiceServiceActionListServiceAction>>(expect1);
      }
    }
  }


  virtual ~ListClusterServiceResponseBodyClusterServiceListClusterServiceServiceActionList() = default;
};
class ListClusterServiceResponseBodyClusterServiceListClusterService : public Darabonba::Model {
public:
  shared_ptr<long> abnormalNum{};
  shared_ptr<bool> clientType{};
  shared_ptr<string> healthStatus{};
  shared_ptr<bool> installStatus{};
  shared_ptr<string> needRestartInfo{};
  shared_ptr<long> needRestartNum{};
  shared_ptr<string> notStartInfo{};
  shared_ptr<ListClusterServiceResponseBodyClusterServiceListClusterServiceServiceActionList> serviceActionList{};
  shared_ptr<string> serviceDisplayName{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceStatus{};
  shared_ptr<string> serviceVersion{};
  shared_ptr<string> state{};
  shared_ptr<long> stoppedNum{};

  ListClusterServiceResponseBodyClusterServiceListClusterService() {}

  explicit ListClusterServiceResponseBodyClusterServiceListClusterService(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalNum) {
      res["AbnormalNum"] = boost::any(*abnormalNum);
    }
    if (clientType) {
      res["ClientType"] = boost::any(*clientType);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (installStatus) {
      res["InstallStatus"] = boost::any(*installStatus);
    }
    if (needRestartInfo) {
      res["NeedRestartInfo"] = boost::any(*needRestartInfo);
    }
    if (needRestartNum) {
      res["NeedRestartNum"] = boost::any(*needRestartNum);
    }
    if (notStartInfo) {
      res["NotStartInfo"] = boost::any(*notStartInfo);
    }
    if (serviceActionList) {
      res["ServiceActionList"] = serviceActionList ? boost::any(serviceActionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceDisplayName) {
      res["ServiceDisplayName"] = boost::any(*serviceDisplayName);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (serviceStatus) {
      res["ServiceStatus"] = boost::any(*serviceStatus);
    }
    if (serviceVersion) {
      res["ServiceVersion"] = boost::any(*serviceVersion);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (stoppedNum) {
      res["StoppedNum"] = boost::any(*stoppedNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalNum") != m.end() && !m["AbnormalNum"].empty()) {
      abnormalNum = make_shared<long>(boost::any_cast<long>(m["AbnormalNum"]));
    }
    if (m.find("ClientType") != m.end() && !m["ClientType"].empty()) {
      clientType = make_shared<bool>(boost::any_cast<bool>(m["ClientType"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("InstallStatus") != m.end() && !m["InstallStatus"].empty()) {
      installStatus = make_shared<bool>(boost::any_cast<bool>(m["InstallStatus"]));
    }
    if (m.find("NeedRestartInfo") != m.end() && !m["NeedRestartInfo"].empty()) {
      needRestartInfo = make_shared<string>(boost::any_cast<string>(m["NeedRestartInfo"]));
    }
    if (m.find("NeedRestartNum") != m.end() && !m["NeedRestartNum"].empty()) {
      needRestartNum = make_shared<long>(boost::any_cast<long>(m["NeedRestartNum"]));
    }
    if (m.find("NotStartInfo") != m.end() && !m["NotStartInfo"].empty()) {
      notStartInfo = make_shared<string>(boost::any_cast<string>(m["NotStartInfo"]));
    }
    if (m.find("ServiceActionList") != m.end() && !m["ServiceActionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceActionList"].type()) {
        ListClusterServiceResponseBodyClusterServiceListClusterServiceServiceActionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceActionList"]));
        serviceActionList = make_shared<ListClusterServiceResponseBodyClusterServiceListClusterServiceServiceActionList>(model1);
      }
    }
    if (m.find("ServiceDisplayName") != m.end() && !m["ServiceDisplayName"].empty()) {
      serviceDisplayName = make_shared<string>(boost::any_cast<string>(m["ServiceDisplayName"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServiceStatus") != m.end() && !m["ServiceStatus"].empty()) {
      serviceStatus = make_shared<string>(boost::any_cast<string>(m["ServiceStatus"]));
    }
    if (m.find("ServiceVersion") != m.end() && !m["ServiceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["ServiceVersion"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("StoppedNum") != m.end() && !m["StoppedNum"].empty()) {
      stoppedNum = make_shared<long>(boost::any_cast<long>(m["StoppedNum"]));
    }
  }


  virtual ~ListClusterServiceResponseBodyClusterServiceListClusterService() = default;
};
class ListClusterServiceResponseBodyClusterServiceList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterServiceResponseBodyClusterServiceListClusterService>> clusterService{};

  ListClusterServiceResponseBodyClusterServiceList() {}

  explicit ListClusterServiceResponseBodyClusterServiceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterService) {
      vector<boost::any> temp1;
      for(auto item1:*clusterService){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterService"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterService") != m.end() && !m["ClusterService"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterService"].type()) {
        vector<ListClusterServiceResponseBodyClusterServiceListClusterService> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterService"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterServiceResponseBodyClusterServiceListClusterService model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterService = make_shared<vector<ListClusterServiceResponseBodyClusterServiceListClusterService>>(expect1);
      }
    }
  }


  virtual ~ListClusterServiceResponseBodyClusterServiceList() = default;
};
class ListClusterServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListClusterServiceResponseBodyClusterServiceList> clusterServiceList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListClusterServiceResponseBody() {}

  explicit ListClusterServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterServiceList) {
      res["ClusterServiceList"] = clusterServiceList ? boost::any(clusterServiceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterServiceList") != m.end() && !m["ClusterServiceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterServiceList"].type()) {
        ListClusterServiceResponseBodyClusterServiceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterServiceList"]));
        clusterServiceList = make_shared<ListClusterServiceResponseBodyClusterServiceList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListClusterServiceResponseBody() = default;
};
class ListClusterServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterServiceResponseBody> body{};

  ListClusterServiceResponse() {}

  explicit ListClusterServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterServiceResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterServiceResponse() = default;
};
class ListClusterServiceComponentHealthInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> componentName{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> serviceName{};

  ListClusterServiceComponentHealthInfoRequest() {}

  explicit ListClusterServiceComponentHealthInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~ListClusterServiceComponentHealthInfoRequest() = default;
};
class ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailListHealthDetailHealthRuleParam : public Darabonba::Model {
public:
  shared_ptr<string> component{};
  shared_ptr<string> hostNames{};
  shared_ptr<string> pass{};
  shared_ptr<string> ruleDescription{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleTitle{};
  shared_ptr<string> service{};

  ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailListHealthDetailHealthRuleParam() {}

  explicit ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailListHealthDetailHealthRuleParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (component) {
      res["Component"] = boost::any(*component);
    }
    if (hostNames) {
      res["HostNames"] = boost::any(*hostNames);
    }
    if (pass) {
      res["Pass"] = boost::any(*pass);
    }
    if (ruleDescription) {
      res["RuleDescription"] = boost::any(*ruleDescription);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleTitle) {
      res["RuleTitle"] = boost::any(*ruleTitle);
    }
    if (service) {
      res["Service"] = boost::any(*service);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Component") != m.end() && !m["Component"].empty()) {
      component = make_shared<string>(boost::any_cast<string>(m["Component"]));
    }
    if (m.find("HostNames") != m.end() && !m["HostNames"].empty()) {
      hostNames = make_shared<string>(boost::any_cast<string>(m["HostNames"]));
    }
    if (m.find("Pass") != m.end() && !m["Pass"].empty()) {
      pass = make_shared<string>(boost::any_cast<string>(m["Pass"]));
    }
    if (m.find("RuleDescription") != m.end() && !m["RuleDescription"].empty()) {
      ruleDescription = make_shared<string>(boost::any_cast<string>(m["RuleDescription"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleTitle") != m.end() && !m["RuleTitle"].empty()) {
      ruleTitle = make_shared<string>(boost::any_cast<string>(m["RuleTitle"]));
    }
    if (m.find("Service") != m.end() && !m["Service"].empty()) {
      service = make_shared<string>(boost::any_cast<string>(m["Service"]));
    }
  }


  virtual ~ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailListHealthDetailHealthRuleParam() = default;
};
class ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailListHealthDetail : public Darabonba::Model {
public:
  shared_ptr<ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailListHealthDetailHealthRuleParam> healthRuleParam{};
  shared_ptr<string> code{};

  ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailListHealthDetail() {}

  explicit ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailListHealthDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthRuleParam) {
      res["HealthRuleParam"] = healthRuleParam ? boost::any(healthRuleParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthRuleParam") != m.end() && !m["HealthRuleParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["HealthRuleParam"].type()) {
        ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailListHealthDetailHealthRuleParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HealthRuleParam"]));
        healthRuleParam = make_shared<ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailListHealthDetailHealthRuleParam>(model1);
      }
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
  }


  virtual ~ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailListHealthDetail() = default;
};
class ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailListHealthDetail>> healthDetail{};

  ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailList() {}

  explicit ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthDetail) {
      vector<boost::any> temp1;
      for(auto item1:*healthDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HealthDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthDetail") != m.end() && !m["HealthDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["HealthDetail"].type()) {
        vector<ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailListHealthDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HealthDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailListHealthDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        healthDetail = make_shared<vector<ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailListHealthDetail>>(expect1);
      }
    }
  }


  virtual ~ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailList() = default;
};
class ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfo : public Darabonba::Model {
public:
  shared_ptr<long> agentHeartBeatLostNum{};
  shared_ptr<long> badHealthNum{};
  shared_ptr<string> componentName{};
  shared_ptr<long> createdTime{};
  shared_ptr<long> disabledHealthNum{};
  shared_ptr<long> goodHealthNum{};
  shared_ptr<ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailList> healthDetailList{};
  shared_ptr<string> healthLevel{};
  shared_ptr<string> healthStatus{};
  shared_ptr<long> manualStoppedNum{};
  shared_ptr<long> noneHealthNum{};
  shared_ptr<long> normalNum{};
  shared_ptr<string> serviceName{};
  shared_ptr<long> stoppedHealthNum{};
  shared_ptr<long> stoppedNum{};
  shared_ptr<long> totalNum{};
  shared_ptr<long> unknownHealthNum{};
  shared_ptr<long> warningHealthNum{};

  ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfo() {}

  explicit ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentHeartBeatLostNum) {
      res["AgentHeartBeatLostNum"] = boost::any(*agentHeartBeatLostNum);
    }
    if (badHealthNum) {
      res["BadHealthNum"] = boost::any(*badHealthNum);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (disabledHealthNum) {
      res["DisabledHealthNum"] = boost::any(*disabledHealthNum);
    }
    if (goodHealthNum) {
      res["GoodHealthNum"] = boost::any(*goodHealthNum);
    }
    if (healthDetailList) {
      res["HealthDetailList"] = healthDetailList ? boost::any(healthDetailList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (healthLevel) {
      res["HealthLevel"] = boost::any(*healthLevel);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (manualStoppedNum) {
      res["ManualStoppedNum"] = boost::any(*manualStoppedNum);
    }
    if (noneHealthNum) {
      res["NoneHealthNum"] = boost::any(*noneHealthNum);
    }
    if (normalNum) {
      res["NormalNum"] = boost::any(*normalNum);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (stoppedHealthNum) {
      res["StoppedHealthNum"] = boost::any(*stoppedHealthNum);
    }
    if (stoppedNum) {
      res["StoppedNum"] = boost::any(*stoppedNum);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    if (unknownHealthNum) {
      res["UnknownHealthNum"] = boost::any(*unknownHealthNum);
    }
    if (warningHealthNum) {
      res["WarningHealthNum"] = boost::any(*warningHealthNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentHeartBeatLostNum") != m.end() && !m["AgentHeartBeatLostNum"].empty()) {
      agentHeartBeatLostNum = make_shared<long>(boost::any_cast<long>(m["AgentHeartBeatLostNum"]));
    }
    if (m.find("BadHealthNum") != m.end() && !m["BadHealthNum"].empty()) {
      badHealthNum = make_shared<long>(boost::any_cast<long>(m["BadHealthNum"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("DisabledHealthNum") != m.end() && !m["DisabledHealthNum"].empty()) {
      disabledHealthNum = make_shared<long>(boost::any_cast<long>(m["DisabledHealthNum"]));
    }
    if (m.find("GoodHealthNum") != m.end() && !m["GoodHealthNum"].empty()) {
      goodHealthNum = make_shared<long>(boost::any_cast<long>(m["GoodHealthNum"]));
    }
    if (m.find("HealthDetailList") != m.end() && !m["HealthDetailList"].empty()) {
      if (typeid(map<string, boost::any>) == m["HealthDetailList"].type()) {
        ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HealthDetailList"]));
        healthDetailList = make_shared<ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfoHealthDetailList>(model1);
      }
    }
    if (m.find("HealthLevel") != m.end() && !m["HealthLevel"].empty()) {
      healthLevel = make_shared<string>(boost::any_cast<string>(m["HealthLevel"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("ManualStoppedNum") != m.end() && !m["ManualStoppedNum"].empty()) {
      manualStoppedNum = make_shared<long>(boost::any_cast<long>(m["ManualStoppedNum"]));
    }
    if (m.find("NoneHealthNum") != m.end() && !m["NoneHealthNum"].empty()) {
      noneHealthNum = make_shared<long>(boost::any_cast<long>(m["NoneHealthNum"]));
    }
    if (m.find("NormalNum") != m.end() && !m["NormalNum"].empty()) {
      normalNum = make_shared<long>(boost::any_cast<long>(m["NormalNum"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("StoppedHealthNum") != m.end() && !m["StoppedHealthNum"].empty()) {
      stoppedHealthNum = make_shared<long>(boost::any_cast<long>(m["StoppedHealthNum"]));
    }
    if (m.find("StoppedNum") != m.end() && !m["StoppedNum"].empty()) {
      stoppedNum = make_shared<long>(boost::any_cast<long>(m["StoppedNum"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
    if (m.find("UnknownHealthNum") != m.end() && !m["UnknownHealthNum"].empty()) {
      unknownHealthNum = make_shared<long>(boost::any_cast<long>(m["UnknownHealthNum"]));
    }
    if (m.find("WarningHealthNum") != m.end() && !m["WarningHealthNum"].empty()) {
      warningHealthNum = make_shared<long>(boost::any_cast<long>(m["WarningHealthNum"]));
    }
  }


  virtual ~ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfo() = default;
};
class ListClusterServiceComponentHealthInfoResponseBodyHealthInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfo>> healthInfo{};

  ListClusterServiceComponentHealthInfoResponseBodyHealthInfoList() {}

  explicit ListClusterServiceComponentHealthInfoResponseBodyHealthInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthInfo) {
      vector<boost::any> temp1;
      for(auto item1:*healthInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HealthInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthInfo") != m.end() && !m["HealthInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["HealthInfo"].type()) {
        vector<ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HealthInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        healthInfo = make_shared<vector<ListClusterServiceComponentHealthInfoResponseBodyHealthInfoListHealthInfo>>(expect1);
      }
    }
  }


  virtual ~ListClusterServiceComponentHealthInfoResponseBodyHealthInfoList() = default;
};
class ListClusterServiceComponentHealthInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<ListClusterServiceComponentHealthInfoResponseBodyHealthInfoList> healthInfoList{};
  shared_ptr<string> requestId{};

  ListClusterServiceComponentHealthInfoResponseBody() {}

  explicit ListClusterServiceComponentHealthInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (healthInfoList) {
      res["HealthInfoList"] = healthInfoList ? boost::any(healthInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("HealthInfoList") != m.end() && !m["HealthInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["HealthInfoList"].type()) {
        ListClusterServiceComponentHealthInfoResponseBodyHealthInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HealthInfoList"]));
        healthInfoList = make_shared<ListClusterServiceComponentHealthInfoResponseBodyHealthInfoList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListClusterServiceComponentHealthInfoResponseBody() = default;
};
class ListClusterServiceComponentHealthInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterServiceComponentHealthInfoResponseBody> body{};

  ListClusterServiceComponentHealthInfoResponse() {}

  explicit ListClusterServiceComponentHealthInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterServiceComponentHealthInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterServiceComponentHealthInfoResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterServiceComponentHealthInfoResponse() = default;
};
class ListClusterServiceConfigHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> author{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> comment{};
  shared_ptr<string> configFileName{};
  shared_ptr<string> configItemKey{};
  shared_ptr<string> configVersion{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostInstanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> serviceName{};

  ListClusterServiceConfigHistoryRequest() {}

  explicit ListClusterServiceConfigHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (configFileName) {
      res["ConfigFileName"] = boost::any(*configFileName);
    }
    if (configItemKey) {
      res["ConfigItemKey"] = boost::any(*configItemKey);
    }
    if (configVersion) {
      res["ConfigVersion"] = boost::any(*configVersion);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostInstanceId) {
      res["HostInstanceId"] = boost::any(*hostInstanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ConfigFileName") != m.end() && !m["ConfigFileName"].empty()) {
      configFileName = make_shared<string>(boost::any_cast<string>(m["ConfigFileName"]));
    }
    if (m.find("ConfigItemKey") != m.end() && !m["ConfigItemKey"].empty()) {
      configItemKey = make_shared<string>(boost::any_cast<string>(m["ConfigItemKey"]));
    }
    if (m.find("ConfigVersion") != m.end() && !m["ConfigVersion"].empty()) {
      configVersion = make_shared<string>(boost::any_cast<string>(m["ConfigVersion"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostInstanceId") != m.end() && !m["HostInstanceId"].empty()) {
      hostInstanceId = make_shared<string>(boost::any_cast<string>(m["HostInstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~ListClusterServiceConfigHistoryRequest() = default;
};
class ListClusterServiceConfigHistoryResponseBodyConfigHistoryListConfigHistory : public Darabonba::Model {
public:
  shared_ptr<bool> applied{};
  shared_ptr<string> author{};
  shared_ptr<string> comment{};
  shared_ptr<string> configFileName{};
  shared_ptr<string> configItemName{};
  shared_ptr<string> configVersion{};
  shared_ptr<long> createTime{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<string> hostInstanceId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> newValue{};
  shared_ptr<string> oldValue{};
  shared_ptr<string> serviceName{};

  ListClusterServiceConfigHistoryResponseBodyConfigHistoryListConfigHistory() {}

  explicit ListClusterServiceConfigHistoryResponseBodyConfigHistoryListConfigHistory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applied) {
      res["Applied"] = boost::any(*applied);
    }
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (configFileName) {
      res["ConfigFileName"] = boost::any(*configFileName);
    }
    if (configItemName) {
      res["ConfigItemName"] = boost::any(*configItemName);
    }
    if (configVersion) {
      res["ConfigVersion"] = boost::any(*configVersion);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (hostInstanceId) {
      res["HostInstanceId"] = boost::any(*hostInstanceId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (newValue) {
      res["NewValue"] = boost::any(*newValue);
    }
    if (oldValue) {
      res["OldValue"] = boost::any(*oldValue);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Applied") != m.end() && !m["Applied"].empty()) {
      applied = make_shared<bool>(boost::any_cast<bool>(m["Applied"]));
    }
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ConfigFileName") != m.end() && !m["ConfigFileName"].empty()) {
      configFileName = make_shared<string>(boost::any_cast<string>(m["ConfigFileName"]));
    }
    if (m.find("ConfigItemName") != m.end() && !m["ConfigItemName"].empty()) {
      configItemName = make_shared<string>(boost::any_cast<string>(m["ConfigItemName"]));
    }
    if (m.find("ConfigVersion") != m.end() && !m["ConfigVersion"].empty()) {
      configVersion = make_shared<string>(boost::any_cast<string>(m["ConfigVersion"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("HostInstanceId") != m.end() && !m["HostInstanceId"].empty()) {
      hostInstanceId = make_shared<string>(boost::any_cast<string>(m["HostInstanceId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("NewValue") != m.end() && !m["NewValue"].empty()) {
      newValue = make_shared<string>(boost::any_cast<string>(m["NewValue"]));
    }
    if (m.find("OldValue") != m.end() && !m["OldValue"].empty()) {
      oldValue = make_shared<string>(boost::any_cast<string>(m["OldValue"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~ListClusterServiceConfigHistoryResponseBodyConfigHistoryListConfigHistory() = default;
};
class ListClusterServiceConfigHistoryResponseBodyConfigHistoryList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterServiceConfigHistoryResponseBodyConfigHistoryListConfigHistory>> configHistory{};

  ListClusterServiceConfigHistoryResponseBodyConfigHistoryList() {}

  explicit ListClusterServiceConfigHistoryResponseBodyConfigHistoryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configHistory) {
      vector<boost::any> temp1;
      for(auto item1:*configHistory){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigHistory"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigHistory") != m.end() && !m["ConfigHistory"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigHistory"].type()) {
        vector<ListClusterServiceConfigHistoryResponseBodyConfigHistoryListConfigHistory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigHistory"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterServiceConfigHistoryResponseBodyConfigHistoryListConfigHistory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configHistory = make_shared<vector<ListClusterServiceConfigHistoryResponseBodyConfigHistoryListConfigHistory>>(expect1);
      }
    }
  }


  virtual ~ListClusterServiceConfigHistoryResponseBodyConfigHistoryList() = default;
};
class ListClusterServiceConfigHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListClusterServiceConfigHistoryResponseBodyConfigHistoryList> configHistoryList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListClusterServiceConfigHistoryResponseBody() {}

  explicit ListClusterServiceConfigHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configHistoryList) {
      res["ConfigHistoryList"] = configHistoryList ? boost::any(configHistoryList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigHistoryList") != m.end() && !m["ConfigHistoryList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigHistoryList"].type()) {
        ListClusterServiceConfigHistoryResponseBodyConfigHistoryList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigHistoryList"]));
        configHistoryList = make_shared<ListClusterServiceConfigHistoryResponseBodyConfigHistoryList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListClusterServiceConfigHistoryResponseBody() = default;
};
class ListClusterServiceConfigHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterServiceConfigHistoryResponseBody> body{};

  ListClusterServiceConfigHistoryResponse() {}

  explicit ListClusterServiceConfigHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterServiceConfigHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterServiceConfigHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterServiceConfigHistoryResponse() = default;
};
class ListClusterServiceQuickLinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<bool> directType{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> serviceName{};

  ListClusterServiceQuickLinkRequest() {}

  explicit ListClusterServiceQuickLinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (directType) {
      res["DirectType"] = boost::any(*directType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DirectType") != m.end() && !m["DirectType"].empty()) {
      directType = make_shared<bool>(boost::any_cast<bool>(m["DirectType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~ListClusterServiceQuickLinkRequest() = default;
};
class ListClusterServiceQuickLinkResponseBodyQuickLinkListQuickLink : public Darabonba::Model {
public:
  shared_ptr<string> port{};
  shared_ptr<string> protocol{};
  shared_ptr<string> quickLinkAddress{};
  shared_ptr<string> serviceDisplayName{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> type{};

  ListClusterServiceQuickLinkResponseBodyQuickLinkListQuickLink() {}

  explicit ListClusterServiceQuickLinkResponseBodyQuickLinkListQuickLink(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (quickLinkAddress) {
      res["QuickLinkAddress"] = boost::any(*quickLinkAddress);
    }
    if (serviceDisplayName) {
      res["ServiceDisplayName"] = boost::any(*serviceDisplayName);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("QuickLinkAddress") != m.end() && !m["QuickLinkAddress"].empty()) {
      quickLinkAddress = make_shared<string>(boost::any_cast<string>(m["QuickLinkAddress"]));
    }
    if (m.find("ServiceDisplayName") != m.end() && !m["ServiceDisplayName"].empty()) {
      serviceDisplayName = make_shared<string>(boost::any_cast<string>(m["ServiceDisplayName"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListClusterServiceQuickLinkResponseBodyQuickLinkListQuickLink() = default;
};
class ListClusterServiceQuickLinkResponseBodyQuickLinkList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterServiceQuickLinkResponseBodyQuickLinkListQuickLink>> quickLink{};

  ListClusterServiceQuickLinkResponseBodyQuickLinkList() {}

  explicit ListClusterServiceQuickLinkResponseBodyQuickLinkList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quickLink) {
      vector<boost::any> temp1;
      for(auto item1:*quickLink){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QuickLink"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QuickLink") != m.end() && !m["QuickLink"].empty()) {
      if (typeid(vector<boost::any>) == m["QuickLink"].type()) {
        vector<ListClusterServiceQuickLinkResponseBodyQuickLinkListQuickLink> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QuickLink"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterServiceQuickLinkResponseBodyQuickLinkListQuickLink model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        quickLink = make_shared<vector<ListClusterServiceQuickLinkResponseBodyQuickLinkListQuickLink>>(expect1);
      }
    }
  }


  virtual ~ListClusterServiceQuickLinkResponseBodyQuickLinkList() = default;
};
class ListClusterServiceQuickLinkResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListClusterServiceQuickLinkResponseBodyQuickLinkList> quickLinkList{};
  shared_ptr<string> requestId{};

  ListClusterServiceQuickLinkResponseBody() {}

  explicit ListClusterServiceQuickLinkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quickLinkList) {
      res["QuickLinkList"] = quickLinkList ? boost::any(quickLinkList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QuickLinkList") != m.end() && !m["QuickLinkList"].empty()) {
      if (typeid(map<string, boost::any>) == m["QuickLinkList"].type()) {
        ListClusterServiceQuickLinkResponseBodyQuickLinkList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QuickLinkList"]));
        quickLinkList = make_shared<ListClusterServiceQuickLinkResponseBodyQuickLinkList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListClusterServiceQuickLinkResponseBody() = default;
};
class ListClusterServiceQuickLinkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterServiceQuickLinkResponseBody> body{};

  ListClusterServiceQuickLinkResponse() {}

  explicit ListClusterServiceQuickLinkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterServiceQuickLinkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterServiceQuickLinkResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterServiceQuickLinkResponse() = default;
};
class ListClusterTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};

  ListClusterTemplatesRequest() {}

  explicit ListClusterTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListClusterTemplatesRequest() = default;
};
class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionListBootstrapAction : public Darabonba::Model {
public:
  shared_ptr<string> arg{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};

  ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionListBootstrapAction() {}

  explicit ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionListBootstrapAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arg) {
      res["Arg"] = boost::any(*arg);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arg") != m.end() && !m["Arg"].empty()) {
      arg = make_shared<string>(boost::any_cast<string>(m["Arg"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionListBootstrapAction() = default;
};
class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionListBootstrapAction>> bootstrapAction{};

  ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionList() {}

  explicit ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bootstrapAction) {
      vector<boost::any> temp1;
      for(auto item1:*bootstrapAction){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BootstrapAction"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BootstrapAction") != m.end() && !m["BootstrapAction"].empty()) {
      if (typeid(vector<boost::any>) == m["BootstrapAction"].type()) {
        vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionListBootstrapAction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BootstrapAction"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionListBootstrapAction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bootstrapAction = make_shared<vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionListBootstrapAction>>(expect1);
      }
    }
  }


  virtual ~ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionList() = default;
};
class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigListConfig : public Darabonba::Model {
public:
  shared_ptr<string> configKey{};
  shared_ptr<string> configValue{};
  shared_ptr<string> encrypt{};
  shared_ptr<string> fileName{};
  shared_ptr<string> replace{};
  shared_ptr<string> serviceName{};

  ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigListConfig() {}

  explicit ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigListConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configKey) {
      res["ConfigKey"] = boost::any(*configKey);
    }
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (encrypt) {
      res["Encrypt"] = boost::any(*encrypt);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (replace) {
      res["Replace"] = boost::any(*replace);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigKey") != m.end() && !m["ConfigKey"].empty()) {
      configKey = make_shared<string>(boost::any_cast<string>(m["ConfigKey"]));
    }
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("Encrypt") != m.end() && !m["Encrypt"].empty()) {
      encrypt = make_shared<string>(boost::any_cast<string>(m["Encrypt"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Replace") != m.end() && !m["Replace"].empty()) {
      replace = make_shared<string>(boost::any_cast<string>(m["Replace"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigListConfig() = default;
};
class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigListConfig>> config{};

  ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigList() {}

  explicit ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      vector<boost::any> temp1;
      for(auto item1:*config){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Config"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(vector<boost::any>) == m["Config"].type()) {
        vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigListConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Config"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigListConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        config = make_shared<vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigListConfig>>(expect1);
      }
    }
  }


  virtual ~ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigList() = default;
};
class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupListHostGroup : public Darabonba::Model {
public:
  shared_ptr<string> chargeType{};
  shared_ptr<long> diskCapacity{};
  shared_ptr<long> diskCount{};
  shared_ptr<string> diskType{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<string> hostGroupType{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> multiInstanceTypes{};
  shared_ptr<long> nodeCount{};
  shared_ptr<string> period{};
  shared_ptr<long> sysDiskCapacity{};
  shared_ptr<string> sysDiskType{};

  ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupListHostGroup() {}

  explicit ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupListHostGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (diskCapacity) {
      res["DiskCapacity"] = boost::any(*diskCapacity);
    }
    if (diskCount) {
      res["DiskCount"] = boost::any(*diskCount);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (hostGroupType) {
      res["HostGroupType"] = boost::any(*hostGroupType);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (multiInstanceTypes) {
      res["MultiInstanceTypes"] = boost::any(*multiInstanceTypes);
    }
    if (nodeCount) {
      res["NodeCount"] = boost::any(*nodeCount);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (sysDiskCapacity) {
      res["SysDiskCapacity"] = boost::any(*sysDiskCapacity);
    }
    if (sysDiskType) {
      res["SysDiskType"] = boost::any(*sysDiskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("DiskCapacity") != m.end() && !m["DiskCapacity"].empty()) {
      diskCapacity = make_shared<long>(boost::any_cast<long>(m["DiskCapacity"]));
    }
    if (m.find("DiskCount") != m.end() && !m["DiskCount"].empty()) {
      diskCount = make_shared<long>(boost::any_cast<long>(m["DiskCount"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("HostGroupType") != m.end() && !m["HostGroupType"].empty()) {
      hostGroupType = make_shared<string>(boost::any_cast<string>(m["HostGroupType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("MultiInstanceTypes") != m.end() && !m["MultiInstanceTypes"].empty()) {
      multiInstanceTypes = make_shared<string>(boost::any_cast<string>(m["MultiInstanceTypes"]));
    }
    if (m.find("NodeCount") != m.end() && !m["NodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["NodeCount"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("SysDiskCapacity") != m.end() && !m["SysDiskCapacity"].empty()) {
      sysDiskCapacity = make_shared<long>(boost::any_cast<long>(m["SysDiskCapacity"]));
    }
    if (m.find("SysDiskType") != m.end() && !m["SysDiskType"].empty()) {
      sysDiskType = make_shared<string>(boost::any_cast<string>(m["SysDiskType"]));
    }
  }


  virtual ~ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupListHostGroup() = default;
};
class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupListHostGroup>> hostGroup{};

  ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupList() {}

  explicit ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostGroup) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostGroup") != m.end() && !m["HostGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["HostGroup"].type()) {
        vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupListHostGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupListHostGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroup = make_shared<vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupListHostGroup>>(expect1);
      }
    }
  }


  virtual ~ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupList() = default;
};
class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoSoftwareInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> softwareInfo{};

  ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoSoftwareInfoList() {}

  explicit ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoSoftwareInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (softwareInfo) {
      res["SoftwareInfo"] = boost::any(*softwareInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SoftwareInfo") != m.end() && !m["SoftwareInfo"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SoftwareInfo"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SoftwareInfo"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      softwareInfo = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoSoftwareInfoList() = default;
};
class ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfo : public Darabonba::Model {
public:
  shared_ptr<bool> allowNotebook{};
  shared_ptr<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionList> bootstrapActionList{};
  shared_ptr<string> clusterType{};
  shared_ptr<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigList> configList{};
  shared_ptr<string> configurations{};
  shared_ptr<string> createSource{};
  shared_ptr<string> depositType{};
  shared_ptr<bool> easEnable{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<bool> highAvailabilityEnable{};
  shared_ptr<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupList> hostGroupList{};
  shared_ptr<string> id{};
  shared_ptr<bool> initCustomHiveMetaDb{};
  shared_ptr<string> instanceGeneration{};
  shared_ptr<bool> ioOptimized{};
  shared_ptr<bool> isOpenPublicIp{};
  shared_ptr<string> keyPairName{};
  shared_ptr<bool> logEnable{};
  shared_ptr<string> logPath{};
  shared_ptr<string> machineType{};
  shared_ptr<long> masterNodeTotal{};
  shared_ptr<string> metaStoreConf{};
  shared_ptr<string> metaStoreType{};
  shared_ptr<string> netType{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> securityGroupName{};
  shared_ptr<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoSoftwareInfoList> softwareInfoList{};
  shared_ptr<bool> sshEnable{};
  shared_ptr<string> templateName{};
  shared_ptr<bool> useCustomHiveMetaDb{};
  shared_ptr<bool> useLocalMetaDb{};
  shared_ptr<string> userDefinedEmrEcsRole{};
  shared_ptr<string> userId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};

  ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfo() {}

  explicit ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowNotebook) {
      res["AllowNotebook"] = boost::any(*allowNotebook);
    }
    if (bootstrapActionList) {
      res["BootstrapActionList"] = bootstrapActionList ? boost::any(bootstrapActionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (configList) {
      res["ConfigList"] = configList ? boost::any(configList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (configurations) {
      res["Configurations"] = boost::any(*configurations);
    }
    if (createSource) {
      res["CreateSource"] = boost::any(*createSource);
    }
    if (depositType) {
      res["DepositType"] = boost::any(*depositType);
    }
    if (easEnable) {
      res["EasEnable"] = boost::any(*easEnable);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (highAvailabilityEnable) {
      res["HighAvailabilityEnable"] = boost::any(*highAvailabilityEnable);
    }
    if (hostGroupList) {
      res["HostGroupList"] = hostGroupList ? boost::any(hostGroupList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (initCustomHiveMetaDb) {
      res["InitCustomHiveMetaDb"] = boost::any(*initCustomHiveMetaDb);
    }
    if (instanceGeneration) {
      res["InstanceGeneration"] = boost::any(*instanceGeneration);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (isOpenPublicIp) {
      res["IsOpenPublicIp"] = boost::any(*isOpenPublicIp);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (logEnable) {
      res["LogEnable"] = boost::any(*logEnable);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (machineType) {
      res["MachineType"] = boost::any(*machineType);
    }
    if (masterNodeTotal) {
      res["MasterNodeTotal"] = boost::any(*masterNodeTotal);
    }
    if (metaStoreConf) {
      res["MetaStoreConf"] = boost::any(*metaStoreConf);
    }
    if (metaStoreType) {
      res["MetaStoreType"] = boost::any(*metaStoreType);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    if (softwareInfoList) {
      res["SoftwareInfoList"] = softwareInfoList ? boost::any(softwareInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sshEnable) {
      res["SshEnable"] = boost::any(*sshEnable);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (useCustomHiveMetaDb) {
      res["UseCustomHiveMetaDb"] = boost::any(*useCustomHiveMetaDb);
    }
    if (useLocalMetaDb) {
      res["UseLocalMetaDb"] = boost::any(*useLocalMetaDb);
    }
    if (userDefinedEmrEcsRole) {
      res["UserDefinedEmrEcsRole"] = boost::any(*userDefinedEmrEcsRole);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowNotebook") != m.end() && !m["AllowNotebook"].empty()) {
      allowNotebook = make_shared<bool>(boost::any_cast<bool>(m["AllowNotebook"]));
    }
    if (m.find("BootstrapActionList") != m.end() && !m["BootstrapActionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["BootstrapActionList"].type()) {
        ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BootstrapActionList"]));
        bootstrapActionList = make_shared<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoBootstrapActionList>(model1);
      }
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("ConfigList") != m.end() && !m["ConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigList"].type()) {
        ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigList"]));
        configList = make_shared<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoConfigList>(model1);
      }
    }
    if (m.find("Configurations") != m.end() && !m["Configurations"].empty()) {
      configurations = make_shared<string>(boost::any_cast<string>(m["Configurations"]));
    }
    if (m.find("CreateSource") != m.end() && !m["CreateSource"].empty()) {
      createSource = make_shared<string>(boost::any_cast<string>(m["CreateSource"]));
    }
    if (m.find("DepositType") != m.end() && !m["DepositType"].empty()) {
      depositType = make_shared<string>(boost::any_cast<string>(m["DepositType"]));
    }
    if (m.find("EasEnable") != m.end() && !m["EasEnable"].empty()) {
      easEnable = make_shared<bool>(boost::any_cast<bool>(m["EasEnable"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("HighAvailabilityEnable") != m.end() && !m["HighAvailabilityEnable"].empty()) {
      highAvailabilityEnable = make_shared<bool>(boost::any_cast<bool>(m["HighAvailabilityEnable"]));
    }
    if (m.find("HostGroupList") != m.end() && !m["HostGroupList"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostGroupList"].type()) {
        ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostGroupList"]));
        hostGroupList = make_shared<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoHostGroupList>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InitCustomHiveMetaDb") != m.end() && !m["InitCustomHiveMetaDb"].empty()) {
      initCustomHiveMetaDb = make_shared<bool>(boost::any_cast<bool>(m["InitCustomHiveMetaDb"]));
    }
    if (m.find("InstanceGeneration") != m.end() && !m["InstanceGeneration"].empty()) {
      instanceGeneration = make_shared<string>(boost::any_cast<string>(m["InstanceGeneration"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<bool>(boost::any_cast<bool>(m["IoOptimized"]));
    }
    if (m.find("IsOpenPublicIp") != m.end() && !m["IsOpenPublicIp"].empty()) {
      isOpenPublicIp = make_shared<bool>(boost::any_cast<bool>(m["IsOpenPublicIp"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("LogEnable") != m.end() && !m["LogEnable"].empty()) {
      logEnable = make_shared<bool>(boost::any_cast<bool>(m["LogEnable"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("MachineType") != m.end() && !m["MachineType"].empty()) {
      machineType = make_shared<string>(boost::any_cast<string>(m["MachineType"]));
    }
    if (m.find("MasterNodeTotal") != m.end() && !m["MasterNodeTotal"].empty()) {
      masterNodeTotal = make_shared<long>(boost::any_cast<long>(m["MasterNodeTotal"]));
    }
    if (m.find("MetaStoreConf") != m.end() && !m["MetaStoreConf"].empty()) {
      metaStoreConf = make_shared<string>(boost::any_cast<string>(m["MetaStoreConf"]));
    }
    if (m.find("MetaStoreType") != m.end() && !m["MetaStoreType"].empty()) {
      metaStoreType = make_shared<string>(boost::any_cast<string>(m["MetaStoreType"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
    if (m.find("SoftwareInfoList") != m.end() && !m["SoftwareInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SoftwareInfoList"].type()) {
        ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoSoftwareInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SoftwareInfoList"]));
        softwareInfoList = make_shared<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfoSoftwareInfoList>(model1);
      }
    }
    if (m.find("SshEnable") != m.end() && !m["SshEnable"].empty()) {
      sshEnable = make_shared<bool>(boost::any_cast<bool>(m["SshEnable"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("UseCustomHiveMetaDb") != m.end() && !m["UseCustomHiveMetaDb"].empty()) {
      useCustomHiveMetaDb = make_shared<bool>(boost::any_cast<bool>(m["UseCustomHiveMetaDb"]));
    }
    if (m.find("UseLocalMetaDb") != m.end() && !m["UseLocalMetaDb"].empty()) {
      useLocalMetaDb = make_shared<bool>(boost::any_cast<bool>(m["UseLocalMetaDb"]));
    }
    if (m.find("UserDefinedEmrEcsRole") != m.end() && !m["UserDefinedEmrEcsRole"].empty()) {
      userDefinedEmrEcsRole = make_shared<string>(boost::any_cast<string>(m["UserDefinedEmrEcsRole"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfo() = default;
};
class ListClusterTemplatesResponseBodyTemplateInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfo>> templateInfo{};

  ListClusterTemplatesResponseBodyTemplateInfoList() {}

  explicit ListClusterTemplatesResponseBodyTemplateInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateInfo) {
      vector<boost::any> temp1;
      for(auto item1:*templateInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TemplateInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateInfo") != m.end() && !m["TemplateInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["TemplateInfo"].type()) {
        vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TemplateInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templateInfo = make_shared<vector<ListClusterTemplatesResponseBodyTemplateInfoListTemplateInfo>>(expect1);
      }
    }
  }


  virtual ~ListClusterTemplatesResponseBodyTemplateInfoList() = default;
};
class ListClusterTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<ListClusterTemplatesResponseBodyTemplateInfoList> templateInfoList{};
  shared_ptr<long> totalCount{};

  ListClusterTemplatesResponseBody() {}

  explicit ListClusterTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateInfoList) {
      res["TemplateInfoList"] = templateInfoList ? boost::any(templateInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateInfoList") != m.end() && !m["TemplateInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateInfoList"].type()) {
        ListClusterTemplatesResponseBodyTemplateInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateInfoList"]));
        templateInfoList = make_shared<ListClusterTemplatesResponseBodyTemplateInfoList>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListClusterTemplatesResponseBody() = default;
};
class ListClusterTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterTemplatesResponseBody> body{};

  ListClusterTemplatesResponse() {}

  explicit ListClusterTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterTemplatesResponse() = default;
};
class ListClustersRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListClustersRequestTag() {}

  explicit ListClustersRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListClustersRequestTag() = default;
};
class ListClustersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> clusterTypeList{};
  shared_ptr<string> createType{};
  shared_ptr<bool> defaultStatus{};
  shared_ptr<string> depositType{};
  shared_ptr<vector<string>> expiredTagList{};
  shared_ptr<bool> isDesc{};
  shared_ptr<string> machineType{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<string>> statusList{};
  shared_ptr<vector<ListClustersRequestTag>> tag{};
  shared_ptr<string> vpcId{};

  ListClustersRequest() {}

  explicit ListClustersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterTypeList) {
      res["ClusterTypeList"] = boost::any(*clusterTypeList);
    }
    if (createType) {
      res["CreateType"] = boost::any(*createType);
    }
    if (defaultStatus) {
      res["DefaultStatus"] = boost::any(*defaultStatus);
    }
    if (depositType) {
      res["DepositType"] = boost::any(*depositType);
    }
    if (expiredTagList) {
      res["ExpiredTagList"] = boost::any(*expiredTagList);
    }
    if (isDesc) {
      res["IsDesc"] = boost::any(*isDesc);
    }
    if (machineType) {
      res["MachineType"] = boost::any(*machineType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterTypeList") != m.end() && !m["ClusterTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ClusterTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ClusterTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      clusterTypeList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CreateType") != m.end() && !m["CreateType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["CreateType"]));
    }
    if (m.find("DefaultStatus") != m.end() && !m["DefaultStatus"].empty()) {
      defaultStatus = make_shared<bool>(boost::any_cast<bool>(m["DefaultStatus"]));
    }
    if (m.find("DepositType") != m.end() && !m["DepositType"].empty()) {
      depositType = make_shared<string>(boost::any_cast<string>(m["DepositType"]));
    }
    if (m.find("ExpiredTagList") != m.end() && !m["ExpiredTagList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExpiredTagList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExpiredTagList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      expiredTagList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IsDesc") != m.end() && !m["IsDesc"].empty()) {
      isDesc = make_shared<bool>(boost::any_cast<bool>(m["IsDesc"]));
    }
    if (m.find("MachineType") != m.end() && !m["MachineType"].empty()) {
      machineType = make_shared<string>(boost::any_cast<string>(m["MachineType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statusList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListClustersRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClustersRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListClustersRequestTag>>(expect1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ListClustersRequest() = default;
};
class ListClustersResponseBodyClustersClusterInfoFailReason : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};

  ListClustersResponseBodyClustersClusterInfoFailReason() {}

  explicit ListClustersResponseBodyClustersClusterInfoFailReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListClustersResponseBodyClustersClusterInfoFailReason() = default;
};
class ListClustersResponseBodyClustersClusterInfoOrderTaskInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentCount{};
  shared_ptr<string> orderIdList{};
  shared_ptr<long> targetCount{};

  ListClustersResponseBodyClustersClusterInfoOrderTaskInfo() {}

  explicit ListClustersResponseBodyClustersClusterInfoOrderTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentCount) {
      res["CurrentCount"] = boost::any(*currentCount);
    }
    if (orderIdList) {
      res["OrderIdList"] = boost::any(*orderIdList);
    }
    if (targetCount) {
      res["TargetCount"] = boost::any(*targetCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentCount") != m.end() && !m["CurrentCount"].empty()) {
      currentCount = make_shared<long>(boost::any_cast<long>(m["CurrentCount"]));
    }
    if (m.find("OrderIdList") != m.end() && !m["OrderIdList"].empty()) {
      orderIdList = make_shared<string>(boost::any_cast<string>(m["OrderIdList"]));
    }
    if (m.find("TargetCount") != m.end() && !m["TargetCount"].empty()) {
      targetCount = make_shared<long>(boost::any_cast<long>(m["TargetCount"]));
    }
  }


  virtual ~ListClustersResponseBodyClustersClusterInfoOrderTaskInfo() = default;
};
class ListClustersResponseBodyClustersClusterInfoTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListClustersResponseBodyClustersClusterInfoTagsTag() {}

  explicit ListClustersResponseBodyClustersClusterInfoTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListClustersResponseBodyClustersClusterInfoTagsTag() = default;
};
class ListClustersResponseBodyClustersClusterInfoTags : public Darabonba::Model {
public:
  shared_ptr<vector<ListClustersResponseBodyClustersClusterInfoTagsTag>> tag{};

  ListClustersResponseBodyClustersClusterInfoTags() {}

  explicit ListClustersResponseBodyClustersClusterInfoTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListClustersResponseBodyClustersClusterInfoTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClustersResponseBodyClustersClusterInfoTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListClustersResponseBodyClustersClusterInfoTagsTag>>(expect1);
      }
    }
  }


  virtual ~ListClustersResponseBodyClustersClusterInfoTags() = default;
};
class ListClustersResponseBodyClustersClusterInfo : public Darabonba::Model {
public:
  shared_ptr<string> chargeType{};
  shared_ptr<string> createResource{};
  shared_ptr<long> createTime{};
  shared_ptr<string> depositType{};
  shared_ptr<long> expiredTime{};
  shared_ptr<ListClustersResponseBodyClustersClusterInfoFailReason> failReason{};
  shared_ptr<bool> hasUncompletedOrder{};
  shared_ptr<string> id{};
  shared_ptr<string> k8sClusterId{};
  shared_ptr<string> machineType{};
  shared_ptr<string> metaStoreType{};
  shared_ptr<string> name{};
  shared_ptr<long> operationId{};
  shared_ptr<string> orderList{};
  shared_ptr<ListClustersResponseBodyClustersClusterInfoOrderTaskInfo> orderTaskInfo{};
  shared_ptr<long> period{};
  shared_ptr<long> runningTime{};
  shared_ptr<string> status{};
  shared_ptr<ListClustersResponseBodyClustersClusterInfoTags> tags{};
  shared_ptr<string> type{};

  ListClustersResponseBodyClustersClusterInfo() {}

  explicit ListClustersResponseBodyClustersClusterInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (createResource) {
      res["CreateResource"] = boost::any(*createResource);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (depositType) {
      res["DepositType"] = boost::any(*depositType);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (failReason) {
      res["FailReason"] = failReason ? boost::any(failReason->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hasUncompletedOrder) {
      res["HasUncompletedOrder"] = boost::any(*hasUncompletedOrder);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (k8sClusterId) {
      res["K8sClusterId"] = boost::any(*k8sClusterId);
    }
    if (machineType) {
      res["MachineType"] = boost::any(*machineType);
    }
    if (metaStoreType) {
      res["MetaStoreType"] = boost::any(*metaStoreType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (orderList) {
      res["OrderList"] = boost::any(*orderList);
    }
    if (orderTaskInfo) {
      res["OrderTaskInfo"] = orderTaskInfo ? boost::any(orderTaskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (runningTime) {
      res["RunningTime"] = boost::any(*runningTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("CreateResource") != m.end() && !m["CreateResource"].empty()) {
      createResource = make_shared<string>(boost::any_cast<string>(m["CreateResource"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DepositType") != m.end() && !m["DepositType"].empty()) {
      depositType = make_shared<string>(boost::any_cast<string>(m["DepositType"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("FailReason") != m.end() && !m["FailReason"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailReason"].type()) {
        ListClustersResponseBodyClustersClusterInfoFailReason model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailReason"]));
        failReason = make_shared<ListClustersResponseBodyClustersClusterInfoFailReason>(model1);
      }
    }
    if (m.find("HasUncompletedOrder") != m.end() && !m["HasUncompletedOrder"].empty()) {
      hasUncompletedOrder = make_shared<bool>(boost::any_cast<bool>(m["HasUncompletedOrder"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("K8sClusterId") != m.end() && !m["K8sClusterId"].empty()) {
      k8sClusterId = make_shared<string>(boost::any_cast<string>(m["K8sClusterId"]));
    }
    if (m.find("MachineType") != m.end() && !m["MachineType"].empty()) {
      machineType = make_shared<string>(boost::any_cast<string>(m["MachineType"]));
    }
    if (m.find("MetaStoreType") != m.end() && !m["MetaStoreType"].empty()) {
      metaStoreType = make_shared<string>(boost::any_cast<string>(m["MetaStoreType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<long>(boost::any_cast<long>(m["OperationId"]));
    }
    if (m.find("OrderList") != m.end() && !m["OrderList"].empty()) {
      orderList = make_shared<string>(boost::any_cast<string>(m["OrderList"]));
    }
    if (m.find("OrderTaskInfo") != m.end() && !m["OrderTaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrderTaskInfo"].type()) {
        ListClustersResponseBodyClustersClusterInfoOrderTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrderTaskInfo"]));
        orderTaskInfo = make_shared<ListClustersResponseBodyClustersClusterInfoOrderTaskInfo>(model1);
      }
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("RunningTime") != m.end() && !m["RunningTime"].empty()) {
      runningTime = make_shared<long>(boost::any_cast<long>(m["RunningTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        ListClustersResponseBodyClustersClusterInfoTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<ListClustersResponseBodyClustersClusterInfoTags>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListClustersResponseBodyClustersClusterInfo() = default;
};
class ListClustersResponseBodyClusters : public Darabonba::Model {
public:
  shared_ptr<vector<ListClustersResponseBodyClustersClusterInfo>> clusterInfo{};

  ListClustersResponseBodyClusters() {}

  explicit ListClustersResponseBodyClusters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterInfo) {
      vector<boost::any> temp1;
      for(auto item1:*clusterInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterInfo") != m.end() && !m["ClusterInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterInfo"].type()) {
        vector<ListClustersResponseBodyClustersClusterInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClustersResponseBodyClustersClusterInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterInfo = make_shared<vector<ListClustersResponseBodyClustersClusterInfo>>(expect1);
      }
    }
  }


  virtual ~ListClustersResponseBodyClusters() = default;
};
class ListClustersResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListClustersResponseBodyClusters> clusters{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListClustersResponseBody() {}

  explicit ListClustersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusters) {
      res["Clusters"] = clusters ? boost::any(clusters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clusters") != m.end() && !m["Clusters"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clusters"].type()) {
        ListClustersResponseBodyClusters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clusters"]));
        clusters = make_shared<ListClustersResponseBodyClusters>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListClustersResponseBody() = default;
};
class ListClustersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClustersResponseBody> body{};

  ListClustersResponse() {}

  explicit ListClustersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClustersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClustersResponseBody>(model1);
      }
    }
  }


  virtual ~ListClustersResponse() = default;
};
class ListEmrAvailableConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};

  ListEmrAvailableConfigRequest() {}

  explicit ListEmrAvailableConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListEmrAvailableConfigRequest() = default;
};
class ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoClusterServiceInfoListClusterServiceInfo : public Darabonba::Model {
public:
  shared_ptr<bool> mandatory{};
  shared_ptr<string> serviceDisplayName{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceVersion{};

  ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoClusterServiceInfoListClusterServiceInfo() {}

  explicit ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoClusterServiceInfoListClusterServiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mandatory) {
      res["Mandatory"] = boost::any(*mandatory);
    }
    if (serviceDisplayName) {
      res["ServiceDisplayName"] = boost::any(*serviceDisplayName);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (serviceVersion) {
      res["ServiceVersion"] = boost::any(*serviceVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Mandatory") != m.end() && !m["Mandatory"].empty()) {
      mandatory = make_shared<bool>(boost::any_cast<bool>(m["Mandatory"]));
    }
    if (m.find("ServiceDisplayName") != m.end() && !m["ServiceDisplayName"].empty()) {
      serviceDisplayName = make_shared<string>(boost::any_cast<string>(m["ServiceDisplayName"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServiceVersion") != m.end() && !m["ServiceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["ServiceVersion"]));
    }
  }


  virtual ~ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoClusterServiceInfoListClusterServiceInfo() = default;
};
class ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoClusterServiceInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoClusterServiceInfoListClusterServiceInfo>> clusterServiceInfo{};

  ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoClusterServiceInfoList() {}

  explicit ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoClusterServiceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterServiceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*clusterServiceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterServiceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterServiceInfo") != m.end() && !m["ClusterServiceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterServiceInfo"].type()) {
        vector<ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoClusterServiceInfoListClusterServiceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterServiceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoClusterServiceInfoListClusterServiceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterServiceInfo = make_shared<vector<ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoClusterServiceInfoListClusterServiceInfo>>(expect1);
      }
    }
  }


  virtual ~ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoClusterServiceInfoList() = default;
};
class ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfo : public Darabonba::Model {
public:
  shared_ptr<ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoClusterServiceInfoList> clusterServiceInfoList{};
  shared_ptr<string> clusterType{};

  ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfo() {}

  explicit ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterServiceInfoList) {
      res["ClusterServiceInfoList"] = clusterServiceInfoList ? boost::any(clusterServiceInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterServiceInfoList") != m.end() && !m["ClusterServiceInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterServiceInfoList"].type()) {
        ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoClusterServiceInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterServiceInfoList"]));
        clusterServiceInfoList = make_shared<ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoClusterServiceInfoList>(model1);
      }
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
  }


  virtual ~ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfo() = default;
};
class ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfo>> clusterTypeInfo{};

  ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoList() {}

  explicit ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterTypeInfo) {
      vector<boost::any> temp1;
      for(auto item1:*clusterTypeInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterTypeInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterTypeInfo") != m.end() && !m["ClusterTypeInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterTypeInfo"].type()) {
        vector<ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterTypeInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterTypeInfo = make_shared<vector<ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfo>>(expect1);
      }
    }
  }


  virtual ~ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoList() = default;
};
class ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersion : public Darabonba::Model {
public:
  shared_ptr<ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoList> clusterTypeInfoList{};
  shared_ptr<bool> ecmVersion{};
  shared_ptr<string> extraInfo{};
  shared_ptr<string> mainVersionName{};
  shared_ptr<bool> onCloudNative{};
  shared_ptr<string> publishType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stackName{};
  shared_ptr<string> stackVersion{};

  ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersion() {}

  explicit ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterTypeInfoList) {
      res["ClusterTypeInfoList"] = clusterTypeInfoList ? boost::any(clusterTypeInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ecmVersion) {
      res["EcmVersion"] = boost::any(*ecmVersion);
    }
    if (extraInfo) {
      res["ExtraInfo"] = boost::any(*extraInfo);
    }
    if (mainVersionName) {
      res["MainVersionName"] = boost::any(*mainVersionName);
    }
    if (onCloudNative) {
      res["OnCloudNative"] = boost::any(*onCloudNative);
    }
    if (publishType) {
      res["PublishType"] = boost::any(*publishType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stackName) {
      res["StackName"] = boost::any(*stackName);
    }
    if (stackVersion) {
      res["StackVersion"] = boost::any(*stackVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterTypeInfoList") != m.end() && !m["ClusterTypeInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterTypeInfoList"].type()) {
        ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterTypeInfoList"]));
        clusterTypeInfoList = make_shared<ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoList>(model1);
      }
    }
    if (m.find("EcmVersion") != m.end() && !m["EcmVersion"].empty()) {
      ecmVersion = make_shared<bool>(boost::any_cast<bool>(m["EcmVersion"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      extraInfo = make_shared<string>(boost::any_cast<string>(m["ExtraInfo"]));
    }
    if (m.find("MainVersionName") != m.end() && !m["MainVersionName"].empty()) {
      mainVersionName = make_shared<string>(boost::any_cast<string>(m["MainVersionName"]));
    }
    if (m.find("OnCloudNative") != m.end() && !m["OnCloudNative"].empty()) {
      onCloudNative = make_shared<bool>(boost::any_cast<bool>(m["OnCloudNative"]));
    }
    if (m.find("PublishType") != m.end() && !m["PublishType"].empty()) {
      publishType = make_shared<string>(boost::any_cast<string>(m["PublishType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StackName") != m.end() && !m["StackName"].empty()) {
      stackName = make_shared<string>(boost::any_cast<string>(m["StackName"]));
    }
    if (m.find("StackVersion") != m.end() && !m["StackVersion"].empty()) {
      stackVersion = make_shared<string>(boost::any_cast<string>(m["StackVersion"]));
    }
  }


  virtual ~ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersion() = default;
};
class ListEmrAvailableConfigResponseBodyEmrMainVersionList : public Darabonba::Model {
public:
  shared_ptr<vector<ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersion>> emrMainVersion{};

  ListEmrAvailableConfigResponseBodyEmrMainVersionList() {}

  explicit ListEmrAvailableConfigResponseBodyEmrMainVersionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (emrMainVersion) {
      vector<boost::any> temp1;
      for(auto item1:*emrMainVersion){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EmrMainVersion"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EmrMainVersion") != m.end() && !m["EmrMainVersion"].empty()) {
      if (typeid(vector<boost::any>) == m["EmrMainVersion"].type()) {
        vector<ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EmrMainVersion"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        emrMainVersion = make_shared<vector<ListEmrAvailableConfigResponseBodyEmrMainVersionListEmrMainVersion>>(expect1);
      }
    }
  }


  virtual ~ListEmrAvailableConfigResponseBodyEmrMainVersionList() = default;
};
class ListEmrAvailableConfigResponseBodyKeyPairNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> keyPairName{};

  ListEmrAvailableConfigResponseBodyKeyPairNameList() {}

  explicit ListEmrAvailableConfigResponseBodyKeyPairNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["KeyPairName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["KeyPairName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      keyPairName = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListEmrAvailableConfigResponseBodyKeyPairNameList() = default;
};
class ListEmrAvailableConfigResponseBodySecurityGroupListSecurityGroup : public Darabonba::Model {
public:
  shared_ptr<long> availableInstanceAmount{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<long> ecsCount{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> securityGroupName{};
  shared_ptr<string> securityGroupType{};
  shared_ptr<string> vpcId{};

  ListEmrAvailableConfigResponseBodySecurityGroupListSecurityGroup() {}

  explicit ListEmrAvailableConfigResponseBodySecurityGroupListSecurityGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableInstanceAmount) {
      res["AvailableInstanceAmount"] = boost::any(*availableInstanceAmount);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ecsCount) {
      res["EcsCount"] = boost::any(*ecsCount);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    if (securityGroupType) {
      res["SecurityGroupType"] = boost::any(*securityGroupType);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableInstanceAmount") != m.end() && !m["AvailableInstanceAmount"].empty()) {
      availableInstanceAmount = make_shared<long>(boost::any_cast<long>(m["AvailableInstanceAmount"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EcsCount") != m.end() && !m["EcsCount"].empty()) {
      ecsCount = make_shared<long>(boost::any_cast<long>(m["EcsCount"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
    if (m.find("SecurityGroupType") != m.end() && !m["SecurityGroupType"].empty()) {
      securityGroupType = make_shared<string>(boost::any_cast<string>(m["SecurityGroupType"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ListEmrAvailableConfigResponseBodySecurityGroupListSecurityGroup() = default;
};
class ListEmrAvailableConfigResponseBodySecurityGroupList : public Darabonba::Model {
public:
  shared_ptr<vector<ListEmrAvailableConfigResponseBodySecurityGroupListSecurityGroup>> securityGroup{};

  ListEmrAvailableConfigResponseBodySecurityGroupList() {}

  explicit ListEmrAvailableConfigResponseBodySecurityGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroup) {
      vector<boost::any> temp1;
      for(auto item1:*securityGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroup") != m.end() && !m["SecurityGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityGroup"].type()) {
        vector<ListEmrAvailableConfigResponseBodySecurityGroupListSecurityGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEmrAvailableConfigResponseBodySecurityGroupListSecurityGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityGroup = make_shared<vector<ListEmrAvailableConfigResponseBodySecurityGroupListSecurityGroup>>(expect1);
      }
    }
  }


  virtual ~ListEmrAvailableConfigResponseBodySecurityGroupList() = default;
};
class ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfoVswitchInfoListVswitchInfo : public Darabonba::Model {
public:
  shared_ptr<long> availableIpAddressCount{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vswitchId{};
  shared_ptr<string> vswitchName{};
  shared_ptr<string> zoneId{};

  ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfoVswitchInfoListVswitchInfo() {}

  explicit ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfoVswitchInfoListVswitchInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableIpAddressCount) {
      res["AvailableIpAddressCount"] = boost::any(*availableIpAddressCount);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    if (vswitchName) {
      res["VswitchName"] = boost::any(*vswitchName);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableIpAddressCount") != m.end() && !m["AvailableIpAddressCount"].empty()) {
      availableIpAddressCount = make_shared<long>(boost::any_cast<long>(m["AvailableIpAddressCount"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
    if (m.find("VswitchName") != m.end() && !m["VswitchName"].empty()) {
      vswitchName = make_shared<string>(boost::any_cast<string>(m["VswitchName"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfoVswitchInfoListVswitchInfo() = default;
};
class ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfoVswitchInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfoVswitchInfoListVswitchInfo>> vswitchInfo{};

  ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfoVswitchInfoList() {}

  explicit ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfoVswitchInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vswitchInfo) {
      vector<boost::any> temp1;
      for(auto item1:*vswitchInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VswitchInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VswitchInfo") != m.end() && !m["VswitchInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["VswitchInfo"].type()) {
        vector<ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfoVswitchInfoListVswitchInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VswitchInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfoVswitchInfoListVswitchInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vswitchInfo = make_shared<vector<ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfoVswitchInfoListVswitchInfo>>(expect1);
      }
    }
  }


  virtual ~ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfoVswitchInfoList() = default;
};
class ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfo : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> VRouterId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcName{};
  shared_ptr<ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfoVswitchInfoList> vswitchInfoList{};

  ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfo() {}

  explicit ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (VRouterId) {
      res["VRouterId"] = boost::any(*VRouterId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    if (vswitchInfoList) {
      res["VswitchInfoList"] = vswitchInfoList ? boost::any(vswitchInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("VRouterId") != m.end() && !m["VRouterId"].empty()) {
      VRouterId = make_shared<string>(boost::any_cast<string>(m["VRouterId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
    if (m.find("VswitchInfoList") != m.end() && !m["VswitchInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VswitchInfoList"].type()) {
        ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfoVswitchInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VswitchInfoList"]));
        vswitchInfoList = make_shared<ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfoVswitchInfoList>(model1);
      }
    }
  }


  virtual ~ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfo() = default;
};
class ListEmrAvailableConfigResponseBodyVpcInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfo>> vpcInfo{};

  ListEmrAvailableConfigResponseBodyVpcInfoList() {}

  explicit ListEmrAvailableConfigResponseBodyVpcInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcInfo) {
      vector<boost::any> temp1;
      for(auto item1:*vpcInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VpcInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcInfo") != m.end() && !m["VpcInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["VpcInfo"].type()) {
        vector<ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VpcInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vpcInfo = make_shared<vector<ListEmrAvailableConfigResponseBodyVpcInfoListVpcInfo>>(expect1);
      }
    }
  }


  virtual ~ListEmrAvailableConfigResponseBodyVpcInfoList() = default;
};
class ListEmrAvailableConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListEmrAvailableConfigResponseBodyEmrMainVersionList> emrMainVersionList{};
  shared_ptr<ListEmrAvailableConfigResponseBodyKeyPairNameList> keyPairNameList{};
  shared_ptr<string> requestId{};
  shared_ptr<ListEmrAvailableConfigResponseBodySecurityGroupList> securityGroupList{};
  shared_ptr<ListEmrAvailableConfigResponseBodyVpcInfoList> vpcInfoList{};

  ListEmrAvailableConfigResponseBody() {}

  explicit ListEmrAvailableConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (emrMainVersionList) {
      res["EmrMainVersionList"] = emrMainVersionList ? boost::any(emrMainVersionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (keyPairNameList) {
      res["KeyPairNameList"] = keyPairNameList ? boost::any(keyPairNameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityGroupList) {
      res["SecurityGroupList"] = securityGroupList ? boost::any(securityGroupList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcInfoList) {
      res["VpcInfoList"] = vpcInfoList ? boost::any(vpcInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EmrMainVersionList") != m.end() && !m["EmrMainVersionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmrMainVersionList"].type()) {
        ListEmrAvailableConfigResponseBodyEmrMainVersionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmrMainVersionList"]));
        emrMainVersionList = make_shared<ListEmrAvailableConfigResponseBodyEmrMainVersionList>(model1);
      }
    }
    if (m.find("KeyPairNameList") != m.end() && !m["KeyPairNameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["KeyPairNameList"].type()) {
        ListEmrAvailableConfigResponseBodyKeyPairNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["KeyPairNameList"]));
        keyPairNameList = make_shared<ListEmrAvailableConfigResponseBodyKeyPairNameList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityGroupList") != m.end() && !m["SecurityGroupList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityGroupList"].type()) {
        ListEmrAvailableConfigResponseBodySecurityGroupList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityGroupList"]));
        securityGroupList = make_shared<ListEmrAvailableConfigResponseBodySecurityGroupList>(model1);
      }
    }
    if (m.find("VpcInfoList") != m.end() && !m["VpcInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpcInfoList"].type()) {
        ListEmrAvailableConfigResponseBodyVpcInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpcInfoList"]));
        vpcInfoList = make_shared<ListEmrAvailableConfigResponseBodyVpcInfoList>(model1);
      }
    }
  }


  virtual ~ListEmrAvailableConfigResponseBody() = default;
};
class ListEmrAvailableConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEmrAvailableConfigResponseBody> body{};

  ListEmrAvailableConfigResponse() {}

  explicit ListEmrAvailableConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEmrAvailableConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEmrAvailableConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ListEmrAvailableConfigResponse() = default;
};
class ListEmrAvailableResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> dataDiskType{};
  shared_ptr<string> depositType{};
  shared_ptr<string> destinationResource{};
  shared_ptr<string> emrVersion{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> netType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> spotStrategy{};
  shared_ptr<string> systemDiskType{};
  shared_ptr<string> zoneId{};

  ListEmrAvailableResourceRequest() {}

  explicit ListEmrAvailableResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (dataDiskType) {
      res["DataDiskType"] = boost::any(*dataDiskType);
    }
    if (depositType) {
      res["DepositType"] = boost::any(*depositType);
    }
    if (destinationResource) {
      res["DestinationResource"] = boost::any(*destinationResource);
    }
    if (emrVersion) {
      res["EmrVersion"] = boost::any(*emrVersion);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (spotStrategy) {
      res["SpotStrategy"] = boost::any(*spotStrategy);
    }
    if (systemDiskType) {
      res["SystemDiskType"] = boost::any(*systemDiskType);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("DataDiskType") != m.end() && !m["DataDiskType"].empty()) {
      dataDiskType = make_shared<string>(boost::any_cast<string>(m["DataDiskType"]));
    }
    if (m.find("DepositType") != m.end() && !m["DepositType"].empty()) {
      depositType = make_shared<string>(boost::any_cast<string>(m["DepositType"]));
    }
    if (m.find("DestinationResource") != m.end() && !m["DestinationResource"].empty()) {
      destinationResource = make_shared<string>(boost::any_cast<string>(m["DestinationResource"]));
    }
    if (m.find("EmrVersion") != m.end() && !m["EmrVersion"].empty()) {
      emrVersion = make_shared<string>(boost::any_cast<string>(m["EmrVersion"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SpotStrategy") != m.end() && !m["SpotStrategy"].empty()) {
      spotStrategy = make_shared<string>(boost::any_cast<string>(m["SpotStrategy"]));
    }
    if (m.find("SystemDiskType") != m.end() && !m["SystemDiskType"].empty()) {
      systemDiskType = make_shared<string>(boost::any_cast<string>(m["SystemDiskType"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~ListEmrAvailableResourceRequest() = default;
};
class ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResourceEmrInstanceType : public Darabonba::Model {
public:
  shared_ptr<long> baselineCredit{};
  shared_ptr<long> cpuCoreCount{};
  shared_ptr<long> eniQuantity{};
  shared_ptr<long> GPUAmount{};
  shared_ptr<string> GPUSpec{};
  shared_ptr<long> initialCredit{};
  shared_ptr<long> instanceBandwidthRx{};
  shared_ptr<long> instanceBandwidthTx{};
  shared_ptr<long> instancePpsRx{};
  shared_ptr<long> instancePpsTx{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<long> localStorageAmount{};
  shared_ptr<long> localStorageCapacity{};
  shared_ptr<string> localStorageCategory{};
  shared_ptr<long> memorySize{};

  ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResourceEmrInstanceType() {}

  explicit ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResourceEmrInstanceType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineCredit) {
      res["BaselineCredit"] = boost::any(*baselineCredit);
    }
    if (cpuCoreCount) {
      res["CpuCoreCount"] = boost::any(*cpuCoreCount);
    }
    if (eniQuantity) {
      res["EniQuantity"] = boost::any(*eniQuantity);
    }
    if (GPUAmount) {
      res["GPUAmount"] = boost::any(*GPUAmount);
    }
    if (GPUSpec) {
      res["GPUSpec"] = boost::any(*GPUSpec);
    }
    if (initialCredit) {
      res["InitialCredit"] = boost::any(*initialCredit);
    }
    if (instanceBandwidthRx) {
      res["InstanceBandwidthRx"] = boost::any(*instanceBandwidthRx);
    }
    if (instanceBandwidthTx) {
      res["InstanceBandwidthTx"] = boost::any(*instanceBandwidthTx);
    }
    if (instancePpsRx) {
      res["InstancePpsRx"] = boost::any(*instancePpsRx);
    }
    if (instancePpsTx) {
      res["InstancePpsTx"] = boost::any(*instancePpsTx);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (localStorageAmount) {
      res["LocalStorageAmount"] = boost::any(*localStorageAmount);
    }
    if (localStorageCapacity) {
      res["LocalStorageCapacity"] = boost::any(*localStorageCapacity);
    }
    if (localStorageCategory) {
      res["LocalStorageCategory"] = boost::any(*localStorageCategory);
    }
    if (memorySize) {
      res["MemorySize"] = boost::any(*memorySize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineCredit") != m.end() && !m["BaselineCredit"].empty()) {
      baselineCredit = make_shared<long>(boost::any_cast<long>(m["BaselineCredit"]));
    }
    if (m.find("CpuCoreCount") != m.end() && !m["CpuCoreCount"].empty()) {
      cpuCoreCount = make_shared<long>(boost::any_cast<long>(m["CpuCoreCount"]));
    }
    if (m.find("EniQuantity") != m.end() && !m["EniQuantity"].empty()) {
      eniQuantity = make_shared<long>(boost::any_cast<long>(m["EniQuantity"]));
    }
    if (m.find("GPUAmount") != m.end() && !m["GPUAmount"].empty()) {
      GPUAmount = make_shared<long>(boost::any_cast<long>(m["GPUAmount"]));
    }
    if (m.find("GPUSpec") != m.end() && !m["GPUSpec"].empty()) {
      GPUSpec = make_shared<string>(boost::any_cast<string>(m["GPUSpec"]));
    }
    if (m.find("InitialCredit") != m.end() && !m["InitialCredit"].empty()) {
      initialCredit = make_shared<long>(boost::any_cast<long>(m["InitialCredit"]));
    }
    if (m.find("InstanceBandwidthRx") != m.end() && !m["InstanceBandwidthRx"].empty()) {
      instanceBandwidthRx = make_shared<long>(boost::any_cast<long>(m["InstanceBandwidthRx"]));
    }
    if (m.find("InstanceBandwidthTx") != m.end() && !m["InstanceBandwidthTx"].empty()) {
      instanceBandwidthTx = make_shared<long>(boost::any_cast<long>(m["InstanceBandwidthTx"]));
    }
    if (m.find("InstancePpsRx") != m.end() && !m["InstancePpsRx"].empty()) {
      instancePpsRx = make_shared<long>(boost::any_cast<long>(m["InstancePpsRx"]));
    }
    if (m.find("InstancePpsTx") != m.end() && !m["InstancePpsTx"].empty()) {
      instancePpsTx = make_shared<long>(boost::any_cast<long>(m["InstancePpsTx"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamily"]));
    }
    if (m.find("LocalStorageAmount") != m.end() && !m["LocalStorageAmount"].empty()) {
      localStorageAmount = make_shared<long>(boost::any_cast<long>(m["LocalStorageAmount"]));
    }
    if (m.find("LocalStorageCapacity") != m.end() && !m["LocalStorageCapacity"].empty()) {
      localStorageCapacity = make_shared<long>(boost::any_cast<long>(m["LocalStorageCapacity"]));
    }
    if (m.find("LocalStorageCategory") != m.end() && !m["LocalStorageCategory"].empty()) {
      localStorageCategory = make_shared<string>(boost::any_cast<string>(m["LocalStorageCategory"]));
    }
    if (m.find("MemorySize") != m.end() && !m["MemorySize"].empty()) {
      memorySize = make_shared<long>(boost::any_cast<long>(m["MemorySize"]));
    }
  }


  virtual ~ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResourceEmrInstanceType() = default;
};
class ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResourceSupportNodeTypeList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> supportNodeType{};

  ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResourceSupportNodeTypeList() {}

  explicit ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResourceSupportNodeTypeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportNodeType) {
      res["SupportNodeType"] = boost::any(*supportNodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportNodeType") != m.end() && !m["SupportNodeType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportNodeType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportNodeType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportNodeType = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResourceSupportNodeTypeList() = default;
};
class ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResource : public Darabonba::Model {
public:
  shared_ptr<ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResourceEmrInstanceType> emrInstanceType{};
  shared_ptr<long> max{};
  shared_ptr<long> min{};
  shared_ptr<ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResourceSupportNodeTypeList> supportNodeTypeList{};
  shared_ptr<string> unit{};
  shared_ptr<string> value{};

  ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResource() {}

  explicit ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (emrInstanceType) {
      res["EmrInstanceType"] = emrInstanceType ? boost::any(emrInstanceType->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    if (supportNodeTypeList) {
      res["SupportNodeTypeList"] = supportNodeTypeList ? boost::any(supportNodeTypeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EmrInstanceType") != m.end() && !m["EmrInstanceType"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmrInstanceType"].type()) {
        ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResourceEmrInstanceType model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmrInstanceType"]));
        emrInstanceType = make_shared<ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResourceEmrInstanceType>(model1);
      }
    }
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<long>(boost::any_cast<long>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<long>(boost::any_cast<long>(m["Min"]));
    }
    if (m.find("SupportNodeTypeList") != m.end() && !m["SupportNodeTypeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportNodeTypeList"].type()) {
        ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResourceSupportNodeTypeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportNodeTypeList"]));
        supportNodeTypeList = make_shared<ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResourceSupportNodeTypeList>(model1);
      }
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResource() = default;
};
class ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceList : public Darabonba::Model {
public:
  shared_ptr<vector<ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResource>> supportedResource{};

  ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceList() {}

  explicit ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportedResource) {
      vector<boost::any> temp1;
      for(auto item1:*supportedResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SupportedResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportedResource") != m.end() && !m["SupportedResource"].empty()) {
      if (typeid(vector<boost::any>) == m["SupportedResource"].type()) {
        vector<ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SupportedResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportedResource = make_shared<vector<ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceListSupportedResource>>(expect1);
      }
    }
  }


  virtual ~ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceList() = default;
};
class ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfo : public Darabonba::Model {
public:
  shared_ptr<ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceList> supportedResourceList{};
  shared_ptr<string> type{};

  ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfo() {}

  explicit ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportedResourceList) {
      res["SupportedResourceList"] = supportedResourceList ? boost::any(supportedResourceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportedResourceList") != m.end() && !m["SupportedResourceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SupportedResourceList"].type()) {
        ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SupportedResourceList"]));
        supportedResourceList = make_shared<ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfoSupportedResourceList>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfo() = default;
};
class ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfo>> emrResourceInfo{};

  ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoList() {}

  explicit ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (emrResourceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*emrResourceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EmrResourceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EmrResourceInfo") != m.end() && !m["EmrResourceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["EmrResourceInfo"].type()) {
        vector<ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EmrResourceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        emrResourceInfo = make_shared<vector<ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoListEmrResourceInfo>>(expect1);
      }
    }
  }


  virtual ~ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoList() = default;
};
class ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfo : public Darabonba::Model {
public:
  shared_ptr<ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoList> emrResourceInfoList{};
  shared_ptr<string> zoneId{};

  ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfo() {}

  explicit ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (emrResourceInfoList) {
      res["EmrResourceInfoList"] = emrResourceInfoList ? boost::any(emrResourceInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EmrResourceInfoList") != m.end() && !m["EmrResourceInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmrResourceInfoList"].type()) {
        ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmrResourceInfoList"]));
        emrResourceInfoList = make_shared<ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfoEmrResourceInfoList>(model1);
      }
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfo() = default;
};
class ListEmrAvailableResourceResponseBodyEmrZoneInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfo>> emrZoneInfo{};

  ListEmrAvailableResourceResponseBodyEmrZoneInfoList() {}

  explicit ListEmrAvailableResourceResponseBodyEmrZoneInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (emrZoneInfo) {
      vector<boost::any> temp1;
      for(auto item1:*emrZoneInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EmrZoneInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EmrZoneInfo") != m.end() && !m["EmrZoneInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["EmrZoneInfo"].type()) {
        vector<ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EmrZoneInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        emrZoneInfo = make_shared<vector<ListEmrAvailableResourceResponseBodyEmrZoneInfoListEmrZoneInfo>>(expect1);
      }
    }
  }


  virtual ~ListEmrAvailableResourceResponseBodyEmrZoneInfoList() = default;
};
class ListEmrAvailableResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListEmrAvailableResourceResponseBodyEmrZoneInfoList> emrZoneInfoList{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};

  ListEmrAvailableResourceResponseBody() {}

  explicit ListEmrAvailableResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (emrZoneInfoList) {
      res["EmrZoneInfoList"] = emrZoneInfoList ? boost::any(emrZoneInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EmrZoneInfoList") != m.end() && !m["EmrZoneInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmrZoneInfoList"].type()) {
        ListEmrAvailableResourceResponseBodyEmrZoneInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmrZoneInfoList"]));
        emrZoneInfoList = make_shared<ListEmrAvailableResourceResponseBodyEmrZoneInfoList>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListEmrAvailableResourceResponseBody() = default;
};
class ListEmrAvailableResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEmrAvailableResourceResponseBody> body{};

  ListEmrAvailableResourceResponse() {}

  explicit ListEmrAvailableResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEmrAvailableResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEmrAvailableResourceResponseBody>(model1);
      }
    }
  }


  virtual ~ListEmrAvailableResourceResponse() = default;
};
class ListEmrMainVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> emrVersion{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> stackName{};
  shared_ptr<string> stackVersion{};

  ListEmrMainVersionRequest() {}

  explicit ListEmrMainVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (emrVersion) {
      res["EmrVersion"] = boost::any(*emrVersion);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (stackName) {
      res["StackName"] = boost::any(*stackName);
    }
    if (stackVersion) {
      res["StackVersion"] = boost::any(*stackVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EmrVersion") != m.end() && !m["EmrVersion"].empty()) {
      emrVersion = make_shared<string>(boost::any_cast<string>(m["EmrVersion"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StackName") != m.end() && !m["StackName"].empty()) {
      stackName = make_shared<string>(boost::any_cast<string>(m["StackName"]));
    }
    if (m.find("StackVersion") != m.end() && !m["StackVersion"].empty()) {
      stackVersion = make_shared<string>(boost::any_cast<string>(m["StackVersion"]));
    }
  }


  virtual ~ListEmrMainVersionRequest() = default;
};
class ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoListServiceInfo : public Darabonba::Model {
public:
  shared_ptr<bool> display{};
  shared_ptr<bool> mandatory{};
  shared_ptr<string> serviceDisplayName{};
  shared_ptr<string> serviceDisplayVersion{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceVersion{};

  ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoListServiceInfo() {}

  explicit ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoListServiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (display) {
      res["Display"] = boost::any(*display);
    }
    if (mandatory) {
      res["Mandatory"] = boost::any(*mandatory);
    }
    if (serviceDisplayName) {
      res["ServiceDisplayName"] = boost::any(*serviceDisplayName);
    }
    if (serviceDisplayVersion) {
      res["ServiceDisplayVersion"] = boost::any(*serviceDisplayVersion);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (serviceVersion) {
      res["ServiceVersion"] = boost::any(*serviceVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Display") != m.end() && !m["Display"].empty()) {
      display = make_shared<bool>(boost::any_cast<bool>(m["Display"]));
    }
    if (m.find("Mandatory") != m.end() && !m["Mandatory"].empty()) {
      mandatory = make_shared<bool>(boost::any_cast<bool>(m["Mandatory"]));
    }
    if (m.find("ServiceDisplayName") != m.end() && !m["ServiceDisplayName"].empty()) {
      serviceDisplayName = make_shared<string>(boost::any_cast<string>(m["ServiceDisplayName"]));
    }
    if (m.find("ServiceDisplayVersion") != m.end() && !m["ServiceDisplayVersion"].empty()) {
      serviceDisplayVersion = make_shared<string>(boost::any_cast<string>(m["ServiceDisplayVersion"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServiceVersion") != m.end() && !m["ServiceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["ServiceVersion"]));
    }
  }


  virtual ~ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoListServiceInfo() = default;
};
class ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoListServiceInfo>> serviceInfo{};

  ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoList() {}

  explicit ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceInfo) {
      vector<boost::any> temp1;
      for(auto item1:*serviceInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceInfo") != m.end() && !m["ServiceInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceInfo"].type()) {
        vector<ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoListServiceInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoListServiceInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceInfo = make_shared<vector<ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoListServiceInfo>>(expect1);
      }
    }
  }


  virtual ~ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoList() = default;
};
class ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfo : public Darabonba::Model {
public:
  shared_ptr<string> clusterType{};
  shared_ptr<ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoList> serviceInfoList{};

  ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfo() {}

  explicit ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (serviceInfoList) {
      res["ServiceInfoList"] = serviceInfoList ? boost::any(serviceInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("ServiceInfoList") != m.end() && !m["ServiceInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceInfoList"].type()) {
        ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceInfoList"]));
        serviceInfoList = make_shared<ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfoServiceInfoList>(model1);
      }
    }
  }


  virtual ~ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfo() = default;
};
class ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfo>> clusterTypeInfo{};

  ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoList() {}

  explicit ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterTypeInfo) {
      vector<boost::any> temp1;
      for(auto item1:*clusterTypeInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterTypeInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterTypeInfo") != m.end() && !m["ClusterTypeInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterTypeInfo"].type()) {
        vector<ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterTypeInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterTypeInfo = make_shared<vector<ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoListClusterTypeInfo>>(expect1);
      }
    }
  }


  virtual ~ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoList() = default;
};
class ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeWhiteUserListClusterTypeWhiteUser : public Darabonba::Model {
public:
  shared_ptr<string> clusterType{};
  shared_ptr<string> userId{};

  ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeWhiteUserListClusterTypeWhiteUser() {}

  explicit ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeWhiteUserListClusterTypeWhiteUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeWhiteUserListClusterTypeWhiteUser() = default;
};
class ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeWhiteUserList : public Darabonba::Model {
public:
  shared_ptr<vector<ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeWhiteUserListClusterTypeWhiteUser>> clusterTypeWhiteUser{};

  ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeWhiteUserList() {}

  explicit ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeWhiteUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterTypeWhiteUser) {
      vector<boost::any> temp1;
      for(auto item1:*clusterTypeWhiteUser){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterTypeWhiteUser"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterTypeWhiteUser") != m.end() && !m["ClusterTypeWhiteUser"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterTypeWhiteUser"].type()) {
        vector<ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeWhiteUserListClusterTypeWhiteUser> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterTypeWhiteUser"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeWhiteUserListClusterTypeWhiteUser model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterTypeWhiteUser = make_shared<vector<ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeWhiteUserListClusterTypeWhiteUser>>(expect1);
      }
    }
  }


  virtual ~ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeWhiteUserList() = default;
};
class ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionWhiteUserList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> whiteUser{};

  ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionWhiteUserList() {}

  explicit ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionWhiteUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (whiteUser) {
      res["WhiteUser"] = boost::any(*whiteUser);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WhiteUser") != m.end() && !m["WhiteUser"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WhiteUser"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WhiteUser"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      whiteUser = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionWhiteUserList() = default;
};
class ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersion : public Darabonba::Model {
public:
  shared_ptr<ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoList> clusterTypeInfoList{};
  shared_ptr<ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeWhiteUserList> clusterTypeWhiteUserList{};
  shared_ptr<bool> display{};
  shared_ptr<bool> ecmVersion{};
  shared_ptr<string> emrVersion{};
  shared_ptr<string> imageId{};
  shared_ptr<string> publishType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stackName{};
  shared_ptr<string> stackVersion{};
  shared_ptr<ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionWhiteUserList> whiteUserList{};

  ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersion() {}

  explicit ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterTypeInfoList) {
      res["ClusterTypeInfoList"] = clusterTypeInfoList ? boost::any(clusterTypeInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clusterTypeWhiteUserList) {
      res["ClusterTypeWhiteUserList"] = clusterTypeWhiteUserList ? boost::any(clusterTypeWhiteUserList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (display) {
      res["Display"] = boost::any(*display);
    }
    if (ecmVersion) {
      res["EcmVersion"] = boost::any(*ecmVersion);
    }
    if (emrVersion) {
      res["EmrVersion"] = boost::any(*emrVersion);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (publishType) {
      res["PublishType"] = boost::any(*publishType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stackName) {
      res["StackName"] = boost::any(*stackName);
    }
    if (stackVersion) {
      res["StackVersion"] = boost::any(*stackVersion);
    }
    if (whiteUserList) {
      res["WhiteUserList"] = whiteUserList ? boost::any(whiteUserList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterTypeInfoList") != m.end() && !m["ClusterTypeInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterTypeInfoList"].type()) {
        ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterTypeInfoList"]));
        clusterTypeInfoList = make_shared<ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeInfoList>(model1);
      }
    }
    if (m.find("ClusterTypeWhiteUserList") != m.end() && !m["ClusterTypeWhiteUserList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterTypeWhiteUserList"].type()) {
        ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeWhiteUserList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterTypeWhiteUserList"]));
        clusterTypeWhiteUserList = make_shared<ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionClusterTypeWhiteUserList>(model1);
      }
    }
    if (m.find("Display") != m.end() && !m["Display"].empty()) {
      display = make_shared<bool>(boost::any_cast<bool>(m["Display"]));
    }
    if (m.find("EcmVersion") != m.end() && !m["EcmVersion"].empty()) {
      ecmVersion = make_shared<bool>(boost::any_cast<bool>(m["EcmVersion"]));
    }
    if (m.find("EmrVersion") != m.end() && !m["EmrVersion"].empty()) {
      emrVersion = make_shared<string>(boost::any_cast<string>(m["EmrVersion"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("PublishType") != m.end() && !m["PublishType"].empty()) {
      publishType = make_shared<string>(boost::any_cast<string>(m["PublishType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StackName") != m.end() && !m["StackName"].empty()) {
      stackName = make_shared<string>(boost::any_cast<string>(m["StackName"]));
    }
    if (m.find("StackVersion") != m.end() && !m["StackVersion"].empty()) {
      stackVersion = make_shared<string>(boost::any_cast<string>(m["StackVersion"]));
    }
    if (m.find("WhiteUserList") != m.end() && !m["WhiteUserList"].empty()) {
      if (typeid(map<string, boost::any>) == m["WhiteUserList"].type()) {
        ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionWhiteUserList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WhiteUserList"]));
        whiteUserList = make_shared<ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersionWhiteUserList>(model1);
      }
    }
  }


  virtual ~ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersion() = default;
};
class ListEmrMainVersionResponseBodyEmrMainVersionList : public Darabonba::Model {
public:
  shared_ptr<vector<ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersion>> emrMainVersion{};

  ListEmrMainVersionResponseBodyEmrMainVersionList() {}

  explicit ListEmrMainVersionResponseBodyEmrMainVersionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (emrMainVersion) {
      vector<boost::any> temp1;
      for(auto item1:*emrMainVersion){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EmrMainVersion"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EmrMainVersion") != m.end() && !m["EmrMainVersion"].empty()) {
      if (typeid(vector<boost::any>) == m["EmrMainVersion"].type()) {
        vector<ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EmrMainVersion"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        emrMainVersion = make_shared<vector<ListEmrMainVersionResponseBodyEmrMainVersionListEmrMainVersion>>(expect1);
      }
    }
  }


  virtual ~ListEmrMainVersionResponseBodyEmrMainVersionList() = default;
};
class ListEmrMainVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListEmrMainVersionResponseBodyEmrMainVersionList> emrMainVersionList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListEmrMainVersionResponseBody() {}

  explicit ListEmrMainVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (emrMainVersionList) {
      res["EmrMainVersionList"] = emrMainVersionList ? boost::any(emrMainVersionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EmrMainVersionList") != m.end() && !m["EmrMainVersionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EmrMainVersionList"].type()) {
        ListEmrMainVersionResponseBodyEmrMainVersionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EmrMainVersionList"]));
        emrMainVersionList = make_shared<ListEmrMainVersionResponseBodyEmrMainVersionList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListEmrMainVersionResponseBody() = default;
};
class ListEmrMainVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEmrMainVersionResponseBody> body{};

  ListEmrMainVersionResponse() {}

  explicit ListEmrMainVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEmrMainVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEmrMainVersionResponseBody>(model1);
      }
    }
  }


  virtual ~ListEmrMainVersionResponse() = default;
};
class ListFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> id{};
  shared_ptr<string> jobId{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> periodic{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};

  ListFlowRequest() {}

  explicit ListFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (periodic) {
      res["Periodic"] = boost::any(*periodic);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Periodic") != m.end() && !m["Periodic"].empty()) {
      periodic = make_shared<bool>(boost::any_cast<bool>(m["Periodic"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListFlowRequest() = default;
};
class ListFlowResponseBodyFlowFlow : public Darabonba::Model {
public:
  shared_ptr<string> alertConf{};
  shared_ptr<string> alertDingDingGroupBizId{};
  shared_ptr<string> alertUserGroupBizId{};
  shared_ptr<string> categoryId{};
  shared_ptr<string> clusterId{};
  shared_ptr<bool> createCluster{};
  shared_ptr<string> cronExpr{};
  shared_ptr<string> description{};
  shared_ptr<long> endSchedule{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> graph{};
  shared_ptr<string> hostName{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<bool> periodic{};
  shared_ptr<string> projectId{};
  shared_ptr<long> startSchedule{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  ListFlowResponseBodyFlowFlow() {}

  explicit ListFlowResponseBodyFlowFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertConf) {
      res["AlertConf"] = boost::any(*alertConf);
    }
    if (alertDingDingGroupBizId) {
      res["AlertDingDingGroupBizId"] = boost::any(*alertDingDingGroupBizId);
    }
    if (alertUserGroupBizId) {
      res["AlertUserGroupBizId"] = boost::any(*alertUserGroupBizId);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (createCluster) {
      res["CreateCluster"] = boost::any(*createCluster);
    }
    if (cronExpr) {
      res["CronExpr"] = boost::any(*cronExpr);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endSchedule) {
      res["EndSchedule"] = boost::any(*endSchedule);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (graph) {
      res["Graph"] = boost::any(*graph);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (periodic) {
      res["Periodic"] = boost::any(*periodic);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (startSchedule) {
      res["StartSchedule"] = boost::any(*startSchedule);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertConf") != m.end() && !m["AlertConf"].empty()) {
      alertConf = make_shared<string>(boost::any_cast<string>(m["AlertConf"]));
    }
    if (m.find("AlertDingDingGroupBizId") != m.end() && !m["AlertDingDingGroupBizId"].empty()) {
      alertDingDingGroupBizId = make_shared<string>(boost::any_cast<string>(m["AlertDingDingGroupBizId"]));
    }
    if (m.find("AlertUserGroupBizId") != m.end() && !m["AlertUserGroupBizId"].empty()) {
      alertUserGroupBizId = make_shared<string>(boost::any_cast<string>(m["AlertUserGroupBizId"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CreateCluster") != m.end() && !m["CreateCluster"].empty()) {
      createCluster = make_shared<bool>(boost::any_cast<bool>(m["CreateCluster"]));
    }
    if (m.find("CronExpr") != m.end() && !m["CronExpr"].empty()) {
      cronExpr = make_shared<string>(boost::any_cast<string>(m["CronExpr"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndSchedule") != m.end() && !m["EndSchedule"].empty()) {
      endSchedule = make_shared<long>(boost::any_cast<long>(m["EndSchedule"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Graph") != m.end() && !m["Graph"].empty()) {
      graph = make_shared<string>(boost::any_cast<string>(m["Graph"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Periodic") != m.end() && !m["Periodic"].empty()) {
      periodic = make_shared<bool>(boost::any_cast<bool>(m["Periodic"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("StartSchedule") != m.end() && !m["StartSchedule"].empty()) {
      startSchedule = make_shared<long>(boost::any_cast<long>(m["StartSchedule"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListFlowResponseBodyFlowFlow() = default;
};
class ListFlowResponseBodyFlow : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowResponseBodyFlowFlow>> flow{};

  ListFlowResponseBodyFlow() {}

  explicit ListFlowResponseBodyFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      vector<boost::any> temp1;
      for(auto item1:*flow){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Flow"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      if (typeid(vector<boost::any>) == m["Flow"].type()) {
        vector<ListFlowResponseBodyFlowFlow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Flow"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowResponseBodyFlowFlow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flow = make_shared<vector<ListFlowResponseBodyFlowFlow>>(expect1);
      }
    }
  }


  virtual ~ListFlowResponseBodyFlow() = default;
};
class ListFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListFlowResponseBodyFlow> flow{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  ListFlowResponseBody() {}

  explicit ListFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = flow ? boost::any(flow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      if (typeid(map<string, boost::any>) == m["Flow"].type()) {
        ListFlowResponseBodyFlow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Flow"]));
        flow = make_shared<ListFlowResponseBodyFlow>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListFlowResponseBody() = default;
};
class ListFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFlowResponseBody> body{};

  ListFlowResponse() {}

  explicit ListFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowResponse() = default;
};
class ListFlowCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> parentId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> root{};

  ListFlowCategoryRequest() {}

  explicit ListFlowCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (root) {
      res["Root"] = boost::any(*root);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Root") != m.end() && !m["Root"].empty()) {
      root = make_shared<bool>(boost::any_cast<bool>(m["Root"]));
    }
  }


  virtual ~ListFlowCategoryRequest() = default;
};
class ListFlowCategoryResponseBodyCategoriesCategory : public Darabonba::Model {
public:
  shared_ptr<string> categoryType{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> objectId{};
  shared_ptr<string> objectType{};
  shared_ptr<string> parentId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> type{};

  ListFlowCategoryResponseBodyCategoriesCategory() {}

  explicit ListFlowCategoryResponseBodyCategoriesCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryType) {
      res["CategoryType"] = boost::any(*categoryType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryType") != m.end() && !m["CategoryType"].empty()) {
      categoryType = make_shared<string>(boost::any_cast<string>(m["CategoryType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListFlowCategoryResponseBodyCategoriesCategory() = default;
};
class ListFlowCategoryResponseBodyCategories : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowCategoryResponseBodyCategoriesCategory>> category{};

  ListFlowCategoryResponseBodyCategories() {}

  explicit ListFlowCategoryResponseBodyCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      vector<boost::any> temp1;
      for(auto item1:*category){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Category"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      if (typeid(vector<boost::any>) == m["Category"].type()) {
        vector<ListFlowCategoryResponseBodyCategoriesCategory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Category"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowCategoryResponseBodyCategoriesCategory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        category = make_shared<vector<ListFlowCategoryResponseBodyCategoriesCategory>>(expect1);
      }
    }
  }


  virtual ~ListFlowCategoryResponseBodyCategories() = default;
};
class ListFlowCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListFlowCategoryResponseBodyCategories> categories{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  ListFlowCategoryResponseBody() {}

  explicit ListFlowCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categories) {
      res["Categories"] = categories ? boost::any(categories->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      if (typeid(map<string, boost::any>) == m["Categories"].type()) {
        ListFlowCategoryResponseBodyCategories model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Categories"]));
        categories = make_shared<ListFlowCategoryResponseBodyCategories>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListFlowCategoryResponseBody() = default;
};
class ListFlowCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFlowCategoryResponseBody> body{};

  ListFlowCategoryResponse() {}

  explicit ListFlowCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowCategoryResponse() = default;
};
class ListFlowClusterRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};

  ListFlowClusterRequest() {}

  explicit ListFlowClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListFlowClusterRequest() = default;
};
class ListFlowClusterResponseBodyClustersClusterInfoFailReason : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};

  ListFlowClusterResponseBodyClustersClusterInfoFailReason() {}

  explicit ListFlowClusterResponseBodyClustersClusterInfoFailReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListFlowClusterResponseBodyClustersClusterInfoFailReason() = default;
};
class ListFlowClusterResponseBodyClustersClusterInfoOrderTaskInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentCount{};
  shared_ptr<string> orderIdList{};
  shared_ptr<long> targetCount{};

  ListFlowClusterResponseBodyClustersClusterInfoOrderTaskInfo() {}

  explicit ListFlowClusterResponseBodyClustersClusterInfoOrderTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentCount) {
      res["CurrentCount"] = boost::any(*currentCount);
    }
    if (orderIdList) {
      res["OrderIdList"] = boost::any(*orderIdList);
    }
    if (targetCount) {
      res["TargetCount"] = boost::any(*targetCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentCount") != m.end() && !m["CurrentCount"].empty()) {
      currentCount = make_shared<long>(boost::any_cast<long>(m["CurrentCount"]));
    }
    if (m.find("OrderIdList") != m.end() && !m["OrderIdList"].empty()) {
      orderIdList = make_shared<string>(boost::any_cast<string>(m["OrderIdList"]));
    }
    if (m.find("TargetCount") != m.end() && !m["TargetCount"].empty()) {
      targetCount = make_shared<long>(boost::any_cast<long>(m["TargetCount"]));
    }
  }


  virtual ~ListFlowClusterResponseBodyClustersClusterInfoOrderTaskInfo() = default;
};
class ListFlowClusterResponseBodyClustersClusterInfo : public Darabonba::Model {
public:
  shared_ptr<string> chargeType{};
  shared_ptr<string> createResource{};
  shared_ptr<long> createTime{};
  shared_ptr<long> expiredTime{};
  shared_ptr<ListFlowClusterResponseBodyClustersClusterInfoFailReason> failReason{};
  shared_ptr<bool> hasUncompletedOrder{};
  shared_ptr<string> id{};
  shared_ptr<string> k8sClusterId{};
  shared_ptr<string> name{};
  shared_ptr<string> orderList{};
  shared_ptr<ListFlowClusterResponseBodyClustersClusterInfoOrderTaskInfo> orderTaskInfo{};
  shared_ptr<long> period{};
  shared_ptr<long> runningTime{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  ListFlowClusterResponseBodyClustersClusterInfo() {}

  explicit ListFlowClusterResponseBodyClustersClusterInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (createResource) {
      res["CreateResource"] = boost::any(*createResource);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (failReason) {
      res["FailReason"] = failReason ? boost::any(failReason->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hasUncompletedOrder) {
      res["HasUncompletedOrder"] = boost::any(*hasUncompletedOrder);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (k8sClusterId) {
      res["K8sClusterId"] = boost::any(*k8sClusterId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (orderList) {
      res["OrderList"] = boost::any(*orderList);
    }
    if (orderTaskInfo) {
      res["OrderTaskInfo"] = orderTaskInfo ? boost::any(orderTaskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (runningTime) {
      res["RunningTime"] = boost::any(*runningTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("CreateResource") != m.end() && !m["CreateResource"].empty()) {
      createResource = make_shared<string>(boost::any_cast<string>(m["CreateResource"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("FailReason") != m.end() && !m["FailReason"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailReason"].type()) {
        ListFlowClusterResponseBodyClustersClusterInfoFailReason model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailReason"]));
        failReason = make_shared<ListFlowClusterResponseBodyClustersClusterInfoFailReason>(model1);
      }
    }
    if (m.find("HasUncompletedOrder") != m.end() && !m["HasUncompletedOrder"].empty()) {
      hasUncompletedOrder = make_shared<bool>(boost::any_cast<bool>(m["HasUncompletedOrder"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("K8sClusterId") != m.end() && !m["K8sClusterId"].empty()) {
      k8sClusterId = make_shared<string>(boost::any_cast<string>(m["K8sClusterId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrderList") != m.end() && !m["OrderList"].empty()) {
      orderList = make_shared<string>(boost::any_cast<string>(m["OrderList"]));
    }
    if (m.find("OrderTaskInfo") != m.end() && !m["OrderTaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrderTaskInfo"].type()) {
        ListFlowClusterResponseBodyClustersClusterInfoOrderTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrderTaskInfo"]));
        orderTaskInfo = make_shared<ListFlowClusterResponseBodyClustersClusterInfoOrderTaskInfo>(model1);
      }
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("RunningTime") != m.end() && !m["RunningTime"].empty()) {
      runningTime = make_shared<long>(boost::any_cast<long>(m["RunningTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListFlowClusterResponseBodyClustersClusterInfo() = default;
};
class ListFlowClusterResponseBodyClusters : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowClusterResponseBodyClustersClusterInfo>> clusterInfo{};

  ListFlowClusterResponseBodyClusters() {}

  explicit ListFlowClusterResponseBodyClusters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterInfo) {
      vector<boost::any> temp1;
      for(auto item1:*clusterInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterInfo") != m.end() && !m["ClusterInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterInfo"].type()) {
        vector<ListFlowClusterResponseBodyClustersClusterInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowClusterResponseBodyClustersClusterInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterInfo = make_shared<vector<ListFlowClusterResponseBodyClustersClusterInfo>>(expect1);
      }
    }
  }


  virtual ~ListFlowClusterResponseBodyClusters() = default;
};
class ListFlowClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListFlowClusterResponseBodyClusters> clusters{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListFlowClusterResponseBody() {}

  explicit ListFlowClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusters) {
      res["Clusters"] = clusters ? boost::any(clusters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clusters") != m.end() && !m["Clusters"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clusters"].type()) {
        ListFlowClusterResponseBodyClusters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clusters"]));
        clusters = make_shared<ListFlowClusterResponseBodyClusters>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListFlowClusterResponseBody() = default;
};
class ListFlowClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFlowClusterResponseBody> body{};

  ListFlowClusterResponse() {}

  explicit ListFlowClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowClusterResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowClusterResponse() = default;
};
class ListFlowClusterAllRequest : public Darabonba::Model {
public:
  shared_ptr<string> productType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};

  ListFlowClusterAllRequest() {}

  explicit ListFlowClusterAllRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListFlowClusterAllRequest() = default;
};
class ListFlowClusterAllResponseBodyClustersClusterInfoFailReason : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> requestId{};

  ListFlowClusterAllResponseBodyClustersClusterInfoFailReason() {}

  explicit ListFlowClusterAllResponseBodyClustersClusterInfoFailReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListFlowClusterAllResponseBodyClustersClusterInfoFailReason() = default;
};
class ListFlowClusterAllResponseBodyClustersClusterInfoOrderTaskInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentCount{};
  shared_ptr<string> orderIdList{};
  shared_ptr<long> targetCount{};

  ListFlowClusterAllResponseBodyClustersClusterInfoOrderTaskInfo() {}

  explicit ListFlowClusterAllResponseBodyClustersClusterInfoOrderTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentCount) {
      res["CurrentCount"] = boost::any(*currentCount);
    }
    if (orderIdList) {
      res["OrderIdList"] = boost::any(*orderIdList);
    }
    if (targetCount) {
      res["TargetCount"] = boost::any(*targetCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentCount") != m.end() && !m["CurrentCount"].empty()) {
      currentCount = make_shared<long>(boost::any_cast<long>(m["CurrentCount"]));
    }
    if (m.find("OrderIdList") != m.end() && !m["OrderIdList"].empty()) {
      orderIdList = make_shared<string>(boost::any_cast<string>(m["OrderIdList"]));
    }
    if (m.find("TargetCount") != m.end() && !m["TargetCount"].empty()) {
      targetCount = make_shared<long>(boost::any_cast<long>(m["TargetCount"]));
    }
  }


  virtual ~ListFlowClusterAllResponseBodyClustersClusterInfoOrderTaskInfo() = default;
};
class ListFlowClusterAllResponseBodyClustersClusterInfo : public Darabonba::Model {
public:
  shared_ptr<string> chargeType{};
  shared_ptr<string> createResource{};
  shared_ptr<long> createTime{};
  shared_ptr<long> expiredTime{};
  shared_ptr<ListFlowClusterAllResponseBodyClustersClusterInfoFailReason> failReason{};
  shared_ptr<bool> hasUncompletedOrder{};
  shared_ptr<string> id{};
  shared_ptr<string> k8sClusterId{};
  shared_ptr<string> name{};
  shared_ptr<string> orderList{};
  shared_ptr<ListFlowClusterAllResponseBodyClustersClusterInfoOrderTaskInfo> orderTaskInfo{};
  shared_ptr<long> period{};
  shared_ptr<long> runningTime{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  ListFlowClusterAllResponseBodyClustersClusterInfo() {}

  explicit ListFlowClusterAllResponseBodyClustersClusterInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (createResource) {
      res["CreateResource"] = boost::any(*createResource);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (failReason) {
      res["FailReason"] = failReason ? boost::any(failReason->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hasUncompletedOrder) {
      res["HasUncompletedOrder"] = boost::any(*hasUncompletedOrder);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (k8sClusterId) {
      res["K8sClusterId"] = boost::any(*k8sClusterId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (orderList) {
      res["OrderList"] = boost::any(*orderList);
    }
    if (orderTaskInfo) {
      res["OrderTaskInfo"] = orderTaskInfo ? boost::any(orderTaskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (runningTime) {
      res["RunningTime"] = boost::any(*runningTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("CreateResource") != m.end() && !m["CreateResource"].empty()) {
      createResource = make_shared<string>(boost::any_cast<string>(m["CreateResource"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("FailReason") != m.end() && !m["FailReason"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailReason"].type()) {
        ListFlowClusterAllResponseBodyClustersClusterInfoFailReason model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailReason"]));
        failReason = make_shared<ListFlowClusterAllResponseBodyClustersClusterInfoFailReason>(model1);
      }
    }
    if (m.find("HasUncompletedOrder") != m.end() && !m["HasUncompletedOrder"].empty()) {
      hasUncompletedOrder = make_shared<bool>(boost::any_cast<bool>(m["HasUncompletedOrder"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("K8sClusterId") != m.end() && !m["K8sClusterId"].empty()) {
      k8sClusterId = make_shared<string>(boost::any_cast<string>(m["K8sClusterId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrderList") != m.end() && !m["OrderList"].empty()) {
      orderList = make_shared<string>(boost::any_cast<string>(m["OrderList"]));
    }
    if (m.find("OrderTaskInfo") != m.end() && !m["OrderTaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrderTaskInfo"].type()) {
        ListFlowClusterAllResponseBodyClustersClusterInfoOrderTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrderTaskInfo"]));
        orderTaskInfo = make_shared<ListFlowClusterAllResponseBodyClustersClusterInfoOrderTaskInfo>(model1);
      }
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("RunningTime") != m.end() && !m["RunningTime"].empty()) {
      runningTime = make_shared<long>(boost::any_cast<long>(m["RunningTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListFlowClusterAllResponseBodyClustersClusterInfo() = default;
};
class ListFlowClusterAllResponseBodyClusters : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowClusterAllResponseBodyClustersClusterInfo>> clusterInfo{};

  ListFlowClusterAllResponseBodyClusters() {}

  explicit ListFlowClusterAllResponseBodyClusters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterInfo) {
      vector<boost::any> temp1;
      for(auto item1:*clusterInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterInfo") != m.end() && !m["ClusterInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterInfo"].type()) {
        vector<ListFlowClusterAllResponseBodyClustersClusterInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowClusterAllResponseBodyClustersClusterInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterInfo = make_shared<vector<ListFlowClusterAllResponseBodyClustersClusterInfo>>(expect1);
      }
    }
  }


  virtual ~ListFlowClusterAllResponseBodyClusters() = default;
};
class ListFlowClusterAllResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListFlowClusterAllResponseBodyClusters> clusters{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListFlowClusterAllResponseBody() {}

  explicit ListFlowClusterAllResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusters) {
      res["Clusters"] = clusters ? boost::any(clusters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clusters") != m.end() && !m["Clusters"].empty()) {
      if (typeid(map<string, boost::any>) == m["Clusters"].type()) {
        ListFlowClusterAllResponseBodyClusters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Clusters"]));
        clusters = make_shared<ListFlowClusterAllResponseBodyClusters>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListFlowClusterAllResponseBody() = default;
};
class ListFlowClusterAllResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFlowClusterAllResponseBody> body{};

  ListFlowClusterAllResponse() {}

  explicit ListFlowClusterAllResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowClusterAllResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowClusterAllResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowClusterAllResponse() = default;
};
class ListFlowClusterAllHostsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};

  ListFlowClusterAllHostsRequest() {}

  explicit ListFlowClusterAllHostsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListFlowClusterAllHostsRequest() = default;
};
class ListFlowClusterAllHostsResponseBodyHostListHost : public Darabonba::Model {
public:
  shared_ptr<long> cpu{};
  shared_ptr<string> hostId{};
  shared_ptr<string> hostInstanceId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> memory{};
  shared_ptr<string> privateIp{};
  shared_ptr<string> publicIp{};
  shared_ptr<string> role{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  ListFlowClusterAllHostsResponseBodyHostListHost() {}

  explicit ListFlowClusterAllHostsResponseBodyHostListHost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (hostInstanceId) {
      res["HostInstanceId"] = boost::any(*hostInstanceId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (privateIp) {
      res["PrivateIp"] = boost::any(*privateIp);
    }
    if (publicIp) {
      res["PublicIp"] = boost::any(*publicIp);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("HostInstanceId") != m.end() && !m["HostInstanceId"].empty()) {
      hostInstanceId = make_shared<string>(boost::any_cast<string>(m["HostInstanceId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("PrivateIp") != m.end() && !m["PrivateIp"].empty()) {
      privateIp = make_shared<string>(boost::any_cast<string>(m["PrivateIp"]));
    }
    if (m.find("PublicIp") != m.end() && !m["PublicIp"].empty()) {
      publicIp = make_shared<string>(boost::any_cast<string>(m["PublicIp"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListFlowClusterAllHostsResponseBodyHostListHost() = default;
};
class ListFlowClusterAllHostsResponseBodyHostList : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowClusterAllHostsResponseBodyHostListHost>> host{};

  ListFlowClusterAllHostsResponseBodyHostList() {}

  explicit ListFlowClusterAllHostsResponseBodyHostList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      vector<boost::any> temp1;
      for(auto item1:*host){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Host"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      if (typeid(vector<boost::any>) == m["Host"].type()) {
        vector<ListFlowClusterAllHostsResponseBodyHostListHost> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Host"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowClusterAllHostsResponseBodyHostListHost model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        host = make_shared<vector<ListFlowClusterAllHostsResponseBodyHostListHost>>(expect1);
      }
    }
  }


  virtual ~ListFlowClusterAllHostsResponseBodyHostList() = default;
};
class ListFlowClusterAllHostsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListFlowClusterAllHostsResponseBodyHostList> hostList{};
  shared_ptr<string> requestId{};

  ListFlowClusterAllHostsResponseBody() {}

  explicit ListFlowClusterAllHostsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostList) {
      res["HostList"] = hostList ? boost::any(hostList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostList") != m.end() && !m["HostList"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostList"].type()) {
        ListFlowClusterAllHostsResponseBodyHostList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostList"]));
        hostList = make_shared<ListFlowClusterAllHostsResponseBodyHostList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListFlowClusterAllHostsResponseBody() = default;
};
class ListFlowClusterAllHostsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFlowClusterAllHostsResponseBody> body{};

  ListFlowClusterAllHostsResponse() {}

  explicit ListFlowClusterAllHostsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowClusterAllHostsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowClusterAllHostsResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowClusterAllHostsResponse() = default;
};
class ListFlowClusterHostRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};

  ListFlowClusterHostRequest() {}

  explicit ListFlowClusterHostRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListFlowClusterHostRequest() = default;
};
class ListFlowClusterHostResponseBodyHostListHost : public Darabonba::Model {
public:
  shared_ptr<long> cpu{};
  shared_ptr<string> hostId{};
  shared_ptr<string> hostInstanceId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> memory{};
  shared_ptr<string> privateIp{};
  shared_ptr<string> publicIp{};
  shared_ptr<string> role{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  ListFlowClusterHostResponseBodyHostListHost() {}

  explicit ListFlowClusterHostResponseBodyHostListHost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (hostId) {
      res["HostId"] = boost::any(*hostId);
    }
    if (hostInstanceId) {
      res["HostInstanceId"] = boost::any(*hostInstanceId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (privateIp) {
      res["PrivateIp"] = boost::any(*privateIp);
    }
    if (publicIp) {
      res["PublicIp"] = boost::any(*publicIp);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("HostId") != m.end() && !m["HostId"].empty()) {
      hostId = make_shared<string>(boost::any_cast<string>(m["HostId"]));
    }
    if (m.find("HostInstanceId") != m.end() && !m["HostInstanceId"].empty()) {
      hostInstanceId = make_shared<string>(boost::any_cast<string>(m["HostInstanceId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("PrivateIp") != m.end() && !m["PrivateIp"].empty()) {
      privateIp = make_shared<string>(boost::any_cast<string>(m["PrivateIp"]));
    }
    if (m.find("PublicIp") != m.end() && !m["PublicIp"].empty()) {
      publicIp = make_shared<string>(boost::any_cast<string>(m["PublicIp"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListFlowClusterHostResponseBodyHostListHost() = default;
};
class ListFlowClusterHostResponseBodyHostList : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowClusterHostResponseBodyHostListHost>> host{};

  ListFlowClusterHostResponseBodyHostList() {}

  explicit ListFlowClusterHostResponseBodyHostList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      vector<boost::any> temp1;
      for(auto item1:*host){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Host"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      if (typeid(vector<boost::any>) == m["Host"].type()) {
        vector<ListFlowClusterHostResponseBodyHostListHost> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Host"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowClusterHostResponseBodyHostListHost model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        host = make_shared<vector<ListFlowClusterHostResponseBodyHostListHost>>(expect1);
      }
    }
  }


  virtual ~ListFlowClusterHostResponseBodyHostList() = default;
};
class ListFlowClusterHostResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListFlowClusterHostResponseBodyHostList> hostList{};
  shared_ptr<string> requestId{};

  ListFlowClusterHostResponseBody() {}

  explicit ListFlowClusterHostResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostList) {
      res["HostList"] = hostList ? boost::any(hostList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostList") != m.end() && !m["HostList"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostList"].type()) {
        ListFlowClusterHostResponseBodyHostList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostList"]));
        hostList = make_shared<ListFlowClusterHostResponseBodyHostList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListFlowClusterHostResponseBody() = default;
};
class ListFlowClusterHostResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFlowClusterHostResponseBody> body{};

  ListFlowClusterHostResponse() {}

  explicit ListFlowClusterHostResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowClusterHostResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowClusterHostResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowClusterHostResponse() = default;
};
class ListFlowInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> flowId{};
  shared_ptr<string> flowName{};
  shared_ptr<string> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeInstanceId{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> orderType{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> statusList{};
  shared_ptr<string> timeRange{};

  ListFlowInstanceRequest() {}

  explicit ListFlowInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (flowName) {
      res["FlowName"] = boost::any(*flowName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeInstanceId) {
      res["NodeInstanceId"] = boost::any(*nodeInstanceId);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    if (timeRange) {
      res["TimeRange"] = boost::any(*timeRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("FlowName") != m.end() && !m["FlowName"].empty()) {
      flowName = make_shared<string>(boost::any_cast<string>(m["FlowName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeInstanceId") != m.end() && !m["NodeInstanceId"].empty()) {
      nodeInstanceId = make_shared<string>(boost::any_cast<string>(m["NodeInstanceId"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statusList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TimeRange") != m.end() && !m["TimeRange"].empty()) {
      timeRange = make_shared<string>(boost::any_cast<string>(m["TimeRange"]));
    }
  }


  virtual ~ListFlowInstanceRequest() = default;
};
class ListFlowInstanceResponseBodyFlowInstancesFlowInstance : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> duration{};
  shared_ptr<long> endTime{};
  shared_ptr<string> flowId{};
  shared_ptr<string> flowName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<bool> hasNodeFailed{};
  shared_ptr<string> id{};
  shared_ptr<string> owner{};
  shared_ptr<string> projectId{};
  shared_ptr<long> scheduleTime{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};

  ListFlowInstanceResponseBodyFlowInstancesFlowInstance() {}

  explicit ListFlowInstanceResponseBodyFlowInstancesFlowInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (flowName) {
      res["FlowName"] = boost::any(*flowName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (hasNodeFailed) {
      res["HasNodeFailed"] = boost::any(*hasNodeFailed);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (scheduleTime) {
      res["ScheduleTime"] = boost::any(*scheduleTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("FlowName") != m.end() && !m["FlowName"].empty()) {
      flowName = make_shared<string>(boost::any_cast<string>(m["FlowName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("HasNodeFailed") != m.end() && !m["HasNodeFailed"].empty()) {
      hasNodeFailed = make_shared<bool>(boost::any_cast<bool>(m["HasNodeFailed"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ScheduleTime") != m.end() && !m["ScheduleTime"].empty()) {
      scheduleTime = make_shared<long>(boost::any_cast<long>(m["ScheduleTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListFlowInstanceResponseBodyFlowInstancesFlowInstance() = default;
};
class ListFlowInstanceResponseBodyFlowInstances : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowInstanceResponseBodyFlowInstancesFlowInstance>> flowInstance{};

  ListFlowInstanceResponseBodyFlowInstances() {}

  explicit ListFlowInstanceResponseBodyFlowInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowInstance) {
      vector<boost::any> temp1;
      for(auto item1:*flowInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FlowInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowInstance") != m.end() && !m["FlowInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["FlowInstance"].type()) {
        vector<ListFlowInstanceResponseBodyFlowInstancesFlowInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FlowInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowInstanceResponseBodyFlowInstancesFlowInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flowInstance = make_shared<vector<ListFlowInstanceResponseBodyFlowInstancesFlowInstance>>(expect1);
      }
    }
  }


  virtual ~ListFlowInstanceResponseBodyFlowInstances() = default;
};
class ListFlowInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListFlowInstanceResponseBodyFlowInstances> flowInstances{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  ListFlowInstanceResponseBody() {}

  explicit ListFlowInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowInstances) {
      res["FlowInstances"] = flowInstances ? boost::any(flowInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowInstances") != m.end() && !m["FlowInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["FlowInstances"].type()) {
        ListFlowInstanceResponseBodyFlowInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FlowInstances"]));
        flowInstances = make_shared<ListFlowInstanceResponseBodyFlowInstances>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListFlowInstanceResponseBody() = default;
};
class ListFlowInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFlowInstanceResponseBody> body{};

  ListFlowInstanceResponse() {}

  explicit ListFlowInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowInstanceResponse() = default;
};
class ListFlowJobRequest : public Darabonba::Model {
public:
  shared_ptr<bool> adhoc{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  ListFlowJobRequest() {}

  explicit ListFlowJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adhoc) {
      res["Adhoc"] = boost::any(*adhoc);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Adhoc") != m.end() && !m["Adhoc"].empty()) {
      adhoc = make_shared<bool>(boost::any_cast<bool>(m["Adhoc"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListFlowJobRequest() = default;
};
class ListFlowJobResponseBodyJobListJobResourceListResource : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> path{};

  ListFlowJobResponseBodyJobListJobResourceListResource() {}

  explicit ListFlowJobResponseBodyJobListJobResourceListResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~ListFlowJobResponseBodyJobListJobResourceListResource() = default;
};
class ListFlowJobResponseBodyJobListJobResourceList : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowJobResponseBodyJobListJobResourceListResource>> resource{};

  ListFlowJobResponseBodyJobListJobResourceList() {}

  explicit ListFlowJobResponseBodyJobListJobResourceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resource) {
      vector<boost::any> temp1;
      for(auto item1:*resource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(vector<boost::any>) == m["Resource"].type()) {
        vector<ListFlowJobResponseBodyJobListJobResourceListResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowJobResponseBodyJobListJobResourceListResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resource = make_shared<vector<ListFlowJobResponseBodyJobListJobResourceListResource>>(expect1);
      }
    }
  }


  virtual ~ListFlowJobResponseBodyJobListJobResourceList() = default;
};
class ListFlowJobResponseBodyJobListJob : public Darabonba::Model {
public:
  shared_ptr<string> adhoc{};
  shared_ptr<string> alertConf{};
  shared_ptr<string> categoryId{};
  shared_ptr<string> customVariables{};
  shared_ptr<string> description{};
  shared_ptr<string> envConf{};
  shared_ptr<string> failAct{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> id{};
  shared_ptr<string> lastInstanceDetail{};
  shared_ptr<long> maxRetry{};
  shared_ptr<string> monitorConf{};
  shared_ptr<string> name{};
  shared_ptr<string> paramConf{};
  shared_ptr<string> params{};
  shared_ptr<ListFlowJobResponseBodyJobListJobResourceList> resourceList{};
  shared_ptr<long> retryInterval{};
  shared_ptr<string> runConf{};
  shared_ptr<string> type{};
  shared_ptr<string> mode{};

  ListFlowJobResponseBodyJobListJob() {}

  explicit ListFlowJobResponseBodyJobListJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adhoc) {
      res["Adhoc"] = boost::any(*adhoc);
    }
    if (alertConf) {
      res["AlertConf"] = boost::any(*alertConf);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (customVariables) {
      res["CustomVariables"] = boost::any(*customVariables);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envConf) {
      res["EnvConf"] = boost::any(*envConf);
    }
    if (failAct) {
      res["FailAct"] = boost::any(*failAct);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastInstanceDetail) {
      res["LastInstanceDetail"] = boost::any(*lastInstanceDetail);
    }
    if (maxRetry) {
      res["MaxRetry"] = boost::any(*maxRetry);
    }
    if (monitorConf) {
      res["MonitorConf"] = boost::any(*monitorConf);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (paramConf) {
      res["ParamConf"] = boost::any(*paramConf);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (resourceList) {
      res["ResourceList"] = resourceList ? boost::any(resourceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (runConf) {
      res["RunConf"] = boost::any(*runConf);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (mode) {
      res["mode"] = boost::any(*mode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Adhoc") != m.end() && !m["Adhoc"].empty()) {
      adhoc = make_shared<string>(boost::any_cast<string>(m["Adhoc"]));
    }
    if (m.find("AlertConf") != m.end() && !m["AlertConf"].empty()) {
      alertConf = make_shared<string>(boost::any_cast<string>(m["AlertConf"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("CustomVariables") != m.end() && !m["CustomVariables"].empty()) {
      customVariables = make_shared<string>(boost::any_cast<string>(m["CustomVariables"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvConf") != m.end() && !m["EnvConf"].empty()) {
      envConf = make_shared<string>(boost::any_cast<string>(m["EnvConf"]));
    }
    if (m.find("FailAct") != m.end() && !m["FailAct"].empty()) {
      failAct = make_shared<string>(boost::any_cast<string>(m["FailAct"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LastInstanceDetail") != m.end() && !m["LastInstanceDetail"].empty()) {
      lastInstanceDetail = make_shared<string>(boost::any_cast<string>(m["LastInstanceDetail"]));
    }
    if (m.find("MaxRetry") != m.end() && !m["MaxRetry"].empty()) {
      maxRetry = make_shared<long>(boost::any_cast<long>(m["MaxRetry"]));
    }
    if (m.find("MonitorConf") != m.end() && !m["MonitorConf"].empty()) {
      monitorConf = make_shared<string>(boost::any_cast<string>(m["MonitorConf"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParamConf") != m.end() && !m["ParamConf"].empty()) {
      paramConf = make_shared<string>(boost::any_cast<string>(m["ParamConf"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("ResourceList") != m.end() && !m["ResourceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceList"].type()) {
        ListFlowJobResponseBodyJobListJobResourceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceList"]));
        resourceList = make_shared<ListFlowJobResponseBodyJobListJobResourceList>(model1);
      }
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<long>(boost::any_cast<long>(m["RetryInterval"]));
    }
    if (m.find("RunConf") != m.end() && !m["RunConf"].empty()) {
      runConf = make_shared<string>(boost::any_cast<string>(m["RunConf"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("mode") != m.end() && !m["mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["mode"]));
    }
  }


  virtual ~ListFlowJobResponseBodyJobListJob() = default;
};
class ListFlowJobResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowJobResponseBodyJobListJob>> job{};

  ListFlowJobResponseBodyJobList() {}

  explicit ListFlowJobResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      vector<boost::any> temp1;
      for(auto item1:*job){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Job"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(vector<boost::any>) == m["Job"].type()) {
        vector<ListFlowJobResponseBodyJobListJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Job"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowJobResponseBodyJobListJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        job = make_shared<vector<ListFlowJobResponseBodyJobListJob>>(expect1);
      }
    }
  }


  virtual ~ListFlowJobResponseBodyJobList() = default;
};
class ListFlowJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListFlowJobResponseBodyJobList> jobList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  ListFlowJobResponseBody() {}

  explicit ListFlowJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobList) {
      res["JobList"] = jobList ? boost::any(jobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobList"].type()) {
        ListFlowJobResponseBodyJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobList"]));
        jobList = make_shared<ListFlowJobResponseBodyJobList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListFlowJobResponseBody() = default;
};
class ListFlowJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFlowJobResponseBody> body{};

  ListFlowJobResponse() {}

  explicit ListFlowJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowJobResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowJobResponse() = default;
};
class ListFlowJobHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> statusList{};
  shared_ptr<string> timeRange{};

  ListFlowJobHistoryRequest() {}

  explicit ListFlowJobHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    if (timeRange) {
      res["TimeRange"] = boost::any(*timeRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statusList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TimeRange") != m.end() && !m["TimeRange"].empty()) {
      timeRange = make_shared<string>(boost::any_cast<string>(m["TimeRange"]));
    }
  }


  virtual ~ListFlowJobHistoryRequest() = default;
};
class ListFlowJobHistoryResponseBodyNodeInstancesNodeInstance : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> envConf{};
  shared_ptr<string> externalId{};
  shared_ptr<string> externalInfo{};
  shared_ptr<string> externalStatus{};
  shared_ptr<string> failAct{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> hostName{};
  shared_ptr<string> id{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<string> jobParams{};
  shared_ptr<string> jobType{};
  shared_ptr<long> maxRetry{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> paramConf{};
  shared_ptr<string> projectId{};
  shared_ptr<long> retries{};
  shared_ptr<long> retryInterval{};
  shared_ptr<string> runConf{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<bool> pending{};

  ListFlowJobHistoryResponseBodyNodeInstancesNodeInstance() {}

  explicit ListFlowJobHistoryResponseBodyNodeInstancesNodeInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (envConf) {
      res["EnvConf"] = boost::any(*envConf);
    }
    if (externalId) {
      res["ExternalId"] = boost::any(*externalId);
    }
    if (externalInfo) {
      res["ExternalInfo"] = boost::any(*externalInfo);
    }
    if (externalStatus) {
      res["ExternalStatus"] = boost::any(*externalStatus);
    }
    if (failAct) {
      res["FailAct"] = boost::any(*failAct);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (jobParams) {
      res["JobParams"] = boost::any(*jobParams);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (maxRetry) {
      res["MaxRetry"] = boost::any(*maxRetry);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (paramConf) {
      res["ParamConf"] = boost::any(*paramConf);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (retries) {
      res["Retries"] = boost::any(*retries);
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (runConf) {
      res["RunConf"] = boost::any(*runConf);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (pending) {
      res["pending"] = boost::any(*pending);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("EnvConf") != m.end() && !m["EnvConf"].empty()) {
      envConf = make_shared<string>(boost::any_cast<string>(m["EnvConf"]));
    }
    if (m.find("ExternalId") != m.end() && !m["ExternalId"].empty()) {
      externalId = make_shared<string>(boost::any_cast<string>(m["ExternalId"]));
    }
    if (m.find("ExternalInfo") != m.end() && !m["ExternalInfo"].empty()) {
      externalInfo = make_shared<string>(boost::any_cast<string>(m["ExternalInfo"]));
    }
    if (m.find("ExternalStatus") != m.end() && !m["ExternalStatus"].empty()) {
      externalStatus = make_shared<string>(boost::any_cast<string>(m["ExternalStatus"]));
    }
    if (m.find("FailAct") != m.end() && !m["FailAct"].empty()) {
      failAct = make_shared<string>(boost::any_cast<string>(m["FailAct"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("JobParams") != m.end() && !m["JobParams"].empty()) {
      jobParams = make_shared<string>(boost::any_cast<string>(m["JobParams"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("MaxRetry") != m.end() && !m["MaxRetry"].empty()) {
      maxRetry = make_shared<long>(boost::any_cast<long>(m["MaxRetry"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("ParamConf") != m.end() && !m["ParamConf"].empty()) {
      paramConf = make_shared<string>(boost::any_cast<string>(m["ParamConf"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Retries") != m.end() && !m["Retries"].empty()) {
      retries = make_shared<long>(boost::any_cast<long>(m["Retries"]));
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<long>(boost::any_cast<long>(m["RetryInterval"]));
    }
    if (m.find("RunConf") != m.end() && !m["RunConf"].empty()) {
      runConf = make_shared<string>(boost::any_cast<string>(m["RunConf"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("pending") != m.end() && !m["pending"].empty()) {
      pending = make_shared<bool>(boost::any_cast<bool>(m["pending"]));
    }
  }


  virtual ~ListFlowJobHistoryResponseBodyNodeInstancesNodeInstance() = default;
};
class ListFlowJobHistoryResponseBodyNodeInstances : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowJobHistoryResponseBodyNodeInstancesNodeInstance>> nodeInstance{};

  ListFlowJobHistoryResponseBodyNodeInstances() {}

  explicit ListFlowJobHistoryResponseBodyNodeInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeInstance) {
      vector<boost::any> temp1;
      for(auto item1:*nodeInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeInstance") != m.end() && !m["NodeInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeInstance"].type()) {
        vector<ListFlowJobHistoryResponseBodyNodeInstancesNodeInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowJobHistoryResponseBodyNodeInstancesNodeInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeInstance = make_shared<vector<ListFlowJobHistoryResponseBodyNodeInstancesNodeInstance>>(expect1);
      }
    }
  }


  virtual ~ListFlowJobHistoryResponseBodyNodeInstances() = default;
};
class ListFlowJobHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListFlowJobHistoryResponseBodyNodeInstances> nodeInstances{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  ListFlowJobHistoryResponseBody() {}

  explicit ListFlowJobHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeInstances) {
      res["NodeInstances"] = nodeInstances ? boost::any(nodeInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeInstances") != m.end() && !m["NodeInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeInstances"].type()) {
        ListFlowJobHistoryResponseBodyNodeInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeInstances"]));
        nodeInstances = make_shared<ListFlowJobHistoryResponseBodyNodeInstances>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListFlowJobHistoryResponseBody() = default;
};
class ListFlowJobHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFlowJobHistoryResponseBody> body{};

  ListFlowJobHistoryResponse() {}

  explicit ListFlowJobHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowJobHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowJobHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowJobHistoryResponse() = default;
};
class ListFlowNodeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> orderBy{};
  shared_ptr<string> orderType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> startTime{};
  shared_ptr<vector<string>> statusList{};

  ListFlowNodeInstanceRequest() {}

  explicit ListFlowNodeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statusList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListFlowNodeInstanceRequest() = default;
};
class ListFlowNodeInstanceResponseBodyFlowNodeInstancesFlowNodeInstance : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> duration{};
  shared_ptr<long> endTime{};
  shared_ptr<string> externalChildIds{};
  shared_ptr<string> externalId{};
  shared_ptr<string> externalInfo{};
  shared_ptr<string> externalStatus{};
  shared_ptr<string> externalSubId{};
  shared_ptr<string> failAct{};
  shared_ptr<string> flowId{};
  shared_ptr<string> flowInstanceId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> hostName{};
  shared_ptr<string> id{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<string> jobParams{};
  shared_ptr<string> jobType{};
  shared_ptr<string> maxRetry{};
  shared_ptr<string> nodeName{};
  shared_ptr<bool> pending{};
  shared_ptr<string> projectId{};
  shared_ptr<long> retries{};
  shared_ptr<string> retryInterval{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  ListFlowNodeInstanceResponseBodyFlowNodeInstancesFlowNodeInstance() {}

  explicit ListFlowNodeInstanceResponseBodyFlowNodeInstancesFlowNodeInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (externalChildIds) {
      res["ExternalChildIds"] = boost::any(*externalChildIds);
    }
    if (externalId) {
      res["ExternalId"] = boost::any(*externalId);
    }
    if (externalInfo) {
      res["ExternalInfo"] = boost::any(*externalInfo);
    }
    if (externalStatus) {
      res["ExternalStatus"] = boost::any(*externalStatus);
    }
    if (externalSubId) {
      res["ExternalSubId"] = boost::any(*externalSubId);
    }
    if (failAct) {
      res["FailAct"] = boost::any(*failAct);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (flowInstanceId) {
      res["FlowInstanceId"] = boost::any(*flowInstanceId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (jobParams) {
      res["JobParams"] = boost::any(*jobParams);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (maxRetry) {
      res["MaxRetry"] = boost::any(*maxRetry);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (pending) {
      res["Pending"] = boost::any(*pending);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (retries) {
      res["Retries"] = boost::any(*retries);
    }
    if (retryInterval) {
      res["RetryInterval"] = boost::any(*retryInterval);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ExternalChildIds") != m.end() && !m["ExternalChildIds"].empty()) {
      externalChildIds = make_shared<string>(boost::any_cast<string>(m["ExternalChildIds"]));
    }
    if (m.find("ExternalId") != m.end() && !m["ExternalId"].empty()) {
      externalId = make_shared<string>(boost::any_cast<string>(m["ExternalId"]));
    }
    if (m.find("ExternalInfo") != m.end() && !m["ExternalInfo"].empty()) {
      externalInfo = make_shared<string>(boost::any_cast<string>(m["ExternalInfo"]));
    }
    if (m.find("ExternalStatus") != m.end() && !m["ExternalStatus"].empty()) {
      externalStatus = make_shared<string>(boost::any_cast<string>(m["ExternalStatus"]));
    }
    if (m.find("ExternalSubId") != m.end() && !m["ExternalSubId"].empty()) {
      externalSubId = make_shared<string>(boost::any_cast<string>(m["ExternalSubId"]));
    }
    if (m.find("FailAct") != m.end() && !m["FailAct"].empty()) {
      failAct = make_shared<string>(boost::any_cast<string>(m["FailAct"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("FlowInstanceId") != m.end() && !m["FlowInstanceId"].empty()) {
      flowInstanceId = make_shared<string>(boost::any_cast<string>(m["FlowInstanceId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("JobParams") != m.end() && !m["JobParams"].empty()) {
      jobParams = make_shared<string>(boost::any_cast<string>(m["JobParams"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("MaxRetry") != m.end() && !m["MaxRetry"].empty()) {
      maxRetry = make_shared<string>(boost::any_cast<string>(m["MaxRetry"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Pending") != m.end() && !m["Pending"].empty()) {
      pending = make_shared<bool>(boost::any_cast<bool>(m["Pending"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Retries") != m.end() && !m["Retries"].empty()) {
      retries = make_shared<long>(boost::any_cast<long>(m["Retries"]));
    }
    if (m.find("RetryInterval") != m.end() && !m["RetryInterval"].empty()) {
      retryInterval = make_shared<string>(boost::any_cast<string>(m["RetryInterval"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListFlowNodeInstanceResponseBodyFlowNodeInstancesFlowNodeInstance() = default;
};
class ListFlowNodeInstanceResponseBodyFlowNodeInstances : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowNodeInstanceResponseBodyFlowNodeInstancesFlowNodeInstance>> flowNodeInstance{};

  ListFlowNodeInstanceResponseBodyFlowNodeInstances() {}

  explicit ListFlowNodeInstanceResponseBodyFlowNodeInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowNodeInstance) {
      vector<boost::any> temp1;
      for(auto item1:*flowNodeInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FlowNodeInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowNodeInstance") != m.end() && !m["FlowNodeInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["FlowNodeInstance"].type()) {
        vector<ListFlowNodeInstanceResponseBodyFlowNodeInstancesFlowNodeInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FlowNodeInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowNodeInstanceResponseBodyFlowNodeInstancesFlowNodeInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flowNodeInstance = make_shared<vector<ListFlowNodeInstanceResponseBodyFlowNodeInstancesFlowNodeInstance>>(expect1);
      }
    }
  }


  virtual ~ListFlowNodeInstanceResponseBodyFlowNodeInstances() = default;
};
class ListFlowNodeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListFlowNodeInstanceResponseBodyFlowNodeInstances> flowNodeInstances{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  ListFlowNodeInstanceResponseBody() {}

  explicit ListFlowNodeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowNodeInstances) {
      res["FlowNodeInstances"] = flowNodeInstances ? boost::any(flowNodeInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowNodeInstances") != m.end() && !m["FlowNodeInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["FlowNodeInstances"].type()) {
        ListFlowNodeInstanceResponseBodyFlowNodeInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FlowNodeInstances"]));
        flowNodeInstances = make_shared<ListFlowNodeInstanceResponseBodyFlowNodeInstances>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListFlowNodeInstanceResponseBody() = default;
};
class ListFlowNodeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFlowNodeInstanceResponseBody> body{};

  ListFlowNodeInstanceResponse() {}

  explicit ListFlowNodeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowNodeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowNodeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowNodeInstanceResponse() = default;
};
class ListFlowNodeInstanceContainerStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> nodeInstanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  ListFlowNodeInstanceContainerStatusRequest() {}

  explicit ListFlowNodeInstanceContainerStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeInstanceId) {
      res["NodeInstanceId"] = boost::any(*nodeInstanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeInstanceId") != m.end() && !m["NodeInstanceId"].empty()) {
      nodeInstanceId = make_shared<string>(boost::any_cast<string>(m["NodeInstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListFlowNodeInstanceContainerStatusRequest() = default;
};
class ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusListContainerStatus : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> containerId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> status{};

  ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusListContainerStatus() {}

  explicit ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusListContainerStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<string>(boost::any_cast<string>(m["ContainerId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusListContainerStatus() = default;
};
class ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusList : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusListContainerStatus>> containerStatus{};

  ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusList() {}

  explicit ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerStatus) {
      vector<boost::any> temp1;
      for(auto item1:*containerStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContainerStatus"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerStatus") != m.end() && !m["ContainerStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["ContainerStatus"].type()) {
        vector<ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusListContainerStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContainerStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusListContainerStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        containerStatus = make_shared<vector<ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusListContainerStatus>>(expect1);
      }
    }
  }


  virtual ~ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusList() = default;
};
class ListFlowNodeInstanceContainerStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusList> containerStatusList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  ListFlowNodeInstanceContainerStatusResponseBody() {}

  explicit ListFlowNodeInstanceContainerStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerStatusList) {
      res["ContainerStatusList"] = containerStatusList ? boost::any(containerStatusList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerStatusList") != m.end() && !m["ContainerStatusList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContainerStatusList"].type()) {
        ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContainerStatusList"]));
        containerStatusList = make_shared<ListFlowNodeInstanceContainerStatusResponseBodyContainerStatusList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListFlowNodeInstanceContainerStatusResponseBody() = default;
};
class ListFlowNodeInstanceContainerStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFlowNodeInstanceContainerStatusResponseBody> body{};

  ListFlowNodeInstanceContainerStatusResponse() {}

  explicit ListFlowNodeInstanceContainerStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowNodeInstanceContainerStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowNodeInstanceContainerStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowNodeInstanceContainerStatusResponse() = default;
};
class ListFlowNodeSqlResultRequest : public Darabonba::Model {
public:
  shared_ptr<long> length{};
  shared_ptr<string> nodeInstanceId{};
  shared_ptr<long> offset{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> sqlIndex{};

  ListFlowNodeSqlResultRequest() {}

  explicit ListFlowNodeSqlResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (nodeInstanceId) {
      res["NodeInstanceId"] = boost::any(*nodeInstanceId);
    }
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sqlIndex) {
      res["SqlIndex"] = boost::any(*sqlIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("NodeInstanceId") != m.end() && !m["NodeInstanceId"].empty()) {
      nodeInstanceId = make_shared<string>(boost::any_cast<string>(m["NodeInstanceId"]));
    }
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SqlIndex") != m.end() && !m["SqlIndex"].empty()) {
      sqlIndex = make_shared<long>(boost::any_cast<long>(m["SqlIndex"]));
    }
  }


  virtual ~ListFlowNodeSqlResultRequest() = default;
};
class ListFlowNodeSqlResultResponseBodyHeaderList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> header{};

  ListFlowNodeSqlResultResponseBodyHeaderList() {}

  explicit ListFlowNodeSqlResultResponseBodyHeaderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (header) {
      res["Header"] = boost::any(*header);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Header"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Header"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      header = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListFlowNodeSqlResultResponseBodyHeaderList() = default;
};
class ListFlowNodeSqlResultResponseBodyRowListRowRowItemList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> rowItem{};

  ListFlowNodeSqlResultResponseBodyRowListRowRowItemList() {}

  explicit ListFlowNodeSqlResultResponseBodyRowListRowRowItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rowItem) {
      res["rowItem"] = boost::any(*rowItem);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("rowItem") != m.end() && !m["rowItem"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["rowItem"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["rowItem"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      rowItem = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListFlowNodeSqlResultResponseBodyRowListRowRowItemList() = default;
};
class ListFlowNodeSqlResultResponseBodyRowListRow : public Darabonba::Model {
public:
  shared_ptr<long> rowIndex{};
  shared_ptr<ListFlowNodeSqlResultResponseBodyRowListRowRowItemList> rowItemList{};

  ListFlowNodeSqlResultResponseBodyRowListRow() {}

  explicit ListFlowNodeSqlResultResponseBodyRowListRow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rowIndex) {
      res["RowIndex"] = boost::any(*rowIndex);
    }
    if (rowItemList) {
      res["RowItemList"] = rowItemList ? boost::any(rowItemList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RowIndex") != m.end() && !m["RowIndex"].empty()) {
      rowIndex = make_shared<long>(boost::any_cast<long>(m["RowIndex"]));
    }
    if (m.find("RowItemList") != m.end() && !m["RowItemList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RowItemList"].type()) {
        ListFlowNodeSqlResultResponseBodyRowListRowRowItemList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RowItemList"]));
        rowItemList = make_shared<ListFlowNodeSqlResultResponseBodyRowListRowRowItemList>(model1);
      }
    }
  }


  virtual ~ListFlowNodeSqlResultResponseBodyRowListRow() = default;
};
class ListFlowNodeSqlResultResponseBodyRowList : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowNodeSqlResultResponseBodyRowListRow>> row{};

  ListFlowNodeSqlResultResponseBodyRowList() {}

  explicit ListFlowNodeSqlResultResponseBodyRowList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (row) {
      vector<boost::any> temp1;
      for(auto item1:*row){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Row"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Row") != m.end() && !m["Row"].empty()) {
      if (typeid(vector<boost::any>) == m["Row"].type()) {
        vector<ListFlowNodeSqlResultResponseBodyRowListRow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Row"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowNodeSqlResultResponseBodyRowListRow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        row = make_shared<vector<ListFlowNodeSqlResultResponseBodyRowListRow>>(expect1);
      }
    }
  }


  virtual ~ListFlowNodeSqlResultResponseBodyRowList() = default;
};
class ListFlowNodeSqlResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> end{};
  shared_ptr<ListFlowNodeSqlResultResponseBodyHeaderList> headerList{};
  shared_ptr<string> requestId{};
  shared_ptr<ListFlowNodeSqlResultResponseBodyRowList> rowList{};

  ListFlowNodeSqlResultResponseBody() {}

  explicit ListFlowNodeSqlResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (headerList) {
      res["HeaderList"] = headerList ? boost::any(headerList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rowList) {
      res["RowList"] = rowList ? boost::any(rowList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<bool>(boost::any_cast<bool>(m["End"]));
    }
    if (m.find("HeaderList") != m.end() && !m["HeaderList"].empty()) {
      if (typeid(map<string, boost::any>) == m["HeaderList"].type()) {
        ListFlowNodeSqlResultResponseBodyHeaderList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HeaderList"]));
        headerList = make_shared<ListFlowNodeSqlResultResponseBodyHeaderList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RowList") != m.end() && !m["RowList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RowList"].type()) {
        ListFlowNodeSqlResultResponseBodyRowList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RowList"]));
        rowList = make_shared<ListFlowNodeSqlResultResponseBodyRowList>(model1);
      }
    }
  }


  virtual ~ListFlowNodeSqlResultResponseBody() = default;
};
class ListFlowNodeSqlResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFlowNodeSqlResultResponseBody> body{};

  ListFlowNodeSqlResultResponse() {}

  explicit ListFlowNodeSqlResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowNodeSqlResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowNodeSqlResultResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowNodeSqlResultResponse() = default;
};
class ListFlowProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> productType{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};

  ListFlowProjectRequest() {}

  explicit ListFlowProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~ListFlowProjectRequest() = default;
};
class ListFlowProjectResponseBodyProjectsProject : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> userId{};

  ListFlowProjectResponseBodyProjectsProject() {}

  explicit ListFlowProjectResponseBodyProjectsProject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListFlowProjectResponseBodyProjectsProject() = default;
};
class ListFlowProjectResponseBodyProjects : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowProjectResponseBodyProjectsProject>> project{};

  ListFlowProjectResponseBodyProjects() {}

  explicit ListFlowProjectResponseBodyProjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (project) {
      vector<boost::any> temp1;
      for(auto item1:*project){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Project"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      if (typeid(vector<boost::any>) == m["Project"].type()) {
        vector<ListFlowProjectResponseBodyProjectsProject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Project"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowProjectResponseBodyProjectsProject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        project = make_shared<vector<ListFlowProjectResponseBodyProjectsProject>>(expect1);
      }
    }
  }


  virtual ~ListFlowProjectResponseBodyProjects() = default;
};
class ListFlowProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<ListFlowProjectResponseBodyProjects> projects{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  ListFlowProjectResponseBody() {}

  explicit ListFlowProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projects) {
      res["Projects"] = projects ? boost::any(projects->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Projects") != m.end() && !m["Projects"].empty()) {
      if (typeid(map<string, boost::any>) == m["Projects"].type()) {
        ListFlowProjectResponseBodyProjects model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Projects"]));
        projects = make_shared<ListFlowProjectResponseBodyProjects>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListFlowProjectResponseBody() = default;
};
class ListFlowProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFlowProjectResponseBody> body{};

  ListFlowProjectResponse() {}

  explicit ListFlowProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowProjectResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowProjectResponse() = default;
};
class ListFlowProjectClusterSettingRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  ListFlowProjectClusterSettingRequest() {}

  explicit ListFlowProjectClusterSettingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListFlowProjectClusterSettingRequest() = default;
};
class ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingHostList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> host{};

  ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingHostList() {}

  explicit ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingHostList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Host"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Host"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      host = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingHostList() = default;
};
class ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingQueueList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> queue{};

  ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingQueueList() {}

  explicit ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingQueueList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Queue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Queue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      queue = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingQueueList() = default;
};
class ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingUserList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> user{};

  ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingUserList() {}

  explicit ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("User") != m.end() && !m["User"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["User"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["User"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      user = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingUserList() = default;
};
class ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSetting : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> defaultQueue{};
  shared_ptr<string> defaultUser{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingHostList> hostList{};
  shared_ptr<string> k8sClusterId{};
  shared_ptr<string> projectId{};
  shared_ptr<ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingQueueList> queueList{};
  shared_ptr<ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingUserList> userList{};

  ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSetting() {}

  explicit ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (defaultQueue) {
      res["DefaultQueue"] = boost::any(*defaultQueue);
    }
    if (defaultUser) {
      res["DefaultUser"] = boost::any(*defaultUser);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (hostList) {
      res["HostList"] = hostList ? boost::any(hostList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (k8sClusterId) {
      res["K8sClusterId"] = boost::any(*k8sClusterId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (queueList) {
      res["QueueList"] = queueList ? boost::any(queueList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userList) {
      res["UserList"] = userList ? boost::any(userList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("DefaultQueue") != m.end() && !m["DefaultQueue"].empty()) {
      defaultQueue = make_shared<string>(boost::any_cast<string>(m["DefaultQueue"]));
    }
    if (m.find("DefaultUser") != m.end() && !m["DefaultUser"].empty()) {
      defaultUser = make_shared<string>(boost::any_cast<string>(m["DefaultUser"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("HostList") != m.end() && !m["HostList"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostList"].type()) {
        ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingHostList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostList"]));
        hostList = make_shared<ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingHostList>(model1);
      }
    }
    if (m.find("K8sClusterId") != m.end() && !m["K8sClusterId"].empty()) {
      k8sClusterId = make_shared<string>(boost::any_cast<string>(m["K8sClusterId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("QueueList") != m.end() && !m["QueueList"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueueList"].type()) {
        ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingQueueList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QueueList"]));
        queueList = make_shared<ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingQueueList>(model1);
      }
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserList"].type()) {
        ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingUserList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserList"]));
        userList = make_shared<ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSettingUserList>(model1);
      }
    }
  }


  virtual ~ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSetting() = default;
};
class ListFlowProjectClusterSettingResponseBodyClusterSettings : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSetting>> clusterSetting{};

  ListFlowProjectClusterSettingResponseBodyClusterSettings() {}

  explicit ListFlowProjectClusterSettingResponseBodyClusterSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterSetting) {
      vector<boost::any> temp1;
      for(auto item1:*clusterSetting){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterSetting"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterSetting") != m.end() && !m["ClusterSetting"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterSetting"].type()) {
        vector<ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSetting> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterSetting"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSetting model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterSetting = make_shared<vector<ListFlowProjectClusterSettingResponseBodyClusterSettingsClusterSetting>>(expect1);
      }
    }
  }


  virtual ~ListFlowProjectClusterSettingResponseBodyClusterSettings() = default;
};
class ListFlowProjectClusterSettingResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListFlowProjectClusterSettingResponseBodyClusterSettings> clusterSettings{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  ListFlowProjectClusterSettingResponseBody() {}

  explicit ListFlowProjectClusterSettingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterSettings) {
      res["ClusterSettings"] = clusterSettings ? boost::any(clusterSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterSettings") != m.end() && !m["ClusterSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterSettings"].type()) {
        ListFlowProjectClusterSettingResponseBodyClusterSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterSettings"]));
        clusterSettings = make_shared<ListFlowProjectClusterSettingResponseBodyClusterSettings>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListFlowProjectClusterSettingResponseBody() = default;
};
class ListFlowProjectClusterSettingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFlowProjectClusterSettingResponseBody> body{};

  ListFlowProjectClusterSettingResponse() {}

  explicit ListFlowProjectClusterSettingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowProjectClusterSettingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowProjectClusterSettingResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowProjectClusterSettingResponse() = default;
};
class ListFlowProjectUserRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  ListFlowProjectUserRequest() {}

  explicit ListFlowProjectUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListFlowProjectUserRequest() = default;
};
class ListFlowProjectUserResponseBodyUsersUser : public Darabonba::Model {
public:
  shared_ptr<string> accountUserId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> userName{};

  ListFlowProjectUserResponseBodyUsersUser() {}

  explicit ListFlowProjectUserResponseBodyUsersUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountUserId) {
      res["AccountUserId"] = boost::any(*accountUserId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountUserId") != m.end() && !m["AccountUserId"].empty()) {
      accountUserId = make_shared<string>(boost::any_cast<string>(m["AccountUserId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~ListFlowProjectUserResponseBodyUsersUser() = default;
};
class ListFlowProjectUserResponseBodyUsers : public Darabonba::Model {
public:
  shared_ptr<vector<ListFlowProjectUserResponseBodyUsersUser>> user{};

  ListFlowProjectUserResponseBodyUsers() {}

  explicit ListFlowProjectUserResponseBodyUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (user) {
      vector<boost::any> temp1;
      for(auto item1:*user){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["User"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(vector<boost::any>) == m["User"].type()) {
        vector<ListFlowProjectUserResponseBodyUsersUser> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["User"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowProjectUserResponseBodyUsersUser model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        user = make_shared<vector<ListFlowProjectUserResponseBodyUsersUser>>(expect1);
      }
    }
  }


  virtual ~ListFlowProjectUserResponseBodyUsers() = default;
};
class ListFlowProjectUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};
  shared_ptr<ListFlowProjectUserResponseBodyUsers> users{};

  ListFlowProjectUserResponseBody() {}

  explicit ListFlowProjectUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (users) {
      res["Users"] = users ? boost::any(users->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      if (typeid(map<string, boost::any>) == m["Users"].type()) {
        ListFlowProjectUserResponseBodyUsers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Users"]));
        users = make_shared<ListFlowProjectUserResponseBodyUsers>(model1);
      }
    }
  }


  virtual ~ListFlowProjectUserResponseBody() = default;
};
class ListFlowProjectUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFlowProjectUserResponseBody> body{};

  ListFlowProjectUserResponse() {}

  explicit ListFlowProjectUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowProjectUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowProjectUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowProjectUserResponse() = default;
};
class ListResourcePoolRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> poolType{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};

  ListResourcePoolRequest() {}

  explicit ListResourcePoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (poolType) {
      res["PoolType"] = boost::any(*poolType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PoolType") != m.end() && !m["PoolType"].empty()) {
      poolType = make_shared<string>(boost::any_cast<string>(m["PoolType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListResourcePoolRequest() = default;
};
class ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePool : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> note{};
  shared_ptr<string> poolType{};
  shared_ptr<string> userId{};
  shared_ptr<string> yarnSiteConfig{};

  ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePool() {}

  explicit ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (poolType) {
      res["PoolType"] = boost::any(*poolType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (yarnSiteConfig) {
      res["YarnSiteConfig"] = boost::any(*yarnSiteConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("PoolType") != m.end() && !m["PoolType"].empty()) {
      poolType = make_shared<string>(boost::any_cast<string>(m["PoolType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("YarnSiteConfig") != m.end() && !m["YarnSiteConfig"].empty()) {
      yarnSiteConfig = make_shared<string>(boost::any_cast<string>(m["YarnSiteConfig"]));
    }
  }


  virtual ~ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePool() = default;
};
class ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePoolConfigListEcmResourcePoolConfig : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> configKey{};
  shared_ptr<string> configType{};
  shared_ptr<string> configValue{};
  shared_ptr<long> id{};
  shared_ptr<string> note{};
  shared_ptr<string> status{};

  ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePoolConfigListEcmResourcePoolConfig() {}

  explicit ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePoolConfigListEcmResourcePoolConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (configKey) {
      res["ConfigKey"] = boost::any(*configKey);
    }
    if (configType) {
      res["ConfigType"] = boost::any(*configType);
    }
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("ConfigKey") != m.end() && !m["ConfigKey"].empty()) {
      configKey = make_shared<string>(boost::any_cast<string>(m["ConfigKey"]));
    }
    if (m.find("ConfigType") != m.end() && !m["ConfigType"].empty()) {
      configType = make_shared<string>(boost::any_cast<string>(m["ConfigType"]));
    }
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePoolConfigListEcmResourcePoolConfig() = default;
};
class ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePoolConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePoolConfigListEcmResourcePoolConfig>> ecmResourcePoolConfig{};

  ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePoolConfigList() {}

  explicit ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePoolConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecmResourcePoolConfig) {
      vector<boost::any> temp1;
      for(auto item1:*ecmResourcePoolConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EcmResourcePoolConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcmResourcePoolConfig") != m.end() && !m["EcmResourcePoolConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["EcmResourcePoolConfig"].type()) {
        vector<ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePoolConfigListEcmResourcePoolConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EcmResourcePoolConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePoolConfigListEcmResourcePoolConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ecmResourcePoolConfig = make_shared<vector<ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePoolConfigListEcmResourcePoolConfig>>(expect1);
      }
    }
  }


  virtual ~ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePoolConfigList() = default;
};
class ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourcePoolConfigListEcmResourcePoolConfig : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> configKey{};
  shared_ptr<string> configType{};
  shared_ptr<string> configValue{};
  shared_ptr<long> id{};
  shared_ptr<string> note{};
  shared_ptr<string> status{};

  ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourcePoolConfigListEcmResourcePoolConfig() {}

  explicit ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourcePoolConfigListEcmResourcePoolConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (configKey) {
      res["ConfigKey"] = boost::any(*configKey);
    }
    if (configType) {
      res["ConfigType"] = boost::any(*configType);
    }
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("ConfigKey") != m.end() && !m["ConfigKey"].empty()) {
      configKey = make_shared<string>(boost::any_cast<string>(m["ConfigKey"]));
    }
    if (m.find("ConfigType") != m.end() && !m["ConfigType"].empty()) {
      configType = make_shared<string>(boost::any_cast<string>(m["ConfigType"]));
    }
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourcePoolConfigListEcmResourcePoolConfig() = default;
};
class ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourcePoolConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourcePoolConfigListEcmResourcePoolConfig>> ecmResourcePoolConfig{};

  ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourcePoolConfigList() {}

  explicit ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourcePoolConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecmResourcePoolConfig) {
      vector<boost::any> temp1;
      for(auto item1:*ecmResourcePoolConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EcmResourcePoolConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcmResourcePoolConfig") != m.end() && !m["EcmResourcePoolConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["EcmResourcePoolConfig"].type()) {
        vector<ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourcePoolConfigListEcmResourcePoolConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EcmResourcePoolConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourcePoolConfigListEcmResourcePoolConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ecmResourcePoolConfig = make_shared<vector<ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourcePoolConfigListEcmResourcePoolConfig>>(expect1);
      }
    }
  }


  virtual ~ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourcePoolConfigList() = default;
};
class ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourceQueue : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<bool> leaf{};
  shared_ptr<string> name{};
  shared_ptr<long> parentQueueId{};
  shared_ptr<string> qualifiedName{};
  shared_ptr<string> queueType{};
  shared_ptr<long> resourcePoolId{};
  shared_ptr<string> status{};
  shared_ptr<string> userId{};

  ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourceQueue() {}

  explicit ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourceQueue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (leaf) {
      res["Leaf"] = boost::any(*leaf);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentQueueId) {
      res["ParentQueueId"] = boost::any(*parentQueueId);
    }
    if (qualifiedName) {
      res["QualifiedName"] = boost::any(*qualifiedName);
    }
    if (queueType) {
      res["QueueType"] = boost::any(*queueType);
    }
    if (resourcePoolId) {
      res["ResourcePoolId"] = boost::any(*resourcePoolId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Leaf") != m.end() && !m["Leaf"].empty()) {
      leaf = make_shared<bool>(boost::any_cast<bool>(m["Leaf"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentQueueId") != m.end() && !m["ParentQueueId"].empty()) {
      parentQueueId = make_shared<long>(boost::any_cast<long>(m["ParentQueueId"]));
    }
    if (m.find("QualifiedName") != m.end() && !m["QualifiedName"].empty()) {
      qualifiedName = make_shared<string>(boost::any_cast<string>(m["QualifiedName"]));
    }
    if (m.find("QueueType") != m.end() && !m["QueueType"].empty()) {
      queueType = make_shared<string>(boost::any_cast<string>(m["QueueType"]));
    }
    if (m.find("ResourcePoolId") != m.end() && !m["ResourcePoolId"].empty()) {
      resourcePoolId = make_shared<long>(boost::any_cast<long>(m["ResourcePoolId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourceQueue() = default;
};
class ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueue : public Darabonba::Model {
public:
  shared_ptr<ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourcePoolConfigList> ecmResourcePoolConfigList{};
  shared_ptr<ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourceQueue> ecmResourceQueue{};

  ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueue() {}

  explicit ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecmResourcePoolConfigList) {
      res["EcmResourcePoolConfigList"] = ecmResourcePoolConfigList ? boost::any(ecmResourcePoolConfigList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ecmResourceQueue) {
      res["EcmResourceQueue"] = ecmResourceQueue ? boost::any(ecmResourceQueue->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcmResourcePoolConfigList") != m.end() && !m["EcmResourcePoolConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EcmResourcePoolConfigList"].type()) {
        ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourcePoolConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EcmResourcePoolConfigList"]));
        ecmResourcePoolConfigList = make_shared<ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourcePoolConfigList>(model1);
      }
    }
    if (m.find("EcmResourceQueue") != m.end() && !m["EcmResourceQueue"].empty()) {
      if (typeid(map<string, boost::any>) == m["EcmResourceQueue"].type()) {
        ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourceQueue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EcmResourceQueue"]));
        ecmResourceQueue = make_shared<ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueueEcmResourceQueue>(model1);
      }
    }
  }


  virtual ~ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueue() = default;
};
class ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueList : public Darabonba::Model {
public:
  shared_ptr<vector<ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueue>> queue{};

  ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueList() {}

  explicit ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queue) {
      vector<boost::any> temp1;
      for(auto item1:*queue){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Queue"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      if (typeid(vector<boost::any>) == m["Queue"].type()) {
        vector<ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Queue"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        queue = make_shared<vector<ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueListQueue>>(expect1);
      }
    }
  }


  virtual ~ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueList() = default;
};
class ListResourcePoolResponseBodyPoolInfoListPoolInfo : public Darabonba::Model {
public:
  shared_ptr<ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePool> ecmResourcePool{};
  shared_ptr<ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePoolConfigList> ecmResourcePoolConfigList{};
  shared_ptr<ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueList> queueList{};

  ListResourcePoolResponseBodyPoolInfoListPoolInfo() {}

  explicit ListResourcePoolResponseBodyPoolInfoListPoolInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecmResourcePool) {
      res["EcmResourcePool"] = ecmResourcePool ? boost::any(ecmResourcePool->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ecmResourcePoolConfigList) {
      res["EcmResourcePoolConfigList"] = ecmResourcePoolConfigList ? boost::any(ecmResourcePoolConfigList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (queueList) {
      res["QueueList"] = queueList ? boost::any(queueList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcmResourcePool") != m.end() && !m["EcmResourcePool"].empty()) {
      if (typeid(map<string, boost::any>) == m["EcmResourcePool"].type()) {
        ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePool model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EcmResourcePool"]));
        ecmResourcePool = make_shared<ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePool>(model1);
      }
    }
    if (m.find("EcmResourcePoolConfigList") != m.end() && !m["EcmResourcePoolConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EcmResourcePoolConfigList"].type()) {
        ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePoolConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EcmResourcePoolConfigList"]));
        ecmResourcePoolConfigList = make_shared<ListResourcePoolResponseBodyPoolInfoListPoolInfoEcmResourcePoolConfigList>(model1);
      }
    }
    if (m.find("QueueList") != m.end() && !m["QueueList"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueueList"].type()) {
        ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QueueList"]));
        queueList = make_shared<ListResourcePoolResponseBodyPoolInfoListPoolInfoQueueList>(model1);
      }
    }
  }


  virtual ~ListResourcePoolResponseBodyPoolInfoListPoolInfo() = default;
};
class ListResourcePoolResponseBodyPoolInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<ListResourcePoolResponseBodyPoolInfoListPoolInfo>> poolInfo{};

  ListResourcePoolResponseBodyPoolInfoList() {}

  explicit ListResourcePoolResponseBodyPoolInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (poolInfo) {
      vector<boost::any> temp1;
      for(auto item1:*poolInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PoolInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PoolInfo") != m.end() && !m["PoolInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PoolInfo"].type()) {
        vector<ListResourcePoolResponseBodyPoolInfoListPoolInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PoolInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourcePoolResponseBodyPoolInfoListPoolInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        poolInfo = make_shared<vector<ListResourcePoolResponseBodyPoolInfoListPoolInfo>>(expect1);
      }
    }
  }


  virtual ~ListResourcePoolResponseBodyPoolInfoList() = default;
};
class ListResourcePoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<ListResourcePoolResponseBodyPoolInfoList> poolInfoList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  ListResourcePoolResponseBody() {}

  explicit ListResourcePoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (poolInfoList) {
      res["PoolInfoList"] = poolInfoList ? boost::any(poolInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PoolInfoList") != m.end() && !m["PoolInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PoolInfoList"].type()) {
        ListResourcePoolResponseBodyPoolInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PoolInfoList"]));
        poolInfoList = make_shared<ListResourcePoolResponseBodyPoolInfoList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListResourcePoolResponseBody() = default;
};
class ListResourcePoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListResourcePoolResponseBody> body{};

  ListResourcePoolResponse() {}

  explicit ListResourcePoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListResourcePoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListResourcePoolResponseBody>(model1);
      }
    }
  }


  virtual ~ListResourcePoolResponse() = default;
};
class ListScalingActivityV2Request : public Darabonba::Model {
public:
  shared_ptr<string> clusterBizId{};
  shared_ptr<long> currentSize{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<long> limit{};
  shared_ptr<string> orderField{};
  shared_ptr<string> orderMode{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingGroupBizId{};
  shared_ptr<string> scalingRuleName{};
  shared_ptr<string> status{};

  ListScalingActivityV2Request() {}

  explicit ListScalingActivityV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterBizId) {
      res["ClusterBizId"] = boost::any(*clusterBizId);
    }
    if (currentSize) {
      res["CurrentSize"] = boost::any(*currentSize);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (orderField) {
      res["OrderField"] = boost::any(*orderField);
    }
    if (orderMode) {
      res["OrderMode"] = boost::any(*orderMode);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    if (scalingRuleName) {
      res["ScalingRuleName"] = boost::any(*scalingRuleName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterBizId") != m.end() && !m["ClusterBizId"].empty()) {
      clusterBizId = make_shared<string>(boost::any_cast<string>(m["ClusterBizId"]));
    }
    if (m.find("CurrentSize") != m.end() && !m["CurrentSize"].empty()) {
      currentSize = make_shared<long>(boost::any_cast<long>(m["CurrentSize"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("OrderField") != m.end() && !m["OrderField"].empty()) {
      orderField = make_shared<string>(boost::any_cast<string>(m["OrderField"]));
    }
    if (m.find("OrderMode") != m.end() && !m["OrderMode"].empty()) {
      orderMode = make_shared<string>(boost::any_cast<string>(m["OrderMode"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
    if (m.find("ScalingRuleName") != m.end() && !m["ScalingRuleName"].empty()) {
      scalingRuleName = make_shared<string>(boost::any_cast<string>(m["ScalingRuleName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListScalingActivityV2Request() = default;
};
class ListScalingActivityV2ResponseBodyItemsItem : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> cause{};
  shared_ptr<string> description{};
  shared_ptr<long> endTime{};
  shared_ptr<long> expectNum{};
  shared_ptr<string> hostGroupBizId{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> scalingRuleId{};
  shared_ptr<string> scalingRuleName{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<long> totalCapacity{};
  shared_ptr<string> transition{};

  ListScalingActivityV2ResponseBodyItemsItem() {}

  explicit ListScalingActivityV2ResponseBodyItemsItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (cause) {
      res["Cause"] = boost::any(*cause);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (expectNum) {
      res["ExpectNum"] = boost::any(*expectNum);
    }
    if (hostGroupBizId) {
      res["HostGroupBizId"] = boost::any(*hostGroupBizId);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (scalingRuleId) {
      res["ScalingRuleId"] = boost::any(*scalingRuleId);
    }
    if (scalingRuleName) {
      res["ScalingRuleName"] = boost::any(*scalingRuleName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalCapacity) {
      res["TotalCapacity"] = boost::any(*totalCapacity);
    }
    if (transition) {
      res["Transition"] = boost::any(*transition);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Cause") != m.end() && !m["Cause"].empty()) {
      cause = make_shared<string>(boost::any_cast<string>(m["Cause"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ExpectNum") != m.end() && !m["ExpectNum"].empty()) {
      expectNum = make_shared<long>(boost::any_cast<long>(m["ExpectNum"]));
    }
    if (m.find("HostGroupBizId") != m.end() && !m["HostGroupBizId"].empty()) {
      hostGroupBizId = make_shared<string>(boost::any_cast<string>(m["HostGroupBizId"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("ScalingRuleId") != m.end() && !m["ScalingRuleId"].empty()) {
      scalingRuleId = make_shared<string>(boost::any_cast<string>(m["ScalingRuleId"]));
    }
    if (m.find("ScalingRuleName") != m.end() && !m["ScalingRuleName"].empty()) {
      scalingRuleName = make_shared<string>(boost::any_cast<string>(m["ScalingRuleName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TotalCapacity") != m.end() && !m["TotalCapacity"].empty()) {
      totalCapacity = make_shared<long>(boost::any_cast<long>(m["TotalCapacity"]));
    }
    if (m.find("Transition") != m.end() && !m["Transition"].empty()) {
      transition = make_shared<string>(boost::any_cast<string>(m["Transition"]));
    }
  }


  virtual ~ListScalingActivityV2ResponseBodyItemsItem() = default;
};
class ListScalingActivityV2ResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<ListScalingActivityV2ResponseBodyItemsItem>> item{};

  ListScalingActivityV2ResponseBodyItems() {}

  explicit ListScalingActivityV2ResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<ListScalingActivityV2ResponseBodyItemsItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScalingActivityV2ResponseBodyItemsItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<ListScalingActivityV2ResponseBodyItemsItem>>(expect1);
      }
    }
  }


  virtual ~ListScalingActivityV2ResponseBodyItems() = default;
};
class ListScalingActivityV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListScalingActivityV2ResponseBodyItems> items{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListScalingActivityV2ResponseBody() {}

  explicit ListScalingActivityV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        ListScalingActivityV2ResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<ListScalingActivityV2ResponseBodyItems>(model1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListScalingActivityV2ResponseBody() = default;
};
class ListScalingActivityV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListScalingActivityV2ResponseBody> body{};

  ListScalingActivityV2Response() {}

  explicit ListScalingActivityV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListScalingActivityV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListScalingActivityV2ResponseBody>(model1);
      }
    }
  }


  virtual ~ListScalingActivityV2Response() = default;
};
class ListScalingConfigItemV2Request : public Darabonba::Model {
public:
  shared_ptr<string> configItemType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingGroupBizId{};

  ListScalingConfigItemV2Request() {}

  explicit ListScalingConfigItemV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configItemType) {
      res["ConfigItemType"] = boost::any(*configItemType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigItemType") != m.end() && !m["ConfigItemType"].empty()) {
      configItemType = make_shared<string>(boost::any_cast<string>(m["ConfigItemType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
  }


  virtual ~ListScalingConfigItemV2Request() = default;
};
class ListScalingConfigItemV2ResponseBodyItemsItem : public Darabonba::Model {
public:
  shared_ptr<string> configItemInformation{};
  shared_ptr<string> configItemType{};
  shared_ptr<string> scalingConfigItemBizId{};
  shared_ptr<string> scalingGroupBizId{};

  ListScalingConfigItemV2ResponseBodyItemsItem() {}

  explicit ListScalingConfigItemV2ResponseBodyItemsItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configItemInformation) {
      res["ConfigItemInformation"] = boost::any(*configItemInformation);
    }
    if (configItemType) {
      res["ConfigItemType"] = boost::any(*configItemType);
    }
    if (scalingConfigItemBizId) {
      res["ScalingConfigItemBizId"] = boost::any(*scalingConfigItemBizId);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigItemInformation") != m.end() && !m["ConfigItemInformation"].empty()) {
      configItemInformation = make_shared<string>(boost::any_cast<string>(m["ConfigItemInformation"]));
    }
    if (m.find("ConfigItemType") != m.end() && !m["ConfigItemType"].empty()) {
      configItemType = make_shared<string>(boost::any_cast<string>(m["ConfigItemType"]));
    }
    if (m.find("ScalingConfigItemBizId") != m.end() && !m["ScalingConfigItemBizId"].empty()) {
      scalingConfigItemBizId = make_shared<string>(boost::any_cast<string>(m["ScalingConfigItemBizId"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
  }


  virtual ~ListScalingConfigItemV2ResponseBodyItemsItem() = default;
};
class ListScalingConfigItemV2ResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<ListScalingConfigItemV2ResponseBodyItemsItem>> item{};

  ListScalingConfigItemV2ResponseBodyItems() {}

  explicit ListScalingConfigItemV2ResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<ListScalingConfigItemV2ResponseBodyItemsItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScalingConfigItemV2ResponseBodyItemsItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<ListScalingConfigItemV2ResponseBodyItemsItem>>(expect1);
      }
    }
  }


  virtual ~ListScalingConfigItemV2ResponseBodyItems() = default;
};
class ListScalingConfigItemV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListScalingConfigItemV2ResponseBodyItems> items{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListScalingConfigItemV2ResponseBody() {}

  explicit ListScalingConfigItemV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        ListScalingConfigItemV2ResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<ListScalingConfigItemV2ResponseBodyItems>(model1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListScalingConfigItemV2ResponseBody() = default;
};
class ListScalingConfigItemV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListScalingConfigItemV2ResponseBody> body{};

  ListScalingConfigItemV2Response() {}

  explicit ListScalingConfigItemV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListScalingConfigItemV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListScalingConfigItemV2ResponseBody>(model1);
      }
    }
  }


  virtual ~ListScalingConfigItemV2Response() = default;
};
class ListScalingGroupV2Request : public Darabonba::Model {
public:
  shared_ptr<string> clusterBizId{};
  shared_ptr<long> currentSize{};
  shared_ptr<long> limit{};
  shared_ptr<string> orderField{};
  shared_ptr<string> orderMode{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};

  ListScalingGroupV2Request() {}

  explicit ListScalingGroupV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterBizId) {
      res["ClusterBizId"] = boost::any(*clusterBizId);
    }
    if (currentSize) {
      res["CurrentSize"] = boost::any(*currentSize);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (orderField) {
      res["OrderField"] = boost::any(*orderField);
    }
    if (orderMode) {
      res["OrderMode"] = boost::any(*orderMode);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterBizId") != m.end() && !m["ClusterBizId"].empty()) {
      clusterBizId = make_shared<string>(boost::any_cast<string>(m["ClusterBizId"]));
    }
    if (m.find("CurrentSize") != m.end() && !m["CurrentSize"].empty()) {
      currentSize = make_shared<long>(boost::any_cast<long>(m["CurrentSize"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("OrderField") != m.end() && !m["OrderField"].empty()) {
      orderField = make_shared<string>(boost::any_cast<string>(m["OrderField"]));
    }
    if (m.find("OrderMode") != m.end() && !m["OrderMode"].empty()) {
      orderMode = make_shared<string>(boost::any_cast<string>(m["OrderMode"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListScalingGroupV2Request() = default;
};
class ListScalingGroupV2ResponseBodyItemsItem : public Darabonba::Model {
public:
  shared_ptr<string> activeStatus{};
  shared_ptr<string> description{};
  shared_ptr<string> hostGroupBizId{};
  shared_ptr<string> name{};
  shared_ptr<string> scalingGroupId{};
  shared_ptr<string> scalingInMode{};
  shared_ptr<long> scalingMaxSize{};
  shared_ptr<long> scalingMinSize{};

  ListScalingGroupV2ResponseBodyItemsItem() {}

  explicit ListScalingGroupV2ResponseBodyItemsItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeStatus) {
      res["ActiveStatus"] = boost::any(*activeStatus);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hostGroupBizId) {
      res["HostGroupBizId"] = boost::any(*hostGroupBizId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (scalingGroupId) {
      res["ScalingGroupId"] = boost::any(*scalingGroupId);
    }
    if (scalingInMode) {
      res["ScalingInMode"] = boost::any(*scalingInMode);
    }
    if (scalingMaxSize) {
      res["ScalingMaxSize"] = boost::any(*scalingMaxSize);
    }
    if (scalingMinSize) {
      res["ScalingMinSize"] = boost::any(*scalingMinSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveStatus") != m.end() && !m["ActiveStatus"].empty()) {
      activeStatus = make_shared<string>(boost::any_cast<string>(m["ActiveStatus"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HostGroupBizId") != m.end() && !m["HostGroupBizId"].empty()) {
      hostGroupBizId = make_shared<string>(boost::any_cast<string>(m["HostGroupBizId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ScalingGroupId") != m.end() && !m["ScalingGroupId"].empty()) {
      scalingGroupId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupId"]));
    }
    if (m.find("ScalingInMode") != m.end() && !m["ScalingInMode"].empty()) {
      scalingInMode = make_shared<string>(boost::any_cast<string>(m["ScalingInMode"]));
    }
    if (m.find("ScalingMaxSize") != m.end() && !m["ScalingMaxSize"].empty()) {
      scalingMaxSize = make_shared<long>(boost::any_cast<long>(m["ScalingMaxSize"]));
    }
    if (m.find("ScalingMinSize") != m.end() && !m["ScalingMinSize"].empty()) {
      scalingMinSize = make_shared<long>(boost::any_cast<long>(m["ScalingMinSize"]));
    }
  }


  virtual ~ListScalingGroupV2ResponseBodyItemsItem() = default;
};
class ListScalingGroupV2ResponseBodyItems : public Darabonba::Model {
public:
  shared_ptr<vector<ListScalingGroupV2ResponseBodyItemsItem>> item{};

  ListScalingGroupV2ResponseBodyItems() {}

  explicit ListScalingGroupV2ResponseBodyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<ListScalingGroupV2ResponseBodyItemsItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScalingGroupV2ResponseBodyItemsItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<ListScalingGroupV2ResponseBodyItemsItem>>(expect1);
      }
    }
  }


  virtual ~ListScalingGroupV2ResponseBodyItems() = default;
};
class ListScalingGroupV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListScalingGroupV2ResponseBodyItems> items{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListScalingGroupV2ResponseBody() {}

  explicit ListScalingGroupV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      res["Items"] = items ? boost::any(items->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(map<string, boost::any>) == m["Items"].type()) {
        ListScalingGroupV2ResponseBodyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Items"]));
        items = make_shared<ListScalingGroupV2ResponseBodyItems>(model1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListScalingGroupV2ResponseBody() = default;
};
class ListScalingGroupV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListScalingGroupV2ResponseBody> body{};

  ListScalingGroupV2Response() {}

  explicit ListScalingGroupV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListScalingGroupV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListScalingGroupV2ResponseBody>(model1);
      }
    }
  }


  virtual ~ListScalingGroupV2Response() = default;
};
class ListTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesRequestTag() {}

  explicit ListTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesRequestTag() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<ListTagResourcesRequestTag>> tag{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListTagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResourcesTagResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResourcesTagResource() {}

  explicit ListTagResourcesResponseBodyTagResourcesTagResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResourcesTagResource() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<vector<ListTagResourcesResponseBodyTagResourcesTagResource>> tagResource{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagResource) {
      vector<boost::any> temp1;
      for(auto item1:*tagResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagResource") != m.end() && !m["TagResource"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResource"].type()) {
        vector<ListTagResourcesResponseBodyTagResourcesTagResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResourcesTagResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResource = make_shared<vector<ListTagResourcesResponseBodyTagResourcesTagResource>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<ListTagResourcesResponseBodyTagResources> tagResources{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      res["TagResources"] = tagResources ? boost::any(tagResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagResources"].type()) {
        ListTagResourcesResponseBodyTagResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagResources"]));
        tagResources = make_shared<ListTagResourcesResponseBodyTagResources>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ModifyClusterNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};

  ModifyClusterNameRequest() {}

  explicit ModifyClusterNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ModifyClusterNameRequest() = default;
};
class ModifyClusterNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyClusterNameResponseBody() {}

  explicit ModifyClusterNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyClusterNameResponseBody() = default;
};
class ModifyClusterNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyClusterNameResponseBody> body{};

  ModifyClusterNameResponse() {}

  explicit ModifyClusterNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyClusterNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyClusterNameResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyClusterNameResponse() = default;
};
class ModifyClusterServiceConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> comment{};
  shared_ptr<string> configParams{};
  shared_ptr<string> configType{};
  shared_ptr<string> customConfigParams{};
  shared_ptr<vector<string>> gatewayClusterIdList{};
  shared_ptr<string> groupId{};
  shared_ptr<string> hostInstanceId{};
  shared_ptr<bool> refreshHostConfig{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> serviceName{};

  ModifyClusterServiceConfigRequest() {}

  explicit ModifyClusterServiceConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (configParams) {
      res["ConfigParams"] = boost::any(*configParams);
    }
    if (configType) {
      res["ConfigType"] = boost::any(*configType);
    }
    if (customConfigParams) {
      res["CustomConfigParams"] = boost::any(*customConfigParams);
    }
    if (gatewayClusterIdList) {
      res["GatewayClusterIdList"] = boost::any(*gatewayClusterIdList);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (hostInstanceId) {
      res["HostInstanceId"] = boost::any(*hostInstanceId);
    }
    if (refreshHostConfig) {
      res["RefreshHostConfig"] = boost::any(*refreshHostConfig);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ConfigParams") != m.end() && !m["ConfigParams"].empty()) {
      configParams = make_shared<string>(boost::any_cast<string>(m["ConfigParams"]));
    }
    if (m.find("ConfigType") != m.end() && !m["ConfigType"].empty()) {
      configType = make_shared<string>(boost::any_cast<string>(m["ConfigType"]));
    }
    if (m.find("CustomConfigParams") != m.end() && !m["CustomConfigParams"].empty()) {
      customConfigParams = make_shared<string>(boost::any_cast<string>(m["CustomConfigParams"]));
    }
    if (m.find("GatewayClusterIdList") != m.end() && !m["GatewayClusterIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GatewayClusterIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GatewayClusterIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      gatewayClusterIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HostInstanceId") != m.end() && !m["HostInstanceId"].empty()) {
      hostInstanceId = make_shared<string>(boost::any_cast<string>(m["HostInstanceId"]));
    }
    if (m.find("RefreshHostConfig") != m.end() && !m["RefreshHostConfig"].empty()) {
      refreshHostConfig = make_shared<bool>(boost::any_cast<bool>(m["RefreshHostConfig"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~ModifyClusterServiceConfigRequest() = default;
};
class ModifyClusterServiceConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyClusterServiceConfigResponseBody() {}

  explicit ModifyClusterServiceConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyClusterServiceConfigResponseBody() = default;
};
class ModifyClusterServiceConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyClusterServiceConfigResponseBody> body{};

  ModifyClusterServiceConfigResponse() {}

  explicit ModifyClusterServiceConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyClusterServiceConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyClusterServiceConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyClusterServiceConfigResponse() = default;
};
class ModifyClusterTemplateRequestBootstrapAction : public Darabonba::Model {
public:
  shared_ptr<string> arg{};
  shared_ptr<string> executionFailStrategy{};
  shared_ptr<string> executionMoment{};
  shared_ptr<string> executionTarget{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};

  ModifyClusterTemplateRequestBootstrapAction() {}

  explicit ModifyClusterTemplateRequestBootstrapAction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arg) {
      res["Arg"] = boost::any(*arg);
    }
    if (executionFailStrategy) {
      res["ExecutionFailStrategy"] = boost::any(*executionFailStrategy);
    }
    if (executionMoment) {
      res["ExecutionMoment"] = boost::any(*executionMoment);
    }
    if (executionTarget) {
      res["ExecutionTarget"] = boost::any(*executionTarget);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arg") != m.end() && !m["Arg"].empty()) {
      arg = make_shared<string>(boost::any_cast<string>(m["Arg"]));
    }
    if (m.find("ExecutionFailStrategy") != m.end() && !m["ExecutionFailStrategy"].empty()) {
      executionFailStrategy = make_shared<string>(boost::any_cast<string>(m["ExecutionFailStrategy"]));
    }
    if (m.find("ExecutionMoment") != m.end() && !m["ExecutionMoment"].empty()) {
      executionMoment = make_shared<string>(boost::any_cast<string>(m["ExecutionMoment"]));
    }
    if (m.find("ExecutionTarget") != m.end() && !m["ExecutionTarget"].empty()) {
      executionTarget = make_shared<string>(boost::any_cast<string>(m["ExecutionTarget"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~ModifyClusterTemplateRequestBootstrapAction() = default;
};
class ModifyClusterTemplateRequestConfig : public Darabonba::Model {
public:
  shared_ptr<string> configKey{};
  shared_ptr<string> configValue{};
  shared_ptr<string> encrypt{};
  shared_ptr<string> fileName{};
  shared_ptr<string> replace{};
  shared_ptr<string> serviceName{};

  ModifyClusterTemplateRequestConfig() {}

  explicit ModifyClusterTemplateRequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configKey) {
      res["ConfigKey"] = boost::any(*configKey);
    }
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (encrypt) {
      res["Encrypt"] = boost::any(*encrypt);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (replace) {
      res["Replace"] = boost::any(*replace);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigKey") != m.end() && !m["ConfigKey"].empty()) {
      configKey = make_shared<string>(boost::any_cast<string>(m["ConfigKey"]));
    }
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("Encrypt") != m.end() && !m["Encrypt"].empty()) {
      encrypt = make_shared<string>(boost::any_cast<string>(m["Encrypt"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Replace") != m.end() && !m["Replace"].empty()) {
      replace = make_shared<string>(boost::any_cast<string>(m["Replace"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~ModifyClusterTemplateRequestConfig() = default;
};
class ModifyClusterTemplateRequestHostGroup : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> comment{};
  shared_ptr<string> createType{};
  shared_ptr<long> diskCapacity{};
  shared_ptr<long> diskCount{};
  shared_ptr<string> diskType{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<string> hostGroupType{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> multiInstanceTypes{};
  shared_ptr<long> nodeCount{};
  shared_ptr<long> period{};
  shared_ptr<long> sysDiskCapacity{};
  shared_ptr<string> sysDiskType{};
  shared_ptr<string> vSwitchId{};

  ModifyClusterTemplateRequestHostGroup() {}

  explicit ModifyClusterTemplateRequestHostGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (createType) {
      res["CreateType"] = boost::any(*createType);
    }
    if (diskCapacity) {
      res["DiskCapacity"] = boost::any(*diskCapacity);
    }
    if (diskCount) {
      res["DiskCount"] = boost::any(*diskCount);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (hostGroupType) {
      res["HostGroupType"] = boost::any(*hostGroupType);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (multiInstanceTypes) {
      res["MultiInstanceTypes"] = boost::any(*multiInstanceTypes);
    }
    if (nodeCount) {
      res["NodeCount"] = boost::any(*nodeCount);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (sysDiskCapacity) {
      res["SysDiskCapacity"] = boost::any(*sysDiskCapacity);
    }
    if (sysDiskType) {
      res["SysDiskType"] = boost::any(*sysDiskType);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreateType") != m.end() && !m["CreateType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["CreateType"]));
    }
    if (m.find("DiskCapacity") != m.end() && !m["DiskCapacity"].empty()) {
      diskCapacity = make_shared<long>(boost::any_cast<long>(m["DiskCapacity"]));
    }
    if (m.find("DiskCount") != m.end() && !m["DiskCount"].empty()) {
      diskCount = make_shared<long>(boost::any_cast<long>(m["DiskCount"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("HostGroupType") != m.end() && !m["HostGroupType"].empty()) {
      hostGroupType = make_shared<string>(boost::any_cast<string>(m["HostGroupType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("MultiInstanceTypes") != m.end() && !m["MultiInstanceTypes"].empty()) {
      multiInstanceTypes = make_shared<string>(boost::any_cast<string>(m["MultiInstanceTypes"]));
    }
    if (m.find("NodeCount") != m.end() && !m["NodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["NodeCount"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("SysDiskCapacity") != m.end() && !m["SysDiskCapacity"].empty()) {
      sysDiskCapacity = make_shared<long>(boost::any_cast<long>(m["SysDiskCapacity"]));
    }
    if (m.find("SysDiskType") != m.end() && !m["SysDiskType"].empty()) {
      sysDiskType = make_shared<string>(boost::any_cast<string>(m["SysDiskType"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~ModifyClusterTemplateRequestHostGroup() = default;
};
class ModifyClusterTemplateRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ModifyClusterTemplateRequestTag() {}

  explicit ModifyClusterTemplateRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyClusterTemplateRequestTag() = default;
};
class ModifyClusterTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> bizId{};
  shared_ptr<vector<ModifyClusterTemplateRequestBootstrapAction>> bootstrapAction{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> clusterType{};
  shared_ptr<vector<ModifyClusterTemplateRequestConfig>> config{};
  shared_ptr<string> configurations{};
  shared_ptr<bool> dataDiskEncrypted{};
  shared_ptr<string> dataDiskKMSKeyId{};
  shared_ptr<string> depositType{};
  shared_ptr<bool> easEnable{};
  shared_ptr<string> emrVer{};
  shared_ptr<bool> highAvailabilityEnable{};
  shared_ptr<vector<ModifyClusterTemplateRequestHostGroup>> hostGroup{};
  shared_ptr<bool> initCustomHiveMetaDb{};
  shared_ptr<string> instanceGeneration{};
  shared_ptr<bool> ioOptimized{};
  shared_ptr<bool> isOpenPublicIp{};
  shared_ptr<string> keyPairName{};
  shared_ptr<string> logPath{};
  shared_ptr<string> machineType{};
  shared_ptr<string> masterPwd{};
  shared_ptr<string> metaStoreConf{};
  shared_ptr<string> metaStoreType{};
  shared_ptr<string> netType{};
  shared_ptr<vector<string>> optionSoftWareList{};
  shared_ptr<long> period{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> securityGroupName{};
  shared_ptr<bool> sshEnable{};
  shared_ptr<vector<ModifyClusterTemplateRequestTag>> tag{};
  shared_ptr<string> templateName{};
  shared_ptr<bool> useCustomHiveMetaDb{};
  shared_ptr<bool> useLocalMetaDb{};
  shared_ptr<string> userDefinedEmrEcsRole{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};

  ModifyClusterTemplateRequest() {}

  explicit ModifyClusterTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bootstrapAction) {
      vector<boost::any> temp1;
      for(auto item1:*bootstrapAction){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BootstrapAction"] = boost::any(temp1);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (config) {
      vector<boost::any> temp1;
      for(auto item1:*config){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Config"] = boost::any(temp1);
    }
    if (configurations) {
      res["Configurations"] = boost::any(*configurations);
    }
    if (dataDiskEncrypted) {
      res["DataDiskEncrypted"] = boost::any(*dataDiskEncrypted);
    }
    if (dataDiskKMSKeyId) {
      res["DataDiskKMSKeyId"] = boost::any(*dataDiskKMSKeyId);
    }
    if (depositType) {
      res["DepositType"] = boost::any(*depositType);
    }
    if (easEnable) {
      res["EasEnable"] = boost::any(*easEnable);
    }
    if (emrVer) {
      res["EmrVer"] = boost::any(*emrVer);
    }
    if (highAvailabilityEnable) {
      res["HighAvailabilityEnable"] = boost::any(*highAvailabilityEnable);
    }
    if (hostGroup) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostGroup"] = boost::any(temp1);
    }
    if (initCustomHiveMetaDb) {
      res["InitCustomHiveMetaDb"] = boost::any(*initCustomHiveMetaDb);
    }
    if (instanceGeneration) {
      res["InstanceGeneration"] = boost::any(*instanceGeneration);
    }
    if (ioOptimized) {
      res["IoOptimized"] = boost::any(*ioOptimized);
    }
    if (isOpenPublicIp) {
      res["IsOpenPublicIp"] = boost::any(*isOpenPublicIp);
    }
    if (keyPairName) {
      res["KeyPairName"] = boost::any(*keyPairName);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (machineType) {
      res["MachineType"] = boost::any(*machineType);
    }
    if (masterPwd) {
      res["MasterPwd"] = boost::any(*masterPwd);
    }
    if (metaStoreConf) {
      res["MetaStoreConf"] = boost::any(*metaStoreConf);
    }
    if (metaStoreType) {
      res["MetaStoreType"] = boost::any(*metaStoreType);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (optionSoftWareList) {
      res["OptionSoftWareList"] = boost::any(*optionSoftWareList);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    if (sshEnable) {
      res["SshEnable"] = boost::any(*sshEnable);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (useCustomHiveMetaDb) {
      res["UseCustomHiveMetaDb"] = boost::any(*useCustomHiveMetaDb);
    }
    if (useLocalMetaDb) {
      res["UseLocalMetaDb"] = boost::any(*useLocalMetaDb);
    }
    if (userDefinedEmrEcsRole) {
      res["UserDefinedEmrEcsRole"] = boost::any(*userDefinedEmrEcsRole);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BootstrapAction") != m.end() && !m["BootstrapAction"].empty()) {
      if (typeid(vector<boost::any>) == m["BootstrapAction"].type()) {
        vector<ModifyClusterTemplateRequestBootstrapAction> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BootstrapAction"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyClusterTemplateRequestBootstrapAction model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bootstrapAction = make_shared<vector<ModifyClusterTemplateRequestBootstrapAction>>(expect1);
      }
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(vector<boost::any>) == m["Config"].type()) {
        vector<ModifyClusterTemplateRequestConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Config"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyClusterTemplateRequestConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        config = make_shared<vector<ModifyClusterTemplateRequestConfig>>(expect1);
      }
    }
    if (m.find("Configurations") != m.end() && !m["Configurations"].empty()) {
      configurations = make_shared<string>(boost::any_cast<string>(m["Configurations"]));
    }
    if (m.find("DataDiskEncrypted") != m.end() && !m["DataDiskEncrypted"].empty()) {
      dataDiskEncrypted = make_shared<bool>(boost::any_cast<bool>(m["DataDiskEncrypted"]));
    }
    if (m.find("DataDiskKMSKeyId") != m.end() && !m["DataDiskKMSKeyId"].empty()) {
      dataDiskKMSKeyId = make_shared<string>(boost::any_cast<string>(m["DataDiskKMSKeyId"]));
    }
    if (m.find("DepositType") != m.end() && !m["DepositType"].empty()) {
      depositType = make_shared<string>(boost::any_cast<string>(m["DepositType"]));
    }
    if (m.find("EasEnable") != m.end() && !m["EasEnable"].empty()) {
      easEnable = make_shared<bool>(boost::any_cast<bool>(m["EasEnable"]));
    }
    if (m.find("EmrVer") != m.end() && !m["EmrVer"].empty()) {
      emrVer = make_shared<string>(boost::any_cast<string>(m["EmrVer"]));
    }
    if (m.find("HighAvailabilityEnable") != m.end() && !m["HighAvailabilityEnable"].empty()) {
      highAvailabilityEnable = make_shared<bool>(boost::any_cast<bool>(m["HighAvailabilityEnable"]));
    }
    if (m.find("HostGroup") != m.end() && !m["HostGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["HostGroup"].type()) {
        vector<ModifyClusterTemplateRequestHostGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyClusterTemplateRequestHostGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroup = make_shared<vector<ModifyClusterTemplateRequestHostGroup>>(expect1);
      }
    }
    if (m.find("InitCustomHiveMetaDb") != m.end() && !m["InitCustomHiveMetaDb"].empty()) {
      initCustomHiveMetaDb = make_shared<bool>(boost::any_cast<bool>(m["InitCustomHiveMetaDb"]));
    }
    if (m.find("InstanceGeneration") != m.end() && !m["InstanceGeneration"].empty()) {
      instanceGeneration = make_shared<string>(boost::any_cast<string>(m["InstanceGeneration"]));
    }
    if (m.find("IoOptimized") != m.end() && !m["IoOptimized"].empty()) {
      ioOptimized = make_shared<bool>(boost::any_cast<bool>(m["IoOptimized"]));
    }
    if (m.find("IsOpenPublicIp") != m.end() && !m["IsOpenPublicIp"].empty()) {
      isOpenPublicIp = make_shared<bool>(boost::any_cast<bool>(m["IsOpenPublicIp"]));
    }
    if (m.find("KeyPairName") != m.end() && !m["KeyPairName"].empty()) {
      keyPairName = make_shared<string>(boost::any_cast<string>(m["KeyPairName"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("MachineType") != m.end() && !m["MachineType"].empty()) {
      machineType = make_shared<string>(boost::any_cast<string>(m["MachineType"]));
    }
    if (m.find("MasterPwd") != m.end() && !m["MasterPwd"].empty()) {
      masterPwd = make_shared<string>(boost::any_cast<string>(m["MasterPwd"]));
    }
    if (m.find("MetaStoreConf") != m.end() && !m["MetaStoreConf"].empty()) {
      metaStoreConf = make_shared<string>(boost::any_cast<string>(m["MetaStoreConf"]));
    }
    if (m.find("MetaStoreType") != m.end() && !m["MetaStoreType"].empty()) {
      metaStoreType = make_shared<string>(boost::any_cast<string>(m["MetaStoreType"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("OptionSoftWareList") != m.end() && !m["OptionSoftWareList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OptionSoftWareList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OptionSoftWareList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      optionSoftWareList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
    if (m.find("SshEnable") != m.end() && !m["SshEnable"].empty()) {
      sshEnable = make_shared<bool>(boost::any_cast<bool>(m["SshEnable"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ModifyClusterTemplateRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyClusterTemplateRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ModifyClusterTemplateRequestTag>>(expect1);
      }
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("UseCustomHiveMetaDb") != m.end() && !m["UseCustomHiveMetaDb"].empty()) {
      useCustomHiveMetaDb = make_shared<bool>(boost::any_cast<bool>(m["UseCustomHiveMetaDb"]));
    }
    if (m.find("UseLocalMetaDb") != m.end() && !m["UseLocalMetaDb"].empty()) {
      useLocalMetaDb = make_shared<bool>(boost::any_cast<bool>(m["UseLocalMetaDb"]));
    }
    if (m.find("UserDefinedEmrEcsRole") != m.end() && !m["UserDefinedEmrEcsRole"].empty()) {
      userDefinedEmrEcsRole = make_shared<string>(boost::any_cast<string>(m["UserDefinedEmrEcsRole"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~ModifyClusterTemplateRequest() = default;
};
class ModifyClusterTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterTemplateId{};
  shared_ptr<string> requestId{};

  ModifyClusterTemplateResponseBody() {}

  explicit ModifyClusterTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterTemplateId) {
      res["ClusterTemplateId"] = boost::any(*clusterTemplateId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterTemplateId") != m.end() && !m["ClusterTemplateId"].empty()) {
      clusterTemplateId = make_shared<string>(boost::any_cast<string>(m["ClusterTemplateId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyClusterTemplateResponseBody() = default;
};
class ModifyClusterTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyClusterTemplateResponseBody> body{};

  ModifyClusterTemplateResponse() {}

  explicit ModifyClusterTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyClusterTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyClusterTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyClusterTemplateResponse() = default;
};
class ModifyFlowCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> parentId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  ModifyFlowCategoryRequest() {}

  explicit ModifyFlowCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyFlowCategoryRequest() = default;
};
class ModifyFlowCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  ModifyFlowCategoryResponseBody() {}

  explicit ModifyFlowCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyFlowCategoryResponseBody() = default;
};
class ModifyFlowCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyFlowCategoryResponseBody> body{};

  ModifyFlowCategoryResponse() {}

  explicit ModifyFlowCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyFlowCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyFlowCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyFlowCategoryResponse() = default;
};
class ModifyFlowForWebRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertConf{};
  shared_ptr<string> alertDingDingGroupBizId{};
  shared_ptr<string> alertUserGroupBizId{};
  shared_ptr<string> clusterId{};
  shared_ptr<bool> createCluster{};
  shared_ptr<string> cronExpr{};
  shared_ptr<string> description{};
  shared_ptr<long> endSchedule{};
  shared_ptr<string> graph{};
  shared_ptr<string> hostName{};
  shared_ptr<string> id{};
  shared_ptr<string> lifecycle{};
  shared_ptr<string> logArchiveLocation{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> parentCategory{};
  shared_ptr<string> parentFlowList{};
  shared_ptr<bool> periodic{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startSchedule{};
  shared_ptr<string> status{};

  ModifyFlowForWebRequest() {}

  explicit ModifyFlowForWebRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertConf) {
      res["AlertConf"] = boost::any(*alertConf);
    }
    if (alertDingDingGroupBizId) {
      res["AlertDingDingGroupBizId"] = boost::any(*alertDingDingGroupBizId);
    }
    if (alertUserGroupBizId) {
      res["AlertUserGroupBizId"] = boost::any(*alertUserGroupBizId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (createCluster) {
      res["CreateCluster"] = boost::any(*createCluster);
    }
    if (cronExpr) {
      res["CronExpr"] = boost::any(*cronExpr);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endSchedule) {
      res["EndSchedule"] = boost::any(*endSchedule);
    }
    if (graph) {
      res["Graph"] = boost::any(*graph);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lifecycle) {
      res["Lifecycle"] = boost::any(*lifecycle);
    }
    if (logArchiveLocation) {
      res["LogArchiveLocation"] = boost::any(*logArchiveLocation);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (parentCategory) {
      res["ParentCategory"] = boost::any(*parentCategory);
    }
    if (parentFlowList) {
      res["ParentFlowList"] = boost::any(*parentFlowList);
    }
    if (periodic) {
      res["Periodic"] = boost::any(*periodic);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startSchedule) {
      res["StartSchedule"] = boost::any(*startSchedule);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertConf") != m.end() && !m["AlertConf"].empty()) {
      alertConf = make_shared<string>(boost::any_cast<string>(m["AlertConf"]));
    }
    if (m.find("AlertDingDingGroupBizId") != m.end() && !m["AlertDingDingGroupBizId"].empty()) {
      alertDingDingGroupBizId = make_shared<string>(boost::any_cast<string>(m["AlertDingDingGroupBizId"]));
    }
    if (m.find("AlertUserGroupBizId") != m.end() && !m["AlertUserGroupBizId"].empty()) {
      alertUserGroupBizId = make_shared<string>(boost::any_cast<string>(m["AlertUserGroupBizId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CreateCluster") != m.end() && !m["CreateCluster"].empty()) {
      createCluster = make_shared<bool>(boost::any_cast<bool>(m["CreateCluster"]));
    }
    if (m.find("CronExpr") != m.end() && !m["CronExpr"].empty()) {
      cronExpr = make_shared<string>(boost::any_cast<string>(m["CronExpr"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndSchedule") != m.end() && !m["EndSchedule"].empty()) {
      endSchedule = make_shared<long>(boost::any_cast<long>(m["EndSchedule"]));
    }
    if (m.find("Graph") != m.end() && !m["Graph"].empty()) {
      graph = make_shared<string>(boost::any_cast<string>(m["Graph"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Lifecycle") != m.end() && !m["Lifecycle"].empty()) {
      lifecycle = make_shared<string>(boost::any_cast<string>(m["Lifecycle"]));
    }
    if (m.find("LogArchiveLocation") != m.end() && !m["LogArchiveLocation"].empty()) {
      logArchiveLocation = make_shared<string>(boost::any_cast<string>(m["LogArchiveLocation"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("ParentCategory") != m.end() && !m["ParentCategory"].empty()) {
      parentCategory = make_shared<string>(boost::any_cast<string>(m["ParentCategory"]));
    }
    if (m.find("ParentFlowList") != m.end() && !m["ParentFlowList"].empty()) {
      parentFlowList = make_shared<string>(boost::any_cast<string>(m["ParentFlowList"]));
    }
    if (m.find("Periodic") != m.end() && !m["Periodic"].empty()) {
      periodic = make_shared<bool>(boost::any_cast<bool>(m["Periodic"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartSchedule") != m.end() && !m["StartSchedule"].empty()) {
      startSchedule = make_shared<long>(boost::any_cast<long>(m["StartSchedule"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ModifyFlowForWebRequest() = default;
};
class ModifyFlowForWebResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  ModifyFlowForWebResponseBody() {}

  explicit ModifyFlowForWebResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyFlowForWebResponseBody() = default;
};
class ModifyFlowForWebResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyFlowForWebResponseBody> body{};

  ModifyFlowForWebResponse() {}

  explicit ModifyFlowForWebResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyFlowForWebResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyFlowForWebResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyFlowForWebResponse() = default;
};
class ModifyFlowProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  ModifyFlowProjectRequest() {}

  explicit ModifyFlowProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyFlowProjectRequest() = default;
};
class ModifyFlowProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  ModifyFlowProjectResponseBody() {}

  explicit ModifyFlowProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyFlowProjectResponseBody() = default;
};
class ModifyFlowProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyFlowProjectResponseBody> body{};

  ModifyFlowProjectResponse() {}

  explicit ModifyFlowProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyFlowProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyFlowProjectResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyFlowProjectResponse() = default;
};
class ModifyFlowProjectClusterSettingRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> defaultQueue{};
  shared_ptr<string> defaultUser{};
  shared_ptr<vector<string>> hostList{};
  shared_ptr<string> projectId{};
  shared_ptr<vector<string>> queueList{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> userList{};

  ModifyFlowProjectClusterSettingRequest() {}

  explicit ModifyFlowProjectClusterSettingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (defaultQueue) {
      res["DefaultQueue"] = boost::any(*defaultQueue);
    }
    if (defaultUser) {
      res["DefaultUser"] = boost::any(*defaultUser);
    }
    if (hostList) {
      res["HostList"] = boost::any(*hostList);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (queueList) {
      res["QueueList"] = boost::any(*queueList);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userList) {
      res["UserList"] = boost::any(*userList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DefaultQueue") != m.end() && !m["DefaultQueue"].empty()) {
      defaultQueue = make_shared<string>(boost::any_cast<string>(m["DefaultQueue"]));
    }
    if (m.find("DefaultUser") != m.end() && !m["DefaultUser"].empty()) {
      defaultUser = make_shared<string>(boost::any_cast<string>(m["DefaultUser"]));
    }
    if (m.find("HostList") != m.end() && !m["HostList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HostList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HostList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("QueueList") != m.end() && !m["QueueList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["QueueList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["QueueList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      queueList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyFlowProjectClusterSettingRequest() = default;
};
class ModifyFlowProjectClusterSettingResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  ModifyFlowProjectClusterSettingResponseBody() {}

  explicit ModifyFlowProjectClusterSettingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyFlowProjectClusterSettingResponseBody() = default;
};
class ModifyFlowProjectClusterSettingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyFlowProjectClusterSettingResponseBody> body{};

  ModifyFlowProjectClusterSettingResponse() {}

  explicit ModifyFlowProjectClusterSettingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyFlowProjectClusterSettingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyFlowProjectClusterSettingResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyFlowProjectClusterSettingResponse() = default;
};
class ModifyResourcePoolRequestConfig : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> configKey{};
  shared_ptr<string> configValue{};
  shared_ptr<string> id{};
  shared_ptr<string> note{};

  ModifyResourcePoolRequestConfig() {}

  explicit ModifyResourcePoolRequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (configKey) {
      res["ConfigKey"] = boost::any(*configKey);
    }
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("ConfigKey") != m.end() && !m["ConfigKey"].empty()) {
      configKey = make_shared<string>(boost::any_cast<string>(m["ConfigKey"]));
    }
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
  }


  virtual ~ModifyResourcePoolRequestConfig() = default;
};
class ModifyResourcePoolRequest : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<string> clusterId{};
  shared_ptr<vector<ModifyResourcePoolRequestConfig>> config{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> yarnsiteconfig{};

  ModifyResourcePoolRequest() {}

  explicit ModifyResourcePoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (config) {
      vector<boost::any> temp1;
      for(auto item1:*config){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Config"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (yarnsiteconfig) {
      res["Yarnsiteconfig"] = boost::any(*yarnsiteconfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(vector<boost::any>) == m["Config"].type()) {
        vector<ModifyResourcePoolRequestConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Config"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyResourcePoolRequestConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        config = make_shared<vector<ModifyResourcePoolRequestConfig>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Yarnsiteconfig") != m.end() && !m["Yarnsiteconfig"].empty()) {
      yarnsiteconfig = make_shared<string>(boost::any_cast<string>(m["Yarnsiteconfig"]));
    }
  }


  virtual ~ModifyResourcePoolRequest() = default;
};
class ModifyResourcePoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyResourcePoolResponseBody() {}

  explicit ModifyResourcePoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyResourcePoolResponseBody() = default;
};
class ModifyResourcePoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyResourcePoolResponseBody> body{};

  ModifyResourcePoolResponse() {}

  explicit ModifyResourcePoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyResourcePoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyResourcePoolResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyResourcePoolResponse() = default;
};
class ModifyResourcePoolSchedulerTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> schedulerType{};

  ModifyResourcePoolSchedulerTypeRequest() {}

  explicit ModifyResourcePoolSchedulerTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (schedulerType) {
      res["SchedulerType"] = boost::any(*schedulerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SchedulerType") != m.end() && !m["SchedulerType"].empty()) {
      schedulerType = make_shared<string>(boost::any_cast<string>(m["SchedulerType"]));
    }
  }


  virtual ~ModifyResourcePoolSchedulerTypeRequest() = default;
};
class ModifyResourcePoolSchedulerTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyResourcePoolSchedulerTypeResponseBody() {}

  explicit ModifyResourcePoolSchedulerTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyResourcePoolSchedulerTypeResponseBody() = default;
};
class ModifyResourcePoolSchedulerTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyResourcePoolSchedulerTypeResponseBody> body{};

  ModifyResourcePoolSchedulerTypeResponse() {}

  explicit ModifyResourcePoolSchedulerTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyResourcePoolSchedulerTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyResourcePoolSchedulerTypeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyResourcePoolSchedulerTypeResponse() = default;
};
class ModifyResourceQueueRequestConfig : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> configKey{};
  shared_ptr<string> configValue{};
  shared_ptr<long> id{};
  shared_ptr<string> note{};

  ModifyResourceQueueRequestConfig() {}

  explicit ModifyResourceQueueRequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (configKey) {
      res["ConfigKey"] = boost::any(*configKey);
    }
    if (configValue) {
      res["ConfigValue"] = boost::any(*configValue);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("ConfigKey") != m.end() && !m["ConfigKey"].empty()) {
      configKey = make_shared<string>(boost::any_cast<string>(m["ConfigKey"]));
    }
    if (m.find("ConfigValue") != m.end() && !m["ConfigValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["ConfigValue"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
  }


  virtual ~ModifyResourceQueueRequestConfig() = default;
};
class ModifyResourceQueueRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<vector<ModifyResourceQueueRequestConfig>> config{};
  shared_ptr<string> id{};
  shared_ptr<bool> leaf{};
  shared_ptr<string> name{};
  shared_ptr<long> parentQueueId{};
  shared_ptr<string> qualifiedName{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> resourcePoolId{};

  ModifyResourceQueueRequest() {}

  explicit ModifyResourceQueueRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (config) {
      vector<boost::any> temp1;
      for(auto item1:*config){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Config"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (leaf) {
      res["Leaf"] = boost::any(*leaf);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentQueueId) {
      res["ParentQueueId"] = boost::any(*parentQueueId);
    }
    if (qualifiedName) {
      res["QualifiedName"] = boost::any(*qualifiedName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourcePoolId) {
      res["ResourcePoolId"] = boost::any(*resourcePoolId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(vector<boost::any>) == m["Config"].type()) {
        vector<ModifyResourceQueueRequestConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Config"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyResourceQueueRequestConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        config = make_shared<vector<ModifyResourceQueueRequestConfig>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Leaf") != m.end() && !m["Leaf"].empty()) {
      leaf = make_shared<bool>(boost::any_cast<bool>(m["Leaf"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentQueueId") != m.end() && !m["ParentQueueId"].empty()) {
      parentQueueId = make_shared<long>(boost::any_cast<long>(m["ParentQueueId"]));
    }
    if (m.find("QualifiedName") != m.end() && !m["QualifiedName"].empty()) {
      qualifiedName = make_shared<string>(boost::any_cast<string>(m["QualifiedName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourcePoolId") != m.end() && !m["ResourcePoolId"].empty()) {
      resourcePoolId = make_shared<long>(boost::any_cast<long>(m["ResourcePoolId"]));
    }
  }


  virtual ~ModifyResourceQueueRequest() = default;
};
class ModifyResourceQueueResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyResourceQueueResponseBody() {}

  explicit ModifyResourceQueueResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyResourceQueueResponseBody() = default;
};
class ModifyResourceQueueResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyResourceQueueResponseBody> body{};

  ModifyResourceQueueResponse() {}

  explicit ModifyResourceQueueResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyResourceQueueResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyResourceQueueResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyResourceQueueResponse() = default;
};
class ModifyScalingConfigItemV2Request : public Darabonba::Model {
public:
  shared_ptr<string> configItemBizId{};
  shared_ptr<string> configItemInformation{};
  shared_ptr<string> configItemType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingGroupBizId{};

  ModifyScalingConfigItemV2Request() {}

  explicit ModifyScalingConfigItemV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configItemBizId) {
      res["ConfigItemBizId"] = boost::any(*configItemBizId);
    }
    if (configItemInformation) {
      res["ConfigItemInformation"] = boost::any(*configItemInformation);
    }
    if (configItemType) {
      res["ConfigItemType"] = boost::any(*configItemType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigItemBizId") != m.end() && !m["ConfigItemBizId"].empty()) {
      configItemBizId = make_shared<string>(boost::any_cast<string>(m["ConfigItemBizId"]));
    }
    if (m.find("ConfigItemInformation") != m.end() && !m["ConfigItemInformation"].empty()) {
      configItemInformation = make_shared<string>(boost::any_cast<string>(m["ConfigItemInformation"]));
    }
    if (m.find("ConfigItemType") != m.end() && !m["ConfigItemType"].empty()) {
      configItemType = make_shared<string>(boost::any_cast<string>(m["ConfigItemType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
  }


  virtual ~ModifyScalingConfigItemV2Request() = default;
};
class ModifyScalingConfigItemV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  ModifyScalingConfigItemV2ResponseBody() {}

  explicit ModifyScalingConfigItemV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyScalingConfigItemV2ResponseBody() = default;
};
class ModifyScalingConfigItemV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyScalingConfigItemV2ResponseBody> body{};

  ModifyScalingConfigItemV2Response() {}

  explicit ModifyScalingConfigItemV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyScalingConfigItemV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyScalingConfigItemV2ResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyScalingConfigItemV2Response() = default;
};
class ModifyScalingGroupV2Request : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingGroupBizId{};

  ModifyScalingGroupV2Request() {}

  explicit ModifyScalingGroupV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
  }


  virtual ~ModifyScalingGroupV2Request() = default;
};
class ModifyScalingGroupV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  ModifyScalingGroupV2ResponseBody() {}

  explicit ModifyScalingGroupV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyScalingGroupV2ResponseBody() = default;
};
class ModifyScalingGroupV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyScalingGroupV2ResponseBody> body{};

  ModifyScalingGroupV2Response() {}

  explicit ModifyScalingGroupV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyScalingGroupV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyScalingGroupV2ResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyScalingGroupV2Response() = default;
};
class RefreshClusterResourcePoolRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> resourcePoolId{};

  RefreshClusterResourcePoolRequest() {}

  explicit RefreshClusterResourcePoolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourcePoolId) {
      res["ResourcePoolId"] = boost::any(*resourcePoolId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourcePoolId") != m.end() && !m["ResourcePoolId"].empty()) {
      resourcePoolId = make_shared<long>(boost::any_cast<long>(m["ResourcePoolId"]));
    }
  }


  virtual ~RefreshClusterResourcePoolRequest() = default;
};
class RefreshClusterResourcePoolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> operationId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> workFlowInstanceId{};

  RefreshClusterResourcePoolResponseBody() {}

  explicit RefreshClusterResourcePoolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (workFlowInstanceId) {
      res["WorkFlowInstanceId"] = boost::any(*workFlowInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WorkFlowInstanceId") != m.end() && !m["WorkFlowInstanceId"].empty()) {
      workFlowInstanceId = make_shared<string>(boost::any_cast<string>(m["WorkFlowInstanceId"]));
    }
  }


  virtual ~RefreshClusterResourcePoolResponseBody() = default;
};
class RefreshClusterResourcePoolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefreshClusterResourcePoolResponseBody> body{};

  RefreshClusterResourcePoolResponse() {}

  explicit RefreshClusterResourcePoolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefreshClusterResourcePoolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefreshClusterResourcePoolResponseBody>(model1);
      }
    }
  }


  virtual ~RefreshClusterResourcePoolResponse() = default;
};
class ReleaseClusterRequest : public Darabonba::Model {
public:
  shared_ptr<bool> forceRelease{};
  shared_ptr<string> id{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};

  ReleaseClusterRequest() {}

  explicit ReleaseClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forceRelease) {
      res["ForceRelease"] = boost::any(*forceRelease);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForceRelease") != m.end() && !m["ForceRelease"].empty()) {
      forceRelease = make_shared<bool>(boost::any_cast<bool>(m["ForceRelease"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ReleaseClusterRequest() = default;
};
class ReleaseClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleaseClusterResponseBody() {}

  explicit ReleaseClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseClusterResponseBody() = default;
};
class ReleaseClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseClusterResponseBody> body{};

  ReleaseClusterResponse() {}

  explicit ReleaseClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseClusterResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseClusterResponse() = default;
};
class ReleaseClusterHostGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> decommissionTimeout{};
  shared_ptr<bool> enableGracefulDecommission{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> instanceIdList{};
  shared_ptr<string> regionId{};
  shared_ptr<long> releaseNumber{};
  shared_ptr<long> resourceOwnerId{};

  ReleaseClusterHostGroupRequest() {}

  explicit ReleaseClusterHostGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (decommissionTimeout) {
      res["DecommissionTimeout"] = boost::any(*decommissionTimeout);
    }
    if (enableGracefulDecommission) {
      res["EnableGracefulDecommission"] = boost::any(*enableGracefulDecommission);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (instanceIdList) {
      res["InstanceIdList"] = boost::any(*instanceIdList);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (releaseNumber) {
      res["ReleaseNumber"] = boost::any(*releaseNumber);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DecommissionTimeout") != m.end() && !m["DecommissionTimeout"].empty()) {
      decommissionTimeout = make_shared<long>(boost::any_cast<long>(m["DecommissionTimeout"]));
    }
    if (m.find("EnableGracefulDecommission") != m.end() && !m["EnableGracefulDecommission"].empty()) {
      enableGracefulDecommission = make_shared<bool>(boost::any_cast<bool>(m["EnableGracefulDecommission"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("InstanceIdList") != m.end() && !m["InstanceIdList"].empty()) {
      instanceIdList = make_shared<string>(boost::any_cast<string>(m["InstanceIdList"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReleaseNumber") != m.end() && !m["ReleaseNumber"].empty()) {
      releaseNumber = make_shared<long>(boost::any_cast<long>(m["ReleaseNumber"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ReleaseClusterHostGroupRequest() = default;
};
class ReleaseClusterHostGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleaseClusterHostGroupResponseBody() {}

  explicit ReleaseClusterHostGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseClusterHostGroupResponseBody() = default;
};
class ReleaseClusterHostGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseClusterHostGroupResponseBody> body{};

  ReleaseClusterHostGroupResponse() {}

  explicit ReleaseClusterHostGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseClusterHostGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseClusterHostGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseClusterHostGroupResponse() = default;
};
class RemoveScalingConfigItemV2Request : public Darabonba::Model {
public:
  shared_ptr<string> configItemBizId{};
  shared_ptr<string> configItemType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingGroupBizId{};

  RemoveScalingConfigItemV2Request() {}

  explicit RemoveScalingConfigItemV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configItemBizId) {
      res["ConfigItemBizId"] = boost::any(*configItemBizId);
    }
    if (configItemType) {
      res["ConfigItemType"] = boost::any(*configItemType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigItemBizId") != m.end() && !m["ConfigItemBizId"].empty()) {
      configItemBizId = make_shared<string>(boost::any_cast<string>(m["ConfigItemBizId"]));
    }
    if (m.find("ConfigItemType") != m.end() && !m["ConfigItemType"].empty()) {
      configItemType = make_shared<string>(boost::any_cast<string>(m["ConfigItemType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
  }


  virtual ~RemoveScalingConfigItemV2Request() = default;
};
class RemoveScalingConfigItemV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  RemoveScalingConfigItemV2ResponseBody() {}

  explicit RemoveScalingConfigItemV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveScalingConfigItemV2ResponseBody() = default;
};
class RemoveScalingConfigItemV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveScalingConfigItemV2ResponseBody> body{};

  RemoveScalingConfigItemV2Response() {}

  explicit RemoveScalingConfigItemV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveScalingConfigItemV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveScalingConfigItemV2ResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveScalingConfigItemV2Response() = default;
};
class RerunFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> flowInstanceId{};
  shared_ptr<string> projectId{};
  shared_ptr<bool> reRunFail{};
  shared_ptr<string> regionId{};

  RerunFlowRequest() {}

  explicit RerunFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowInstanceId) {
      res["FlowInstanceId"] = boost::any(*flowInstanceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (reRunFail) {
      res["ReRunFail"] = boost::any(*reRunFail);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowInstanceId") != m.end() && !m["FlowInstanceId"].empty()) {
      flowInstanceId = make_shared<string>(boost::any_cast<string>(m["FlowInstanceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ReRunFail") != m.end() && !m["ReRunFail"].empty()) {
      reRunFail = make_shared<bool>(boost::any_cast<bool>(m["ReRunFail"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~RerunFlowRequest() = default;
};
class RerunFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  RerunFlowResponseBody() {}

  explicit RerunFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RerunFlowResponseBody() = default;
};
class RerunFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RerunFlowResponseBody> body{};

  RerunFlowResponse() {}

  explicit RerunFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RerunFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RerunFlowResponseBody>(model1);
      }
    }
  }


  virtual ~RerunFlowResponse() = default;
};
class ResizeClusterV2RequestHostComponentInfo : public Darabonba::Model {
public:
  shared_ptr<vector<string>> componentNameList{};
  shared_ptr<string> hostName{};
  shared_ptr<string> serviceName{};

  ResizeClusterV2RequestHostComponentInfo() {}

  explicit ResizeClusterV2RequestHostComponentInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentNameList) {
      res["ComponentNameList"] = boost::any(*componentNameList);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentNameList") != m.end() && !m["ComponentNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComponentNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComponentNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      componentNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~ResizeClusterV2RequestHostComponentInfo() = default;
};
class ResizeClusterV2RequestHostGroup : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> comment{};
  shared_ptr<string> createType{};
  shared_ptr<long> diskCapacity{};
  shared_ptr<long> diskCount{};
  shared_ptr<string> diskType{};
  shared_ptr<string> hostGroupId{};
  shared_ptr<string> hostGroupName{};
  shared_ptr<string> hostGroupType{};
  shared_ptr<string> hostKeyPairName{};
  shared_ptr<string> hostPassword{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> nodeCount{};
  shared_ptr<long> period{};
  shared_ptr<string> privatePoolOptionsId{};
  shared_ptr<string> privatePoolOptionsMatchCriteria{};
  shared_ptr<long> sysDiskCapacity{};
  shared_ptr<string> sysDiskType{};
  shared_ptr<long> vswitchId{};

  ResizeClusterV2RequestHostGroup() {}

  explicit ResizeClusterV2RequestHostGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (createType) {
      res["CreateType"] = boost::any(*createType);
    }
    if (diskCapacity) {
      res["DiskCapacity"] = boost::any(*diskCapacity);
    }
    if (diskCount) {
      res["DiskCount"] = boost::any(*diskCount);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (hostGroupId) {
      res["HostGroupId"] = boost::any(*hostGroupId);
    }
    if (hostGroupName) {
      res["HostGroupName"] = boost::any(*hostGroupName);
    }
    if (hostGroupType) {
      res["HostGroupType"] = boost::any(*hostGroupType);
    }
    if (hostKeyPairName) {
      res["HostKeyPairName"] = boost::any(*hostKeyPairName);
    }
    if (hostPassword) {
      res["HostPassword"] = boost::any(*hostPassword);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (nodeCount) {
      res["NodeCount"] = boost::any(*nodeCount);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (privatePoolOptionsId) {
      res["PrivatePoolOptionsId"] = boost::any(*privatePoolOptionsId);
    }
    if (privatePoolOptionsMatchCriteria) {
      res["PrivatePoolOptionsMatchCriteria"] = boost::any(*privatePoolOptionsMatchCriteria);
    }
    if (sysDiskCapacity) {
      res["SysDiskCapacity"] = boost::any(*sysDiskCapacity);
    }
    if (sysDiskType) {
      res["SysDiskType"] = boost::any(*sysDiskType);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreateType") != m.end() && !m["CreateType"].empty()) {
      createType = make_shared<string>(boost::any_cast<string>(m["CreateType"]));
    }
    if (m.find("DiskCapacity") != m.end() && !m["DiskCapacity"].empty()) {
      diskCapacity = make_shared<long>(boost::any_cast<long>(m["DiskCapacity"]));
    }
    if (m.find("DiskCount") != m.end() && !m["DiskCount"].empty()) {
      diskCount = make_shared<long>(boost::any_cast<long>(m["DiskCount"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("HostGroupId") != m.end() && !m["HostGroupId"].empty()) {
      hostGroupId = make_shared<string>(boost::any_cast<string>(m["HostGroupId"]));
    }
    if (m.find("HostGroupName") != m.end() && !m["HostGroupName"].empty()) {
      hostGroupName = make_shared<string>(boost::any_cast<string>(m["HostGroupName"]));
    }
    if (m.find("HostGroupType") != m.end() && !m["HostGroupType"].empty()) {
      hostGroupType = make_shared<string>(boost::any_cast<string>(m["HostGroupType"]));
    }
    if (m.find("HostKeyPairName") != m.end() && !m["HostKeyPairName"].empty()) {
      hostKeyPairName = make_shared<string>(boost::any_cast<string>(m["HostKeyPairName"]));
    }
    if (m.find("HostPassword") != m.end() && !m["HostPassword"].empty()) {
      hostPassword = make_shared<string>(boost::any_cast<string>(m["HostPassword"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("NodeCount") != m.end() && !m["NodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["NodeCount"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PrivatePoolOptionsId") != m.end() && !m["PrivatePoolOptionsId"].empty()) {
      privatePoolOptionsId = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptionsId"]));
    }
    if (m.find("PrivatePoolOptionsMatchCriteria") != m.end() && !m["PrivatePoolOptionsMatchCriteria"].empty()) {
      privatePoolOptionsMatchCriteria = make_shared<string>(boost::any_cast<string>(m["PrivatePoolOptionsMatchCriteria"]));
    }
    if (m.find("SysDiskCapacity") != m.end() && !m["SysDiskCapacity"].empty()) {
      sysDiskCapacity = make_shared<long>(boost::any_cast<long>(m["SysDiskCapacity"]));
    }
    if (m.find("SysDiskType") != m.end() && !m["SysDiskType"].empty()) {
      sysDiskType = make_shared<string>(boost::any_cast<string>(m["SysDiskType"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<long>(boost::any_cast<long>(m["VswitchId"]));
    }
  }


  virtual ~ResizeClusterV2RequestHostGroup() = default;
};
class ResizeClusterV2RequestPromotionInfo : public Darabonba::Model {
public:
  shared_ptr<string> productCode{};
  shared_ptr<string> promotionOptionCode{};
  shared_ptr<string> promotionOptionNo{};

  ResizeClusterV2RequestPromotionInfo() {}

  explicit ResizeClusterV2RequestPromotionInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (promotionOptionCode) {
      res["PromotionOptionCode"] = boost::any(*promotionOptionCode);
    }
    if (promotionOptionNo) {
      res["PromotionOptionNo"] = boost::any(*promotionOptionNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("PromotionOptionCode") != m.end() && !m["PromotionOptionCode"].empty()) {
      promotionOptionCode = make_shared<string>(boost::any_cast<string>(m["PromotionOptionCode"]));
    }
    if (m.find("PromotionOptionNo") != m.end() && !m["PromotionOptionNo"].empty()) {
      promotionOptionNo = make_shared<string>(boost::any_cast<string>(m["PromotionOptionNo"]));
    }
  }


  virtual ~ResizeClusterV2RequestPromotionInfo() = default;
};
class ResizeClusterV2Request : public Darabonba::Model {
public:
  shared_ptr<bool> autoPayOrder{};
  shared_ptr<string> clickhouseConf{};
  shared_ptr<string> clusterId{};
  shared_ptr<vector<ResizeClusterV2RequestHostComponentInfo>> hostComponentInfo{};
  shared_ptr<vector<ResizeClusterV2RequestHostGroup>> hostGroup{};
  shared_ptr<bool> isOpenPublicIp{};
  shared_ptr<vector<ResizeClusterV2RequestPromotionInfo>> promotionInfo{};
  shared_ptr<string> regionId{};
  shared_ptr<string> vswitchId{};

  ResizeClusterV2Request() {}

  explicit ResizeClusterV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPayOrder) {
      res["AutoPayOrder"] = boost::any(*autoPayOrder);
    }
    if (clickhouseConf) {
      res["ClickhouseConf"] = boost::any(*clickhouseConf);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (hostComponentInfo) {
      vector<boost::any> temp1;
      for(auto item1:*hostComponentInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostComponentInfo"] = boost::any(temp1);
    }
    if (hostGroup) {
      vector<boost::any> temp1;
      for(auto item1:*hostGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HostGroup"] = boost::any(temp1);
    }
    if (isOpenPublicIp) {
      res["IsOpenPublicIp"] = boost::any(*isOpenPublicIp);
    }
    if (promotionInfo) {
      vector<boost::any> temp1;
      for(auto item1:*promotionInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PromotionInfo"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPayOrder") != m.end() && !m["AutoPayOrder"].empty()) {
      autoPayOrder = make_shared<bool>(boost::any_cast<bool>(m["AutoPayOrder"]));
    }
    if (m.find("ClickhouseConf") != m.end() && !m["ClickhouseConf"].empty()) {
      clickhouseConf = make_shared<string>(boost::any_cast<string>(m["ClickhouseConf"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("HostComponentInfo") != m.end() && !m["HostComponentInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["HostComponentInfo"].type()) {
        vector<ResizeClusterV2RequestHostComponentInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostComponentInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ResizeClusterV2RequestHostComponentInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostComponentInfo = make_shared<vector<ResizeClusterV2RequestHostComponentInfo>>(expect1);
      }
    }
    if (m.find("HostGroup") != m.end() && !m["HostGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["HostGroup"].type()) {
        vector<ResizeClusterV2RequestHostGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HostGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ResizeClusterV2RequestHostGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hostGroup = make_shared<vector<ResizeClusterV2RequestHostGroup>>(expect1);
      }
    }
    if (m.find("IsOpenPublicIp") != m.end() && !m["IsOpenPublicIp"].empty()) {
      isOpenPublicIp = make_shared<bool>(boost::any_cast<bool>(m["IsOpenPublicIp"]));
    }
    if (m.find("PromotionInfo") != m.end() && !m["PromotionInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PromotionInfo"].type()) {
        vector<ResizeClusterV2RequestPromotionInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PromotionInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ResizeClusterV2RequestPromotionInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        promotionInfo = make_shared<vector<ResizeClusterV2RequestPromotionInfo>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~ResizeClusterV2Request() = default;
};
class ResizeClusterV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> operationId{};
  shared_ptr<string> requestId{};

  ResizeClusterV2ResponseBody() {}

  explicit ResizeClusterV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResizeClusterV2ResponseBody() = default;
};
class ResizeClusterV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResizeClusterV2ResponseBody> body{};

  ResizeClusterV2Response() {}

  explicit ResizeClusterV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResizeClusterV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResizeClusterV2ResponseBody>(model1);
      }
    }
  }


  virtual ~ResizeClusterV2Response() = default;
};
class ResumeFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> flowInstanceId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  ResumeFlowRequest() {}

  explicit ResumeFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowInstanceId) {
      res["FlowInstanceId"] = boost::any(*flowInstanceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowInstanceId") != m.end() && !m["FlowInstanceId"].empty()) {
      flowInstanceId = make_shared<string>(boost::any_cast<string>(m["FlowInstanceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ResumeFlowRequest() = default;
};
class ResumeFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  ResumeFlowResponseBody() {}

  explicit ResumeFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResumeFlowResponseBody() = default;
};
class ResumeFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResumeFlowResponseBody> body{};

  ResumeFlowResponse() {}

  explicit ResumeFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumeFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumeFlowResponseBody>(model1);
      }
    }
  }


  virtual ~ResumeFlowResponse() = default;
};
class RunClusterServiceActionRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> comment{};
  shared_ptr<string> componentNameList{};
  shared_ptr<string> customCommand{};
  shared_ptr<string> customParams{};
  shared_ptr<string> executeStrategy{};
  shared_ptr<vector<string>> hostGroupIdList{};
  shared_ptr<string> hostIdList{};
  shared_ptr<long> interval{};
  shared_ptr<bool> isRolling{};
  shared_ptr<long> nodeCountPerBatch{};
  shared_ptr<bool> onlyRestartStaleConfigNodes{};
  shared_ptr<string> regionId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> serviceActionName{};
  shared_ptr<string> serviceName{};
  shared_ptr<long> totlerateFailCount{};
  shared_ptr<bool> turnOnMaintenanceMode{};

  RunClusterServiceActionRequest() {}

  explicit RunClusterServiceActionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (componentNameList) {
      res["ComponentNameList"] = boost::any(*componentNameList);
    }
    if (customCommand) {
      res["CustomCommand"] = boost::any(*customCommand);
    }
    if (customParams) {
      res["CustomParams"] = boost::any(*customParams);
    }
    if (executeStrategy) {
      res["ExecuteStrategy"] = boost::any(*executeStrategy);
    }
    if (hostGroupIdList) {
      res["HostGroupIdList"] = boost::any(*hostGroupIdList);
    }
    if (hostIdList) {
      res["HostIdList"] = boost::any(*hostIdList);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (isRolling) {
      res["IsRolling"] = boost::any(*isRolling);
    }
    if (nodeCountPerBatch) {
      res["NodeCountPerBatch"] = boost::any(*nodeCountPerBatch);
    }
    if (onlyRestartStaleConfigNodes) {
      res["OnlyRestartStaleConfigNodes"] = boost::any(*onlyRestartStaleConfigNodes);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (serviceActionName) {
      res["ServiceActionName"] = boost::any(*serviceActionName);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (totlerateFailCount) {
      res["TotlerateFailCount"] = boost::any(*totlerateFailCount);
    }
    if (turnOnMaintenanceMode) {
      res["TurnOnMaintenanceMode"] = boost::any(*turnOnMaintenanceMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ComponentNameList") != m.end() && !m["ComponentNameList"].empty()) {
      componentNameList = make_shared<string>(boost::any_cast<string>(m["ComponentNameList"]));
    }
    if (m.find("CustomCommand") != m.end() && !m["CustomCommand"].empty()) {
      customCommand = make_shared<string>(boost::any_cast<string>(m["CustomCommand"]));
    }
    if (m.find("CustomParams") != m.end() && !m["CustomParams"].empty()) {
      customParams = make_shared<string>(boost::any_cast<string>(m["CustomParams"]));
    }
    if (m.find("ExecuteStrategy") != m.end() && !m["ExecuteStrategy"].empty()) {
      executeStrategy = make_shared<string>(boost::any_cast<string>(m["ExecuteStrategy"]));
    }
    if (m.find("HostGroupIdList") != m.end() && !m["HostGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HostGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HostGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hostGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HostIdList") != m.end() && !m["HostIdList"].empty()) {
      hostIdList = make_shared<string>(boost::any_cast<string>(m["HostIdList"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IsRolling") != m.end() && !m["IsRolling"].empty()) {
      isRolling = make_shared<bool>(boost::any_cast<bool>(m["IsRolling"]));
    }
    if (m.find("NodeCountPerBatch") != m.end() && !m["NodeCountPerBatch"].empty()) {
      nodeCountPerBatch = make_shared<long>(boost::any_cast<long>(m["NodeCountPerBatch"]));
    }
    if (m.find("OnlyRestartStaleConfigNodes") != m.end() && !m["OnlyRestartStaleConfigNodes"].empty()) {
      onlyRestartStaleConfigNodes = make_shared<bool>(boost::any_cast<bool>(m["OnlyRestartStaleConfigNodes"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ServiceActionName") != m.end() && !m["ServiceActionName"].empty()) {
      serviceActionName = make_shared<string>(boost::any_cast<string>(m["ServiceActionName"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("TotlerateFailCount") != m.end() && !m["TotlerateFailCount"].empty()) {
      totlerateFailCount = make_shared<long>(boost::any_cast<long>(m["TotlerateFailCount"]));
    }
    if (m.find("TurnOnMaintenanceMode") != m.end() && !m["TurnOnMaintenanceMode"].empty()) {
      turnOnMaintenanceMode = make_shared<bool>(boost::any_cast<bool>(m["TurnOnMaintenanceMode"]));
    }
  }


  virtual ~RunClusterServiceActionRequest() = default;
};
class RunClusterServiceActionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RunClusterServiceActionResponseBody() {}

  explicit RunClusterServiceActionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunClusterServiceActionResponseBody() = default;
};
class RunClusterServiceActionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunClusterServiceActionResponseBody> body{};

  RunClusterServiceActionResponse() {}

  explicit RunClusterServiceActionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunClusterServiceActionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunClusterServiceActionResponseBody>(model1);
      }
    }
  }


  virtual ~RunClusterServiceActionResponse() = default;
};
class RunScalingActionV2Request : public Darabonba::Model {
public:
  shared_ptr<string> actionParam{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> scalingActionType{};
  shared_ptr<string> scalingGroupBizId{};

  RunScalingActionV2Request() {}

  explicit RunScalingActionV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionParam) {
      res["ActionParam"] = boost::any(*actionParam);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (scalingActionType) {
      res["ScalingActionType"] = boost::any(*scalingActionType);
    }
    if (scalingGroupBizId) {
      res["ScalingGroupBizId"] = boost::any(*scalingGroupBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionParam") != m.end() && !m["ActionParam"].empty()) {
      actionParam = make_shared<string>(boost::any_cast<string>(m["ActionParam"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ScalingActionType") != m.end() && !m["ScalingActionType"].empty()) {
      scalingActionType = make_shared<string>(boost::any_cast<string>(m["ScalingActionType"]));
    }
    if (m.find("ScalingGroupBizId") != m.end() && !m["ScalingGroupBizId"].empty()) {
      scalingGroupBizId = make_shared<string>(boost::any_cast<string>(m["ScalingGroupBizId"]));
    }
  }


  virtual ~RunScalingActionV2Request() = default;
};
class RunScalingActionV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  RunScalingActionV2ResponseBody() {}

  explicit RunScalingActionV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunScalingActionV2ResponseBody() = default;
};
class RunScalingActionV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunScalingActionV2ResponseBody> body{};

  RunScalingActionV2Response() {}

  explicit RunScalingActionV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunScalingActionV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunScalingActionV2ResponseBody>(model1);
      }
    }
  }


  virtual ~RunScalingActionV2Response() = default;
};
class StartFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> flowInstanceId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  StartFlowRequest() {}

  explicit StartFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowInstanceId) {
      res["FlowInstanceId"] = boost::any(*flowInstanceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowInstanceId") != m.end() && !m["FlowInstanceId"].empty()) {
      flowInstanceId = make_shared<string>(boost::any_cast<string>(m["FlowInstanceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~StartFlowRequest() = default;
};
class StartFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  StartFlowResponseBody() {}

  explicit StartFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartFlowResponseBody() = default;
};
class StartFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartFlowResponseBody> body{};

  StartFlowResponse() {}

  explicit StartFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartFlowResponseBody>(model1);
      }
    }
  }


  virtual ~StartFlowResponse() = default;
};
class SubmitFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> conf{};
  shared_ptr<string> flowId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  SubmitFlowRequest() {}

  explicit SubmitFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conf) {
      res["Conf"] = boost::any(*conf);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Conf") != m.end() && !m["Conf"].empty()) {
      conf = make_shared<string>(boost::any_cast<string>(m["Conf"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SubmitFlowRequest() = default;
};
class SubmitFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  SubmitFlowResponseBody() {}

  explicit SubmitFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitFlowResponseBody() = default;
};
class SubmitFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitFlowResponseBody> body{};

  SubmitFlowResponse() {}

  explicit SubmitFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitFlowResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitFlowResponse() = default;
};
class SubmitFlowJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> conf{};
  shared_ptr<string> hostName{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobInstanceId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  SubmitFlowJobRequest() {}

  explicit SubmitFlowJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (conf) {
      res["Conf"] = boost::any(*conf);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobInstanceId) {
      res["JobInstanceId"] = boost::any(*jobInstanceId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Conf") != m.end() && !m["Conf"].empty()) {
      conf = make_shared<string>(boost::any_cast<string>(m["Conf"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobInstanceId") != m.end() && !m["JobInstanceId"].empty()) {
      jobInstanceId = make_shared<string>(boost::any_cast<string>(m["JobInstanceId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SubmitFlowJobRequest() = default;
};
class SubmitFlowJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  SubmitFlowJobResponseBody() {}

  explicit SubmitFlowJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitFlowJobResponseBody() = default;
};
class SubmitFlowJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitFlowJobResponseBody> body{};

  SubmitFlowJobResponse() {}

  explicit SubmitFlowJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitFlowJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitFlowJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitFlowJobResponse() = default;
};
class SuspendFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> flowInstanceId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};

  SuspendFlowRequest() {}

  explicit SuspendFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowInstanceId) {
      res["FlowInstanceId"] = boost::any(*flowInstanceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowInstanceId") != m.end() && !m["FlowInstanceId"].empty()) {
      flowInstanceId = make_shared<string>(boost::any_cast<string>(m["FlowInstanceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SuspendFlowRequest() = default;
};
class SuspendFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  SuspendFlowResponseBody() {}

  explicit SuspendFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SuspendFlowResponseBody() = default;
};
class SuspendFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SuspendFlowResponseBody> body{};

  SuspendFlowResponse() {}

  explicit SuspendFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SuspendFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SuspendFlowResponseBody>(model1);
      }
    }
  }


  virtual ~SuspendFlowResponse() = default;
};
class TagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTag() {}

  explicit TagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTag() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagResourcesRequestTag>> tag{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKey{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddClusterServiceResponse addClusterServiceWithOptions(shared_ptr<AddClusterServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddClusterServiceResponse addClusterService(shared_ptr<AddClusterServiceRequest> request);
  AddScalingConfigItemV2Response addScalingConfigItemV2WithOptions(shared_ptr<AddScalingConfigItemV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddScalingConfigItemV2Response addScalingConfigItemV2(shared_ptr<AddScalingConfigItemV2Request> request);
  CloneFlowResponse cloneFlowWithOptions(shared_ptr<CloneFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloneFlowResponse cloneFlow(shared_ptr<CloneFlowRequest> request);
  CloneFlowJobResponse cloneFlowJobWithOptions(shared_ptr<CloneFlowJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloneFlowJobResponse cloneFlowJob(shared_ptr<CloneFlowJobRequest> request);
  CreateClusterHostGroupResponse createClusterHostGroupWithOptions(shared_ptr<CreateClusterHostGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateClusterHostGroupResponse createClusterHostGroup(shared_ptr<CreateClusterHostGroupRequest> request);
  CreateClusterTemplateResponse createClusterTemplateWithOptions(shared_ptr<CreateClusterTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateClusterTemplateResponse createClusterTemplate(shared_ptr<CreateClusterTemplateRequest> request);
  CreateClusterV2Response createClusterV2WithOptions(shared_ptr<CreateClusterV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateClusterV2Response createClusterV2(shared_ptr<CreateClusterV2Request> request);
  CreateClusterWithTemplateResponse createClusterWithTemplateWithOptions(shared_ptr<CreateClusterWithTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateClusterWithTemplateResponse createClusterWithTemplate(shared_ptr<CreateClusterWithTemplateRequest> request);
  CreateFlowResponse createFlowWithOptions(shared_ptr<CreateFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFlowResponse createFlow(shared_ptr<CreateFlowRequest> request);
  CreateFlowCategoryResponse createFlowCategoryWithOptions(shared_ptr<CreateFlowCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFlowCategoryResponse createFlowCategory(shared_ptr<CreateFlowCategoryRequest> request);
  CreateFlowForWebResponse createFlowForWebWithOptions(shared_ptr<CreateFlowForWebRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFlowForWebResponse createFlowForWeb(shared_ptr<CreateFlowForWebRequest> request);
  CreateFlowJobResponse createFlowJobWithOptions(shared_ptr<CreateFlowJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFlowJobResponse createFlowJob(shared_ptr<CreateFlowJobRequest> request);
  CreateFlowProjectResponse createFlowProjectWithOptions(shared_ptr<CreateFlowProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFlowProjectResponse createFlowProject(shared_ptr<CreateFlowProjectRequest> request);
  CreateFlowProjectClusterSettingResponse createFlowProjectClusterSettingWithOptions(shared_ptr<CreateFlowProjectClusterSettingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFlowProjectClusterSettingResponse createFlowProjectClusterSetting(shared_ptr<CreateFlowProjectClusterSettingRequest> request);
  CreateFlowProjectUserResponse createFlowProjectUserWithOptions(shared_ptr<CreateFlowProjectUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFlowProjectUserResponse createFlowProjectUser(shared_ptr<CreateFlowProjectUserRequest> request);
  CreateResourcePoolResponse createResourcePoolWithOptions(shared_ptr<CreateResourcePoolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateResourcePoolResponse createResourcePool(shared_ptr<CreateResourcePoolRequest> request);
  CreateResourceQueueResponse createResourceQueueWithOptions(shared_ptr<CreateResourceQueueRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateResourceQueueResponse createResourceQueue(shared_ptr<CreateResourceQueueRequest> request);
  CreateScalingGroupV2Response createScalingGroupV2WithOptions(shared_ptr<CreateScalingGroupV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateScalingGroupV2Response createScalingGroupV2(shared_ptr<CreateScalingGroupV2Request> request);
  DeleteClusterTemplateResponse deleteClusterTemplateWithOptions(shared_ptr<DeleteClusterTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteClusterTemplateResponse deleteClusterTemplate(shared_ptr<DeleteClusterTemplateRequest> request);
  DeleteFlowResponse deleteFlowWithOptions(shared_ptr<DeleteFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFlowResponse deleteFlow(shared_ptr<DeleteFlowRequest> request);
  DeleteFlowCategoryResponse deleteFlowCategoryWithOptions(shared_ptr<DeleteFlowCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFlowCategoryResponse deleteFlowCategory(shared_ptr<DeleteFlowCategoryRequest> request);
  DeleteFlowJobResponse deleteFlowJobWithOptions(shared_ptr<DeleteFlowJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFlowJobResponse deleteFlowJob(shared_ptr<DeleteFlowJobRequest> request);
  DeleteFlowProjectResponse deleteFlowProjectWithOptions(shared_ptr<DeleteFlowProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFlowProjectResponse deleteFlowProject(shared_ptr<DeleteFlowProjectRequest> request);
  DeleteFlowProjectClusterSettingResponse deleteFlowProjectClusterSettingWithOptions(shared_ptr<DeleteFlowProjectClusterSettingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFlowProjectClusterSettingResponse deleteFlowProjectClusterSetting(shared_ptr<DeleteFlowProjectClusterSettingRequest> request);
  DeleteFlowProjectUserResponse deleteFlowProjectUserWithOptions(shared_ptr<DeleteFlowProjectUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFlowProjectUserResponse deleteFlowProjectUser(shared_ptr<DeleteFlowProjectUserRequest> request);
  DeleteResourcePoolResponse deleteResourcePoolWithOptions(shared_ptr<DeleteResourcePoolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteResourcePoolResponse deleteResourcePool(shared_ptr<DeleteResourcePoolRequest> request);
  DeleteResourceQueueResponse deleteResourceQueueWithOptions(shared_ptr<DeleteResourceQueueRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteResourceQueueResponse deleteResourceQueue(shared_ptr<DeleteResourceQueueRequest> request);
  DescribeClusterBasicInfoResponse describeClusterBasicInfoWithOptions(shared_ptr<DescribeClusterBasicInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterBasicInfoResponse describeClusterBasicInfo(shared_ptr<DescribeClusterBasicInfoRequest> request);
  DescribeClusterOperationHostTaskLogResponse describeClusterOperationHostTaskLogWithOptions(shared_ptr<DescribeClusterOperationHostTaskLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterOperationHostTaskLogResponse describeClusterOperationHostTaskLog(shared_ptr<DescribeClusterOperationHostTaskLogRequest> request);
  DescribeClusterResourcePoolSchedulerTypeResponse describeClusterResourcePoolSchedulerTypeWithOptions(shared_ptr<DescribeClusterResourcePoolSchedulerTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterResourcePoolSchedulerTypeResponse describeClusterResourcePoolSchedulerType(shared_ptr<DescribeClusterResourcePoolSchedulerTypeRequest> request);
  DescribeClusterServiceResponse describeClusterServiceWithOptions(shared_ptr<DescribeClusterServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterServiceResponse describeClusterService(shared_ptr<DescribeClusterServiceRequest> request);
  DescribeClusterServiceConfigResponse describeClusterServiceConfigWithOptions(shared_ptr<DescribeClusterServiceConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterServiceConfigResponse describeClusterServiceConfig(shared_ptr<DescribeClusterServiceConfigRequest> request);
  DescribeClusterServiceConfigTagResponse describeClusterServiceConfigTagWithOptions(shared_ptr<DescribeClusterServiceConfigTagRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterServiceConfigTagResponse describeClusterServiceConfigTag(shared_ptr<DescribeClusterServiceConfigTagRequest> request);
  DescribeClusterTemplateResponse describeClusterTemplateWithOptions(shared_ptr<DescribeClusterTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterTemplateResponse describeClusterTemplate(shared_ptr<DescribeClusterTemplateRequest> request);
  DescribeClusterV2Response describeClusterV2WithOptions(shared_ptr<DescribeClusterV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterV2Response describeClusterV2(shared_ptr<DescribeClusterV2Request> request);
  DescribeFlowResponse describeFlowWithOptions(shared_ptr<DescribeFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowResponse describeFlow(shared_ptr<DescribeFlowRequest> request);
  DescribeFlowCategoryResponse describeFlowCategoryWithOptions(shared_ptr<DescribeFlowCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowCategoryResponse describeFlowCategory(shared_ptr<DescribeFlowCategoryRequest> request);
  DescribeFlowCategoryTreeResponse describeFlowCategoryTreeWithOptions(shared_ptr<DescribeFlowCategoryTreeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowCategoryTreeResponse describeFlowCategoryTree(shared_ptr<DescribeFlowCategoryTreeRequest> request);
  DescribeFlowInstanceResponse describeFlowInstanceWithOptions(shared_ptr<DescribeFlowInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowInstanceResponse describeFlowInstance(shared_ptr<DescribeFlowInstanceRequest> request);
  DescribeFlowJobResponse describeFlowJobWithOptions(shared_ptr<DescribeFlowJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowJobResponse describeFlowJob(shared_ptr<DescribeFlowJobRequest> request);
  DescribeFlowNodeInstanceResponse describeFlowNodeInstanceWithOptions(shared_ptr<DescribeFlowNodeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowNodeInstanceResponse describeFlowNodeInstance(shared_ptr<DescribeFlowNodeInstanceRequest> request);
  DescribeFlowNodeInstanceContainerLogResponse describeFlowNodeInstanceContainerLogWithOptions(shared_ptr<DescribeFlowNodeInstanceContainerLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowNodeInstanceContainerLogResponse describeFlowNodeInstanceContainerLog(shared_ptr<DescribeFlowNodeInstanceContainerLogRequest> request);
  DescribeFlowNodeInstanceLauncherLogResponse describeFlowNodeInstanceLauncherLogWithOptions(shared_ptr<DescribeFlowNodeInstanceLauncherLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowNodeInstanceLauncherLogResponse describeFlowNodeInstanceLauncherLog(shared_ptr<DescribeFlowNodeInstanceLauncherLogRequest> request);
  DescribeFlowProjectResponse describeFlowProjectWithOptions(shared_ptr<DescribeFlowProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowProjectResponse describeFlowProject(shared_ptr<DescribeFlowProjectRequest> request);
  DescribeFlowProjectClusterSettingResponse describeFlowProjectClusterSettingWithOptions(shared_ptr<DescribeFlowProjectClusterSettingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowProjectClusterSettingResponse describeFlowProjectClusterSetting(shared_ptr<DescribeFlowProjectClusterSettingRequest> request);
  DescribeScalingConfigItemV2Response describeScalingConfigItemV2WithOptions(shared_ptr<DescribeScalingConfigItemV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScalingConfigItemV2Response describeScalingConfigItemV2(shared_ptr<DescribeScalingConfigItemV2Request> request);
  DescribeScalingGroupInstanceV2Response describeScalingGroupInstanceV2WithOptions(shared_ptr<DescribeScalingGroupInstanceV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScalingGroupInstanceV2Response describeScalingGroupInstanceV2(shared_ptr<DescribeScalingGroupInstanceV2Request> request);
  DescribeScalingGroupV2Response describeScalingGroupV2WithOptions(shared_ptr<DescribeScalingGroupV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScalingGroupV2Response describeScalingGroupV2(shared_ptr<DescribeScalingGroupV2Request> request);
  JoinResourceGroupResponse joinResourceGroupWithOptions(shared_ptr<JoinResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  JoinResourceGroupResponse joinResourceGroup(shared_ptr<JoinResourceGroupRequest> request);
  KillFlowJobResponse killFlowJobWithOptions(shared_ptr<KillFlowJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  KillFlowJobResponse killFlowJob(shared_ptr<KillFlowJobRequest> request);
  ListClusterHostResponse listClusterHostWithOptions(shared_ptr<ListClusterHostRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterHostResponse listClusterHost(shared_ptr<ListClusterHostRequest> request);
  ListClusterHostComponentResponse listClusterHostComponentWithOptions(shared_ptr<ListClusterHostComponentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterHostComponentResponse listClusterHostComponent(shared_ptr<ListClusterHostComponentRequest> request);
  ListClusterHostGroupResponse listClusterHostGroupWithOptions(shared_ptr<ListClusterHostGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterHostGroupResponse listClusterHostGroup(shared_ptr<ListClusterHostGroupRequest> request);
  ListClusterInstalledServiceResponse listClusterInstalledServiceWithOptions(shared_ptr<ListClusterInstalledServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterInstalledServiceResponse listClusterInstalledService(shared_ptr<ListClusterInstalledServiceRequest> request);
  ListClusterOperationResponse listClusterOperationWithOptions(shared_ptr<ListClusterOperationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterOperationResponse listClusterOperation(shared_ptr<ListClusterOperationRequest> request);
  ListClusterOperationHostResponse listClusterOperationHostWithOptions(shared_ptr<ListClusterOperationHostRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterOperationHostResponse listClusterOperationHost(shared_ptr<ListClusterOperationHostRequest> request);
  ListClusterOperationHostTaskResponse listClusterOperationHostTaskWithOptions(shared_ptr<ListClusterOperationHostTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterOperationHostTaskResponse listClusterOperationHostTask(shared_ptr<ListClusterOperationHostTaskRequest> request);
  ListClusterOperationTaskResponse listClusterOperationTaskWithOptions(shared_ptr<ListClusterOperationTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterOperationTaskResponse listClusterOperationTask(shared_ptr<ListClusterOperationTaskRequest> request);
  ListClusterServiceResponse listClusterServiceWithOptions(shared_ptr<ListClusterServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterServiceResponse listClusterService(shared_ptr<ListClusterServiceRequest> request);
  ListClusterServiceComponentHealthInfoResponse listClusterServiceComponentHealthInfoWithOptions(shared_ptr<ListClusterServiceComponentHealthInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterServiceComponentHealthInfoResponse listClusterServiceComponentHealthInfo(shared_ptr<ListClusterServiceComponentHealthInfoRequest> request);
  ListClusterServiceConfigHistoryResponse listClusterServiceConfigHistoryWithOptions(shared_ptr<ListClusterServiceConfigHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterServiceConfigHistoryResponse listClusterServiceConfigHistory(shared_ptr<ListClusterServiceConfigHistoryRequest> request);
  ListClusterServiceQuickLinkResponse listClusterServiceQuickLinkWithOptions(shared_ptr<ListClusterServiceQuickLinkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterServiceQuickLinkResponse listClusterServiceQuickLink(shared_ptr<ListClusterServiceQuickLinkRequest> request);
  ListClusterTemplatesResponse listClusterTemplatesWithOptions(shared_ptr<ListClusterTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterTemplatesResponse listClusterTemplates(shared_ptr<ListClusterTemplatesRequest> request);
  ListClustersResponse listClustersWithOptions(shared_ptr<ListClustersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClustersResponse listClusters(shared_ptr<ListClustersRequest> request);
  ListEmrAvailableConfigResponse listEmrAvailableConfigWithOptions(shared_ptr<ListEmrAvailableConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEmrAvailableConfigResponse listEmrAvailableConfig(shared_ptr<ListEmrAvailableConfigRequest> request);
  ListEmrAvailableResourceResponse listEmrAvailableResourceWithOptions(shared_ptr<ListEmrAvailableResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEmrAvailableResourceResponse listEmrAvailableResource(shared_ptr<ListEmrAvailableResourceRequest> request);
  ListEmrMainVersionResponse listEmrMainVersionWithOptions(shared_ptr<ListEmrMainVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEmrMainVersionResponse listEmrMainVersion(shared_ptr<ListEmrMainVersionRequest> request);
  ListFlowResponse listFlowWithOptions(shared_ptr<ListFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowResponse listFlow(shared_ptr<ListFlowRequest> request);
  ListFlowCategoryResponse listFlowCategoryWithOptions(shared_ptr<ListFlowCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowCategoryResponse listFlowCategory(shared_ptr<ListFlowCategoryRequest> request);
  ListFlowClusterResponse listFlowClusterWithOptions(shared_ptr<ListFlowClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowClusterResponse listFlowCluster(shared_ptr<ListFlowClusterRequest> request);
  ListFlowClusterAllResponse listFlowClusterAllWithOptions(shared_ptr<ListFlowClusterAllRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowClusterAllResponse listFlowClusterAll(shared_ptr<ListFlowClusterAllRequest> request);
  ListFlowClusterAllHostsResponse listFlowClusterAllHostsWithOptions(shared_ptr<ListFlowClusterAllHostsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowClusterAllHostsResponse listFlowClusterAllHosts(shared_ptr<ListFlowClusterAllHostsRequest> request);
  ListFlowClusterHostResponse listFlowClusterHostWithOptions(shared_ptr<ListFlowClusterHostRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowClusterHostResponse listFlowClusterHost(shared_ptr<ListFlowClusterHostRequest> request);
  ListFlowInstanceResponse listFlowInstanceWithOptions(shared_ptr<ListFlowInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowInstanceResponse listFlowInstance(shared_ptr<ListFlowInstanceRequest> request);
  ListFlowJobResponse listFlowJobWithOptions(shared_ptr<ListFlowJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowJobResponse listFlowJob(shared_ptr<ListFlowJobRequest> request);
  ListFlowJobHistoryResponse listFlowJobHistoryWithOptions(shared_ptr<ListFlowJobHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowJobHistoryResponse listFlowJobHistory(shared_ptr<ListFlowJobHistoryRequest> request);
  ListFlowNodeInstanceResponse listFlowNodeInstanceWithOptions(shared_ptr<ListFlowNodeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowNodeInstanceResponse listFlowNodeInstance(shared_ptr<ListFlowNodeInstanceRequest> request);
  ListFlowNodeInstanceContainerStatusResponse listFlowNodeInstanceContainerStatusWithOptions(shared_ptr<ListFlowNodeInstanceContainerStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowNodeInstanceContainerStatusResponse listFlowNodeInstanceContainerStatus(shared_ptr<ListFlowNodeInstanceContainerStatusRequest> request);
  ListFlowNodeSqlResultResponse listFlowNodeSqlResultWithOptions(shared_ptr<ListFlowNodeSqlResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowNodeSqlResultResponse listFlowNodeSqlResult(shared_ptr<ListFlowNodeSqlResultRequest> request);
  ListFlowProjectResponse listFlowProjectWithOptions(shared_ptr<ListFlowProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowProjectResponse listFlowProject(shared_ptr<ListFlowProjectRequest> request);
  ListFlowProjectClusterSettingResponse listFlowProjectClusterSettingWithOptions(shared_ptr<ListFlowProjectClusterSettingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowProjectClusterSettingResponse listFlowProjectClusterSetting(shared_ptr<ListFlowProjectClusterSettingRequest> request);
  ListFlowProjectUserResponse listFlowProjectUserWithOptions(shared_ptr<ListFlowProjectUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowProjectUserResponse listFlowProjectUser(shared_ptr<ListFlowProjectUserRequest> request);
  ListResourcePoolResponse listResourcePoolWithOptions(shared_ptr<ListResourcePoolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListResourcePoolResponse listResourcePool(shared_ptr<ListResourcePoolRequest> request);
  ListScalingActivityV2Response listScalingActivityV2WithOptions(shared_ptr<ListScalingActivityV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListScalingActivityV2Response listScalingActivityV2(shared_ptr<ListScalingActivityV2Request> request);
  ListScalingConfigItemV2Response listScalingConfigItemV2WithOptions(shared_ptr<ListScalingConfigItemV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListScalingConfigItemV2Response listScalingConfigItemV2(shared_ptr<ListScalingConfigItemV2Request> request);
  ListScalingGroupV2Response listScalingGroupV2WithOptions(shared_ptr<ListScalingGroupV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListScalingGroupV2Response listScalingGroupV2(shared_ptr<ListScalingGroupV2Request> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ModifyClusterNameResponse modifyClusterNameWithOptions(shared_ptr<ModifyClusterNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyClusterNameResponse modifyClusterName(shared_ptr<ModifyClusterNameRequest> request);
  ModifyClusterServiceConfigResponse modifyClusterServiceConfigWithOptions(shared_ptr<ModifyClusterServiceConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyClusterServiceConfigResponse modifyClusterServiceConfig(shared_ptr<ModifyClusterServiceConfigRequest> request);
  ModifyClusterTemplateResponse modifyClusterTemplateWithOptions(shared_ptr<ModifyClusterTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyClusterTemplateResponse modifyClusterTemplate(shared_ptr<ModifyClusterTemplateRequest> request);
  ModifyFlowCategoryResponse modifyFlowCategoryWithOptions(shared_ptr<ModifyFlowCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyFlowCategoryResponse modifyFlowCategory(shared_ptr<ModifyFlowCategoryRequest> request);
  ModifyFlowForWebResponse modifyFlowForWebWithOptions(shared_ptr<ModifyFlowForWebRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyFlowForWebResponse modifyFlowForWeb(shared_ptr<ModifyFlowForWebRequest> request);
  ModifyFlowProjectResponse modifyFlowProjectWithOptions(shared_ptr<ModifyFlowProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyFlowProjectResponse modifyFlowProject(shared_ptr<ModifyFlowProjectRequest> request);
  ModifyFlowProjectClusterSettingResponse modifyFlowProjectClusterSettingWithOptions(shared_ptr<ModifyFlowProjectClusterSettingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyFlowProjectClusterSettingResponse modifyFlowProjectClusterSetting(shared_ptr<ModifyFlowProjectClusterSettingRequest> request);
  ModifyResourcePoolResponse modifyResourcePoolWithOptions(shared_ptr<ModifyResourcePoolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyResourcePoolResponse modifyResourcePool(shared_ptr<ModifyResourcePoolRequest> request);
  ModifyResourcePoolSchedulerTypeResponse modifyResourcePoolSchedulerTypeWithOptions(shared_ptr<ModifyResourcePoolSchedulerTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyResourcePoolSchedulerTypeResponse modifyResourcePoolSchedulerType(shared_ptr<ModifyResourcePoolSchedulerTypeRequest> request);
  ModifyResourceQueueResponse modifyResourceQueueWithOptions(shared_ptr<ModifyResourceQueueRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyResourceQueueResponse modifyResourceQueue(shared_ptr<ModifyResourceQueueRequest> request);
  ModifyScalingConfigItemV2Response modifyScalingConfigItemV2WithOptions(shared_ptr<ModifyScalingConfigItemV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyScalingConfigItemV2Response modifyScalingConfigItemV2(shared_ptr<ModifyScalingConfigItemV2Request> request);
  ModifyScalingGroupV2Response modifyScalingGroupV2WithOptions(shared_ptr<ModifyScalingGroupV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyScalingGroupV2Response modifyScalingGroupV2(shared_ptr<ModifyScalingGroupV2Request> request);
  RefreshClusterResourcePoolResponse refreshClusterResourcePoolWithOptions(shared_ptr<RefreshClusterResourcePoolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefreshClusterResourcePoolResponse refreshClusterResourcePool(shared_ptr<RefreshClusterResourcePoolRequest> request);
  ReleaseClusterResponse releaseClusterWithOptions(shared_ptr<ReleaseClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseClusterResponse releaseCluster(shared_ptr<ReleaseClusterRequest> request);
  ReleaseClusterHostGroupResponse releaseClusterHostGroupWithOptions(shared_ptr<ReleaseClusterHostGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseClusterHostGroupResponse releaseClusterHostGroup(shared_ptr<ReleaseClusterHostGroupRequest> request);
  RemoveScalingConfigItemV2Response removeScalingConfigItemV2WithOptions(shared_ptr<RemoveScalingConfigItemV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveScalingConfigItemV2Response removeScalingConfigItemV2(shared_ptr<RemoveScalingConfigItemV2Request> request);
  RerunFlowResponse rerunFlowWithOptions(shared_ptr<RerunFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RerunFlowResponse rerunFlow(shared_ptr<RerunFlowRequest> request);
  ResizeClusterV2Response resizeClusterV2WithOptions(shared_ptr<ResizeClusterV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResizeClusterV2Response resizeClusterV2(shared_ptr<ResizeClusterV2Request> request);
  ResumeFlowResponse resumeFlowWithOptions(shared_ptr<ResumeFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeFlowResponse resumeFlow(shared_ptr<ResumeFlowRequest> request);
  RunClusterServiceActionResponse runClusterServiceActionWithOptions(shared_ptr<RunClusterServiceActionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunClusterServiceActionResponse runClusterServiceAction(shared_ptr<RunClusterServiceActionRequest> request);
  RunScalingActionV2Response runScalingActionV2WithOptions(shared_ptr<RunScalingActionV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunScalingActionV2Response runScalingActionV2(shared_ptr<RunScalingActionV2Request> request);
  StartFlowResponse startFlowWithOptions(shared_ptr<StartFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartFlowResponse startFlow(shared_ptr<StartFlowRequest> request);
  SubmitFlowResponse submitFlowWithOptions(shared_ptr<SubmitFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitFlowResponse submitFlow(shared_ptr<SubmitFlowRequest> request);
  SubmitFlowJobResponse submitFlowJobWithOptions(shared_ptr<SubmitFlowJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitFlowJobResponse submitFlowJob(shared_ptr<SubmitFlowJobRequest> request);
  SuspendFlowResponse suspendFlowWithOptions(shared_ptr<SuspendFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SuspendFlowResponse suspendFlow(shared_ptr<SuspendFlowRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Emr20160408

#endif
