// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_ALIDING20230426_H_
#define ALIBABACLOUD_ALIDING20230426_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Aliding20230426 {
class DentryAppPropertiesValue : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};
  shared_ptr<string> visibility{};

  DentryAppPropertiesValue() {}

  explicit DentryAppPropertiesValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DentryAppPropertiesValue() = default;
};
class DentriesAppPropertiesValue : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};
  shared_ptr<string> visibility{};

  DentriesAppPropertiesValue() {}

  explicit DentriesAppPropertiesValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DentriesAppPropertiesValue() = default;
};
class AddAttendeeHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  AddAttendeeHeadersAccountContext() {}

  explicit AddAttendeeHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~AddAttendeeHeadersAccountContext() = default;
};
class AddAttendeeHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<AddAttendeeHeadersAccountContext> accountContext{};

  AddAttendeeHeaders() {}

  explicit AddAttendeeHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        AddAttendeeHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<AddAttendeeHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~AddAttendeeHeaders() = default;
};
class AddAttendeeShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  AddAttendeeShrinkHeaders() {}

  explicit AddAttendeeShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~AddAttendeeShrinkHeaders() = default;
};
class AddAttendeeRequestAttendeesToAdd : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<bool> isOptional{};

  AddAttendeeRequestAttendeesToAdd() {}

  explicit AddAttendeeRequestAttendeesToAdd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isOptional) {
      res["isOptional"] = boost::any(*isOptional);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("isOptional") != m.end() && !m["isOptional"].empty()) {
      isOptional = make_shared<bool>(boost::any_cast<bool>(m["isOptional"]));
    }
  }


  virtual ~AddAttendeeRequestAttendeesToAdd() = default;
};
class AddAttendeeRequest : public Darabonba::Model {
public:
  shared_ptr<vector<AddAttendeeRequestAttendeesToAdd>> attendeesToAdd{};
  shared_ptr<string> calendarId{};
  shared_ptr<string> eventId{};
  shared_ptr<bool> chatNotification{};
  shared_ptr<bool> pushNotification{};

  AddAttendeeRequest() {}

  explicit AddAttendeeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendeesToAdd) {
      vector<boost::any> temp1;
      for(auto item1:*attendeesToAdd){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AttendeesToAdd"] = boost::any(temp1);
    }
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (chatNotification) {
      res["chatNotification"] = boost::any(*chatNotification);
    }
    if (pushNotification) {
      res["pushNotification"] = boost::any(*pushNotification);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttendeesToAdd") != m.end() && !m["AttendeesToAdd"].empty()) {
      if (typeid(vector<boost::any>) == m["AttendeesToAdd"].type()) {
        vector<AddAttendeeRequestAttendeesToAdd> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AttendeesToAdd"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddAttendeeRequestAttendeesToAdd model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attendeesToAdd = make_shared<vector<AddAttendeeRequestAttendeesToAdd>>(expect1);
      }
    }
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("chatNotification") != m.end() && !m["chatNotification"].empty()) {
      chatNotification = make_shared<bool>(boost::any_cast<bool>(m["chatNotification"]));
    }
    if (m.find("pushNotification") != m.end() && !m["pushNotification"].empty()) {
      pushNotification = make_shared<bool>(boost::any_cast<bool>(m["pushNotification"]));
    }
  }


  virtual ~AddAttendeeRequest() = default;
};
class AddAttendeeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> attendeesToAddShrink{};
  shared_ptr<string> calendarId{};
  shared_ptr<string> eventId{};
  shared_ptr<bool> chatNotification{};
  shared_ptr<bool> pushNotification{};

  AddAttendeeShrinkRequest() {}

  explicit AddAttendeeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendeesToAddShrink) {
      res["AttendeesToAdd"] = boost::any(*attendeesToAddShrink);
    }
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (chatNotification) {
      res["chatNotification"] = boost::any(*chatNotification);
    }
    if (pushNotification) {
      res["pushNotification"] = boost::any(*pushNotification);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttendeesToAdd") != m.end() && !m["AttendeesToAdd"].empty()) {
      attendeesToAddShrink = make_shared<string>(boost::any_cast<string>(m["AttendeesToAdd"]));
    }
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("chatNotification") != m.end() && !m["chatNotification"].empty()) {
      chatNotification = make_shared<bool>(boost::any_cast<bool>(m["chatNotification"]));
    }
    if (m.find("pushNotification") != m.end() && !m["pushNotification"].empty()) {
      pushNotification = make_shared<bool>(boost::any_cast<bool>(m["pushNotification"]));
    }
  }


  virtual ~AddAttendeeShrinkRequest() = default;
};
class AddAttendeeResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};

  AddAttendeeResponseBodyContent() {}

  explicit AddAttendeeResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
  }


  virtual ~AddAttendeeResponseBodyContent() = default;
};
class AddAttendeeResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddAttendeeResponseBodyContent> content{};
  shared_ptr<string> errorCode{};
  shared_ptr<map<string, boost::any>> errorCtx{};
  shared_ptr<string> errorMsg{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddAttendeeResponseBody() {}

  explicit AddAttendeeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorCtx) {
      res["ErrorCtx"] = boost::any(*errorCtx);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        AddAttendeeResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<AddAttendeeResponseBodyContent>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorCtx") != m.end() && !m["ErrorCtx"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ErrorCtx"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      errorCtx = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddAttendeeResponseBody() = default;
};
class AddAttendeeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddAttendeeResponseBody> body{};

  AddAttendeeResponse() {}

  explicit AddAttendeeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddAttendeeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddAttendeeResponseBody>(model1);
      }
    }
  }


  virtual ~AddAttendeeResponse() = default;
};
class AddDriveSpaceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  AddDriveSpaceHeadersAccountContext() {}

  explicit AddDriveSpaceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~AddDriveSpaceHeadersAccountContext() = default;
};
class AddDriveSpaceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<AddDriveSpaceHeadersAccountContext> accountContext{};

  AddDriveSpaceHeaders() {}

  explicit AddDriveSpaceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        AddDriveSpaceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<AddDriveSpaceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~AddDriveSpaceHeaders() = default;
};
class AddDriveSpaceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  AddDriveSpaceShrinkHeaders() {}

  explicit AddDriveSpaceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~AddDriveSpaceShrinkHeaders() = default;
};
class AddDriveSpaceRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  AddDriveSpaceRequestTenantContext() {}

  explicit AddDriveSpaceRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~AddDriveSpaceRequestTenantContext() = default;
};
class AddDriveSpaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<AddDriveSpaceRequestTenantContext> tenantContext{};

  AddDriveSpaceRequest() {}

  explicit AddDriveSpaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        AddDriveSpaceRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<AddDriveSpaceRequestTenantContext>(model1);
      }
    }
  }


  virtual ~AddDriveSpaceRequest() = default;
};
class AddDriveSpaceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> tenantContextShrink{};

  AddDriveSpaceShrinkRequest() {}

  explicit AddDriveSpaceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~AddDriveSpaceShrinkRequest() = default;
};
class AddDriveSpaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> permissionMode{};
  shared_ptr<long> quota{};
  shared_ptr<string> requestId{};
  shared_ptr<string> spaceId{};
  shared_ptr<string> spaceName{};
  shared_ptr<string> spaceType{};
  shared_ptr<long> usedQuota{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  AddDriveSpaceResponseBody() {}

  explicit AddDriveSpaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (modifyTime) {
      res["modifyTime"] = boost::any(*modifyTime);
    }
    if (permissionMode) {
      res["permissionMode"] = boost::any(*permissionMode);
    }
    if (quota) {
      res["quota"] = boost::any(*quota);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (spaceId) {
      res["spaceId"] = boost::any(*spaceId);
    }
    if (spaceName) {
      res["spaceName"] = boost::any(*spaceName);
    }
    if (spaceType) {
      res["spaceType"] = boost::any(*spaceType);
    }
    if (usedQuota) {
      res["usedQuota"] = boost::any(*usedQuota);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("modifyTime") != m.end() && !m["modifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["modifyTime"]));
    }
    if (m.find("permissionMode") != m.end() && !m["permissionMode"].empty()) {
      permissionMode = make_shared<string>(boost::any_cast<string>(m["permissionMode"]));
    }
    if (m.find("quota") != m.end() && !m["quota"].empty()) {
      quota = make_shared<long>(boost::any_cast<long>(m["quota"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("spaceId") != m.end() && !m["spaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["spaceId"]));
    }
    if (m.find("spaceName") != m.end() && !m["spaceName"].empty()) {
      spaceName = make_shared<string>(boost::any_cast<string>(m["spaceName"]));
    }
    if (m.find("spaceType") != m.end() && !m["spaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["spaceType"]));
    }
    if (m.find("usedQuota") != m.end() && !m["usedQuota"].empty()) {
      usedQuota = make_shared<long>(boost::any_cast<long>(m["usedQuota"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~AddDriveSpaceResponseBody() = default;
};
class AddDriveSpaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddDriveSpaceResponseBody> body{};

  AddDriveSpaceResponse() {}

  explicit AddDriveSpaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDriveSpaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDriveSpaceResponseBody>(model1);
      }
    }
  }


  virtual ~AddDriveSpaceResponse() = default;
};
class AddFolderHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  AddFolderHeadersAccountContext() {}

  explicit AddFolderHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~AddFolderHeadersAccountContext() = default;
};
class AddFolderHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<AddFolderHeadersAccountContext> accountContext{};

  AddFolderHeaders() {}

  explicit AddFolderHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        AddFolderHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<AddFolderHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~AddFolderHeaders() = default;
};
class AddFolderShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  AddFolderShrinkHeaders() {}

  explicit AddFolderShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~AddFolderShrinkHeaders() = default;
};
class AddFolderRequestOptionAppProperties : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};
  shared_ptr<string> visibility{};

  AddFolderRequestOptionAppProperties() {}

  explicit AddFolderRequestOptionAppProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~AddFolderRequestOptionAppProperties() = default;
};
class AddFolderRequestOption : public Darabonba::Model {
public:
  shared_ptr<vector<AddFolderRequestOptionAppProperties>> appProperties{};
  shared_ptr<string> conflictStrategy{};

  AddFolderRequestOption() {}

  explicit AddFolderRequestOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appProperties) {
      vector<boost::any> temp1;
      for(auto item1:*appProperties){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppProperties"] = boost::any(temp1);
    }
    if (conflictStrategy) {
      res["ConflictStrategy"] = boost::any(*conflictStrategy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppProperties") != m.end() && !m["AppProperties"].empty()) {
      if (typeid(vector<boost::any>) == m["AppProperties"].type()) {
        vector<AddFolderRequestOptionAppProperties> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppProperties"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddFolderRequestOptionAppProperties model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appProperties = make_shared<vector<AddFolderRequestOptionAppProperties>>(expect1);
      }
    }
    if (m.find("ConflictStrategy") != m.end() && !m["ConflictStrategy"].empty()) {
      conflictStrategy = make_shared<string>(boost::any_cast<string>(m["ConflictStrategy"]));
    }
  }


  virtual ~AddFolderRequestOption() = default;
};
class AddFolderRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  AddFolderRequestTenantContext() {}

  explicit AddFolderRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~AddFolderRequestTenantContext() = default;
};
class AddFolderRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<AddFolderRequestOption> option{};
  shared_ptr<string> parentId{};
  shared_ptr<string> spaceId{};
  shared_ptr<AddFolderRequestTenantContext> tenantContext{};

  AddFolderRequest() {}

  explicit AddFolderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (option) {
      res["Option"] = option ? boost::any(option->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      if (typeid(map<string, boost::any>) == m["Option"].type()) {
        AddFolderRequestOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Option"]));
        option = make_shared<AddFolderRequestOption>(model1);
      }
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        AddFolderRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<AddFolderRequestTenantContext>(model1);
      }
    }
  }


  virtual ~AddFolderRequest() = default;
};
class AddFolderShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> optionShrink{};
  shared_ptr<string> parentId{};
  shared_ptr<string> spaceId{};
  shared_ptr<string> tenantContextShrink{};

  AddFolderShrinkRequest() {}

  explicit AddFolderShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (optionShrink) {
      res["Option"] = boost::any(*optionShrink);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      optionShrink = make_shared<string>(boost::any_cast<string>(m["Option"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~AddFolderShrinkRequest() = default;
};
class AddFolderResponseBodyDentryProperties : public Darabonba::Model {
public:
  shared_ptr<bool> readOnly{};

  AddFolderResponseBodyDentryProperties() {}

  explicit AddFolderResponseBodyDentryProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
  }


  virtual ~AddFolderResponseBodyDentryProperties() = default;
};
class AddFolderResponseBodyDentry : public Darabonba::Model {
public:
  shared_ptr<map<string, vector<DentryAppPropertiesValue>>> appProperties{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> extension{};
  shared_ptr<string> id{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> name{};
  shared_ptr<string> parentId{};
  shared_ptr<string> partitionType{};
  shared_ptr<string> path{};
  shared_ptr<AddFolderResponseBodyDentryProperties> properties{};
  shared_ptr<long> size{};
  shared_ptr<string> spaceId{};
  shared_ptr<string> status{};
  shared_ptr<string> storageDriver{};
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};
  shared_ptr<long> version{};

  AddFolderResponseBodyDentry() {}

  explicit AddFolderResponseBodyDentry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appProperties) {
      map<string, boost::any> temp1;
      for(auto item1:*appProperties){
        vector<boost::any> temp2;
        for(auto item2:item1.second){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1[item1.first] = boost::any(temp2);
      }
      res["AppProperties"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (partitionType) {
      res["PartitionType"] = boost::any(*partitionType);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageDriver) {
      res["StorageDriver"] = boost::any(*storageDriver);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppProperties") != m.end() && !m["AppProperties"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppProperties"].type()) {
        map<string, vector<DentryAppPropertiesValue>> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["AppProperties"])){
          if (typeid(vector<boost::any>) == item1.second.type()) {
            vector<DentryAppPropertiesValue> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1.second)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                DentryAppPropertiesValue model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1[item1.first] = expect2;
          }
        }
        appProperties = make_shared<map<string, vector<DentryAppPropertiesValue>>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["ModifierId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("PartitionType") != m.end() && !m["PartitionType"].empty()) {
      partitionType = make_shared<string>(boost::any_cast<string>(m["PartitionType"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        AddFolderResponseBodyDentryProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<AddFolderResponseBodyDentryProperties>(model1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageDriver") != m.end() && !m["StorageDriver"].empty()) {
      storageDriver = make_shared<string>(boost::any_cast<string>(m["StorageDriver"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~AddFolderResponseBodyDentry() = default;
};
class AddFolderResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddFolderResponseBodyDentry> dentry{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  AddFolderResponseBody() {}

  explicit AddFolderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentry) {
      res["dentry"] = dentry ? boost::any(dentry->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dentry") != m.end() && !m["dentry"].empty()) {
      if (typeid(map<string, boost::any>) == m["dentry"].type()) {
        AddFolderResponseBodyDentry model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dentry"]));
        dentry = make_shared<AddFolderResponseBodyDentry>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~AddFolderResponseBody() = default;
};
class AddFolderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddFolderResponseBody> body{};

  AddFolderResponse() {}

  explicit AddFolderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddFolderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddFolderResponseBody>(model1);
      }
    }
  }


  virtual ~AddFolderResponse() = default;
};
class AddMeetingRoomsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  AddMeetingRoomsHeadersAccountContext() {}

  explicit AddMeetingRoomsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~AddMeetingRoomsHeadersAccountContext() = default;
};
class AddMeetingRoomsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<AddMeetingRoomsHeadersAccountContext> accountContext{};

  AddMeetingRoomsHeaders() {}

  explicit AddMeetingRoomsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        AddMeetingRoomsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<AddMeetingRoomsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~AddMeetingRoomsHeaders() = default;
};
class AddMeetingRoomsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  AddMeetingRoomsShrinkHeaders() {}

  explicit AddMeetingRoomsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~AddMeetingRoomsShrinkHeaders() = default;
};
class AddMeetingRoomsRequestMeetingRoomsToAdd : public Darabonba::Model {
public:
  shared_ptr<string> roomId{};

  AddMeetingRoomsRequestMeetingRoomsToAdd() {}

  explicit AddMeetingRoomsRequestMeetingRoomsToAdd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
  }


  virtual ~AddMeetingRoomsRequestMeetingRoomsToAdd() = default;
};
class AddMeetingRoomsRequest : public Darabonba::Model {
public:
  shared_ptr<string> calendarId{};
  shared_ptr<string> eventId{};
  shared_ptr<vector<AddMeetingRoomsRequestMeetingRoomsToAdd>> meetingRoomsToAdd{};

  AddMeetingRoomsRequest() {}

  explicit AddMeetingRoomsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (meetingRoomsToAdd) {
      vector<boost::any> temp1;
      for(auto item1:*meetingRoomsToAdd){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MeetingRoomsToAdd"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("MeetingRoomsToAdd") != m.end() && !m["MeetingRoomsToAdd"].empty()) {
      if (typeid(vector<boost::any>) == m["MeetingRoomsToAdd"].type()) {
        vector<AddMeetingRoomsRequestMeetingRoomsToAdd> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MeetingRoomsToAdd"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddMeetingRoomsRequestMeetingRoomsToAdd model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        meetingRoomsToAdd = make_shared<vector<AddMeetingRoomsRequestMeetingRoomsToAdd>>(expect1);
      }
    }
  }


  virtual ~AddMeetingRoomsRequest() = default;
};
class AddMeetingRoomsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> calendarId{};
  shared_ptr<string> eventId{};
  shared_ptr<string> meetingRoomsToAddShrink{};

  AddMeetingRoomsShrinkRequest() {}

  explicit AddMeetingRoomsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (meetingRoomsToAddShrink) {
      res["MeetingRoomsToAdd"] = boost::any(*meetingRoomsToAddShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("MeetingRoomsToAdd") != m.end() && !m["MeetingRoomsToAdd"].empty()) {
      meetingRoomsToAddShrink = make_shared<string>(boost::any_cast<string>(m["MeetingRoomsToAdd"]));
    }
  }


  virtual ~AddMeetingRoomsShrinkRequest() = default;
};
class AddMeetingRoomsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  AddMeetingRoomsResponseBody() {}

  explicit AddMeetingRoomsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~AddMeetingRoomsResponseBody() = default;
};
class AddMeetingRoomsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddMeetingRoomsResponseBody> body{};

  AddMeetingRoomsResponse() {}

  explicit AddMeetingRoomsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddMeetingRoomsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddMeetingRoomsResponseBody>(model1);
      }
    }
  }


  virtual ~AddMeetingRoomsResponse() = default;
};
class AddMultiDimTableHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  AddMultiDimTableHeadersAccountContext() {}

  explicit AddMultiDimTableHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~AddMultiDimTableHeadersAccountContext() = default;
};
class AddMultiDimTableHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<AddMultiDimTableHeadersAccountContext> accountContext{};

  AddMultiDimTableHeaders() {}

  explicit AddMultiDimTableHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        AddMultiDimTableHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<AddMultiDimTableHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~AddMultiDimTableHeaders() = default;
};
class AddMultiDimTableShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  AddMultiDimTableShrinkHeaders() {}

  explicit AddMultiDimTableShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~AddMultiDimTableShrinkHeaders() = default;
};
class AddMultiDimTableRequestFields : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<map<string, boost::any>> property{};
  shared_ptr<string> type{};

  AddMultiDimTableRequestFields() {}

  explicit AddMultiDimTableRequestFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (property) {
      res["Property"] = boost::any(*property);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Property"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      property = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddMultiDimTableRequestFields() = default;
};
class AddMultiDimTableRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  AddMultiDimTableRequestTenantContext() {}

  explicit AddMultiDimTableRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~AddMultiDimTableRequestTenantContext() = default;
};
class AddMultiDimTableRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<vector<AddMultiDimTableRequestFields>> fields{};
  shared_ptr<string> name{};
  shared_ptr<AddMultiDimTableRequestTenantContext> tenantContext{};

  AddMultiDimTableRequest() {}

  explicit AddMultiDimTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (fields) {
      vector<boost::any> temp1;
      for(auto item1:*fields){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Fields"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("Fields") != m.end() && !m["Fields"].empty()) {
      if (typeid(vector<boost::any>) == m["Fields"].type()) {
        vector<AddMultiDimTableRequestFields> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Fields"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddMultiDimTableRequestFields model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fields = make_shared<vector<AddMultiDimTableRequestFields>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        AddMultiDimTableRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<AddMultiDimTableRequestTenantContext>(model1);
      }
    }
  }


  virtual ~AddMultiDimTableRequest() = default;
};
class AddMultiDimTableShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<string> fieldsShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> tenantContextShrink{};

  AddMultiDimTableShrinkRequest() {}

  explicit AddMultiDimTableShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (fieldsShrink) {
      res["Fields"] = boost::any(*fieldsShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("Fields") != m.end() && !m["Fields"].empty()) {
      fieldsShrink = make_shared<string>(boost::any_cast<string>(m["Fields"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~AddMultiDimTableShrinkRequest() = default;
};
class AddMultiDimTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  AddMultiDimTableResponseBody() {}

  explicit AddMultiDimTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~AddMultiDimTableResponseBody() = default;
};
class AddMultiDimTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddMultiDimTableResponseBody> body{};

  AddMultiDimTableResponse() {}

  explicit AddMultiDimTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddMultiDimTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddMultiDimTableResponseBody>(model1);
      }
    }
  }


  virtual ~AddMultiDimTableResponse() = default;
};
class AddPermissionHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  AddPermissionHeadersAccountContext() {}

  explicit AddPermissionHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~AddPermissionHeadersAccountContext() = default;
};
class AddPermissionHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<AddPermissionHeadersAccountContext> accountContext{};

  AddPermissionHeaders() {}

  explicit AddPermissionHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        AddPermissionHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<AddPermissionHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~AddPermissionHeaders() = default;
};
class AddPermissionShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  AddPermissionShrinkHeaders() {}

  explicit AddPermissionShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~AddPermissionShrinkHeaders() = default;
};
class AddPermissionRequestMembers : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<string> id{};
  shared_ptr<string> type{};

  AddPermissionRequestMembers() {}

  explicit AddPermissionRequestMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddPermissionRequestMembers() = default;
};
class AddPermissionRequestOption : public Darabonba::Model {
public:
  shared_ptr<long> duration{};

  AddPermissionRequestOption() {}

  explicit AddPermissionRequestOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
  }


  virtual ~AddPermissionRequestOption() = default;
};
class AddPermissionRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  AddPermissionRequestTenantContext() {}

  explicit AddPermissionRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~AddPermissionRequestTenantContext() = default;
};
class AddPermissionRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryUuid{};
  shared_ptr<vector<AddPermissionRequestMembers>> members{};
  shared_ptr<AddPermissionRequestOption> option{};
  shared_ptr<string> roleId{};
  shared_ptr<AddPermissionRequestTenantContext> tenantContext{};

  AddPermissionRequest() {}

  explicit AddPermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryUuid) {
      res["DentryUuid"] = boost::any(*dentryUuid);
    }
    if (members) {
      vector<boost::any> temp1;
      for(auto item1:*members){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Members"] = boost::any(temp1);
    }
    if (option) {
      res["Option"] = option ? boost::any(option->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryUuid") != m.end() && !m["DentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["DentryUuid"]));
    }
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      if (typeid(vector<boost::any>) == m["Members"].type()) {
        vector<AddPermissionRequestMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Members"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddPermissionRequestMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        members = make_shared<vector<AddPermissionRequestMembers>>(expect1);
      }
    }
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      if (typeid(map<string, boost::any>) == m["Option"].type()) {
        AddPermissionRequestOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Option"]));
        option = make_shared<AddPermissionRequestOption>(model1);
      }
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        AddPermissionRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<AddPermissionRequestTenantContext>(model1);
      }
    }
  }


  virtual ~AddPermissionRequest() = default;
};
class AddPermissionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryUuid{};
  shared_ptr<string> membersShrink{};
  shared_ptr<string> optionShrink{};
  shared_ptr<string> roleId{};
  shared_ptr<string> tenantContextShrink{};

  AddPermissionShrinkRequest() {}

  explicit AddPermissionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryUuid) {
      res["DentryUuid"] = boost::any(*dentryUuid);
    }
    if (membersShrink) {
      res["Members"] = boost::any(*membersShrink);
    }
    if (optionShrink) {
      res["Option"] = boost::any(*optionShrink);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryUuid") != m.end() && !m["DentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["DentryUuid"]));
    }
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      membersShrink = make_shared<string>(boost::any_cast<string>(m["Members"]));
    }
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      optionShrink = make_shared<string>(boost::any_cast<string>(m["Option"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~AddPermissionShrinkRequest() = default;
};
class AddPermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  AddPermissionResponseBody() {}

  explicit AddPermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~AddPermissionResponseBody() = default;
};
class AddPermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddPermissionResponseBody> body{};

  AddPermissionResponse() {}

  explicit AddPermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPermissionResponseBody>(model1);
      }
    }
  }


  virtual ~AddPermissionResponse() = default;
};
class AddRecordPermissionHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  AddRecordPermissionHeadersAccountContext() {}

  explicit AddRecordPermissionHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~AddRecordPermissionHeadersAccountContext() = default;
};
class AddRecordPermissionHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<AddRecordPermissionHeadersAccountContext> accountContext{};

  AddRecordPermissionHeaders() {}

  explicit AddRecordPermissionHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        AddRecordPermissionHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<AddRecordPermissionHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~AddRecordPermissionHeaders() = default;
};
class AddRecordPermissionShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  AddRecordPermissionShrinkHeaders() {}

  explicit AddRecordPermissionShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~AddRecordPermissionShrinkHeaders() = default;
};
class AddRecordPermissionRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  AddRecordPermissionRequestTenantContext() {}

  explicit AddRecordPermissionRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~AddRecordPermissionRequestTenantContext() = default;
};
class AddRecordPermissionRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> conferenceId{};
  shared_ptr<AddRecordPermissionRequestTenantContext> tenantContext{};
  shared_ptr<string> userId{};

  AddRecordPermissionRequest() {}

  explicit AddRecordPermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (conferenceId) {
      res["ConferenceId"] = boost::any(*conferenceId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ConferenceId") != m.end() && !m["ConferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["ConferenceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        AddRecordPermissionRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<AddRecordPermissionRequestTenantContext>(model1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~AddRecordPermissionRequest() = default;
};
class AddRecordPermissionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> conferenceId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> userId{};

  AddRecordPermissionShrinkRequest() {}

  explicit AddRecordPermissionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (conferenceId) {
      res["ConferenceId"] = boost::any(*conferenceId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ConferenceId") != m.end() && !m["ConferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["ConferenceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~AddRecordPermissionShrinkRequest() = default;
};
class AddRecordPermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  AddRecordPermissionResponseBody() {}

  explicit AddRecordPermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~AddRecordPermissionResponseBody() = default;
};
class AddRecordPermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddRecordPermissionResponseBody> body{};

  AddRecordPermissionResponse() {}

  explicit AddRecordPermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddRecordPermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddRecordPermissionResponseBody>(model1);
      }
    }
  }


  virtual ~AddRecordPermissionResponse() = default;
};
class AddScenegroupMemberHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  AddScenegroupMemberHeadersAccountContext() {}

  explicit AddScenegroupMemberHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~AddScenegroupMemberHeadersAccountContext() = default;
};
class AddScenegroupMemberHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<AddScenegroupMemberHeadersAccountContext> accountContext{};

  AddScenegroupMemberHeaders() {}

  explicit AddScenegroupMemberHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        AddScenegroupMemberHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<AddScenegroupMemberHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~AddScenegroupMemberHeaders() = default;
};
class AddScenegroupMemberShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  AddScenegroupMemberShrinkHeaders() {}

  explicit AddScenegroupMemberShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~AddScenegroupMemberShrinkHeaders() = default;
};
class AddScenegroupMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> openConversationId{};
  shared_ptr<string> userIds{};

  AddScenegroupMemberRequest() {}

  explicit AddScenegroupMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openConversationId) {
      res["OpenConversationId"] = boost::any(*openConversationId);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpenConversationId") != m.end() && !m["OpenConversationId"].empty()) {
      openConversationId = make_shared<string>(boost::any_cast<string>(m["OpenConversationId"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      userIds = make_shared<string>(boost::any_cast<string>(m["UserIds"]));
    }
  }


  virtual ~AddScenegroupMemberRequest() = default;
};
class AddScenegroupMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddScenegroupMemberResponseBody() {}

  explicit AddScenegroupMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~AddScenegroupMemberResponseBody() = default;
};
class AddScenegroupMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddScenegroupMemberResponseBody> body{};

  AddScenegroupMemberResponse() {}

  explicit AddScenegroupMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddScenegroupMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddScenegroupMemberResponseBody>(model1);
      }
    }
  }


  virtual ~AddScenegroupMemberResponse() = default;
};
class AddTicketMemoHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  AddTicketMemoHeadersAccountContext() {}

  explicit AddTicketMemoHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~AddTicketMemoHeadersAccountContext() = default;
};
class AddTicketMemoHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<AddTicketMemoHeadersAccountContext> accountContext{};

  AddTicketMemoHeaders() {}

  explicit AddTicketMemoHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        AddTicketMemoHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<AddTicketMemoHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~AddTicketMemoHeaders() = default;
};
class AddTicketMemoShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  AddTicketMemoShrinkHeaders() {}

  explicit AddTicketMemoShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~AddTicketMemoShrinkHeaders() = default;
};
class AddTicketMemoRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  AddTicketMemoRequestTenantContext() {}

  explicit AddTicketMemoRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~AddTicketMemoRequestTenantContext() = default;
};
class AddTicketMemoRequestTicketMemoAttachments : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> key{};

  AddTicketMemoRequestTicketMemoAttachments() {}

  explicit AddTicketMemoRequestTicketMemoAttachments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~AddTicketMemoRequestTicketMemoAttachments() = default;
};
class AddTicketMemoRequestTicketMemo : public Darabonba::Model {
public:
  shared_ptr<vector<AddTicketMemoRequestTicketMemoAttachments>> attachments{};
  shared_ptr<string> memo{};

  AddTicketMemoRequestTicketMemo() {}

  explicit AddTicketMemoRequestTicketMemo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachments) {
      vector<boost::any> temp1;
      for(auto item1:*attachments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attachments"] = boost::any(temp1);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attachments") != m.end() && !m["Attachments"].empty()) {
      if (typeid(vector<boost::any>) == m["Attachments"].type()) {
        vector<AddTicketMemoRequestTicketMemoAttachments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attachments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddTicketMemoRequestTicketMemoAttachments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attachments = make_shared<vector<AddTicketMemoRequestTicketMemoAttachments>>(expect1);
      }
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
  }


  virtual ~AddTicketMemoRequestTicketMemo() = default;
};
class AddTicketMemoRequest : public Darabonba::Model {
public:
  shared_ptr<string> openTeamId{};
  shared_ptr<string> openTicketId{};
  shared_ptr<AddTicketMemoRequestTenantContext> tenantContext{};
  shared_ptr<AddTicketMemoRequestTicketMemo> ticketMemo{};

  AddTicketMemoRequest() {}

  explicit AddTicketMemoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openTeamId) {
      res["OpenTeamId"] = boost::any(*openTeamId);
    }
    if (openTicketId) {
      res["OpenTicketId"] = boost::any(*openTicketId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ticketMemo) {
      res["TicketMemo"] = ticketMemo ? boost::any(ticketMemo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpenTeamId") != m.end() && !m["OpenTeamId"].empty()) {
      openTeamId = make_shared<string>(boost::any_cast<string>(m["OpenTeamId"]));
    }
    if (m.find("OpenTicketId") != m.end() && !m["OpenTicketId"].empty()) {
      openTicketId = make_shared<string>(boost::any_cast<string>(m["OpenTicketId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        AddTicketMemoRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<AddTicketMemoRequestTenantContext>(model1);
      }
    }
    if (m.find("TicketMemo") != m.end() && !m["TicketMemo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TicketMemo"].type()) {
        AddTicketMemoRequestTicketMemo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TicketMemo"]));
        ticketMemo = make_shared<AddTicketMemoRequestTicketMemo>(model1);
      }
    }
  }


  virtual ~AddTicketMemoRequest() = default;
};
class AddTicketMemoShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> openTeamId{};
  shared_ptr<string> openTicketId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> ticketMemoShrink{};

  AddTicketMemoShrinkRequest() {}

  explicit AddTicketMemoShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openTeamId) {
      res["OpenTeamId"] = boost::any(*openTeamId);
    }
    if (openTicketId) {
      res["OpenTicketId"] = boost::any(*openTicketId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (ticketMemoShrink) {
      res["TicketMemo"] = boost::any(*ticketMemoShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpenTeamId") != m.end() && !m["OpenTeamId"].empty()) {
      openTeamId = make_shared<string>(boost::any_cast<string>(m["OpenTeamId"]));
    }
    if (m.find("OpenTicketId") != m.end() && !m["OpenTicketId"].empty()) {
      openTicketId = make_shared<string>(boost::any_cast<string>(m["OpenTicketId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("TicketMemo") != m.end() && !m["TicketMemo"].empty()) {
      ticketMemoShrink = make_shared<string>(boost::any_cast<string>(m["TicketMemo"]));
    }
  }


  virtual ~AddTicketMemoShrinkRequest() = default;
};
class AddTicketMemoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  AddTicketMemoResponseBody() {}

  explicit AddTicketMemoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~AddTicketMemoResponseBody() = default;
};
class AddTicketMemoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddTicketMemoResponseBody> body{};

  AddTicketMemoResponse() {}

  explicit AddTicketMemoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddTicketMemoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddTicketMemoResponseBody>(model1);
      }
    }
  }


  virtual ~AddTicketMemoResponse() = default;
};
class AddWorkspaceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  AddWorkspaceHeadersAccountContext() {}

  explicit AddWorkspaceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~AddWorkspaceHeadersAccountContext() = default;
};
class AddWorkspaceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<AddWorkspaceHeadersAccountContext> accountContext{};

  AddWorkspaceHeaders() {}

  explicit AddWorkspaceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        AddWorkspaceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<AddWorkspaceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~AddWorkspaceHeaders() = default;
};
class AddWorkspaceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  AddWorkspaceShrinkHeaders() {}

  explicit AddWorkspaceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~AddWorkspaceShrinkHeaders() = default;
};
class AddWorkspaceRequestOption : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> teamId{};

  AddWorkspaceRequestOption() {}

  explicit AddWorkspaceRequestOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (teamId) {
      res["TeamId"] = boost::any(*teamId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("TeamId") != m.end() && !m["TeamId"].empty()) {
      teamId = make_shared<string>(boost::any_cast<string>(m["TeamId"]));
    }
  }


  virtual ~AddWorkspaceRequestOption() = default;
};
class AddWorkspaceRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  AddWorkspaceRequestTenantContext() {}

  explicit AddWorkspaceRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~AddWorkspaceRequestTenantContext() = default;
};
class AddWorkspaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<AddWorkspaceRequestOption> option{};
  shared_ptr<AddWorkspaceRequestTenantContext> tenantContext{};

  AddWorkspaceRequest() {}

  explicit AddWorkspaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (option) {
      res["Option"] = option ? boost::any(option->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      if (typeid(map<string, boost::any>) == m["Option"].type()) {
        AddWorkspaceRequestOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Option"]));
        option = make_shared<AddWorkspaceRequestOption>(model1);
      }
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        AddWorkspaceRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<AddWorkspaceRequestTenantContext>(model1);
      }
    }
  }


  virtual ~AddWorkspaceRequest() = default;
};
class AddWorkspaceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> optionShrink{};
  shared_ptr<string> tenantContextShrink{};

  AddWorkspaceShrinkRequest() {}

  explicit AddWorkspaceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (optionShrink) {
      res["Option"] = boost::any(*optionShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      optionShrink = make_shared<string>(boost::any_cast<string>(m["Option"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~AddWorkspaceShrinkRequest() = default;
};
class AddWorkspaceResponseBodyWorkspaceIcon : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  AddWorkspaceResponseBodyWorkspaceIcon() {}

  explicit AddWorkspaceResponseBodyWorkspaceIcon(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~AddWorkspaceResponseBodyWorkspaceIcon() = default;
};
class AddWorkspaceResponseBodyWorkspace : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<string> cover{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<AddWorkspaceResponseBodyWorkspaceIcon> icon{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> name{};
  shared_ptr<string> permissionRole{};
  shared_ptr<string> rootNodeId{};
  shared_ptr<string> teamId{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  AddWorkspaceResponseBodyWorkspace() {}

  explicit AddWorkspaceResponseBodyWorkspace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (cover) {
      res["Cover"] = boost::any(*cover);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (icon) {
      res["Icon"] = icon ? boost::any(icon->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (permissionRole) {
      res["PermissionRole"] = boost::any(*permissionRole);
    }
    if (rootNodeId) {
      res["RootNodeId"] = boost::any(*rootNodeId);
    }
    if (teamId) {
      res["TeamId"] = boost::any(*teamId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      cover = make_shared<string>(boost::any_cast<string>(m["Cover"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      if (typeid(map<string, boost::any>) == m["Icon"].type()) {
        AddWorkspaceResponseBodyWorkspaceIcon model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Icon"]));
        icon = make_shared<AddWorkspaceResponseBodyWorkspaceIcon>(model1);
      }
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["ModifierId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PermissionRole") != m.end() && !m["PermissionRole"].empty()) {
      permissionRole = make_shared<string>(boost::any_cast<string>(m["PermissionRole"]));
    }
    if (m.find("RootNodeId") != m.end() && !m["RootNodeId"].empty()) {
      rootNodeId = make_shared<string>(boost::any_cast<string>(m["RootNodeId"]));
    }
    if (m.find("TeamId") != m.end() && !m["TeamId"].empty()) {
      teamId = make_shared<string>(boost::any_cast<string>(m["TeamId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~AddWorkspaceResponseBodyWorkspace() = default;
};
class AddWorkspaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<AddWorkspaceResponseBodyWorkspace> workspace{};

  AddWorkspaceResponseBody() {}

  explicit AddWorkspaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (workspace) {
      res["workspace"] = workspace ? boost::any(workspace->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("workspace") != m.end() && !m["workspace"].empty()) {
      if (typeid(map<string, boost::any>) == m["workspace"].type()) {
        AddWorkspaceResponseBodyWorkspace model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["workspace"]));
        workspace = make_shared<AddWorkspaceResponseBodyWorkspace>(model1);
      }
    }
  }


  virtual ~AddWorkspaceResponseBody() = default;
};
class AddWorkspaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddWorkspaceResponseBody> body{};

  AddWorkspaceResponse() {}

  explicit AddWorkspaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddWorkspaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddWorkspaceResponseBody>(model1);
      }
    }
  }


  virtual ~AddWorkspaceResponse() = default;
};
class AddWorkspaceDocMembersHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  AddWorkspaceDocMembersHeadersAccountContext() {}

  explicit AddWorkspaceDocMembersHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~AddWorkspaceDocMembersHeadersAccountContext() = default;
};
class AddWorkspaceDocMembersHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<AddWorkspaceDocMembersHeadersAccountContext> accountContext{};

  AddWorkspaceDocMembersHeaders() {}

  explicit AddWorkspaceDocMembersHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        AddWorkspaceDocMembersHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<AddWorkspaceDocMembersHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~AddWorkspaceDocMembersHeaders() = default;
};
class AddWorkspaceDocMembersShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  AddWorkspaceDocMembersShrinkHeaders() {}

  explicit AddWorkspaceDocMembersShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~AddWorkspaceDocMembersShrinkHeaders() = default;
};
class AddWorkspaceDocMembersRequestMembers : public Darabonba::Model {
public:
  shared_ptr<string> memberId{};
  shared_ptr<string> memberType{};
  shared_ptr<string> roleType{};

  AddWorkspaceDocMembersRequestMembers() {}

  explicit AddWorkspaceDocMembersRequestMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberId) {
      res["MemberId"] = boost::any(*memberId);
    }
    if (memberType) {
      res["MemberType"] = boost::any(*memberType);
    }
    if (roleType) {
      res["RoleType"] = boost::any(*roleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemberId") != m.end() && !m["MemberId"].empty()) {
      memberId = make_shared<string>(boost::any_cast<string>(m["MemberId"]));
    }
    if (m.find("MemberType") != m.end() && !m["MemberType"].empty()) {
      memberType = make_shared<string>(boost::any_cast<string>(m["MemberType"]));
    }
    if (m.find("RoleType") != m.end() && !m["RoleType"].empty()) {
      roleType = make_shared<string>(boost::any_cast<string>(m["RoleType"]));
    }
  }


  virtual ~AddWorkspaceDocMembersRequestMembers() = default;
};
class AddWorkspaceDocMembersRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  AddWorkspaceDocMembersRequestTenantContext() {}

  explicit AddWorkspaceDocMembersRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~AddWorkspaceDocMembersRequestTenantContext() = default;
};
class AddWorkspaceDocMembersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<AddWorkspaceDocMembersRequestMembers>> members{};
  shared_ptr<string> nodeId{};
  shared_ptr<AddWorkspaceDocMembersRequestTenantContext> tenantContext{};
  shared_ptr<string> workspaceId{};

  AddWorkspaceDocMembersRequest() {}

  explicit AddWorkspaceDocMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (members) {
      vector<boost::any> temp1;
      for(auto item1:*members){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Members"] = boost::any(temp1);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      if (typeid(vector<boost::any>) == m["Members"].type()) {
        vector<AddWorkspaceDocMembersRequestMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Members"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddWorkspaceDocMembersRequestMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        members = make_shared<vector<AddWorkspaceDocMembersRequestMembers>>(expect1);
      }
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        AddWorkspaceDocMembersRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<AddWorkspaceDocMembersRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~AddWorkspaceDocMembersRequest() = default;
};
class AddWorkspaceDocMembersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> membersShrink{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workspaceId{};

  AddWorkspaceDocMembersShrinkRequest() {}

  explicit AddWorkspaceDocMembersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (membersShrink) {
      res["Members"] = boost::any(*membersShrink);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      membersShrink = make_shared<string>(boost::any_cast<string>(m["Members"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~AddWorkspaceDocMembersShrinkRequest() = default;
};
class AddWorkspaceDocMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddWorkspaceDocMembersResponseBody() {}

  explicit AddWorkspaceDocMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~AddWorkspaceDocMembersResponseBody() = default;
};
class AddWorkspaceDocMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddWorkspaceDocMembersResponseBody> body{};

  AddWorkspaceDocMembersResponse() {}

  explicit AddWorkspaceDocMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddWorkspaceDocMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddWorkspaceDocMembersResponseBody>(model1);
      }
    }
  }


  virtual ~AddWorkspaceDocMembersResponse() = default;
};
class AddWorkspaceMembersHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  AddWorkspaceMembersHeadersAccountContext() {}

  explicit AddWorkspaceMembersHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~AddWorkspaceMembersHeadersAccountContext() = default;
};
class AddWorkspaceMembersHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<AddWorkspaceMembersHeadersAccountContext> accountContext{};

  AddWorkspaceMembersHeaders() {}

  explicit AddWorkspaceMembersHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        AddWorkspaceMembersHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<AddWorkspaceMembersHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~AddWorkspaceMembersHeaders() = default;
};
class AddWorkspaceMembersShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  AddWorkspaceMembersShrinkHeaders() {}

  explicit AddWorkspaceMembersShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~AddWorkspaceMembersShrinkHeaders() = default;
};
class AddWorkspaceMembersRequestMembers : public Darabonba::Model {
public:
  shared_ptr<string> memberId{};
  shared_ptr<string> memberType{};
  shared_ptr<string> roleType{};

  AddWorkspaceMembersRequestMembers() {}

  explicit AddWorkspaceMembersRequestMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberId) {
      res["MemberId"] = boost::any(*memberId);
    }
    if (memberType) {
      res["MemberType"] = boost::any(*memberType);
    }
    if (roleType) {
      res["RoleType"] = boost::any(*roleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemberId") != m.end() && !m["MemberId"].empty()) {
      memberId = make_shared<string>(boost::any_cast<string>(m["MemberId"]));
    }
    if (m.find("MemberType") != m.end() && !m["MemberType"].empty()) {
      memberType = make_shared<string>(boost::any_cast<string>(m["MemberType"]));
    }
    if (m.find("RoleType") != m.end() && !m["RoleType"].empty()) {
      roleType = make_shared<string>(boost::any_cast<string>(m["RoleType"]));
    }
  }


  virtual ~AddWorkspaceMembersRequestMembers() = default;
};
class AddWorkspaceMembersRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  AddWorkspaceMembersRequestTenantContext() {}

  explicit AddWorkspaceMembersRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~AddWorkspaceMembersRequestTenantContext() = default;
};
class AddWorkspaceMembersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<AddWorkspaceMembersRequestMembers>> members{};
  shared_ptr<AddWorkspaceMembersRequestTenantContext> tenantContext{};
  shared_ptr<string> workspaceId{};

  AddWorkspaceMembersRequest() {}

  explicit AddWorkspaceMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (members) {
      vector<boost::any> temp1;
      for(auto item1:*members){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Members"] = boost::any(temp1);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      if (typeid(vector<boost::any>) == m["Members"].type()) {
        vector<AddWorkspaceMembersRequestMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Members"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddWorkspaceMembersRequestMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        members = make_shared<vector<AddWorkspaceMembersRequestMembers>>(expect1);
      }
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        AddWorkspaceMembersRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<AddWorkspaceMembersRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~AddWorkspaceMembersRequest() = default;
};
class AddWorkspaceMembersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> membersShrink{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workspaceId{};

  AddWorkspaceMembersShrinkRequest() {}

  explicit AddWorkspaceMembersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (membersShrink) {
      res["Members"] = boost::any(*membersShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      membersShrink = make_shared<string>(boost::any_cast<string>(m["Members"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~AddWorkspaceMembersShrinkRequest() = default;
};
class AddWorkspaceMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> notInOrgList{};
  shared_ptr<string> requestId{};

  AddWorkspaceMembersResponseBody() {}

  explicit AddWorkspaceMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notInOrgList) {
      res["NotInOrgList"] = boost::any(*notInOrgList);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotInOrgList") != m.end() && !m["NotInOrgList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NotInOrgList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NotInOrgList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      notInOrgList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~AddWorkspaceMembersResponseBody() = default;
};
class AddWorkspaceMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddWorkspaceMembersResponseBody> body{};

  AddWorkspaceMembersResponse() {}

  explicit AddWorkspaceMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddWorkspaceMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddWorkspaceMembersResponseBody>(model1);
      }
    }
  }


  virtual ~AddWorkspaceMembersResponse() = default;
};
class AssignTicketHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  AssignTicketHeadersAccountContext() {}

  explicit AssignTicketHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~AssignTicketHeadersAccountContext() = default;
};
class AssignTicketHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<AssignTicketHeadersAccountContext> accountContext{};

  AssignTicketHeaders() {}

  explicit AssignTicketHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        AssignTicketHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<AssignTicketHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~AssignTicketHeaders() = default;
};
class AssignTicketShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  AssignTicketShrinkHeaders() {}

  explicit AssignTicketShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~AssignTicketShrinkHeaders() = default;
};
class AssignTicketRequestNotify : public Darabonba::Model {
public:
  shared_ptr<vector<string>> groupNoticeReceiverUserIds{};
  shared_ptr<bool> noticeAllGroupMember{};
  shared_ptr<vector<string>> workNoticeReceiverUserIds{};

  AssignTicketRequestNotify() {}

  explicit AssignTicketRequestNotify(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupNoticeReceiverUserIds) {
      res["GroupNoticeReceiverUserIds"] = boost::any(*groupNoticeReceiverUserIds);
    }
    if (noticeAllGroupMember) {
      res["NoticeAllGroupMember"] = boost::any(*noticeAllGroupMember);
    }
    if (workNoticeReceiverUserIds) {
      res["WorkNoticeReceiverUserIds"] = boost::any(*workNoticeReceiverUserIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupNoticeReceiverUserIds") != m.end() && !m["GroupNoticeReceiverUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupNoticeReceiverUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupNoticeReceiverUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupNoticeReceiverUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NoticeAllGroupMember") != m.end() && !m["NoticeAllGroupMember"].empty()) {
      noticeAllGroupMember = make_shared<bool>(boost::any_cast<bool>(m["NoticeAllGroupMember"]));
    }
    if (m.find("WorkNoticeReceiverUserIds") != m.end() && !m["WorkNoticeReceiverUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WorkNoticeReceiverUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WorkNoticeReceiverUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      workNoticeReceiverUserIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AssignTicketRequestNotify() = default;
};
class AssignTicketRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  AssignTicketRequestTenantContext() {}

  explicit AssignTicketRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~AssignTicketRequestTenantContext() = default;
};
class AssignTicketRequestTicketMemoAttachments : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> key{};

  AssignTicketRequestTicketMemoAttachments() {}

  explicit AssignTicketRequestTicketMemoAttachments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~AssignTicketRequestTicketMemoAttachments() = default;
};
class AssignTicketRequestTicketMemo : public Darabonba::Model {
public:
  shared_ptr<vector<AssignTicketRequestTicketMemoAttachments>> attachments{};
  shared_ptr<string> memo{};

  AssignTicketRequestTicketMemo() {}

  explicit AssignTicketRequestTicketMemo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachments) {
      vector<boost::any> temp1;
      for(auto item1:*attachments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attachments"] = boost::any(temp1);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attachments") != m.end() && !m["Attachments"].empty()) {
      if (typeid(vector<boost::any>) == m["Attachments"].type()) {
        vector<AssignTicketRequestTicketMemoAttachments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attachments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AssignTicketRequestTicketMemoAttachments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attachments = make_shared<vector<AssignTicketRequestTicketMemoAttachments>>(expect1);
      }
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
  }


  virtual ~AssignTicketRequestTicketMemo() = default;
};
class AssignTicketRequest : public Darabonba::Model {
public:
  shared_ptr<AssignTicketRequestNotify> notify{};
  shared_ptr<string> openTeamId{};
  shared_ptr<string> openTicketId{};
  shared_ptr<vector<string>> processorUserIds{};
  shared_ptr<AssignTicketRequestTenantContext> tenantContext{};
  shared_ptr<AssignTicketRequestTicketMemo> ticketMemo{};

  AssignTicketRequest() {}

  explicit AssignTicketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notify) {
      res["Notify"] = notify ? boost::any(notify->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (openTeamId) {
      res["OpenTeamId"] = boost::any(*openTeamId);
    }
    if (openTicketId) {
      res["OpenTicketId"] = boost::any(*openTicketId);
    }
    if (processorUserIds) {
      res["ProcessorUserIds"] = boost::any(*processorUserIds);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ticketMemo) {
      res["TicketMemo"] = ticketMemo ? boost::any(ticketMemo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Notify") != m.end() && !m["Notify"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notify"].type()) {
        AssignTicketRequestNotify model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notify"]));
        notify = make_shared<AssignTicketRequestNotify>(model1);
      }
    }
    if (m.find("OpenTeamId") != m.end() && !m["OpenTeamId"].empty()) {
      openTeamId = make_shared<string>(boost::any_cast<string>(m["OpenTeamId"]));
    }
    if (m.find("OpenTicketId") != m.end() && !m["OpenTicketId"].empty()) {
      openTicketId = make_shared<string>(boost::any_cast<string>(m["OpenTicketId"]));
    }
    if (m.find("ProcessorUserIds") != m.end() && !m["ProcessorUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProcessorUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProcessorUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      processorUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        AssignTicketRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<AssignTicketRequestTenantContext>(model1);
      }
    }
    if (m.find("TicketMemo") != m.end() && !m["TicketMemo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TicketMemo"].type()) {
        AssignTicketRequestTicketMemo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TicketMemo"]));
        ticketMemo = make_shared<AssignTicketRequestTicketMemo>(model1);
      }
    }
  }


  virtual ~AssignTicketRequest() = default;
};
class AssignTicketShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> notifyShrink{};
  shared_ptr<string> openTeamId{};
  shared_ptr<string> openTicketId{};
  shared_ptr<string> processorUserIdsShrink{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> ticketMemoShrink{};

  AssignTicketShrinkRequest() {}

  explicit AssignTicketShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notifyShrink) {
      res["Notify"] = boost::any(*notifyShrink);
    }
    if (openTeamId) {
      res["OpenTeamId"] = boost::any(*openTeamId);
    }
    if (openTicketId) {
      res["OpenTicketId"] = boost::any(*openTicketId);
    }
    if (processorUserIdsShrink) {
      res["ProcessorUserIds"] = boost::any(*processorUserIdsShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (ticketMemoShrink) {
      res["TicketMemo"] = boost::any(*ticketMemoShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Notify") != m.end() && !m["Notify"].empty()) {
      notifyShrink = make_shared<string>(boost::any_cast<string>(m["Notify"]));
    }
    if (m.find("OpenTeamId") != m.end() && !m["OpenTeamId"].empty()) {
      openTeamId = make_shared<string>(boost::any_cast<string>(m["OpenTeamId"]));
    }
    if (m.find("OpenTicketId") != m.end() && !m["OpenTicketId"].empty()) {
      openTicketId = make_shared<string>(boost::any_cast<string>(m["OpenTicketId"]));
    }
    if (m.find("ProcessorUserIds") != m.end() && !m["ProcessorUserIds"].empty()) {
      processorUserIdsShrink = make_shared<string>(boost::any_cast<string>(m["ProcessorUserIds"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("TicketMemo") != m.end() && !m["TicketMemo"].empty()) {
      ticketMemoShrink = make_shared<string>(boost::any_cast<string>(m["TicketMemo"]));
    }
  }


  virtual ~AssignTicketShrinkRequest() = default;
};
class AssignTicketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  AssignTicketResponseBody() {}

  explicit AssignTicketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~AssignTicketResponseBody() = default;
};
class AssignTicketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AssignTicketResponseBody> body{};

  AssignTicketResponse() {}

  explicit AssignTicketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssignTicketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssignTicketResponseBody>(model1);
      }
    }
  }


  virtual ~AssignTicketResponse() = default;
};
class AuthorizeSkillHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  AuthorizeSkillHeadersAccountContext() {}

  explicit AuthorizeSkillHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~AuthorizeSkillHeadersAccountContext() = default;
};
class AuthorizeSkillHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<AuthorizeSkillHeadersAccountContext> accountContext{};

  AuthorizeSkillHeaders() {}

  explicit AuthorizeSkillHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        AuthorizeSkillHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<AuthorizeSkillHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~AuthorizeSkillHeaders() = default;
};
class AuthorizeSkillShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  AuthorizeSkillShrinkHeaders() {}

  explicit AuthorizeSkillShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~AuthorizeSkillShrinkHeaders() = default;
};
class AuthorizeSkillRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> permissionCodes{};

  AuthorizeSkillRequest() {}

  explicit AuthorizeSkillRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (permissionCodes) {
      res["PermissionCodes"] = boost::any(*permissionCodes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PermissionCodes") != m.end() && !m["PermissionCodes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PermissionCodes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PermissionCodes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      permissionCodes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AuthorizeSkillRequest() = default;
};
class AuthorizeSkillShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> permissionCodesShrink{};

  AuthorizeSkillShrinkRequest() {}

  explicit AuthorizeSkillShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (permissionCodesShrink) {
      res["PermissionCodes"] = boost::any(*permissionCodesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PermissionCodes") != m.end() && !m["PermissionCodes"].empty()) {
      permissionCodesShrink = make_shared<string>(boost::any_cast<string>(m["PermissionCodes"]));
    }
  }


  virtual ~AuthorizeSkillShrinkRequest() = default;
};
class AuthorizeSkillResponseBody : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};
  shared_ptr<string> requestId{};

  AuthorizeSkillResponseBody() {}

  explicit AuthorizeSkillResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AuthorizeSkillResponseBody() = default;
};
class AuthorizeSkillResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AuthorizeSkillResponseBody> body{};

  AuthorizeSkillResponse() {}

  explicit AuthorizeSkillResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AuthorizeSkillResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AuthorizeSkillResponseBody>(model1);
      }
    }
  }


  virtual ~AuthorizeSkillResponse() = default;
};
class BatchGetFormDataByIdListHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  BatchGetFormDataByIdListHeadersAccountContext() {}

  explicit BatchGetFormDataByIdListHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~BatchGetFormDataByIdListHeadersAccountContext() = default;
};
class BatchGetFormDataByIdListHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<BatchGetFormDataByIdListHeadersAccountContext> accountContext{};

  BatchGetFormDataByIdListHeaders() {}

  explicit BatchGetFormDataByIdListHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        BatchGetFormDataByIdListHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<BatchGetFormDataByIdListHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~BatchGetFormDataByIdListHeaders() = default;
};
class BatchGetFormDataByIdListShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  BatchGetFormDataByIdListShrinkHeaders() {}

  explicit BatchGetFormDataByIdListShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~BatchGetFormDataByIdListShrinkHeaders() = default;
};
class BatchGetFormDataByIdListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<vector<string>> formInstanceIdList{};
  shared_ptr<string> formUuid{};
  shared_ptr<bool> needFormInstanceValue{};
  shared_ptr<string> systemToken{};

  BatchGetFormDataByIdListRequest() {}

  explicit BatchGetFormDataByIdListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (formInstanceIdList) {
      res["FormInstanceIdList"] = boost::any(*formInstanceIdList);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (needFormInstanceValue) {
      res["NeedFormInstanceValue"] = boost::any(*needFormInstanceValue);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("FormInstanceIdList") != m.end() && !m["FormInstanceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FormInstanceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FormInstanceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      formInstanceIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("NeedFormInstanceValue") != m.end() && !m["NeedFormInstanceValue"].empty()) {
      needFormInstanceValue = make_shared<bool>(boost::any_cast<bool>(m["NeedFormInstanceValue"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~BatchGetFormDataByIdListRequest() = default;
};
class BatchGetFormDataByIdListShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> formInstanceIdListShrink{};
  shared_ptr<string> formUuid{};
  shared_ptr<bool> needFormInstanceValue{};
  shared_ptr<string> systemToken{};

  BatchGetFormDataByIdListShrinkRequest() {}

  explicit BatchGetFormDataByIdListShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (formInstanceIdListShrink) {
      res["FormInstanceIdList"] = boost::any(*formInstanceIdListShrink);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (needFormInstanceValue) {
      res["NeedFormInstanceValue"] = boost::any(*needFormInstanceValue);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("FormInstanceIdList") != m.end() && !m["FormInstanceIdList"].empty()) {
      formInstanceIdListShrink = make_shared<string>(boost::any_cast<string>(m["FormInstanceIdList"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("NeedFormInstanceValue") != m.end() && !m["NeedFormInstanceValue"].empty()) {
      needFormInstanceValue = make_shared<bool>(boost::any_cast<bool>(m["NeedFormInstanceValue"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~BatchGetFormDataByIdListShrinkRequest() = default;
};
class BatchGetFormDataByIdListResponseBodyResultModifyUserName : public Darabonba::Model {
public:
  shared_ptr<string> nameInChinese{};
  shared_ptr<string> nameInEnglish{};

  BatchGetFormDataByIdListResponseBodyResultModifyUserName() {}

  explicit BatchGetFormDataByIdListResponseBodyResultModifyUserName(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameInChinese) {
      res["NameInChinese"] = boost::any(*nameInChinese);
    }
    if (nameInEnglish) {
      res["NameInEnglish"] = boost::any(*nameInEnglish);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameInChinese") != m.end() && !m["NameInChinese"].empty()) {
      nameInChinese = make_shared<string>(boost::any_cast<string>(m["NameInChinese"]));
    }
    if (m.find("NameInEnglish") != m.end() && !m["NameInEnglish"].empty()) {
      nameInEnglish = make_shared<string>(boost::any_cast<string>(m["NameInEnglish"]));
    }
  }


  virtual ~BatchGetFormDataByIdListResponseBodyResultModifyUserName() = default;
};
class BatchGetFormDataByIdListResponseBodyResultModifyUser : public Darabonba::Model {
public:
  shared_ptr<BatchGetFormDataByIdListResponseBodyResultModifyUserName> name{};
  shared_ptr<string> userId{};

  BatchGetFormDataByIdListResponseBodyResultModifyUser() {}

  explicit BatchGetFormDataByIdListResponseBodyResultModifyUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = name ? boost::any(name->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      if (typeid(map<string, boost::any>) == m["Name"].type()) {
        BatchGetFormDataByIdListResponseBodyResultModifyUserName model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Name"]));
        name = make_shared<BatchGetFormDataByIdListResponseBodyResultModifyUserName>(model1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~BatchGetFormDataByIdListResponseBodyResultModifyUser() = default;
};
class BatchGetFormDataByIdListResponseBodyResultOriginatorName : public Darabonba::Model {
public:
  shared_ptr<string> nameInChinese{};
  shared_ptr<string> nameInEnglish{};

  BatchGetFormDataByIdListResponseBodyResultOriginatorName() {}

  explicit BatchGetFormDataByIdListResponseBodyResultOriginatorName(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameInChinese) {
      res["NameInChinese"] = boost::any(*nameInChinese);
    }
    if (nameInEnglish) {
      res["NameInEnglish"] = boost::any(*nameInEnglish);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameInChinese") != m.end() && !m["NameInChinese"].empty()) {
      nameInChinese = make_shared<string>(boost::any_cast<string>(m["NameInChinese"]));
    }
    if (m.find("NameInEnglish") != m.end() && !m["NameInEnglish"].empty()) {
      nameInEnglish = make_shared<string>(boost::any_cast<string>(m["NameInEnglish"]));
    }
  }


  virtual ~BatchGetFormDataByIdListResponseBodyResultOriginatorName() = default;
};
class BatchGetFormDataByIdListResponseBodyResultOriginator : public Darabonba::Model {
public:
  shared_ptr<BatchGetFormDataByIdListResponseBodyResultOriginatorName> name{};
  shared_ptr<string> userId{};

  BatchGetFormDataByIdListResponseBodyResultOriginator() {}

  explicit BatchGetFormDataByIdListResponseBodyResultOriginator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = name ? boost::any(name->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      if (typeid(map<string, boost::any>) == m["Name"].type()) {
        BatchGetFormDataByIdListResponseBodyResultOriginatorName model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Name"]));
        name = make_shared<BatchGetFormDataByIdListResponseBodyResultOriginatorName>(model1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~BatchGetFormDataByIdListResponseBodyResultOriginator() = default;
};
class BatchGetFormDataByIdListResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> createTimeGMT{};
  shared_ptr<string> creatorUserId{};
  shared_ptr<map<string, boost::any>> formData{};
  shared_ptr<string> formInstanceId{};
  shared_ptr<string> formUuid{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceValue{};
  shared_ptr<string> modifiedTimeGMT{};
  shared_ptr<string> modifier{};
  shared_ptr<BatchGetFormDataByIdListResponseBodyResultModifyUser> modifyUser{};
  shared_ptr<BatchGetFormDataByIdListResponseBodyResultOriginator> originator{};
  shared_ptr<string> sequence{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> title{};
  shared_ptr<long> version{};

  BatchGetFormDataByIdListResponseBodyResult() {}

  explicit BatchGetFormDataByIdListResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTimeGMT) {
      res["CreateTimeGMT"] = boost::any(*createTimeGMT);
    }
    if (creatorUserId) {
      res["CreatorUserId"] = boost::any(*creatorUserId);
    }
    if (formData) {
      res["FormData"] = boost::any(*formData);
    }
    if (formInstanceId) {
      res["FormInstanceId"] = boost::any(*formInstanceId);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceValue) {
      res["InstanceValue"] = boost::any(*instanceValue);
    }
    if (modifiedTimeGMT) {
      res["ModifiedTimeGMT"] = boost::any(*modifiedTimeGMT);
    }
    if (modifier) {
      res["Modifier"] = boost::any(*modifier);
    }
    if (modifyUser) {
      res["ModifyUser"] = modifyUser ? boost::any(modifyUser->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (originator) {
      res["Originator"] = originator ? boost::any(originator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTimeGMT") != m.end() && !m["CreateTimeGMT"].empty()) {
      createTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateTimeGMT"]));
    }
    if (m.find("CreatorUserId") != m.end() && !m["CreatorUserId"].empty()) {
      creatorUserId = make_shared<string>(boost::any_cast<string>(m["CreatorUserId"]));
    }
    if (m.find("FormData") != m.end() && !m["FormData"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["FormData"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      formData = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("FormInstanceId") != m.end() && !m["FormInstanceId"].empty()) {
      formInstanceId = make_shared<string>(boost::any_cast<string>(m["FormInstanceId"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceValue") != m.end() && !m["InstanceValue"].empty()) {
      instanceValue = make_shared<string>(boost::any_cast<string>(m["InstanceValue"]));
    }
    if (m.find("ModifiedTimeGMT") != m.end() && !m["ModifiedTimeGMT"].empty()) {
      modifiedTimeGMT = make_shared<string>(boost::any_cast<string>(m["ModifiedTimeGMT"]));
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["Modifier"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModifyUser"].type()) {
        BatchGetFormDataByIdListResponseBodyResultModifyUser model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModifyUser"]));
        modifyUser = make_shared<BatchGetFormDataByIdListResponseBodyResultModifyUser>(model1);
      }
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      if (typeid(map<string, boost::any>) == m["Originator"].type()) {
        BatchGetFormDataByIdListResponseBodyResultOriginator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Originator"]));
        originator = make_shared<BatchGetFormDataByIdListResponseBodyResultOriginator>(model1);
      }
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~BatchGetFormDataByIdListResponseBodyResult() = default;
};
class BatchGetFormDataByIdListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<BatchGetFormDataByIdListResponseBodyResult>> result{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  BatchGetFormDataByIdListResponseBody() {}

  explicit BatchGetFormDataByIdListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<BatchGetFormDataByIdListResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetFormDataByIdListResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<BatchGetFormDataByIdListResponseBodyResult>>(expect1);
      }
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~BatchGetFormDataByIdListResponseBody() = default;
};
class BatchGetFormDataByIdListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchGetFormDataByIdListResponseBody> body{};

  BatchGetFormDataByIdListResponse() {}

  explicit BatchGetFormDataByIdListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGetFormDataByIdListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGetFormDataByIdListResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGetFormDataByIdListResponse() = default;
};
class BatchRemovalByFormInstanceIdListHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  BatchRemovalByFormInstanceIdListHeadersAccountContext() {}

  explicit BatchRemovalByFormInstanceIdListHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~BatchRemovalByFormInstanceIdListHeadersAccountContext() = default;
};
class BatchRemovalByFormInstanceIdListHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<BatchRemovalByFormInstanceIdListHeadersAccountContext> accountContext{};

  BatchRemovalByFormInstanceIdListHeaders() {}

  explicit BatchRemovalByFormInstanceIdListHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        BatchRemovalByFormInstanceIdListHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<BatchRemovalByFormInstanceIdListHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~BatchRemovalByFormInstanceIdListHeaders() = default;
};
class BatchRemovalByFormInstanceIdListShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  BatchRemovalByFormInstanceIdListShrinkHeaders() {}

  explicit BatchRemovalByFormInstanceIdListShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~BatchRemovalByFormInstanceIdListShrinkHeaders() = default;
};
class BatchRemovalByFormInstanceIdListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<bool> asynchronousExecution{};
  shared_ptr<bool> executeExpression{};
  shared_ptr<vector<string>> formInstanceIdList{};
  shared_ptr<string> formUuid{};
  shared_ptr<string> systemToken{};

  BatchRemovalByFormInstanceIdListRequest() {}

  explicit BatchRemovalByFormInstanceIdListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (asynchronousExecution) {
      res["AsynchronousExecution"] = boost::any(*asynchronousExecution);
    }
    if (executeExpression) {
      res["ExecuteExpression"] = boost::any(*executeExpression);
    }
    if (formInstanceIdList) {
      res["FormInstanceIdList"] = boost::any(*formInstanceIdList);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("AsynchronousExecution") != m.end() && !m["AsynchronousExecution"].empty()) {
      asynchronousExecution = make_shared<bool>(boost::any_cast<bool>(m["AsynchronousExecution"]));
    }
    if (m.find("ExecuteExpression") != m.end() && !m["ExecuteExpression"].empty()) {
      executeExpression = make_shared<bool>(boost::any_cast<bool>(m["ExecuteExpression"]));
    }
    if (m.find("FormInstanceIdList") != m.end() && !m["FormInstanceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FormInstanceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FormInstanceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      formInstanceIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~BatchRemovalByFormInstanceIdListRequest() = default;
};
class BatchRemovalByFormInstanceIdListShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<bool> asynchronousExecution{};
  shared_ptr<bool> executeExpression{};
  shared_ptr<string> formInstanceIdListShrink{};
  shared_ptr<string> formUuid{};
  shared_ptr<string> systemToken{};

  BatchRemovalByFormInstanceIdListShrinkRequest() {}

  explicit BatchRemovalByFormInstanceIdListShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (asynchronousExecution) {
      res["AsynchronousExecution"] = boost::any(*asynchronousExecution);
    }
    if (executeExpression) {
      res["ExecuteExpression"] = boost::any(*executeExpression);
    }
    if (formInstanceIdListShrink) {
      res["FormInstanceIdList"] = boost::any(*formInstanceIdListShrink);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("AsynchronousExecution") != m.end() && !m["AsynchronousExecution"].empty()) {
      asynchronousExecution = make_shared<bool>(boost::any_cast<bool>(m["AsynchronousExecution"]));
    }
    if (m.find("ExecuteExpression") != m.end() && !m["ExecuteExpression"].empty()) {
      executeExpression = make_shared<bool>(boost::any_cast<bool>(m["ExecuteExpression"]));
    }
    if (m.find("FormInstanceIdList") != m.end() && !m["FormInstanceIdList"].empty()) {
      formInstanceIdListShrink = make_shared<string>(boost::any_cast<string>(m["FormInstanceIdList"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~BatchRemovalByFormInstanceIdListShrinkRequest() = default;
};
class BatchRemovalByFormInstanceIdListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  BatchRemovalByFormInstanceIdListResponseBody() {}

  explicit BatchRemovalByFormInstanceIdListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~BatchRemovalByFormInstanceIdListResponseBody() = default;
};
class BatchRemovalByFormInstanceIdListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchRemovalByFormInstanceIdListResponseBody> body{};

  BatchRemovalByFormInstanceIdListResponse() {}

  explicit BatchRemovalByFormInstanceIdListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchRemovalByFormInstanceIdListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchRemovalByFormInstanceIdListResponseBody>(model1);
      }
    }
  }


  virtual ~BatchRemovalByFormInstanceIdListResponse() = default;
};
class BatchSaveFormDataHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  BatchSaveFormDataHeadersAccountContext() {}

  explicit BatchSaveFormDataHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~BatchSaveFormDataHeadersAccountContext() = default;
};
class BatchSaveFormDataHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<BatchSaveFormDataHeadersAccountContext> accountContext{};

  BatchSaveFormDataHeaders() {}

  explicit BatchSaveFormDataHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        BatchSaveFormDataHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<BatchSaveFormDataHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~BatchSaveFormDataHeaders() = default;
};
class BatchSaveFormDataShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  BatchSaveFormDataShrinkHeaders() {}

  explicit BatchSaveFormDataShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~BatchSaveFormDataShrinkHeaders() = default;
};
class BatchSaveFormDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<bool> asynchronousExecution{};
  shared_ptr<vector<string>> formDataJsonList{};
  shared_ptr<string> formUuid{};
  shared_ptr<bool> keepRunningAfterException{};
  shared_ptr<bool> noExecuteExpression{};
  shared_ptr<string> systemToken{};

  BatchSaveFormDataRequest() {}

  explicit BatchSaveFormDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (asynchronousExecution) {
      res["AsynchronousExecution"] = boost::any(*asynchronousExecution);
    }
    if (formDataJsonList) {
      res["FormDataJsonList"] = boost::any(*formDataJsonList);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (keepRunningAfterException) {
      res["KeepRunningAfterException"] = boost::any(*keepRunningAfterException);
    }
    if (noExecuteExpression) {
      res["NoExecuteExpression"] = boost::any(*noExecuteExpression);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("AsynchronousExecution") != m.end() && !m["AsynchronousExecution"].empty()) {
      asynchronousExecution = make_shared<bool>(boost::any_cast<bool>(m["AsynchronousExecution"]));
    }
    if (m.find("FormDataJsonList") != m.end() && !m["FormDataJsonList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FormDataJsonList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FormDataJsonList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      formDataJsonList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("KeepRunningAfterException") != m.end() && !m["KeepRunningAfterException"].empty()) {
      keepRunningAfterException = make_shared<bool>(boost::any_cast<bool>(m["KeepRunningAfterException"]));
    }
    if (m.find("NoExecuteExpression") != m.end() && !m["NoExecuteExpression"].empty()) {
      noExecuteExpression = make_shared<bool>(boost::any_cast<bool>(m["NoExecuteExpression"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~BatchSaveFormDataRequest() = default;
};
class BatchSaveFormDataShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<bool> asynchronousExecution{};
  shared_ptr<string> formDataJsonListShrink{};
  shared_ptr<string> formUuid{};
  shared_ptr<bool> keepRunningAfterException{};
  shared_ptr<bool> noExecuteExpression{};
  shared_ptr<string> systemToken{};

  BatchSaveFormDataShrinkRequest() {}

  explicit BatchSaveFormDataShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (asynchronousExecution) {
      res["AsynchronousExecution"] = boost::any(*asynchronousExecution);
    }
    if (formDataJsonListShrink) {
      res["FormDataJsonList"] = boost::any(*formDataJsonListShrink);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (keepRunningAfterException) {
      res["KeepRunningAfterException"] = boost::any(*keepRunningAfterException);
    }
    if (noExecuteExpression) {
      res["NoExecuteExpression"] = boost::any(*noExecuteExpression);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("AsynchronousExecution") != m.end() && !m["AsynchronousExecution"].empty()) {
      asynchronousExecution = make_shared<bool>(boost::any_cast<bool>(m["AsynchronousExecution"]));
    }
    if (m.find("FormDataJsonList") != m.end() && !m["FormDataJsonList"].empty()) {
      formDataJsonListShrink = make_shared<string>(boost::any_cast<string>(m["FormDataJsonList"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("KeepRunningAfterException") != m.end() && !m["KeepRunningAfterException"].empty()) {
      keepRunningAfterException = make_shared<bool>(boost::any_cast<bool>(m["KeepRunningAfterException"]));
    }
    if (m.find("NoExecuteExpression") != m.end() && !m["NoExecuteExpression"].empty()) {
      noExecuteExpression = make_shared<bool>(boost::any_cast<bool>(m["NoExecuteExpression"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~BatchSaveFormDataShrinkRequest() = default;
};
class BatchSaveFormDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> result{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  BatchSaveFormDataResponseBody() {}

  explicit BatchSaveFormDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["result"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      result = make_shared<vector<string>>(toVec1);
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~BatchSaveFormDataResponseBody() = default;
};
class BatchSaveFormDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchSaveFormDataResponseBody> body{};

  BatchSaveFormDataResponse() {}

  explicit BatchSaveFormDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchSaveFormDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchSaveFormDataResponseBody>(model1);
      }
    }
  }


  virtual ~BatchSaveFormDataResponse() = default;
};
class BatchUpdateFormDataByInstanceIdHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  BatchUpdateFormDataByInstanceIdHeadersAccountContext() {}

  explicit BatchUpdateFormDataByInstanceIdHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~BatchUpdateFormDataByInstanceIdHeadersAccountContext() = default;
};
class BatchUpdateFormDataByInstanceIdHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<BatchUpdateFormDataByInstanceIdHeadersAccountContext> accountContext{};

  BatchUpdateFormDataByInstanceIdHeaders() {}

  explicit BatchUpdateFormDataByInstanceIdHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        BatchUpdateFormDataByInstanceIdHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<BatchUpdateFormDataByInstanceIdHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~BatchUpdateFormDataByInstanceIdHeaders() = default;
};
class BatchUpdateFormDataByInstanceIdShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  BatchUpdateFormDataByInstanceIdShrinkHeaders() {}

  explicit BatchUpdateFormDataByInstanceIdShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~BatchUpdateFormDataByInstanceIdShrinkHeaders() = default;
};
class BatchUpdateFormDataByInstanceIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<bool> asynchronousExecution{};
  shared_ptr<vector<string>> formInstanceIdList{};
  shared_ptr<string> formUuid{};
  shared_ptr<bool> ignoreEmpty{};
  shared_ptr<bool> noExecuteExpression{};
  shared_ptr<string> systemToken{};
  shared_ptr<string> updateFormDataJson{};
  shared_ptr<bool> useLatestFormSchemaVersion{};

  BatchUpdateFormDataByInstanceIdRequest() {}

  explicit BatchUpdateFormDataByInstanceIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (asynchronousExecution) {
      res["AsynchronousExecution"] = boost::any(*asynchronousExecution);
    }
    if (formInstanceIdList) {
      res["FormInstanceIdList"] = boost::any(*formInstanceIdList);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (ignoreEmpty) {
      res["IgnoreEmpty"] = boost::any(*ignoreEmpty);
    }
    if (noExecuteExpression) {
      res["NoExecuteExpression"] = boost::any(*noExecuteExpression);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    if (updateFormDataJson) {
      res["UpdateFormDataJson"] = boost::any(*updateFormDataJson);
    }
    if (useLatestFormSchemaVersion) {
      res["UseLatestFormSchemaVersion"] = boost::any(*useLatestFormSchemaVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("AsynchronousExecution") != m.end() && !m["AsynchronousExecution"].empty()) {
      asynchronousExecution = make_shared<bool>(boost::any_cast<bool>(m["AsynchronousExecution"]));
    }
    if (m.find("FormInstanceIdList") != m.end() && !m["FormInstanceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FormInstanceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FormInstanceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      formInstanceIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("IgnoreEmpty") != m.end() && !m["IgnoreEmpty"].empty()) {
      ignoreEmpty = make_shared<bool>(boost::any_cast<bool>(m["IgnoreEmpty"]));
    }
    if (m.find("NoExecuteExpression") != m.end() && !m["NoExecuteExpression"].empty()) {
      noExecuteExpression = make_shared<bool>(boost::any_cast<bool>(m["NoExecuteExpression"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
    if (m.find("UpdateFormDataJson") != m.end() && !m["UpdateFormDataJson"].empty()) {
      updateFormDataJson = make_shared<string>(boost::any_cast<string>(m["UpdateFormDataJson"]));
    }
    if (m.find("UseLatestFormSchemaVersion") != m.end() && !m["UseLatestFormSchemaVersion"].empty()) {
      useLatestFormSchemaVersion = make_shared<bool>(boost::any_cast<bool>(m["UseLatestFormSchemaVersion"]));
    }
  }


  virtual ~BatchUpdateFormDataByInstanceIdRequest() = default;
};
class BatchUpdateFormDataByInstanceIdShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<bool> asynchronousExecution{};
  shared_ptr<string> formInstanceIdListShrink{};
  shared_ptr<string> formUuid{};
  shared_ptr<bool> ignoreEmpty{};
  shared_ptr<bool> noExecuteExpression{};
  shared_ptr<string> systemToken{};
  shared_ptr<string> updateFormDataJson{};
  shared_ptr<bool> useLatestFormSchemaVersion{};

  BatchUpdateFormDataByInstanceIdShrinkRequest() {}

  explicit BatchUpdateFormDataByInstanceIdShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (asynchronousExecution) {
      res["AsynchronousExecution"] = boost::any(*asynchronousExecution);
    }
    if (formInstanceIdListShrink) {
      res["FormInstanceIdList"] = boost::any(*formInstanceIdListShrink);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (ignoreEmpty) {
      res["IgnoreEmpty"] = boost::any(*ignoreEmpty);
    }
    if (noExecuteExpression) {
      res["NoExecuteExpression"] = boost::any(*noExecuteExpression);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    if (updateFormDataJson) {
      res["UpdateFormDataJson"] = boost::any(*updateFormDataJson);
    }
    if (useLatestFormSchemaVersion) {
      res["UseLatestFormSchemaVersion"] = boost::any(*useLatestFormSchemaVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("AsynchronousExecution") != m.end() && !m["AsynchronousExecution"].empty()) {
      asynchronousExecution = make_shared<bool>(boost::any_cast<bool>(m["AsynchronousExecution"]));
    }
    if (m.find("FormInstanceIdList") != m.end() && !m["FormInstanceIdList"].empty()) {
      formInstanceIdListShrink = make_shared<string>(boost::any_cast<string>(m["FormInstanceIdList"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("IgnoreEmpty") != m.end() && !m["IgnoreEmpty"].empty()) {
      ignoreEmpty = make_shared<bool>(boost::any_cast<bool>(m["IgnoreEmpty"]));
    }
    if (m.find("NoExecuteExpression") != m.end() && !m["NoExecuteExpression"].empty()) {
      noExecuteExpression = make_shared<bool>(boost::any_cast<bool>(m["NoExecuteExpression"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
    if (m.find("UpdateFormDataJson") != m.end() && !m["UpdateFormDataJson"].empty()) {
      updateFormDataJson = make_shared<string>(boost::any_cast<string>(m["UpdateFormDataJson"]));
    }
    if (m.find("UseLatestFormSchemaVersion") != m.end() && !m["UseLatestFormSchemaVersion"].empty()) {
      useLatestFormSchemaVersion = make_shared<bool>(boost::any_cast<bool>(m["UseLatestFormSchemaVersion"]));
    }
  }


  virtual ~BatchUpdateFormDataByInstanceIdShrinkRequest() = default;
};
class BatchUpdateFormDataByInstanceIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> result{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  BatchUpdateFormDataByInstanceIdResponseBody() {}

  explicit BatchUpdateFormDataByInstanceIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["result"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      result = make_shared<vector<string>>(toVec1);
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~BatchUpdateFormDataByInstanceIdResponseBody() = default;
};
class BatchUpdateFormDataByInstanceIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchUpdateFormDataByInstanceIdResponseBody> body{};

  BatchUpdateFormDataByInstanceIdResponse() {}

  explicit BatchUpdateFormDataByInstanceIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchUpdateFormDataByInstanceIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchUpdateFormDataByInstanceIdResponseBody>(model1);
      }
    }
  }


  virtual ~BatchUpdateFormDataByInstanceIdResponse() = default;
};
class BatchUpdateFormDataByInstanceMapHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  BatchUpdateFormDataByInstanceMapHeadersAccountContext() {}

  explicit BatchUpdateFormDataByInstanceMapHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~BatchUpdateFormDataByInstanceMapHeadersAccountContext() = default;
};
class BatchUpdateFormDataByInstanceMapHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<BatchUpdateFormDataByInstanceMapHeadersAccountContext> accountContext{};

  BatchUpdateFormDataByInstanceMapHeaders() {}

  explicit BatchUpdateFormDataByInstanceMapHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        BatchUpdateFormDataByInstanceMapHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<BatchUpdateFormDataByInstanceMapHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~BatchUpdateFormDataByInstanceMapHeaders() = default;
};
class BatchUpdateFormDataByInstanceMapShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  BatchUpdateFormDataByInstanceMapShrinkHeaders() {}

  explicit BatchUpdateFormDataByInstanceMapShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~BatchUpdateFormDataByInstanceMapShrinkHeaders() = default;
};
class BatchUpdateFormDataByInstanceMapRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<bool> asynchronousExecution{};
  shared_ptr<string> formUuid{};
  shared_ptr<bool> ignoreEmpty{};
  shared_ptr<bool> noExecuteExpression{};
  shared_ptr<string> systemToken{};
  shared_ptr<map<string, boost::any>> updateFormDataJsonMap{};
  shared_ptr<bool> useLatestFormSchemaVersion{};

  BatchUpdateFormDataByInstanceMapRequest() {}

  explicit BatchUpdateFormDataByInstanceMapRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (asynchronousExecution) {
      res["AsynchronousExecution"] = boost::any(*asynchronousExecution);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (ignoreEmpty) {
      res["IgnoreEmpty"] = boost::any(*ignoreEmpty);
    }
    if (noExecuteExpression) {
      res["NoExecuteExpression"] = boost::any(*noExecuteExpression);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    if (updateFormDataJsonMap) {
      res["UpdateFormDataJsonMap"] = boost::any(*updateFormDataJsonMap);
    }
    if (useLatestFormSchemaVersion) {
      res["UseLatestFormSchemaVersion"] = boost::any(*useLatestFormSchemaVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("AsynchronousExecution") != m.end() && !m["AsynchronousExecution"].empty()) {
      asynchronousExecution = make_shared<bool>(boost::any_cast<bool>(m["AsynchronousExecution"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("IgnoreEmpty") != m.end() && !m["IgnoreEmpty"].empty()) {
      ignoreEmpty = make_shared<bool>(boost::any_cast<bool>(m["IgnoreEmpty"]));
    }
    if (m.find("NoExecuteExpression") != m.end() && !m["NoExecuteExpression"].empty()) {
      noExecuteExpression = make_shared<bool>(boost::any_cast<bool>(m["NoExecuteExpression"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
    if (m.find("UpdateFormDataJsonMap") != m.end() && !m["UpdateFormDataJsonMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["UpdateFormDataJsonMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      updateFormDataJsonMap = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("UseLatestFormSchemaVersion") != m.end() && !m["UseLatestFormSchemaVersion"].empty()) {
      useLatestFormSchemaVersion = make_shared<bool>(boost::any_cast<bool>(m["UseLatestFormSchemaVersion"]));
    }
  }


  virtual ~BatchUpdateFormDataByInstanceMapRequest() = default;
};
class BatchUpdateFormDataByInstanceMapShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<bool> asynchronousExecution{};
  shared_ptr<string> formUuid{};
  shared_ptr<bool> ignoreEmpty{};
  shared_ptr<bool> noExecuteExpression{};
  shared_ptr<string> systemToken{};
  shared_ptr<string> updateFormDataJsonMapShrink{};
  shared_ptr<bool> useLatestFormSchemaVersion{};

  BatchUpdateFormDataByInstanceMapShrinkRequest() {}

  explicit BatchUpdateFormDataByInstanceMapShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (asynchronousExecution) {
      res["AsynchronousExecution"] = boost::any(*asynchronousExecution);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (ignoreEmpty) {
      res["IgnoreEmpty"] = boost::any(*ignoreEmpty);
    }
    if (noExecuteExpression) {
      res["NoExecuteExpression"] = boost::any(*noExecuteExpression);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    if (updateFormDataJsonMapShrink) {
      res["UpdateFormDataJsonMap"] = boost::any(*updateFormDataJsonMapShrink);
    }
    if (useLatestFormSchemaVersion) {
      res["UseLatestFormSchemaVersion"] = boost::any(*useLatestFormSchemaVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("AsynchronousExecution") != m.end() && !m["AsynchronousExecution"].empty()) {
      asynchronousExecution = make_shared<bool>(boost::any_cast<bool>(m["AsynchronousExecution"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("IgnoreEmpty") != m.end() && !m["IgnoreEmpty"].empty()) {
      ignoreEmpty = make_shared<bool>(boost::any_cast<bool>(m["IgnoreEmpty"]));
    }
    if (m.find("NoExecuteExpression") != m.end() && !m["NoExecuteExpression"].empty()) {
      noExecuteExpression = make_shared<bool>(boost::any_cast<bool>(m["NoExecuteExpression"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
    if (m.find("UpdateFormDataJsonMap") != m.end() && !m["UpdateFormDataJsonMap"].empty()) {
      updateFormDataJsonMapShrink = make_shared<string>(boost::any_cast<string>(m["UpdateFormDataJsonMap"]));
    }
    if (m.find("UseLatestFormSchemaVersion") != m.end() && !m["UseLatestFormSchemaVersion"].empty()) {
      useLatestFormSchemaVersion = make_shared<bool>(boost::any_cast<bool>(m["UseLatestFormSchemaVersion"]));
    }
  }


  virtual ~BatchUpdateFormDataByInstanceMapShrinkRequest() = default;
};
class BatchUpdateFormDataByInstanceMapResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> result{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  BatchUpdateFormDataByInstanceMapResponseBody() {}

  explicit BatchUpdateFormDataByInstanceMapResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["result"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      result = make_shared<vector<string>>(toVec1);
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~BatchUpdateFormDataByInstanceMapResponseBody() = default;
};
class BatchUpdateFormDataByInstanceMapResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchUpdateFormDataByInstanceMapResponseBody> body{};

  BatchUpdateFormDataByInstanceMapResponse() {}

  explicit BatchUpdateFormDataByInstanceMapResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchUpdateFormDataByInstanceMapResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchUpdateFormDataByInstanceMapResponseBody>(model1);
      }
    }
  }


  virtual ~BatchUpdateFormDataByInstanceMapResponse() = default;
};
class CancelScheduleConferenceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CancelScheduleConferenceHeadersAccountContext() {}

  explicit CancelScheduleConferenceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CancelScheduleConferenceHeadersAccountContext() = default;
};
class CancelScheduleConferenceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CancelScheduleConferenceHeadersAccountContext> accountContext{};

  CancelScheduleConferenceHeaders() {}

  explicit CancelScheduleConferenceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CancelScheduleConferenceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CancelScheduleConferenceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CancelScheduleConferenceHeaders() = default;
};
class CancelScheduleConferenceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CancelScheduleConferenceShrinkHeaders() {}

  explicit CancelScheduleConferenceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CancelScheduleConferenceShrinkHeaders() = default;
};
class CancelScheduleConferenceRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CancelScheduleConferenceRequestTenantContext() {}

  explicit CancelScheduleConferenceRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CancelScheduleConferenceRequestTenantContext() = default;
};
class CancelScheduleConferenceRequest : public Darabonba::Model {
public:
  shared_ptr<string> scheduleConferenceId{};
  shared_ptr<CancelScheduleConferenceRequestTenantContext> tenantContext{};

  CancelScheduleConferenceRequest() {}

  explicit CancelScheduleConferenceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scheduleConferenceId) {
      res["ScheduleConferenceId"] = boost::any(*scheduleConferenceId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScheduleConferenceId") != m.end() && !m["ScheduleConferenceId"].empty()) {
      scheduleConferenceId = make_shared<string>(boost::any_cast<string>(m["ScheduleConferenceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CancelScheduleConferenceRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CancelScheduleConferenceRequestTenantContext>(model1);
      }
    }
  }


  virtual ~CancelScheduleConferenceRequest() = default;
};
class CancelScheduleConferenceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> scheduleConferenceId{};
  shared_ptr<string> tenantContextShrink{};

  CancelScheduleConferenceShrinkRequest() {}

  explicit CancelScheduleConferenceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scheduleConferenceId) {
      res["ScheduleConferenceId"] = boost::any(*scheduleConferenceId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScheduleConferenceId") != m.end() && !m["ScheduleConferenceId"].empty()) {
      scheduleConferenceId = make_shared<string>(boost::any_cast<string>(m["ScheduleConferenceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~CancelScheduleConferenceShrinkRequest() = default;
};
class CancelScheduleConferenceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CancelScheduleConferenceResponseBody() {}

  explicit CancelScheduleConferenceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CancelScheduleConferenceResponseBody() = default;
};
class CancelScheduleConferenceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelScheduleConferenceResponseBody> body{};

  CancelScheduleConferenceResponse() {}

  explicit CancelScheduleConferenceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelScheduleConferenceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelScheduleConferenceResponseBody>(model1);
      }
    }
  }


  virtual ~CancelScheduleConferenceResponse() = default;
};
class CheckAlibabaStaffHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CheckAlibabaStaffHeadersAccountContext() {}

  explicit CheckAlibabaStaffHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CheckAlibabaStaffHeadersAccountContext() = default;
};
class CheckAlibabaStaffHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CheckAlibabaStaffHeadersAccountContext> accountContext{};

  CheckAlibabaStaffHeaders() {}

  explicit CheckAlibabaStaffHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CheckAlibabaStaffHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CheckAlibabaStaffHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CheckAlibabaStaffHeaders() = default;
};
class CheckAlibabaStaffShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CheckAlibabaStaffShrinkHeaders() {}

  explicit CheckAlibabaStaffShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CheckAlibabaStaffShrinkHeaders() = default;
};
class CheckAlibabaStaffRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CheckAlibabaStaffRequestTenantContext() {}

  explicit CheckAlibabaStaffRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CheckAlibabaStaffRequestTenantContext() = default;
};
class CheckAlibabaStaffRequest : public Darabonba::Model {
public:
  shared_ptr<string> mobile{};
  shared_ptr<CheckAlibabaStaffRequestTenantContext> tenantContext{};

  CheckAlibabaStaffRequest() {}

  explicit CheckAlibabaStaffRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CheckAlibabaStaffRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CheckAlibabaStaffRequestTenantContext>(model1);
      }
    }
  }


  virtual ~CheckAlibabaStaffRequest() = default;
};
class CheckAlibabaStaffShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> mobile{};
  shared_ptr<string> tenantContextShrink{};

  CheckAlibabaStaffShrinkRequest() {}

  explicit CheckAlibabaStaffShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~CheckAlibabaStaffShrinkRequest() = default;
};
class CheckAlibabaStaffResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> isAlibabaStaff{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  CheckAlibabaStaffResponseBody() {}

  explicit CheckAlibabaStaffResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isAlibabaStaff) {
      res["isAlibabaStaff"] = boost::any(*isAlibabaStaff);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isAlibabaStaff") != m.end() && !m["isAlibabaStaff"].empty()) {
      isAlibabaStaff = make_shared<bool>(boost::any_cast<bool>(m["isAlibabaStaff"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~CheckAlibabaStaffResponseBody() = default;
};
class CheckAlibabaStaffResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckAlibabaStaffResponseBody> body{};

  CheckAlibabaStaffResponse() {}

  explicit CheckAlibabaStaffResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckAlibabaStaffResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckAlibabaStaffResponseBody>(model1);
      }
    }
  }


  virtual ~CheckAlibabaStaffResponse() = default;
};
class CheckUserIsGroupMemberHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CheckUserIsGroupMemberHeadersAccountContext() {}

  explicit CheckUserIsGroupMemberHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CheckUserIsGroupMemberHeadersAccountContext() = default;
};
class CheckUserIsGroupMemberHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CheckUserIsGroupMemberHeadersAccountContext> accountContext{};

  CheckUserIsGroupMemberHeaders() {}

  explicit CheckUserIsGroupMemberHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CheckUserIsGroupMemberHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CheckUserIsGroupMemberHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CheckUserIsGroupMemberHeaders() = default;
};
class CheckUserIsGroupMemberShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CheckUserIsGroupMemberShrinkHeaders() {}

  explicit CheckUserIsGroupMemberShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CheckUserIsGroupMemberShrinkHeaders() = default;
};
class CheckUserIsGroupMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> openConversationId{};

  CheckUserIsGroupMemberRequest() {}

  explicit CheckUserIsGroupMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openConversationId) {
      res["OpenConversationId"] = boost::any(*openConversationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpenConversationId") != m.end() && !m["OpenConversationId"].empty()) {
      openConversationId = make_shared<string>(boost::any_cast<string>(m["OpenConversationId"]));
    }
  }


  virtual ~CheckUserIsGroupMemberRequest() = default;
};
class CheckUserIsGroupMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  CheckUserIsGroupMemberResponseBody() {}

  explicit CheckUserIsGroupMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~CheckUserIsGroupMemberResponseBody() = default;
};
class CheckUserIsGroupMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckUserIsGroupMemberResponseBody> body{};

  CheckUserIsGroupMemberResponse() {}

  explicit CheckUserIsGroupMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckUserIsGroupMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckUserIsGroupMemberResponseBody>(model1);
      }
    }
  }


  virtual ~CheckUserIsGroupMemberResponse() = default;
};
class ClearHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ClearHeadersAccountContext() {}

  explicit ClearHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ClearHeadersAccountContext() = default;
};
class ClearHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ClearHeadersAccountContext> accountContext{};

  ClearHeaders() {}

  explicit ClearHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ClearHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ClearHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ClearHeaders() = default;
};
class ClearShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ClearShrinkHeaders() {}

  explicit ClearShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ClearShrinkHeaders() = default;
};
class ClearRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  ClearRequestTenantContext() {}

  explicit ClearRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~ClearRequestTenantContext() = default;
};
class ClearRequest : public Darabonba::Model {
public:
  shared_ptr<string> rangeAddress{};
  shared_ptr<string> sheetId{};
  shared_ptr<ClearRequestTenantContext> tenantContext{};
  shared_ptr<string> workbookId{};

  ClearRequest() {}

  explicit ClearRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rangeAddress) {
      res["RangeAddress"] = boost::any(*rangeAddress);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RangeAddress") != m.end() && !m["RangeAddress"].empty()) {
      rangeAddress = make_shared<string>(boost::any_cast<string>(m["RangeAddress"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        ClearRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<ClearRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~ClearRequest() = default;
};
class ClearShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> rangeAddress{};
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workbookId{};

  ClearShrinkRequest() {}

  explicit ClearShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rangeAddress) {
      res["RangeAddress"] = boost::any(*rangeAddress);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RangeAddress") != m.end() && !m["RangeAddress"].empty()) {
      rangeAddress = make_shared<string>(boost::any_cast<string>(m["RangeAddress"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~ClearShrinkRequest() = default;
};
class ClearResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> a1Notation{};
  shared_ptr<string> requestId{};

  ClearResponseBody() {}

  explicit ClearResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (a1Notation) {
      res["a1Notation"] = boost::any(*a1Notation);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("a1Notation") != m.end() && !m["a1Notation"].empty()) {
      a1Notation = make_shared<string>(boost::any_cast<string>(m["a1Notation"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ClearResponseBody() = default;
};
class ClearResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ClearResponseBody> body{};

  ClearResponse() {}

  explicit ClearResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ClearResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ClearResponseBody>(model1);
      }
    }
  }


  virtual ~ClearResponse() = default;
};
class ClearDataHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ClearDataHeadersAccountContext() {}

  explicit ClearDataHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ClearDataHeadersAccountContext() = default;
};
class ClearDataHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ClearDataHeadersAccountContext> accountContext{};

  ClearDataHeaders() {}

  explicit ClearDataHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ClearDataHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ClearDataHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ClearDataHeaders() = default;
};
class ClearDataShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ClearDataShrinkHeaders() {}

  explicit ClearDataShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ClearDataShrinkHeaders() = default;
};
class ClearDataRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  ClearDataRequestTenantContext() {}

  explicit ClearDataRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~ClearDataRequestTenantContext() = default;
};
class ClearDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> rangeAddress{};
  shared_ptr<string> sheetId{};
  shared_ptr<ClearDataRequestTenantContext> tenantContext{};
  shared_ptr<string> workbookId{};

  ClearDataRequest() {}

  explicit ClearDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rangeAddress) {
      res["RangeAddress"] = boost::any(*rangeAddress);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RangeAddress") != m.end() && !m["RangeAddress"].empty()) {
      rangeAddress = make_shared<string>(boost::any_cast<string>(m["RangeAddress"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        ClearDataRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<ClearDataRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~ClearDataRequest() = default;
};
class ClearDataShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> rangeAddress{};
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workbookId{};

  ClearDataShrinkRequest() {}

  explicit ClearDataShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rangeAddress) {
      res["RangeAddress"] = boost::any(*rangeAddress);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RangeAddress") != m.end() && !m["RangeAddress"].empty()) {
      rangeAddress = make_shared<string>(boost::any_cast<string>(m["RangeAddress"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~ClearDataShrinkRequest() = default;
};
class ClearDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> a1Notation{};
  shared_ptr<string> requestId{};

  ClearDataResponseBody() {}

  explicit ClearDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (a1Notation) {
      res["a1Notation"] = boost::any(*a1Notation);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("a1Notation") != m.end() && !m["a1Notation"].empty()) {
      a1Notation = make_shared<string>(boost::any_cast<string>(m["a1Notation"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ClearDataResponseBody() = default;
};
class ClearDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ClearDataResponseBody> body{};

  ClearDataResponse() {}

  explicit ClearDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ClearDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ClearDataResponseBody>(model1);
      }
    }
  }


  virtual ~ClearDataResponse() = default;
};
class CloseVideoConferenceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CloseVideoConferenceHeadersAccountContext() {}

  explicit CloseVideoConferenceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CloseVideoConferenceHeadersAccountContext() = default;
};
class CloseVideoConferenceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CloseVideoConferenceHeadersAccountContext> accountContext{};

  CloseVideoConferenceHeaders() {}

  explicit CloseVideoConferenceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CloseVideoConferenceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CloseVideoConferenceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CloseVideoConferenceHeaders() = default;
};
class CloseVideoConferenceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CloseVideoConferenceShrinkHeaders() {}

  explicit CloseVideoConferenceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CloseVideoConferenceShrinkHeaders() = default;
};
class CloseVideoConferenceRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CloseVideoConferenceRequestTenantContext() {}

  explicit CloseVideoConferenceRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CloseVideoConferenceRequestTenantContext() = default;
};
class CloseVideoConferenceRequest : public Darabonba::Model {
public:
  shared_ptr<CloseVideoConferenceRequestTenantContext> tenantContext{};
  shared_ptr<string> conferenceId{};

  CloseVideoConferenceRequest() {}

  explicit CloseVideoConferenceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CloseVideoConferenceRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CloseVideoConferenceRequestTenantContext>(model1);
      }
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~CloseVideoConferenceRequest() = default;
};
class CloseVideoConferenceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> conferenceId{};

  CloseVideoConferenceShrinkRequest() {}

  explicit CloseVideoConferenceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~CloseVideoConferenceShrinkRequest() = default;
};
class CloseVideoConferenceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> cause{};
  shared_ptr<long> code{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  CloseVideoConferenceResponseBody() {}

  explicit CloseVideoConferenceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cause) {
      res["cause"] = boost::any(*cause);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cause") != m.end() && !m["cause"].empty()) {
      cause = make_shared<string>(boost::any_cast<string>(m["cause"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["code"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~CloseVideoConferenceResponseBody() = default;
};
class CloseVideoConferenceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CloseVideoConferenceResponseBody> body{};

  CloseVideoConferenceResponse() {}

  explicit CloseVideoConferenceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CloseVideoConferenceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CloseVideoConferenceResponseBody>(model1);
      }
    }
  }


  virtual ~CloseVideoConferenceResponse() = default;
};
class CommentListReportHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CommentListReportHeadersAccountContext() {}

  explicit CommentListReportHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CommentListReportHeadersAccountContext() = default;
};
class CommentListReportHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CommentListReportHeadersAccountContext> accountContext{};

  CommentListReportHeaders() {}

  explicit CommentListReportHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CommentListReportHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CommentListReportHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CommentListReportHeaders() = default;
};
class CommentListReportShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CommentListReportShrinkHeaders() {}

  explicit CommentListReportShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CommentListReportShrinkHeaders() = default;
};
class CommentListReportRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CommentListReportRequestTenantContext() {}

  explicit CommentListReportRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CommentListReportRequestTenantContext() = default;
};
class CommentListReportRequest : public Darabonba::Model {
public:
  shared_ptr<long> offset{};
  shared_ptr<string> reportId{};
  shared_ptr<long> size{};
  shared_ptr<CommentListReportRequestTenantContext> tenantContext{};

  CommentListReportRequest() {}

  explicit CommentListReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CommentListReportRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CommentListReportRequestTenantContext>(model1);
      }
    }
  }


  virtual ~CommentListReportRequest() = default;
};
class CommentListReportShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> offset{};
  shared_ptr<string> reportId{};
  shared_ptr<long> size{};
  shared_ptr<string> tenantContextShrink{};

  CommentListReportShrinkRequest() {}

  explicit CommentListReportShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~CommentListReportShrinkRequest() = default;
};
class CommentListReportResponseBodyComments : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> createTime{};
  shared_ptr<string> userid{};

  CommentListReportResponseBodyComments() {}

  explicit CommentListReportResponseBodyComments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (userid) {
      res["Userid"] = boost::any(*userid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Userid") != m.end() && !m["Userid"].empty()) {
      userid = make_shared<string>(boost::any_cast<string>(m["Userid"]));
    }
  }


  virtual ~CommentListReportResponseBodyComments() = default;
};
class CommentListReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<CommentListReportResponseBodyComments>> comments{};
  shared_ptr<bool> hasMore{};
  shared_ptr<long> nextCursor{};
  shared_ptr<string> requestId{};

  CommentListReportResponseBody() {}

  explicit CommentListReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comments) {
      vector<boost::any> temp1;
      for(auto item1:*comments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["comments"] = boost::any(temp1);
    }
    if (hasMore) {
      res["hasMore"] = boost::any(*hasMore);
    }
    if (nextCursor) {
      res["nextCursor"] = boost::any(*nextCursor);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("comments") != m.end() && !m["comments"].empty()) {
      if (typeid(vector<boost::any>) == m["comments"].type()) {
        vector<CommentListReportResponseBodyComments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["comments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CommentListReportResponseBodyComments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        comments = make_shared<vector<CommentListReportResponseBodyComments>>(expect1);
      }
    }
    if (m.find("hasMore") != m.end() && !m["hasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["hasMore"]));
    }
    if (m.find("nextCursor") != m.end() && !m["nextCursor"].empty()) {
      nextCursor = make_shared<long>(boost::any_cast<long>(m["nextCursor"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CommentListReportResponseBody() = default;
};
class CommentListReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CommentListReportResponseBody> body{};

  CommentListReportResponse() {}

  explicit CommentListReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CommentListReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CommentListReportResponseBody>(model1);
      }
    }
  }


  virtual ~CommentListReportResponse() = default;
};
class CommitFileHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CommitFileHeadersAccountContext() {}

  explicit CommitFileHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CommitFileHeadersAccountContext() = default;
};
class CommitFileHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CommitFileHeadersAccountContext> accountContext{};

  CommitFileHeaders() {}

  explicit CommitFileHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CommitFileHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CommitFileHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CommitFileHeaders() = default;
};
class CommitFileShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CommitFileShrinkHeaders() {}

  explicit CommitFileShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CommitFileShrinkHeaders() = default;
};
class CommitFileRequestOptionAppProperties : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};
  shared_ptr<string> visibility{};

  CommitFileRequestOptionAppProperties() {}

  explicit CommitFileRequestOptionAppProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~CommitFileRequestOptionAppProperties() = default;
};
class CommitFileRequestOption : public Darabonba::Model {
public:
  shared_ptr<vector<CommitFileRequestOptionAppProperties>> appProperties{};
  shared_ptr<string> conflictStrategy{};
  shared_ptr<bool> convertToOnlineDoc{};
  shared_ptr<string> convertToOnlineDocTargetDocumentType{};
  shared_ptr<long> size{};

  CommitFileRequestOption() {}

  explicit CommitFileRequestOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appProperties) {
      vector<boost::any> temp1;
      for(auto item1:*appProperties){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppProperties"] = boost::any(temp1);
    }
    if (conflictStrategy) {
      res["ConflictStrategy"] = boost::any(*conflictStrategy);
    }
    if (convertToOnlineDoc) {
      res["ConvertToOnlineDoc"] = boost::any(*convertToOnlineDoc);
    }
    if (convertToOnlineDocTargetDocumentType) {
      res["ConvertToOnlineDocTargetDocumentType"] = boost::any(*convertToOnlineDocTargetDocumentType);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppProperties") != m.end() && !m["AppProperties"].empty()) {
      if (typeid(vector<boost::any>) == m["AppProperties"].type()) {
        vector<CommitFileRequestOptionAppProperties> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppProperties"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CommitFileRequestOptionAppProperties model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appProperties = make_shared<vector<CommitFileRequestOptionAppProperties>>(expect1);
      }
    }
    if (m.find("ConflictStrategy") != m.end() && !m["ConflictStrategy"].empty()) {
      conflictStrategy = make_shared<string>(boost::any_cast<string>(m["ConflictStrategy"]));
    }
    if (m.find("ConvertToOnlineDoc") != m.end() && !m["ConvertToOnlineDoc"].empty()) {
      convertToOnlineDoc = make_shared<bool>(boost::any_cast<bool>(m["ConvertToOnlineDoc"]));
    }
    if (m.find("ConvertToOnlineDocTargetDocumentType") != m.end() && !m["ConvertToOnlineDocTargetDocumentType"].empty()) {
      convertToOnlineDocTargetDocumentType = make_shared<string>(boost::any_cast<string>(m["ConvertToOnlineDocTargetDocumentType"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~CommitFileRequestOption() = default;
};
class CommitFileRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CommitFileRequestTenantContext() {}

  explicit CommitFileRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CommitFileRequestTenantContext() = default;
};
class CommitFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<CommitFileRequestOption> option{};
  shared_ptr<string> parentDentryUuid{};
  shared_ptr<CommitFileRequestTenantContext> tenantContext{};
  shared_ptr<string> uploadKey{};

  CommitFileRequest() {}

  explicit CommitFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (option) {
      res["Option"] = option ? boost::any(option->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parentDentryUuid) {
      res["ParentDentryUuid"] = boost::any(*parentDentryUuid);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (uploadKey) {
      res["UploadKey"] = boost::any(*uploadKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      if (typeid(map<string, boost::any>) == m["Option"].type()) {
        CommitFileRequestOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Option"]));
        option = make_shared<CommitFileRequestOption>(model1);
      }
    }
    if (m.find("ParentDentryUuid") != m.end() && !m["ParentDentryUuid"].empty()) {
      parentDentryUuid = make_shared<string>(boost::any_cast<string>(m["ParentDentryUuid"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CommitFileRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CommitFileRequestTenantContext>(model1);
      }
    }
    if (m.find("UploadKey") != m.end() && !m["UploadKey"].empty()) {
      uploadKey = make_shared<string>(boost::any_cast<string>(m["UploadKey"]));
    }
  }


  virtual ~CommitFileRequest() = default;
};
class CommitFileShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> optionShrink{};
  shared_ptr<string> parentDentryUuid{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> uploadKey{};

  CommitFileShrinkRequest() {}

  explicit CommitFileShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (optionShrink) {
      res["Option"] = boost::any(*optionShrink);
    }
    if (parentDentryUuid) {
      res["ParentDentryUuid"] = boost::any(*parentDentryUuid);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (uploadKey) {
      res["UploadKey"] = boost::any(*uploadKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      optionShrink = make_shared<string>(boost::any_cast<string>(m["Option"]));
    }
    if (m.find("ParentDentryUuid") != m.end() && !m["ParentDentryUuid"].empty()) {
      parentDentryUuid = make_shared<string>(boost::any_cast<string>(m["ParentDentryUuid"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("UploadKey") != m.end() && !m["UploadKey"].empty()) {
      uploadKey = make_shared<string>(boost::any_cast<string>(m["UploadKey"]));
    }
  }


  virtual ~CommitFileShrinkRequest() = default;
};
class CommitFileResponseBodyDentryProperties : public Darabonba::Model {
public:
  shared_ptr<bool> readOnly{};

  CommitFileResponseBodyDentryProperties() {}

  explicit CommitFileResponseBodyDentryProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
  }


  virtual ~CommitFileResponseBodyDentryProperties() = default;
};
class CommitFileResponseBodyDentryThumbnail : public Darabonba::Model {
public:
  shared_ptr<long> height{};
  shared_ptr<string> url{};
  shared_ptr<long> width{};

  CommitFileResponseBodyDentryThumbnail() {}

  explicit CommitFileResponseBodyDentryThumbnail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~CommitFileResponseBodyDentryThumbnail() = default;
};
class CommitFileResponseBodyDentry : public Darabonba::Model {
public:
  shared_ptr<map<string, vector<DentryAppPropertiesValue>>> appProperties{};
  shared_ptr<string> category{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> extension{};
  shared_ptr<string> id{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> name{};
  shared_ptr<string> parentId{};
  shared_ptr<string> partitionType{};
  shared_ptr<string> path{};
  shared_ptr<CommitFileResponseBodyDentryProperties> properties{};
  shared_ptr<long> size{};
  shared_ptr<string> spaceId{};
  shared_ptr<string> status{};
  shared_ptr<string> storageDriver{};
  shared_ptr<CommitFileResponseBodyDentryThumbnail> thumbnail{};
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};
  shared_ptr<long> version{};

  CommitFileResponseBodyDentry() {}

  explicit CommitFileResponseBodyDentry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appProperties) {
      map<string, boost::any> temp1;
      for(auto item1:*appProperties){
        vector<boost::any> temp2;
        for(auto item2:item1.second){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1[item1.first] = boost::any(temp2);
      }
      res["AppProperties"] = boost::any(temp1);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (partitionType) {
      res["PartitionType"] = boost::any(*partitionType);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageDriver) {
      res["StorageDriver"] = boost::any(*storageDriver);
    }
    if (thumbnail) {
      res["Thumbnail"] = thumbnail ? boost::any(thumbnail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppProperties") != m.end() && !m["AppProperties"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppProperties"].type()) {
        map<string, vector<DentryAppPropertiesValue>> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["AppProperties"])){
          if (typeid(vector<boost::any>) == item1.second.type()) {
            vector<DentryAppPropertiesValue> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1.second)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                DentryAppPropertiesValue model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1[item1.first] = expect2;
          }
        }
        appProperties = make_shared<map<string, vector<DentryAppPropertiesValue>>>(expect1);
      }
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["ModifierId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("PartitionType") != m.end() && !m["PartitionType"].empty()) {
      partitionType = make_shared<string>(boost::any_cast<string>(m["PartitionType"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        CommitFileResponseBodyDentryProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<CommitFileResponseBodyDentryProperties>(model1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageDriver") != m.end() && !m["StorageDriver"].empty()) {
      storageDriver = make_shared<string>(boost::any_cast<string>(m["StorageDriver"]));
    }
    if (m.find("Thumbnail") != m.end() && !m["Thumbnail"].empty()) {
      if (typeid(map<string, boost::any>) == m["Thumbnail"].type()) {
        CommitFileResponseBodyDentryThumbnail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Thumbnail"]));
        thumbnail = make_shared<CommitFileResponseBodyDentryThumbnail>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~CommitFileResponseBodyDentry() = default;
};
class CommitFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<CommitFileResponseBodyDentry> dentry{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  CommitFileResponseBody() {}

  explicit CommitFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentry) {
      res["dentry"] = dentry ? boost::any(dentry->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dentry") != m.end() && !m["dentry"].empty()) {
      if (typeid(map<string, boost::any>) == m["dentry"].type()) {
        CommitFileResponseBodyDentry model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dentry"]));
        dentry = make_shared<CommitFileResponseBodyDentry>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~CommitFileResponseBody() = default;
};
class CommitFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CommitFileResponseBody> body{};

  CommitFileResponse() {}

  explicit CommitFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CommitFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CommitFileResponseBody>(model1);
      }
    }
  }


  virtual ~CommitFileResponse() = default;
};
class CopyDentryHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CopyDentryHeadersAccountContext() {}

  explicit CopyDentryHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CopyDentryHeadersAccountContext() = default;
};
class CopyDentryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CopyDentryHeadersAccountContext> accountContext{};

  CopyDentryHeaders() {}

  explicit CopyDentryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CopyDentryHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CopyDentryHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CopyDentryHeaders() = default;
};
class CopyDentryShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CopyDentryShrinkHeaders() {}

  explicit CopyDentryShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CopyDentryShrinkHeaders() = default;
};
class CopyDentryRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CopyDentryRequestTenantContext() {}

  explicit CopyDentryRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CopyDentryRequestTenantContext() = default;
};
class CopyDentryRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryId{};
  shared_ptr<string> name{};
  shared_ptr<string> spaceId{};
  shared_ptr<string> targetSpaceId{};
  shared_ptr<CopyDentryRequestTenantContext> tenantContext{};
  shared_ptr<string> toNextDentryId{};
  shared_ptr<string> toParentDentryId{};
  shared_ptr<string> toPrevDentryId{};

  CopyDentryRequest() {}

  explicit CopyDentryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryId) {
      res["DentryId"] = boost::any(*dentryId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (targetSpaceId) {
      res["TargetSpaceId"] = boost::any(*targetSpaceId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (toNextDentryId) {
      res["ToNextDentryId"] = boost::any(*toNextDentryId);
    }
    if (toParentDentryId) {
      res["ToParentDentryId"] = boost::any(*toParentDentryId);
    }
    if (toPrevDentryId) {
      res["ToPrevDentryId"] = boost::any(*toPrevDentryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryId") != m.end() && !m["DentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["DentryId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("TargetSpaceId") != m.end() && !m["TargetSpaceId"].empty()) {
      targetSpaceId = make_shared<string>(boost::any_cast<string>(m["TargetSpaceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CopyDentryRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CopyDentryRequestTenantContext>(model1);
      }
    }
    if (m.find("ToNextDentryId") != m.end() && !m["ToNextDentryId"].empty()) {
      toNextDentryId = make_shared<string>(boost::any_cast<string>(m["ToNextDentryId"]));
    }
    if (m.find("ToParentDentryId") != m.end() && !m["ToParentDentryId"].empty()) {
      toParentDentryId = make_shared<string>(boost::any_cast<string>(m["ToParentDentryId"]));
    }
    if (m.find("ToPrevDentryId") != m.end() && !m["ToPrevDentryId"].empty()) {
      toPrevDentryId = make_shared<string>(boost::any_cast<string>(m["ToPrevDentryId"]));
    }
  }


  virtual ~CopyDentryRequest() = default;
};
class CopyDentryShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryId{};
  shared_ptr<string> name{};
  shared_ptr<string> spaceId{};
  shared_ptr<string> targetSpaceId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> toNextDentryId{};
  shared_ptr<string> toParentDentryId{};
  shared_ptr<string> toPrevDentryId{};

  CopyDentryShrinkRequest() {}

  explicit CopyDentryShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryId) {
      res["DentryId"] = boost::any(*dentryId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (targetSpaceId) {
      res["TargetSpaceId"] = boost::any(*targetSpaceId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (toNextDentryId) {
      res["ToNextDentryId"] = boost::any(*toNextDentryId);
    }
    if (toParentDentryId) {
      res["ToParentDentryId"] = boost::any(*toParentDentryId);
    }
    if (toPrevDentryId) {
      res["ToPrevDentryId"] = boost::any(*toPrevDentryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryId") != m.end() && !m["DentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["DentryId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("TargetSpaceId") != m.end() && !m["TargetSpaceId"].empty()) {
      targetSpaceId = make_shared<string>(boost::any_cast<string>(m["TargetSpaceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("ToNextDentryId") != m.end() && !m["ToNextDentryId"].empty()) {
      toNextDentryId = make_shared<string>(boost::any_cast<string>(m["ToNextDentryId"]));
    }
    if (m.find("ToParentDentryId") != m.end() && !m["ToParentDentryId"].empty()) {
      toParentDentryId = make_shared<string>(boost::any_cast<string>(m["ToParentDentryId"]));
    }
    if (m.find("ToPrevDentryId") != m.end() && !m["ToPrevDentryId"].empty()) {
      toPrevDentryId = make_shared<string>(boost::any_cast<string>(m["ToPrevDentryId"]));
    }
  }


  virtual ~CopyDentryShrinkRequest() = default;
};
class CopyDentryResponseBodyLinkSourceInfoIconUrl : public Darabonba::Model {
public:
  shared_ptr<string> line{};
  shared_ptr<string> small{};

  CopyDentryResponseBodyLinkSourceInfoIconUrl() {}

  explicit CopyDentryResponseBodyLinkSourceInfoIconUrl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (small) {
      res["Small"] = boost::any(*small);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("Small") != m.end() && !m["Small"].empty()) {
      small = make_shared<string>(boost::any_cast<string>(m["Small"]));
    }
  }


  virtual ~CopyDentryResponseBodyLinkSourceInfoIconUrl() = default;
};
class CopyDentryResponseBodyLinkSourceInfo : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<CopyDentryResponseBodyLinkSourceInfoIconUrl> iconUrl{};
  shared_ptr<string> id{};
  shared_ptr<long> linkType{};
  shared_ptr<string> spaceId{};

  CopyDentryResponseBodyLinkSourceInfo() {}

  explicit CopyDentryResponseBodyLinkSourceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (iconUrl) {
      res["IconUrl"] = iconUrl ? boost::any(iconUrl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (linkType) {
      res["LinkType"] = boost::any(*linkType);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("IconUrl") != m.end() && !m["IconUrl"].empty()) {
      if (typeid(map<string, boost::any>) == m["IconUrl"].type()) {
        CopyDentryResponseBodyLinkSourceInfoIconUrl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IconUrl"]));
        iconUrl = make_shared<CopyDentryResponseBodyLinkSourceInfoIconUrl>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LinkType") != m.end() && !m["LinkType"].empty()) {
      linkType = make_shared<long>(boost::any_cast<long>(m["LinkType"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
  }


  virtual ~CopyDentryResponseBodyLinkSourceInfo() = default;
};
class CopyDentryResponseBodySpaceHdIconVO : public Darabonba::Model {
public:
  shared_ptr<string> icon{};
  shared_ptr<string> type{};

  CopyDentryResponseBodySpaceHdIconVO() {}

  explicit CopyDentryResponseBodySpaceHdIconVO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CopyDentryResponseBodySpaceHdIconVO() = default;
};
class CopyDentryResponseBodySpaceIconVO : public Darabonba::Model {
public:
  shared_ptr<string> icon{};
  shared_ptr<string> type{};

  CopyDentryResponseBodySpaceIconVO() {}

  explicit CopyDentryResponseBodySpaceIconVO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CopyDentryResponseBodySpaceIconVO() = default;
};
class CopyDentryResponseBodySpaceOwner : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> userId{};

  CopyDentryResponseBodySpaceOwner() {}

  explicit CopyDentryResponseBodySpaceOwner(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CopyDentryResponseBodySpaceOwner() = default;
};
class CopyDentryResponseBodySpaceRecentListCreator : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> userId{};

  CopyDentryResponseBodySpaceRecentListCreator() {}

  explicit CopyDentryResponseBodySpaceRecentListCreator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CopyDentryResponseBodySpaceRecentListCreator() = default;
};
class CopyDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl : public Darabonba::Model {
public:
  shared_ptr<string> line{};
  shared_ptr<string> small{};

  CopyDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl() {}

  explicit CopyDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (small) {
      res["Small"] = boost::any(*small);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("Small") != m.end() && !m["Small"].empty()) {
      small = make_shared<string>(boost::any_cast<string>(m["Small"]));
    }
  }


  virtual ~CopyDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl() = default;
};
class CopyDentryResponseBodySpaceRecentListLinkSourceInfo : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<CopyDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl> iconUrl{};
  shared_ptr<string> id{};
  shared_ptr<long> linkType{};
  shared_ptr<string> spaceId{};

  CopyDentryResponseBodySpaceRecentListLinkSourceInfo() {}

  explicit CopyDentryResponseBodySpaceRecentListLinkSourceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (iconUrl) {
      res["IconUrl"] = iconUrl ? boost::any(iconUrl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (linkType) {
      res["LinkType"] = boost::any(*linkType);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("IconUrl") != m.end() && !m["IconUrl"].empty()) {
      if (typeid(map<string, boost::any>) == m["IconUrl"].type()) {
        CopyDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IconUrl"]));
        iconUrl = make_shared<CopyDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LinkType") != m.end() && !m["LinkType"].empty()) {
      linkType = make_shared<long>(boost::any_cast<long>(m["LinkType"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
  }


  virtual ~CopyDentryResponseBodySpaceRecentListLinkSourceInfo() = default;
};
class CopyDentryResponseBodySpaceRecentListStatisticalInfo : public Darabonba::Model {
public:
  shared_ptr<long> wordCount{};

  CopyDentryResponseBodySpaceRecentListStatisticalInfo() {}

  explicit CopyDentryResponseBodySpaceRecentListStatisticalInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (wordCount) {
      res["WordCount"] = boost::any(*wordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WordCount") != m.end() && !m["WordCount"].empty()) {
      wordCount = make_shared<long>(boost::any_cast<long>(m["WordCount"]));
    }
  }


  virtual ~CopyDentryResponseBodySpaceRecentListStatisticalInfo() = default;
};
class CopyDentryResponseBodySpaceRecentListUpdater : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> userId{};

  CopyDentryResponseBodySpaceRecentListUpdater() {}

  explicit CopyDentryResponseBodySpaceRecentListUpdater(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CopyDentryResponseBodySpaceRecentListUpdater() = default;
};
class CopyDentryResponseBodySpaceRecentListVisitorInfo : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dentryActions{};
  shared_ptr<string> roleCode{};
  shared_ptr<vector<string>> spaceActions{};

  CopyDentryResponseBodySpaceRecentListVisitorInfo() {}

  explicit CopyDentryResponseBodySpaceRecentListVisitorInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryActions) {
      res["DentryActions"] = boost::any(*dentryActions);
    }
    if (roleCode) {
      res["RoleCode"] = boost::any(*roleCode);
    }
    if (spaceActions) {
      res["SpaceActions"] = boost::any(*spaceActions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryActions") != m.end() && !m["DentryActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DentryActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DentryActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dentryActions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoleCode") != m.end() && !m["RoleCode"].empty()) {
      roleCode = make_shared<string>(boost::any_cast<string>(m["RoleCode"]));
    }
    if (m.find("SpaceActions") != m.end() && !m["SpaceActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SpaceActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SpaceActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      spaceActions = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CopyDentryResponseBodySpaceRecentListVisitorInfo() = default;
};
class CopyDentryResponseBodySpaceRecentList : public Darabonba::Model {
public:
  shared_ptr<string> contentType{};
  shared_ptr<long> createdTime{};
  shared_ptr<CopyDentryResponseBodySpaceRecentListCreator> creator{};
  shared_ptr<string> dentryId{};
  shared_ptr<string> dentryType{};
  shared_ptr<string> dentryUuid{};
  shared_ptr<string> docKey{};
  shared_ptr<string> extension{};
  shared_ptr<bool> hasChildren{};
  shared_ptr<CopyDentryResponseBodySpaceRecentListLinkSourceInfo> linkSourceInfo{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<boost::any> space{};
  shared_ptr<string> spaceId{};
  shared_ptr<CopyDentryResponseBodySpaceRecentListStatisticalInfo> statisticalInfo{};
  shared_ptr<long> updatedTime{};
  shared_ptr<CopyDentryResponseBodySpaceRecentListUpdater> updater{};
  shared_ptr<string> url{};
  shared_ptr<CopyDentryResponseBodySpaceRecentListVisitorInfo> visitorInfo{};

  CopyDentryResponseBodySpaceRecentList() {}

  explicit CopyDentryResponseBodySpaceRecentList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (creator) {
      res["Creator"] = creator ? boost::any(creator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dentryId) {
      res["DentryId"] = boost::any(*dentryId);
    }
    if (dentryType) {
      res["DentryType"] = boost::any(*dentryType);
    }
    if (dentryUuid) {
      res["DentryUuid"] = boost::any(*dentryUuid);
    }
    if (docKey) {
      res["DocKey"] = boost::any(*docKey);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (hasChildren) {
      res["HasChildren"] = boost::any(*hasChildren);
    }
    if (linkSourceInfo) {
      res["LinkSourceInfo"] = linkSourceInfo ? boost::any(linkSourceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (space) {
      res["Space"] = boost::any(*space);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (statisticalInfo) {
      res["StatisticalInfo"] = statisticalInfo ? boost::any(statisticalInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    if (updater) {
      res["Updater"] = updater ? boost::any(updater->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (visitorInfo) {
      res["VisitorInfo"] = visitorInfo ? boost::any(visitorInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      if (typeid(map<string, boost::any>) == m["Creator"].type()) {
        CopyDentryResponseBodySpaceRecentListCreator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Creator"]));
        creator = make_shared<CopyDentryResponseBodySpaceRecentListCreator>(model1);
      }
    }
    if (m.find("DentryId") != m.end() && !m["DentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["DentryId"]));
    }
    if (m.find("DentryType") != m.end() && !m["DentryType"].empty()) {
      dentryType = make_shared<string>(boost::any_cast<string>(m["DentryType"]));
    }
    if (m.find("DentryUuid") != m.end() && !m["DentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["DentryUuid"]));
    }
    if (m.find("DocKey") != m.end() && !m["DocKey"].empty()) {
      docKey = make_shared<string>(boost::any_cast<string>(m["DocKey"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("HasChildren") != m.end() && !m["HasChildren"].empty()) {
      hasChildren = make_shared<bool>(boost::any_cast<bool>(m["HasChildren"]));
    }
    if (m.find("LinkSourceInfo") != m.end() && !m["LinkSourceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["LinkSourceInfo"].type()) {
        CopyDentryResponseBodySpaceRecentListLinkSourceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LinkSourceInfo"]));
        linkSourceInfo = make_shared<CopyDentryResponseBodySpaceRecentListLinkSourceInfo>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Space") != m.end() && !m["Space"].empty()) {
      space = make_shared<boost::any>(boost::any_cast<boost::any>(m["Space"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("StatisticalInfo") != m.end() && !m["StatisticalInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatisticalInfo"].type()) {
        CopyDentryResponseBodySpaceRecentListStatisticalInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatisticalInfo"]));
        statisticalInfo = make_shared<CopyDentryResponseBodySpaceRecentListStatisticalInfo>(model1);
      }
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["UpdatedTime"]));
    }
    if (m.find("Updater") != m.end() && !m["Updater"].empty()) {
      if (typeid(map<string, boost::any>) == m["Updater"].type()) {
        CopyDentryResponseBodySpaceRecentListUpdater model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Updater"]));
        updater = make_shared<CopyDentryResponseBodySpaceRecentListUpdater>(model1);
      }
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("VisitorInfo") != m.end() && !m["VisitorInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["VisitorInfo"].type()) {
        CopyDentryResponseBodySpaceRecentListVisitorInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VisitorInfo"]));
        visitorInfo = make_shared<CopyDentryResponseBodySpaceRecentListVisitorInfo>(model1);
      }
    }
  }


  virtual ~CopyDentryResponseBodySpaceRecentList() = default;
};
class CopyDentryResponseBodySpaceVisitorInfo : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dentryActions{};
  shared_ptr<string> roleCode{};
  shared_ptr<vector<string>> spaceActions{};

  CopyDentryResponseBodySpaceVisitorInfo() {}

  explicit CopyDentryResponseBodySpaceVisitorInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryActions) {
      res["DentryActions"] = boost::any(*dentryActions);
    }
    if (roleCode) {
      res["RoleCode"] = boost::any(*roleCode);
    }
    if (spaceActions) {
      res["SpaceActions"] = boost::any(*spaceActions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryActions") != m.end() && !m["DentryActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DentryActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DentryActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dentryActions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoleCode") != m.end() && !m["RoleCode"].empty()) {
      roleCode = make_shared<string>(boost::any_cast<string>(m["RoleCode"]));
    }
    if (m.find("SpaceActions") != m.end() && !m["SpaceActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SpaceActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SpaceActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      spaceActions = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CopyDentryResponseBodySpaceVisitorInfo() = default;
};
class CopyDentryResponseBodySpace : public Darabonba::Model {
public:
  shared_ptr<string> cover{};
  shared_ptr<string> description{};
  shared_ptr<CopyDentryResponseBodySpaceHdIconVO> hdIconVO{};
  shared_ptr<CopyDentryResponseBodySpaceIconVO> iconVO{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<CopyDentryResponseBodySpaceOwner> owner{};
  shared_ptr<vector<CopyDentryResponseBodySpaceRecentList>> recentList{};
  shared_ptr<long> type{};
  shared_ptr<string> url{};
  shared_ptr<CopyDentryResponseBodySpaceVisitorInfo> visitorInfo{};

  CopyDentryResponseBodySpace() {}

  explicit CopyDentryResponseBodySpace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cover) {
      res["Cover"] = boost::any(*cover);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hdIconVO) {
      res["HdIconVO"] = hdIconVO ? boost::any(hdIconVO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (iconVO) {
      res["IconVO"] = iconVO ? boost::any(iconVO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = owner ? boost::any(owner->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recentList) {
      vector<boost::any> temp1;
      for(auto item1:*recentList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecentList"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (visitorInfo) {
      res["VisitorInfo"] = visitorInfo ? boost::any(visitorInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      cover = make_shared<string>(boost::any_cast<string>(m["Cover"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HdIconVO") != m.end() && !m["HdIconVO"].empty()) {
      if (typeid(map<string, boost::any>) == m["HdIconVO"].type()) {
        CopyDentryResponseBodySpaceHdIconVO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HdIconVO"]));
        hdIconVO = make_shared<CopyDentryResponseBodySpaceHdIconVO>(model1);
      }
    }
    if (m.find("IconVO") != m.end() && !m["IconVO"].empty()) {
      if (typeid(map<string, boost::any>) == m["IconVO"].type()) {
        CopyDentryResponseBodySpaceIconVO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IconVO"]));
        iconVO = make_shared<CopyDentryResponseBodySpaceIconVO>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      if (typeid(map<string, boost::any>) == m["Owner"].type()) {
        CopyDentryResponseBodySpaceOwner model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Owner"]));
        owner = make_shared<CopyDentryResponseBodySpaceOwner>(model1);
      }
    }
    if (m.find("RecentList") != m.end() && !m["RecentList"].empty()) {
      if (typeid(vector<boost::any>) == m["RecentList"].type()) {
        vector<CopyDentryResponseBodySpaceRecentList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecentList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CopyDentryResponseBodySpaceRecentList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recentList = make_shared<vector<CopyDentryResponseBodySpaceRecentList>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("VisitorInfo") != m.end() && !m["VisitorInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["VisitorInfo"].type()) {
        CopyDentryResponseBodySpaceVisitorInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VisitorInfo"]));
        visitorInfo = make_shared<CopyDentryResponseBodySpaceVisitorInfo>(model1);
      }
    }
  }


  virtual ~CopyDentryResponseBodySpace() = default;
};
class CopyDentryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> contentType{};
  shared_ptr<long> createdTime{};
  shared_ptr<map<string, boost::any>> creator{};
  shared_ptr<string> dentryId{};
  shared_ptr<string> dentryType{};
  shared_ptr<string> dentryUuid{};
  shared_ptr<string> docKey{};
  shared_ptr<string> extension{};
  shared_ptr<bool> hasChildren{};
  shared_ptr<CopyDentryResponseBodyLinkSourceInfo> linkSourceInfo{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<string> requestId{};
  shared_ptr<CopyDentryResponseBodySpace> space{};
  shared_ptr<string> spaceId{};
  shared_ptr<long> updatedTime{};
  shared_ptr<map<string, boost::any>> updater{};
  shared_ptr<string> url{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};
  shared_ptr<map<string, boost::any>> visitorInfo{};

  CopyDentryResponseBody() {}

  explicit CopyDentryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentType) {
      res["contentType"] = boost::any(*contentType);
    }
    if (createdTime) {
      res["createdTime"] = boost::any(*createdTime);
    }
    if (creator) {
      res["creator"] = boost::any(*creator);
    }
    if (dentryId) {
      res["dentryId"] = boost::any(*dentryId);
    }
    if (dentryType) {
      res["dentryType"] = boost::any(*dentryType);
    }
    if (dentryUuid) {
      res["dentryUuid"] = boost::any(*dentryUuid);
    }
    if (docKey) {
      res["docKey"] = boost::any(*docKey);
    }
    if (extension) {
      res["extension"] = boost::any(*extension);
    }
    if (hasChildren) {
      res["hasChildren"] = boost::any(*hasChildren);
    }
    if (linkSourceInfo) {
      res["linkSourceInfo"] = linkSourceInfo ? boost::any(linkSourceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (space) {
      res["space"] = space ? boost::any(space->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spaceId) {
      res["spaceId"] = boost::any(*spaceId);
    }
    if (updatedTime) {
      res["updatedTime"] = boost::any(*updatedTime);
    }
    if (updater) {
      res["updater"] = boost::any(*updater);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    if (visitorInfo) {
      res["visitorInfo"] = boost::any(*visitorInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("contentType") != m.end() && !m["contentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["contentType"]));
    }
    if (m.find("createdTime") != m.end() && !m["createdTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["createdTime"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["creator"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      creator = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("dentryId") != m.end() && !m["dentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["dentryId"]));
    }
    if (m.find("dentryType") != m.end() && !m["dentryType"].empty()) {
      dentryType = make_shared<string>(boost::any_cast<string>(m["dentryType"]));
    }
    if (m.find("dentryUuid") != m.end() && !m["dentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["dentryUuid"]));
    }
    if (m.find("docKey") != m.end() && !m["docKey"].empty()) {
      docKey = make_shared<string>(boost::any_cast<string>(m["docKey"]));
    }
    if (m.find("extension") != m.end() && !m["extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["extension"]));
    }
    if (m.find("hasChildren") != m.end() && !m["hasChildren"].empty()) {
      hasChildren = make_shared<bool>(boost::any_cast<bool>(m["hasChildren"]));
    }
    if (m.find("linkSourceInfo") != m.end() && !m["linkSourceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["linkSourceInfo"].type()) {
        CopyDentryResponseBodyLinkSourceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["linkSourceInfo"]));
        linkSourceInfo = make_shared<CopyDentryResponseBodyLinkSourceInfo>(model1);
      }
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("space") != m.end() && !m["space"].empty()) {
      if (typeid(map<string, boost::any>) == m["space"].type()) {
        CopyDentryResponseBodySpace model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["space"]));
        space = make_shared<CopyDentryResponseBodySpace>(model1);
      }
    }
    if (m.find("spaceId") != m.end() && !m["spaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["spaceId"]));
    }
    if (m.find("updatedTime") != m.end() && !m["updatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["updatedTime"]));
    }
    if (m.find("updater") != m.end() && !m["updater"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["updater"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      updater = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
    if (m.find("visitorInfo") != m.end() && !m["visitorInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["visitorInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      visitorInfo = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~CopyDentryResponseBody() = default;
};
class CopyDentryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CopyDentryResponseBody> body{};

  CopyDentryResponse() {}

  explicit CopyDentryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopyDentryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopyDentryResponseBody>(model1);
      }
    }
  }


  virtual ~CopyDentryResponse() = default;
};
class CreateDeliveryPlanHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> userToken{};

  CreateDeliveryPlanHeadersAccountContext() {}

  explicit CreateDeliveryPlanHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userToken) {
      res["userToken"] = boost::any(*userToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("userToken") != m.end() && !m["userToken"].empty()) {
      userToken = make_shared<string>(boost::any_cast<string>(m["userToken"]));
    }
  }


  virtual ~CreateDeliveryPlanHeadersAccountContext() = default;
};
class CreateDeliveryPlanHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateDeliveryPlanHeadersAccountContext> accountContext{};

  CreateDeliveryPlanHeaders() {}

  explicit CreateDeliveryPlanHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateDeliveryPlanHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateDeliveryPlanHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateDeliveryPlanHeaders() = default;
};
class CreateDeliveryPlanShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateDeliveryPlanShrinkHeaders() {}

  explicit CreateDeliveryPlanShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateDeliveryPlanShrinkHeaders() = default;
};
class CreateDeliveryPlanRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateDeliveryPlanRequestTenantContext() {}

  explicit CreateDeliveryPlanRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateDeliveryPlanRequestTenantContext() = default;
};
class CreateDeliveryPlanRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<long> endTime{};
  shared_ptr<string> resId{};
  shared_ptr<long> startTime{};
  shared_ptr<CreateDeliveryPlanRequestTenantContext> tenantContext{};
  shared_ptr<vector<string>> userIdList{};

  CreateDeliveryPlanRequest() {}

  explicit CreateDeliveryPlanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (resId) {
      res["ResId"] = boost::any(*resId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userIdList) {
      res["UserIdList"] = boost::any(*userIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ResId") != m.end() && !m["ResId"].empty()) {
      resId = make_shared<string>(boost::any_cast<string>(m["ResId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateDeliveryPlanRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateDeliveryPlanRequestTenantContext>(model1);
      }
    }
    if (m.find("UserIdList") != m.end() && !m["UserIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateDeliveryPlanRequest() = default;
};
class CreateDeliveryPlanShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> contentShrink{};
  shared_ptr<long> endTime{};
  shared_ptr<string> resId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> userIdListShrink{};

  CreateDeliveryPlanShrinkRequest() {}

  explicit CreateDeliveryPlanShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentShrink) {
      res["Content"] = boost::any(*contentShrink);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (resId) {
      res["ResId"] = boost::any(*resId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (userIdListShrink) {
      res["UserIdList"] = boost::any(*userIdListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      contentShrink = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ResId") != m.end() && !m["ResId"].empty()) {
      resId = make_shared<string>(boost::any_cast<string>(m["ResId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("UserIdList") != m.end() && !m["UserIdList"].empty()) {
      userIdListShrink = make_shared<string>(boost::any_cast<string>(m["UserIdList"]));
    }
  }


  virtual ~CreateDeliveryPlanShrinkRequest() = default;
};
class CreateDeliveryPlanResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<boost::any>> arguments{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  CreateDeliveryPlanResponseBody() {}

  explicit CreateDeliveryPlanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arguments) {
      res["arguments"] = boost::any(*arguments);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arguments") != m.end() && !m["arguments"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["arguments"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["arguments"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      arguments = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~CreateDeliveryPlanResponseBody() = default;
};
class CreateDeliveryPlanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDeliveryPlanResponseBody> body{};

  CreateDeliveryPlanResponse() {}

  explicit CreateDeliveryPlanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDeliveryPlanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDeliveryPlanResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDeliveryPlanResponse() = default;
};
class CreateDingtalkPersonalTodoTaskHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateDingtalkPersonalTodoTaskHeadersAccountContext() {}

  explicit CreateDingtalkPersonalTodoTaskHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateDingtalkPersonalTodoTaskHeadersAccountContext() = default;
};
class CreateDingtalkPersonalTodoTaskHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateDingtalkPersonalTodoTaskHeadersAccountContext> accountContext{};

  CreateDingtalkPersonalTodoTaskHeaders() {}

  explicit CreateDingtalkPersonalTodoTaskHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateDingtalkPersonalTodoTaskHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateDingtalkPersonalTodoTaskHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateDingtalkPersonalTodoTaskHeaders() = default;
};
class CreateDingtalkPersonalTodoTaskShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateDingtalkPersonalTodoTaskShrinkHeaders() {}

  explicit CreateDingtalkPersonalTodoTaskShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateDingtalkPersonalTodoTaskShrinkHeaders() = default;
};
class CreateDingtalkPersonalTodoTaskRequestNotifyConfigs : public Darabonba::Model {
public:
  shared_ptr<string> dingNotify{};

  CreateDingtalkPersonalTodoTaskRequestNotifyConfigs() {}

  explicit CreateDingtalkPersonalTodoTaskRequestNotifyConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dingNotify) {
      res["DingNotify"] = boost::any(*dingNotify);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DingNotify") != m.end() && !m["DingNotify"].empty()) {
      dingNotify = make_shared<string>(boost::any_cast<string>(m["DingNotify"]));
    }
  }


  virtual ~CreateDingtalkPersonalTodoTaskRequestNotifyConfigs() = default;
};
class CreateDingtalkPersonalTodoTaskRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateDingtalkPersonalTodoTaskRequestTenantContext() {}

  explicit CreateDingtalkPersonalTodoTaskRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateDingtalkPersonalTodoTaskRequestTenantContext() = default;
};
class CreateDingtalkPersonalTodoTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> dueTime{};
  shared_ptr<vector<string>> executorIds{};
  shared_ptr<CreateDingtalkPersonalTodoTaskRequestNotifyConfigs> notifyConfigs{};
  shared_ptr<vector<string>> participantIds{};
  shared_ptr<string> subject{};
  shared_ptr<CreateDingtalkPersonalTodoTaskRequestTenantContext> tenantContext{};
  shared_ptr<string> userToken{};

  CreateDingtalkPersonalTodoTaskRequest() {}

  explicit CreateDingtalkPersonalTodoTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dueTime) {
      res["DueTime"] = boost::any(*dueTime);
    }
    if (executorIds) {
      res["ExecutorIds"] = boost::any(*executorIds);
    }
    if (notifyConfigs) {
      res["NotifyConfigs"] = notifyConfigs ? boost::any(notifyConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (participantIds) {
      res["ParticipantIds"] = boost::any(*participantIds);
    }
    if (subject) {
      res["Subject"] = boost::any(*subject);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userToken) {
      res["UserToken"] = boost::any(*userToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DueTime") != m.end() && !m["DueTime"].empty()) {
      dueTime = make_shared<long>(boost::any_cast<long>(m["DueTime"]));
    }
    if (m.find("ExecutorIds") != m.end() && !m["ExecutorIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExecutorIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExecutorIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      executorIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NotifyConfigs") != m.end() && !m["NotifyConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfigs"].type()) {
        CreateDingtalkPersonalTodoTaskRequestNotifyConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfigs"]));
        notifyConfigs = make_shared<CreateDingtalkPersonalTodoTaskRequestNotifyConfigs>(model1);
      }
    }
    if (m.find("ParticipantIds") != m.end() && !m["ParticipantIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ParticipantIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ParticipantIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      participantIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Subject") != m.end() && !m["Subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["Subject"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateDingtalkPersonalTodoTaskRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateDingtalkPersonalTodoTaskRequestTenantContext>(model1);
      }
    }
    if (m.find("UserToken") != m.end() && !m["UserToken"].empty()) {
      userToken = make_shared<string>(boost::any_cast<string>(m["UserToken"]));
    }
  }


  virtual ~CreateDingtalkPersonalTodoTaskRequest() = default;
};
class CreateDingtalkPersonalTodoTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> dueTime{};
  shared_ptr<string> executorIdsShrink{};
  shared_ptr<string> notifyConfigsShrink{};
  shared_ptr<string> participantIdsShrink{};
  shared_ptr<string> subject{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> userToken{};

  CreateDingtalkPersonalTodoTaskShrinkRequest() {}

  explicit CreateDingtalkPersonalTodoTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dueTime) {
      res["DueTime"] = boost::any(*dueTime);
    }
    if (executorIdsShrink) {
      res["ExecutorIds"] = boost::any(*executorIdsShrink);
    }
    if (notifyConfigsShrink) {
      res["NotifyConfigs"] = boost::any(*notifyConfigsShrink);
    }
    if (participantIdsShrink) {
      res["ParticipantIds"] = boost::any(*participantIdsShrink);
    }
    if (subject) {
      res["Subject"] = boost::any(*subject);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (userToken) {
      res["UserToken"] = boost::any(*userToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DueTime") != m.end() && !m["DueTime"].empty()) {
      dueTime = make_shared<long>(boost::any_cast<long>(m["DueTime"]));
    }
    if (m.find("ExecutorIds") != m.end() && !m["ExecutorIds"].empty()) {
      executorIdsShrink = make_shared<string>(boost::any_cast<string>(m["ExecutorIds"]));
    }
    if (m.find("NotifyConfigs") != m.end() && !m["NotifyConfigs"].empty()) {
      notifyConfigsShrink = make_shared<string>(boost::any_cast<string>(m["NotifyConfigs"]));
    }
    if (m.find("ParticipantIds") != m.end() && !m["ParticipantIds"].empty()) {
      participantIdsShrink = make_shared<string>(boost::any_cast<string>(m["ParticipantIds"]));
    }
    if (m.find("Subject") != m.end() && !m["Subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["Subject"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("UserToken") != m.end() && !m["UserToken"].empty()) {
      userToken = make_shared<string>(boost::any_cast<string>(m["UserToken"]));
    }
  }


  virtual ~CreateDingtalkPersonalTodoTaskShrinkRequest() = default;
};
class CreateDingtalkPersonalTodoTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> createdTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  CreateDingtalkPersonalTodoTaskResponseBody() {}

  explicit CreateDingtalkPersonalTodoTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["createdTime"] = boost::any(*createdTime);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createdTime") != m.end() && !m["createdTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["createdTime"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~CreateDingtalkPersonalTodoTaskResponseBody() = default;
};
class CreateDingtalkPersonalTodoTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDingtalkPersonalTodoTaskResponseBody> body{};

  CreateDingtalkPersonalTodoTaskResponse() {}

  explicit CreateDingtalkPersonalTodoTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDingtalkPersonalTodoTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDingtalkPersonalTodoTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDingtalkPersonalTodoTaskResponse() = default;
};
class CreateEventHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateEventHeadersAccountContext() {}

  explicit CreateEventHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateEventHeadersAccountContext() = default;
};
class CreateEventHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateEventHeadersAccountContext> accountContext{};

  CreateEventHeaders() {}

  explicit CreateEventHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateEventHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateEventHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateEventHeaders() = default;
};
class CreateEventShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateEventShrinkHeaders() {}

  explicit CreateEventShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateEventShrinkHeaders() = default;
};
class CreateEventRequestAttendees : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<bool> isOptional{};

  CreateEventRequestAttendees() {}

  explicit CreateEventRequestAttendees(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isOptional) {
      res["isOptional"] = boost::any(*isOptional);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("isOptional") != m.end() && !m["isOptional"].empty()) {
      isOptional = make_shared<bool>(boost::any_cast<bool>(m["isOptional"]));
    }
  }


  virtual ~CreateEventRequestAttendees() = default;
};
class CreateEventRequestCardInstances : public Darabonba::Model {
public:
  shared_ptr<string> outTrackId{};
  shared_ptr<string> scenario{};

  CreateEventRequestCardInstances() {}

  explicit CreateEventRequestCardInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outTrackId) {
      res["OutTrackId"] = boost::any(*outTrackId);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutTrackId") != m.end() && !m["OutTrackId"].empty()) {
      outTrackId = make_shared<string>(boost::any_cast<string>(m["OutTrackId"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
  }


  virtual ~CreateEventRequestCardInstances() = default;
};
class CreateEventRequestEnd : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  CreateEventRequestEnd() {}

  explicit CreateEventRequestEnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["date"] = boost::any(*date);
    }
    if (dateTime) {
      res["dateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["timeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("date") != m.end() && !m["date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["date"]));
    }
    if (m.find("dateTime") != m.end() && !m["dateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["dateTime"]));
    }
    if (m.find("timeZone") != m.end() && !m["timeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["timeZone"]));
    }
  }


  virtual ~CreateEventRequestEnd() = default;
};
class CreateEventRequestLocation : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};

  CreateEventRequestLocation() {}

  explicit CreateEventRequestLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["displayName"] = boost::any(*displayName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("displayName") != m.end() && !m["displayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["displayName"]));
    }
  }


  virtual ~CreateEventRequestLocation() = default;
};
class CreateEventRequestOnlineMeetingInfo : public Darabonba::Model {
public:
  shared_ptr<string> type{};

  CreateEventRequestOnlineMeetingInfo() {}

  explicit CreateEventRequestOnlineMeetingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateEventRequestOnlineMeetingInfo() = default;
};
class CreateEventRequestRecurrencePattern : public Darabonba::Model {
public:
  shared_ptr<long> dayOfMonth{};
  shared_ptr<string> daysOfWeek{};
  shared_ptr<string> index{};
  shared_ptr<long> interval{};
  shared_ptr<string> type{};

  CreateEventRequestRecurrencePattern() {}

  explicit CreateEventRequestRecurrencePattern(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dayOfMonth) {
      res["dayOfMonth"] = boost::any(*dayOfMonth);
    }
    if (daysOfWeek) {
      res["daysOfWeek"] = boost::any(*daysOfWeek);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (interval) {
      res["interval"] = boost::any(*interval);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dayOfMonth") != m.end() && !m["dayOfMonth"].empty()) {
      dayOfMonth = make_shared<long>(boost::any_cast<long>(m["dayOfMonth"]));
    }
    if (m.find("daysOfWeek") != m.end() && !m["daysOfWeek"].empty()) {
      daysOfWeek = make_shared<string>(boost::any_cast<string>(m["daysOfWeek"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("interval") != m.end() && !m["interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["interval"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateEventRequestRecurrencePattern() = default;
};
class CreateEventRequestRecurrenceRange : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<long> numberOfOccurrences{};
  shared_ptr<string> type{};

  CreateEventRequestRecurrenceRange() {}

  explicit CreateEventRequestRecurrenceRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["endDate"] = boost::any(*endDate);
    }
    if (numberOfOccurrences) {
      res["numberOfOccurrences"] = boost::any(*numberOfOccurrences);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endDate") != m.end() && !m["endDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["endDate"]));
    }
    if (m.find("numberOfOccurrences") != m.end() && !m["numberOfOccurrences"].empty()) {
      numberOfOccurrences = make_shared<long>(boost::any_cast<long>(m["numberOfOccurrences"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateEventRequestRecurrenceRange() = default;
};
class CreateEventRequestRecurrence : public Darabonba::Model {
public:
  shared_ptr<CreateEventRequestRecurrencePattern> pattern{};
  shared_ptr<CreateEventRequestRecurrenceRange> range{};

  CreateEventRequestRecurrence() {}

  explicit CreateEventRequestRecurrence(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pattern) {
      res["pattern"] = pattern ? boost::any(pattern->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (range) {
      res["range"] = range ? boost::any(range->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("pattern") != m.end() && !m["pattern"].empty()) {
      if (typeid(map<string, boost::any>) == m["pattern"].type()) {
        CreateEventRequestRecurrencePattern model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["pattern"]));
        pattern = make_shared<CreateEventRequestRecurrencePattern>(model1);
      }
    }
    if (m.find("range") != m.end() && !m["range"].empty()) {
      if (typeid(map<string, boost::any>) == m["range"].type()) {
        CreateEventRequestRecurrenceRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["range"]));
        range = make_shared<CreateEventRequestRecurrenceRange>(model1);
      }
    }
  }


  virtual ~CreateEventRequestRecurrence() = default;
};
class CreateEventRequestReminders : public Darabonba::Model {
public:
  shared_ptr<string> method{};
  shared_ptr<long> minutes{};

  CreateEventRequestReminders() {}

  explicit CreateEventRequestReminders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["method"] = boost::any(*method);
    }
    if (minutes) {
      res["minutes"] = boost::any(*minutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("method") != m.end() && !m["method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["method"]));
    }
    if (m.find("minutes") != m.end() && !m["minutes"].empty()) {
      minutes = make_shared<long>(boost::any_cast<long>(m["minutes"]));
    }
  }


  virtual ~CreateEventRequestReminders() = default;
};
class CreateEventRequestRichTextDescription : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  CreateEventRequestRichTextDescription() {}

  explicit CreateEventRequestRichTextDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
  }


  virtual ~CreateEventRequestRichTextDescription() = default;
};
class CreateEventRequestUiConfigs : public Darabonba::Model {
public:
  shared_ptr<string> uiName{};
  shared_ptr<string> uiStatus{};

  CreateEventRequestUiConfigs() {}

  explicit CreateEventRequestUiConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uiName) {
      res["uiName"] = boost::any(*uiName);
    }
    if (uiStatus) {
      res["uiStatus"] = boost::any(*uiStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("uiName") != m.end() && !m["uiName"].empty()) {
      uiName = make_shared<string>(boost::any_cast<string>(m["uiName"]));
    }
    if (m.find("uiStatus") != m.end() && !m["uiStatus"].empty()) {
      uiStatus = make_shared<string>(boost::any_cast<string>(m["uiStatus"]));
    }
  }


  virtual ~CreateEventRequestUiConfigs() = default;
};
class CreateEventRequestStart : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  CreateEventRequestStart() {}

  explicit CreateEventRequestStart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["date"] = boost::any(*date);
    }
    if (dateTime) {
      res["dateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["timeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("date") != m.end() && !m["date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["date"]));
    }
    if (m.find("dateTime") != m.end() && !m["dateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["dateTime"]));
    }
    if (m.find("timeZone") != m.end() && !m["timeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["timeZone"]));
    }
  }


  virtual ~CreateEventRequestStart() = default;
};
class CreateEventRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateEventRequestAttendees>> attendees{};
  shared_ptr<vector<CreateEventRequestCardInstances>> cardInstances{};
  shared_ptr<string> description{};
  shared_ptr<CreateEventRequestEnd> end{};
  shared_ptr<map<string, string>> extra{};
  shared_ptr<bool> isAllDay{};
  shared_ptr<CreateEventRequestLocation> location{};
  shared_ptr<CreateEventRequestOnlineMeetingInfo> onlineMeetingInfo{};
  shared_ptr<CreateEventRequestRecurrence> recurrence{};
  shared_ptr<vector<CreateEventRequestReminders>> reminders{};
  shared_ptr<CreateEventRequestRichTextDescription> richTextDescription{};
  shared_ptr<string> summary{};
  shared_ptr<vector<CreateEventRequestUiConfigs>> uiConfigs{};
  shared_ptr<string> calendarId{};
  shared_ptr<CreateEventRequestStart> start{};

  CreateEventRequest() {}

  explicit CreateEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendees) {
      vector<boost::any> temp1;
      for(auto item1:*attendees){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attendees"] = boost::any(temp1);
    }
    if (cardInstances) {
      vector<boost::any> temp1;
      for(auto item1:*cardInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CardInstances"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (end) {
      res["End"] = end ? boost::any(end->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (isAllDay) {
      res["IsAllDay"] = boost::any(*isAllDay);
    }
    if (location) {
      res["Location"] = location ? boost::any(location->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (onlineMeetingInfo) {
      res["OnlineMeetingInfo"] = onlineMeetingInfo ? boost::any(onlineMeetingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recurrence) {
      res["Recurrence"] = recurrence ? boost::any(recurrence->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reminders) {
      vector<boost::any> temp1;
      for(auto item1:*reminders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Reminders"] = boost::any(temp1);
    }
    if (richTextDescription) {
      res["RichTextDescription"] = richTextDescription ? boost::any(richTextDescription->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (uiConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*uiConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UiConfigs"] = boost::any(temp1);
    }
    if (calendarId) {
      res["calendarId"] = boost::any(*calendarId);
    }
    if (start) {
      res["start"] = start ? boost::any(start->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attendees") != m.end() && !m["Attendees"].empty()) {
      if (typeid(vector<boost::any>) == m["Attendees"].type()) {
        vector<CreateEventRequestAttendees> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attendees"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEventRequestAttendees model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attendees = make_shared<vector<CreateEventRequestAttendees>>(expect1);
      }
    }
    if (m.find("CardInstances") != m.end() && !m["CardInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["CardInstances"].type()) {
        vector<CreateEventRequestCardInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CardInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEventRequestCardInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cardInstances = make_shared<vector<CreateEventRequestCardInstances>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      if (typeid(map<string, boost::any>) == m["End"].type()) {
        CreateEventRequestEnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["End"]));
        end = make_shared<CreateEventRequestEnd>(model1);
      }
    }
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Extra"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extra = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("IsAllDay") != m.end() && !m["IsAllDay"].empty()) {
      isAllDay = make_shared<bool>(boost::any_cast<bool>(m["IsAllDay"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      if (typeid(map<string, boost::any>) == m["Location"].type()) {
        CreateEventRequestLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Location"]));
        location = make_shared<CreateEventRequestLocation>(model1);
      }
    }
    if (m.find("OnlineMeetingInfo") != m.end() && !m["OnlineMeetingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["OnlineMeetingInfo"].type()) {
        CreateEventRequestOnlineMeetingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OnlineMeetingInfo"]));
        onlineMeetingInfo = make_shared<CreateEventRequestOnlineMeetingInfo>(model1);
      }
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      if (typeid(map<string, boost::any>) == m["Recurrence"].type()) {
        CreateEventRequestRecurrence model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Recurrence"]));
        recurrence = make_shared<CreateEventRequestRecurrence>(model1);
      }
    }
    if (m.find("Reminders") != m.end() && !m["Reminders"].empty()) {
      if (typeid(vector<boost::any>) == m["Reminders"].type()) {
        vector<CreateEventRequestReminders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Reminders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEventRequestReminders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reminders = make_shared<vector<CreateEventRequestReminders>>(expect1);
      }
    }
    if (m.find("RichTextDescription") != m.end() && !m["RichTextDescription"].empty()) {
      if (typeid(map<string, boost::any>) == m["RichTextDescription"].type()) {
        CreateEventRequestRichTextDescription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RichTextDescription"]));
        richTextDescription = make_shared<CreateEventRequestRichTextDescription>(model1);
      }
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("UiConfigs") != m.end() && !m["UiConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["UiConfigs"].type()) {
        vector<CreateEventRequestUiConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UiConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEventRequestUiConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        uiConfigs = make_shared<vector<CreateEventRequestUiConfigs>>(expect1);
      }
    }
    if (m.find("calendarId") != m.end() && !m["calendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["calendarId"]));
    }
    if (m.find("start") != m.end() && !m["start"].empty()) {
      if (typeid(map<string, boost::any>) == m["start"].type()) {
        CreateEventRequestStart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["start"]));
        start = make_shared<CreateEventRequestStart>(model1);
      }
    }
  }


  virtual ~CreateEventRequest() = default;
};
class CreateEventShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> attendeesShrink{};
  shared_ptr<string> cardInstancesShrink{};
  shared_ptr<string> description{};
  shared_ptr<string> endShrink{};
  shared_ptr<string> extraShrink{};
  shared_ptr<bool> isAllDay{};
  shared_ptr<string> locationShrink{};
  shared_ptr<string> onlineMeetingInfoShrink{};
  shared_ptr<string> recurrenceShrink{};
  shared_ptr<string> remindersShrink{};
  shared_ptr<string> richTextDescriptionShrink{};
  shared_ptr<string> summary{};
  shared_ptr<string> uiConfigsShrink{};
  shared_ptr<string> calendarId{};
  shared_ptr<string> startShrink{};

  CreateEventShrinkRequest() {}

  explicit CreateEventShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendeesShrink) {
      res["Attendees"] = boost::any(*attendeesShrink);
    }
    if (cardInstancesShrink) {
      res["CardInstances"] = boost::any(*cardInstancesShrink);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endShrink) {
      res["End"] = boost::any(*endShrink);
    }
    if (extraShrink) {
      res["Extra"] = boost::any(*extraShrink);
    }
    if (isAllDay) {
      res["IsAllDay"] = boost::any(*isAllDay);
    }
    if (locationShrink) {
      res["Location"] = boost::any(*locationShrink);
    }
    if (onlineMeetingInfoShrink) {
      res["OnlineMeetingInfo"] = boost::any(*onlineMeetingInfoShrink);
    }
    if (recurrenceShrink) {
      res["Recurrence"] = boost::any(*recurrenceShrink);
    }
    if (remindersShrink) {
      res["Reminders"] = boost::any(*remindersShrink);
    }
    if (richTextDescriptionShrink) {
      res["RichTextDescription"] = boost::any(*richTextDescriptionShrink);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (uiConfigsShrink) {
      res["UiConfigs"] = boost::any(*uiConfigsShrink);
    }
    if (calendarId) {
      res["calendarId"] = boost::any(*calendarId);
    }
    if (startShrink) {
      res["start"] = boost::any(*startShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attendees") != m.end() && !m["Attendees"].empty()) {
      attendeesShrink = make_shared<string>(boost::any_cast<string>(m["Attendees"]));
    }
    if (m.find("CardInstances") != m.end() && !m["CardInstances"].empty()) {
      cardInstancesShrink = make_shared<string>(boost::any_cast<string>(m["CardInstances"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      endShrink = make_shared<string>(boost::any_cast<string>(m["End"]));
    }
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extraShrink = make_shared<string>(boost::any_cast<string>(m["Extra"]));
    }
    if (m.find("IsAllDay") != m.end() && !m["IsAllDay"].empty()) {
      isAllDay = make_shared<bool>(boost::any_cast<bool>(m["IsAllDay"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      locationShrink = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OnlineMeetingInfo") != m.end() && !m["OnlineMeetingInfo"].empty()) {
      onlineMeetingInfoShrink = make_shared<string>(boost::any_cast<string>(m["OnlineMeetingInfo"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrenceShrink = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("Reminders") != m.end() && !m["Reminders"].empty()) {
      remindersShrink = make_shared<string>(boost::any_cast<string>(m["Reminders"]));
    }
    if (m.find("RichTextDescription") != m.end() && !m["RichTextDescription"].empty()) {
      richTextDescriptionShrink = make_shared<string>(boost::any_cast<string>(m["RichTextDescription"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("UiConfigs") != m.end() && !m["UiConfigs"].empty()) {
      uiConfigsShrink = make_shared<string>(boost::any_cast<string>(m["UiConfigs"]));
    }
    if (m.find("calendarId") != m.end() && !m["calendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["calendarId"]));
    }
    if (m.find("start") != m.end() && !m["start"].empty()) {
      startShrink = make_shared<string>(boost::any_cast<string>(m["start"]));
    }
  }


  virtual ~CreateEventShrinkRequest() = default;
};
class CreateEventResponseBodyAttendees : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<bool> isOptional{};
  shared_ptr<string> responseStatus{};
  shared_ptr<bool> self{};

  CreateEventResponseBodyAttendees() {}

  explicit CreateEventResponseBodyAttendees(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (isOptional) {
      res["IsOptional"] = boost::any(*isOptional);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (self) {
      res["Self"] = boost::any(*self);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("IsOptional") != m.end() && !m["IsOptional"].empty()) {
      isOptional = make_shared<bool>(boost::any_cast<bool>(m["IsOptional"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("Self") != m.end() && !m["Self"].empty()) {
      self = make_shared<bool>(boost::any_cast<bool>(m["Self"]));
    }
  }


  virtual ~CreateEventResponseBodyAttendees() = default;
};
class CreateEventResponseBodyEnd : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  CreateEventResponseBodyEnd() {}

  explicit CreateEventResponseBodyEnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~CreateEventResponseBodyEnd() = default;
};
class CreateEventResponseBodyLocation : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};

  CreateEventResponseBodyLocation() {}

  explicit CreateEventResponseBodyLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
  }


  virtual ~CreateEventResponseBodyLocation() = default;
};
class CreateEventResponseBodyOnlineMeetingInfo : public Darabonba::Model {
public:
  shared_ptr<string> conferenceId{};
  shared_ptr<map<string, boost::any>> extraInfo{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  CreateEventResponseBodyOnlineMeetingInfo() {}

  explicit CreateEventResponseBodyOnlineMeetingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conferenceId) {
      res["ConferenceId"] = boost::any(*conferenceId);
    }
    if (extraInfo) {
      res["ExtraInfo"] = boost::any(*extraInfo);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConferenceId") != m.end() && !m["ConferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["ConferenceId"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~CreateEventResponseBodyOnlineMeetingInfo() = default;
};
class CreateEventResponseBodyOrganizer : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> id{};
  shared_ptr<string> responseStatus{};
  shared_ptr<bool> self{};

  CreateEventResponseBodyOrganizer() {}

  explicit CreateEventResponseBodyOrganizer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (self) {
      res["Self"] = boost::any(*self);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("Self") != m.end() && !m["Self"].empty()) {
      self = make_shared<bool>(boost::any_cast<bool>(m["Self"]));
    }
  }


  virtual ~CreateEventResponseBodyOrganizer() = default;
};
class CreateEventResponseBodyRecurrencePattern : public Darabonba::Model {
public:
  shared_ptr<long> dayOfMonth{};
  shared_ptr<string> daysOfWeek{};
  shared_ptr<string> index{};
  shared_ptr<long> interval{};
  shared_ptr<string> type{};

  CreateEventResponseBodyRecurrencePattern() {}

  explicit CreateEventResponseBodyRecurrencePattern(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dayOfMonth) {
      res["DayOfMonth"] = boost::any(*dayOfMonth);
    }
    if (daysOfWeek) {
      res["DaysOfWeek"] = boost::any(*daysOfWeek);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DayOfMonth") != m.end() && !m["DayOfMonth"].empty()) {
      dayOfMonth = make_shared<long>(boost::any_cast<long>(m["DayOfMonth"]));
    }
    if (m.find("DaysOfWeek") != m.end() && !m["DaysOfWeek"].empty()) {
      daysOfWeek = make_shared<string>(boost::any_cast<string>(m["DaysOfWeek"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateEventResponseBodyRecurrencePattern() = default;
};
class CreateEventResponseBodyRecurrenceRange : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<long> numberOfOccurrences{};
  shared_ptr<string> type{};

  CreateEventResponseBodyRecurrenceRange() {}

  explicit CreateEventResponseBodyRecurrenceRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (numberOfOccurrences) {
      res["NumberOfOccurrences"] = boost::any(*numberOfOccurrences);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("NumberOfOccurrences") != m.end() && !m["NumberOfOccurrences"].empty()) {
      numberOfOccurrences = make_shared<long>(boost::any_cast<long>(m["NumberOfOccurrences"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateEventResponseBodyRecurrenceRange() = default;
};
class CreateEventResponseBodyRecurrence : public Darabonba::Model {
public:
  shared_ptr<CreateEventResponseBodyRecurrencePattern> pattern{};
  shared_ptr<CreateEventResponseBodyRecurrenceRange> range{};

  CreateEventResponseBodyRecurrence() {}

  explicit CreateEventResponseBodyRecurrence(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pattern) {
      res["Pattern"] = pattern ? boost::any(pattern->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (range) {
      res["Range"] = range ? boost::any(range->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pattern"].type()) {
        CreateEventResponseBodyRecurrencePattern model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pattern"]));
        pattern = make_shared<CreateEventResponseBodyRecurrencePattern>(model1);
      }
    }
    if (m.find("Range") != m.end() && !m["Range"].empty()) {
      if (typeid(map<string, boost::any>) == m["Range"].type()) {
        CreateEventResponseBodyRecurrenceRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Range"]));
        range = make_shared<CreateEventResponseBodyRecurrenceRange>(model1);
      }
    }
  }


  virtual ~CreateEventResponseBodyRecurrence() = default;
};
class CreateEventResponseBodyReminders : public Darabonba::Model {
public:
  shared_ptr<string> method{};
  shared_ptr<string> minutes{};

  CreateEventResponseBodyReminders() {}

  explicit CreateEventResponseBodyReminders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (minutes) {
      res["Minutes"] = boost::any(*minutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Minutes") != m.end() && !m["Minutes"].empty()) {
      minutes = make_shared<string>(boost::any_cast<string>(m["Minutes"]));
    }
  }


  virtual ~CreateEventResponseBodyReminders() = default;
};
class CreateEventResponseBodyRichTextDescription : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  CreateEventResponseBodyRichTextDescription() {}

  explicit CreateEventResponseBodyRichTextDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
  }


  virtual ~CreateEventResponseBodyRichTextDescription() = default;
};
class CreateEventResponseBodyStart : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  CreateEventResponseBodyStart() {}

  explicit CreateEventResponseBodyStart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~CreateEventResponseBodyStart() = default;
};
class CreateEventResponseBodyUiConfigs : public Darabonba::Model {
public:
  shared_ptr<string> uiName{};
  shared_ptr<string> uiStatus{};

  CreateEventResponseBodyUiConfigs() {}

  explicit CreateEventResponseBodyUiConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uiName) {
      res["UiName"] = boost::any(*uiName);
    }
    if (uiStatus) {
      res["UiStatus"] = boost::any(*uiStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UiName") != m.end() && !m["UiName"].empty()) {
      uiName = make_shared<string>(boost::any_cast<string>(m["UiName"]));
    }
    if (m.find("UiStatus") != m.end() && !m["UiStatus"].empty()) {
      uiStatus = make_shared<string>(boost::any_cast<string>(m["UiStatus"]));
    }
  }


  virtual ~CreateEventResponseBodyUiConfigs() = default;
};
class CreateEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<CreateEventResponseBodyAttendees>> attendees{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<CreateEventResponseBodyEnd> end{};
  shared_ptr<string> id{};
  shared_ptr<bool> isAllDay{};
  shared_ptr<CreateEventResponseBodyLocation> location{};
  shared_ptr<CreateEventResponseBodyOnlineMeetingInfo> onlineMeetingInfo{};
  shared_ptr<CreateEventResponseBodyOrganizer> organizer{};
  shared_ptr<CreateEventResponseBodyRecurrence> recurrence{};
  shared_ptr<vector<CreateEventResponseBodyReminders>> reminders{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateEventResponseBodyRichTextDescription> richTextDescription{};
  shared_ptr<CreateEventResponseBodyStart> start{};
  shared_ptr<string> summary{};
  shared_ptr<vector<CreateEventResponseBodyUiConfigs>> uiConfigs{};
  shared_ptr<string> updateTime{};

  CreateEventResponseBody() {}

  explicit CreateEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendees) {
      vector<boost::any> temp1;
      for(auto item1:*attendees){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["attendees"] = boost::any(temp1);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (end) {
      res["end"] = end ? boost::any(end->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isAllDay) {
      res["isAllDay"] = boost::any(*isAllDay);
    }
    if (location) {
      res["location"] = location ? boost::any(location->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (onlineMeetingInfo) {
      res["onlineMeetingInfo"] = onlineMeetingInfo ? boost::any(onlineMeetingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (organizer) {
      res["organizer"] = organizer ? boost::any(organizer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recurrence) {
      res["recurrence"] = recurrence ? boost::any(recurrence->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reminders) {
      vector<boost::any> temp1;
      for(auto item1:*reminders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["reminders"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (richTextDescription) {
      res["richTextDescription"] = richTextDescription ? boost::any(richTextDescription->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (start) {
      res["start"] = start ? boost::any(start->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (summary) {
      res["summary"] = boost::any(*summary);
    }
    if (uiConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*uiConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["uiConfigs"] = boost::any(temp1);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("attendees") != m.end() && !m["attendees"].empty()) {
      if (typeid(vector<boost::any>) == m["attendees"].type()) {
        vector<CreateEventResponseBodyAttendees> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["attendees"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEventResponseBodyAttendees model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attendees = make_shared<vector<CreateEventResponseBodyAttendees>>(expect1);
      }
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("end") != m.end() && !m["end"].empty()) {
      if (typeid(map<string, boost::any>) == m["end"].type()) {
        CreateEventResponseBodyEnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["end"]));
        end = make_shared<CreateEventResponseBodyEnd>(model1);
      }
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("isAllDay") != m.end() && !m["isAllDay"].empty()) {
      isAllDay = make_shared<bool>(boost::any_cast<bool>(m["isAllDay"]));
    }
    if (m.find("location") != m.end() && !m["location"].empty()) {
      if (typeid(map<string, boost::any>) == m["location"].type()) {
        CreateEventResponseBodyLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["location"]));
        location = make_shared<CreateEventResponseBodyLocation>(model1);
      }
    }
    if (m.find("onlineMeetingInfo") != m.end() && !m["onlineMeetingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["onlineMeetingInfo"].type()) {
        CreateEventResponseBodyOnlineMeetingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["onlineMeetingInfo"]));
        onlineMeetingInfo = make_shared<CreateEventResponseBodyOnlineMeetingInfo>(model1);
      }
    }
    if (m.find("organizer") != m.end() && !m["organizer"].empty()) {
      if (typeid(map<string, boost::any>) == m["organizer"].type()) {
        CreateEventResponseBodyOrganizer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["organizer"]));
        organizer = make_shared<CreateEventResponseBodyOrganizer>(model1);
      }
    }
    if (m.find("recurrence") != m.end() && !m["recurrence"].empty()) {
      if (typeid(map<string, boost::any>) == m["recurrence"].type()) {
        CreateEventResponseBodyRecurrence model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["recurrence"]));
        recurrence = make_shared<CreateEventResponseBodyRecurrence>(model1);
      }
    }
    if (m.find("reminders") != m.end() && !m["reminders"].empty()) {
      if (typeid(vector<boost::any>) == m["reminders"].type()) {
        vector<CreateEventResponseBodyReminders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["reminders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEventResponseBodyReminders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reminders = make_shared<vector<CreateEventResponseBodyReminders>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("richTextDescription") != m.end() && !m["richTextDescription"].empty()) {
      if (typeid(map<string, boost::any>) == m["richTextDescription"].type()) {
        CreateEventResponseBodyRichTextDescription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["richTextDescription"]));
        richTextDescription = make_shared<CreateEventResponseBodyRichTextDescription>(model1);
      }
    }
    if (m.find("start") != m.end() && !m["start"].empty()) {
      if (typeid(map<string, boost::any>) == m["start"].type()) {
        CreateEventResponseBodyStart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["start"]));
        start = make_shared<CreateEventResponseBodyStart>(model1);
      }
    }
    if (m.find("summary") != m.end() && !m["summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["summary"]));
    }
    if (m.find("uiConfigs") != m.end() && !m["uiConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["uiConfigs"].type()) {
        vector<CreateEventResponseBodyUiConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["uiConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEventResponseBodyUiConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        uiConfigs = make_shared<vector<CreateEventResponseBodyUiConfigs>>(expect1);
      }
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["updateTime"]));
    }
  }


  virtual ~CreateEventResponseBody() = default;
};
class CreateEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEventResponseBody> body{};

  CreateEventResponse() {}

  explicit CreateEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEventResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEventResponse() = default;
};
class CreateLiveHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateLiveHeadersAccountContext() {}

  explicit CreateLiveHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateLiveHeadersAccountContext() = default;
};
class CreateLiveHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateLiveHeadersAccountContext> accountContext{};

  CreateLiveHeaders() {}

  explicit CreateLiveHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateLiveHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateLiveHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateLiveHeaders() = default;
};
class CreateLiveShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateLiveShrinkHeaders() {}

  explicit CreateLiveShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateLiveShrinkHeaders() = default;
};
class CreateLiveRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateLiveRequestTenantContext() {}

  explicit CreateLiveRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateLiveRequestTenantContext() = default;
};
class CreateLiveRequest : public Darabonba::Model {
public:
  shared_ptr<string> coverUrl{};
  shared_ptr<string> introduction{};
  shared_ptr<long> preEndTime{};
  shared_ptr<long> preStartTime{};
  shared_ptr<long> publicType{};
  shared_ptr<CreateLiveRequestTenantContext> tenantContext{};
  shared_ptr<string> title{};

  CreateLiveRequest() {}

  explicit CreateLiveRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverUrl) {
      res["CoverUrl"] = boost::any(*coverUrl);
    }
    if (introduction) {
      res["Introduction"] = boost::any(*introduction);
    }
    if (preEndTime) {
      res["PreEndTime"] = boost::any(*preEndTime);
    }
    if (preStartTime) {
      res["PreStartTime"] = boost::any(*preStartTime);
    }
    if (publicType) {
      res["PublicType"] = boost::any(*publicType);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverUrl") != m.end() && !m["CoverUrl"].empty()) {
      coverUrl = make_shared<string>(boost::any_cast<string>(m["CoverUrl"]));
    }
    if (m.find("Introduction") != m.end() && !m["Introduction"].empty()) {
      introduction = make_shared<string>(boost::any_cast<string>(m["Introduction"]));
    }
    if (m.find("PreEndTime") != m.end() && !m["PreEndTime"].empty()) {
      preEndTime = make_shared<long>(boost::any_cast<long>(m["PreEndTime"]));
    }
    if (m.find("PreStartTime") != m.end() && !m["PreStartTime"].empty()) {
      preStartTime = make_shared<long>(boost::any_cast<long>(m["PreStartTime"]));
    }
    if (m.find("PublicType") != m.end() && !m["PublicType"].empty()) {
      publicType = make_shared<long>(boost::any_cast<long>(m["PublicType"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateLiveRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateLiveRequestTenantContext>(model1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~CreateLiveRequest() = default;
};
class CreateLiveShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> coverUrl{};
  shared_ptr<string> introduction{};
  shared_ptr<long> preEndTime{};
  shared_ptr<long> preStartTime{};
  shared_ptr<long> publicType{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> title{};

  CreateLiveShrinkRequest() {}

  explicit CreateLiveShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverUrl) {
      res["CoverUrl"] = boost::any(*coverUrl);
    }
    if (introduction) {
      res["Introduction"] = boost::any(*introduction);
    }
    if (preEndTime) {
      res["PreEndTime"] = boost::any(*preEndTime);
    }
    if (preStartTime) {
      res["PreStartTime"] = boost::any(*preStartTime);
    }
    if (publicType) {
      res["PublicType"] = boost::any(*publicType);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverUrl") != m.end() && !m["CoverUrl"].empty()) {
      coverUrl = make_shared<string>(boost::any_cast<string>(m["CoverUrl"]));
    }
    if (m.find("Introduction") != m.end() && !m["Introduction"].empty()) {
      introduction = make_shared<string>(boost::any_cast<string>(m["Introduction"]));
    }
    if (m.find("PreEndTime") != m.end() && !m["PreEndTime"].empty()) {
      preEndTime = make_shared<long>(boost::any_cast<long>(m["PreEndTime"]));
    }
    if (m.find("PreStartTime") != m.end() && !m["PreStartTime"].empty()) {
      preStartTime = make_shared<long>(boost::any_cast<long>(m["PreStartTime"]));
    }
    if (m.find("PublicType") != m.end() && !m["PublicType"].empty()) {
      publicType = make_shared<long>(boost::any_cast<long>(m["PublicType"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~CreateLiveShrinkRequest() = default;
};
class CreateLiveResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> liveId{};
  shared_ptr<string> requestId{};

  CreateLiveResponseBody() {}

  explicit CreateLiveResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveId) {
      res["liveId"] = boost::any(*liveId);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("liveId") != m.end() && !m["liveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["liveId"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateLiveResponseBody() = default;
};
class CreateLiveResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLiveResponseBody> body{};

  CreateLiveResponse() {}

  explicit CreateLiveResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLiveResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLiveResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLiveResponse() = default;
};
class CreateMeetingRoomHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateMeetingRoomHeadersAccountContext() {}

  explicit CreateMeetingRoomHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateMeetingRoomHeadersAccountContext() = default;
};
class CreateMeetingRoomHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateMeetingRoomHeadersAccountContext> accountContext{};

  CreateMeetingRoomHeaders() {}

  explicit CreateMeetingRoomHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateMeetingRoomHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateMeetingRoomHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateMeetingRoomHeaders() = default;
};
class CreateMeetingRoomShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateMeetingRoomShrinkHeaders() {}

  explicit CreateMeetingRoomShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateMeetingRoomShrinkHeaders() = default;
};
class CreateMeetingRoomRequestReservationAuthorityAuthorizedMembers : public Darabonba::Model {
public:
  shared_ptr<string> memberId{};
  shared_ptr<string> memberName{};
  shared_ptr<string> memberType{};

  CreateMeetingRoomRequestReservationAuthorityAuthorizedMembers() {}

  explicit CreateMeetingRoomRequestReservationAuthorityAuthorizedMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberId) {
      res["MemberId"] = boost::any(*memberId);
    }
    if (memberName) {
      res["MemberName"] = boost::any(*memberName);
    }
    if (memberType) {
      res["MemberType"] = boost::any(*memberType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemberId") != m.end() && !m["MemberId"].empty()) {
      memberId = make_shared<string>(boost::any_cast<string>(m["MemberId"]));
    }
    if (m.find("MemberName") != m.end() && !m["MemberName"].empty()) {
      memberName = make_shared<string>(boost::any_cast<string>(m["MemberName"]));
    }
    if (m.find("MemberType") != m.end() && !m["MemberType"].empty()) {
      memberType = make_shared<string>(boost::any_cast<string>(m["MemberType"]));
    }
  }


  virtual ~CreateMeetingRoomRequestReservationAuthorityAuthorizedMembers() = default;
};
class CreateMeetingRoomRequestReservationAuthority : public Darabonba::Model {
public:
  shared_ptr<vector<CreateMeetingRoomRequestReservationAuthorityAuthorizedMembers>> authorizedMembers{};

  CreateMeetingRoomRequestReservationAuthority() {}

  explicit CreateMeetingRoomRequestReservationAuthority(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizedMembers) {
      vector<boost::any> temp1;
      for(auto item1:*authorizedMembers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizedMembers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizedMembers") != m.end() && !m["AuthorizedMembers"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizedMembers"].type()) {
        vector<CreateMeetingRoomRequestReservationAuthorityAuthorizedMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizedMembers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMeetingRoomRequestReservationAuthorityAuthorizedMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizedMembers = make_shared<vector<CreateMeetingRoomRequestReservationAuthorityAuthorizedMembers>>(expect1);
      }
    }
  }


  virtual ~CreateMeetingRoomRequestReservationAuthority() = default;
};
class CreateMeetingRoomRequestRoomLocation : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> title{};

  CreateMeetingRoomRequestRoomLocation() {}

  explicit CreateMeetingRoomRequestRoomLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~CreateMeetingRoomRequestRoomLocation() = default;
};
class CreateMeetingRoomRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateMeetingRoomRequestTenantContext() {}

  explicit CreateMeetingRoomRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateMeetingRoomRequestTenantContext() = default;
};
class CreateMeetingRoomRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enableCycleReservation{};
  shared_ptr<long> groupId{};
  shared_ptr<string> isvRoomId{};
  shared_ptr<CreateMeetingRoomRequestReservationAuthority> reservationAuthority{};
  shared_ptr<long> roomCapacity{};
  shared_ptr<vector<long>> roomLabelIds{};
  shared_ptr<CreateMeetingRoomRequestRoomLocation> roomLocation{};
  shared_ptr<string> roomName{};
  shared_ptr<string> roomPicture{};
  shared_ptr<long> roomStatus{};
  shared_ptr<CreateMeetingRoomRequestTenantContext> tenantContext{};

  CreateMeetingRoomRequest() {}

  explicit CreateMeetingRoomRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableCycleReservation) {
      res["EnableCycleReservation"] = boost::any(*enableCycleReservation);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (isvRoomId) {
      res["IsvRoomId"] = boost::any(*isvRoomId);
    }
    if (reservationAuthority) {
      res["ReservationAuthority"] = reservationAuthority ? boost::any(reservationAuthority->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (roomCapacity) {
      res["RoomCapacity"] = boost::any(*roomCapacity);
    }
    if (roomLabelIds) {
      res["RoomLabelIds"] = boost::any(*roomLabelIds);
    }
    if (roomLocation) {
      res["RoomLocation"] = roomLocation ? boost::any(roomLocation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (roomName) {
      res["RoomName"] = boost::any(*roomName);
    }
    if (roomPicture) {
      res["RoomPicture"] = boost::any(*roomPicture);
    }
    if (roomStatus) {
      res["RoomStatus"] = boost::any(*roomStatus);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableCycleReservation") != m.end() && !m["EnableCycleReservation"].empty()) {
      enableCycleReservation = make_shared<bool>(boost::any_cast<bool>(m["EnableCycleReservation"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("IsvRoomId") != m.end() && !m["IsvRoomId"].empty()) {
      isvRoomId = make_shared<string>(boost::any_cast<string>(m["IsvRoomId"]));
    }
    if (m.find("ReservationAuthority") != m.end() && !m["ReservationAuthority"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReservationAuthority"].type()) {
        CreateMeetingRoomRequestReservationAuthority model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReservationAuthority"]));
        reservationAuthority = make_shared<CreateMeetingRoomRequestReservationAuthority>(model1);
      }
    }
    if (m.find("RoomCapacity") != m.end() && !m["RoomCapacity"].empty()) {
      roomCapacity = make_shared<long>(boost::any_cast<long>(m["RoomCapacity"]));
    }
    if (m.find("RoomLabelIds") != m.end() && !m["RoomLabelIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RoomLabelIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoomLabelIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      roomLabelIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RoomLocation") != m.end() && !m["RoomLocation"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoomLocation"].type()) {
        CreateMeetingRoomRequestRoomLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoomLocation"]));
        roomLocation = make_shared<CreateMeetingRoomRequestRoomLocation>(model1);
      }
    }
    if (m.find("RoomName") != m.end() && !m["RoomName"].empty()) {
      roomName = make_shared<string>(boost::any_cast<string>(m["RoomName"]));
    }
    if (m.find("RoomPicture") != m.end() && !m["RoomPicture"].empty()) {
      roomPicture = make_shared<string>(boost::any_cast<string>(m["RoomPicture"]));
    }
    if (m.find("RoomStatus") != m.end() && !m["RoomStatus"].empty()) {
      roomStatus = make_shared<long>(boost::any_cast<long>(m["RoomStatus"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateMeetingRoomRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateMeetingRoomRequestTenantContext>(model1);
      }
    }
  }


  virtual ~CreateMeetingRoomRequest() = default;
};
class CreateMeetingRoomShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enableCycleReservation{};
  shared_ptr<long> groupId{};
  shared_ptr<string> isvRoomId{};
  shared_ptr<string> reservationAuthorityShrink{};
  shared_ptr<long> roomCapacity{};
  shared_ptr<string> roomLabelIdsShrink{};
  shared_ptr<string> roomLocationShrink{};
  shared_ptr<string> roomName{};
  shared_ptr<string> roomPicture{};
  shared_ptr<long> roomStatus{};
  shared_ptr<string> tenantContextShrink{};

  CreateMeetingRoomShrinkRequest() {}

  explicit CreateMeetingRoomShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableCycleReservation) {
      res["EnableCycleReservation"] = boost::any(*enableCycleReservation);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (isvRoomId) {
      res["IsvRoomId"] = boost::any(*isvRoomId);
    }
    if (reservationAuthorityShrink) {
      res["ReservationAuthority"] = boost::any(*reservationAuthorityShrink);
    }
    if (roomCapacity) {
      res["RoomCapacity"] = boost::any(*roomCapacity);
    }
    if (roomLabelIdsShrink) {
      res["RoomLabelIds"] = boost::any(*roomLabelIdsShrink);
    }
    if (roomLocationShrink) {
      res["RoomLocation"] = boost::any(*roomLocationShrink);
    }
    if (roomName) {
      res["RoomName"] = boost::any(*roomName);
    }
    if (roomPicture) {
      res["RoomPicture"] = boost::any(*roomPicture);
    }
    if (roomStatus) {
      res["RoomStatus"] = boost::any(*roomStatus);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableCycleReservation") != m.end() && !m["EnableCycleReservation"].empty()) {
      enableCycleReservation = make_shared<bool>(boost::any_cast<bool>(m["EnableCycleReservation"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("IsvRoomId") != m.end() && !m["IsvRoomId"].empty()) {
      isvRoomId = make_shared<string>(boost::any_cast<string>(m["IsvRoomId"]));
    }
    if (m.find("ReservationAuthority") != m.end() && !m["ReservationAuthority"].empty()) {
      reservationAuthorityShrink = make_shared<string>(boost::any_cast<string>(m["ReservationAuthority"]));
    }
    if (m.find("RoomCapacity") != m.end() && !m["RoomCapacity"].empty()) {
      roomCapacity = make_shared<long>(boost::any_cast<long>(m["RoomCapacity"]));
    }
    if (m.find("RoomLabelIds") != m.end() && !m["RoomLabelIds"].empty()) {
      roomLabelIdsShrink = make_shared<string>(boost::any_cast<string>(m["RoomLabelIds"]));
    }
    if (m.find("RoomLocation") != m.end() && !m["RoomLocation"].empty()) {
      roomLocationShrink = make_shared<string>(boost::any_cast<string>(m["RoomLocation"]));
    }
    if (m.find("RoomName") != m.end() && !m["RoomName"].empty()) {
      roomName = make_shared<string>(boost::any_cast<string>(m["RoomName"]));
    }
    if (m.find("RoomPicture") != m.end() && !m["RoomPicture"].empty()) {
      roomPicture = make_shared<string>(boost::any_cast<string>(m["RoomPicture"]));
    }
    if (m.find("RoomStatus") != m.end() && !m["RoomStatus"].empty()) {
      roomStatus = make_shared<long>(boost::any_cast<long>(m["RoomStatus"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~CreateMeetingRoomShrinkRequest() = default;
};
class CreateMeetingRoomResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  CreateMeetingRoomResponseBody() {}

  explicit CreateMeetingRoomResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["result"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~CreateMeetingRoomResponseBody() = default;
};
class CreateMeetingRoomResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMeetingRoomResponseBody> body{};

  CreateMeetingRoomResponse() {}

  explicit CreateMeetingRoomResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMeetingRoomResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMeetingRoomResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMeetingRoomResponse() = default;
};
class CreateMeetingRoomGroupHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateMeetingRoomGroupHeadersAccountContext() {}

  explicit CreateMeetingRoomGroupHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateMeetingRoomGroupHeadersAccountContext() = default;
};
class CreateMeetingRoomGroupHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateMeetingRoomGroupHeadersAccountContext> accountContext{};

  CreateMeetingRoomGroupHeaders() {}

  explicit CreateMeetingRoomGroupHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateMeetingRoomGroupHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateMeetingRoomGroupHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateMeetingRoomGroupHeaders() = default;
};
class CreateMeetingRoomGroupShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateMeetingRoomGroupShrinkHeaders() {}

  explicit CreateMeetingRoomGroupShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateMeetingRoomGroupShrinkHeaders() = default;
};
class CreateMeetingRoomGroupRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateMeetingRoomGroupRequestTenantContext() {}

  explicit CreateMeetingRoomGroupRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateMeetingRoomGroupRequestTenantContext() = default;
};
class CreateMeetingRoomGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<long> parentGroupId{};
  shared_ptr<CreateMeetingRoomGroupRequestTenantContext> tenantContext{};

  CreateMeetingRoomGroupRequest() {}

  explicit CreateMeetingRoomGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (parentGroupId) {
      res["ParentGroupId"] = boost::any(*parentGroupId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ParentGroupId") != m.end() && !m["ParentGroupId"].empty()) {
      parentGroupId = make_shared<long>(boost::any_cast<long>(m["ParentGroupId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateMeetingRoomGroupRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateMeetingRoomGroupRequestTenantContext>(model1);
      }
    }
  }


  virtual ~CreateMeetingRoomGroupRequest() = default;
};
class CreateMeetingRoomGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<long> parentGroupId{};
  shared_ptr<string> tenantContextShrink{};

  CreateMeetingRoomGroupShrinkRequest() {}

  explicit CreateMeetingRoomGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (parentGroupId) {
      res["ParentGroupId"] = boost::any(*parentGroupId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ParentGroupId") != m.end() && !m["ParentGroupId"].empty()) {
      parentGroupId = make_shared<long>(boost::any_cast<long>(m["ParentGroupId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~CreateMeetingRoomGroupShrinkRequest() = default;
};
class CreateMeetingRoomGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> result{};

  CreateMeetingRoomGroupResponseBody() {}

  explicit CreateMeetingRoomGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<long>(boost::any_cast<long>(m["result"]));
    }
  }


  virtual ~CreateMeetingRoomGroupResponseBody() = default;
};
class CreateMeetingRoomGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMeetingRoomGroupResponseBody> body{};

  CreateMeetingRoomGroupResponse() {}

  explicit CreateMeetingRoomGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMeetingRoomGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMeetingRoomGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMeetingRoomGroupResponse() = default;
};
class CreateMessageHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountId{};

  CreateMessageHeaders() {}

  explicit CreateMessageHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateMessageHeaders() = default;
};
class CreateMessageRequestMessagesContentCardCallback : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> relatedMessageId{};

  CreateMessageRequestMessagesContentCardCallback() {}

  explicit CreateMessageRequestMessagesContentCardCallback(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (relatedMessageId) {
      res["relatedMessageId"] = boost::any(*relatedMessageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("relatedMessageId") != m.end() && !m["relatedMessageId"].empty()) {
      relatedMessageId = make_shared<string>(boost::any_cast<string>(m["relatedMessageId"]));
    }
  }


  virtual ~CreateMessageRequestMessagesContentCardCallback() = default;
};
class CreateMessageRequestMessagesContentDingCard : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentType{};
  shared_ptr<bool> finished{};
  shared_ptr<string> templateId{};

  CreateMessageRequestMessagesContentDingCard() {}

  explicit CreateMessageRequestMessagesContentDingCard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (contentType) {
      res["contentType"] = boost::any(*contentType);
    }
    if (finished) {
      res["finished"] = boost::any(*finished);
    }
    if (templateId) {
      res["templateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("contentType") != m.end() && !m["contentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["contentType"]));
    }
    if (m.find("finished") != m.end() && !m["finished"].empty()) {
      finished = make_shared<bool>(boost::any_cast<bool>(m["finished"]));
    }
    if (m.find("templateId") != m.end() && !m["templateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["templateId"]));
    }
  }


  virtual ~CreateMessageRequestMessagesContentDingCard() = default;
};
class CreateMessageRequestMessagesContentDingNormalCardCardData : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> cardParamMap{};

  CreateMessageRequestMessagesContentDingNormalCardCardData() {}

  explicit CreateMessageRequestMessagesContentDingNormalCardCardData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardParamMap) {
      res["cardParamMap"] = boost::any(*cardParamMap);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cardParamMap") != m.end() && !m["cardParamMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["cardParamMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      cardParamMap = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~CreateMessageRequestMessagesContentDingNormalCardCardData() = default;
};
class CreateMessageRequestMessagesContentDingNormalCardCardUpdateOptions : public Darabonba::Model {
public:
  shared_ptr<bool> updateCardDataByKey{};
  shared_ptr<bool> updatePrivateDataByKey{};

  CreateMessageRequestMessagesContentDingNormalCardCardUpdateOptions() {}

  explicit CreateMessageRequestMessagesContentDingNormalCardCardUpdateOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateCardDataByKey) {
      res["updateCardDataByKey"] = boost::any(*updateCardDataByKey);
    }
    if (updatePrivateDataByKey) {
      res["updatePrivateDataByKey"] = boost::any(*updatePrivateDataByKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("updateCardDataByKey") != m.end() && !m["updateCardDataByKey"].empty()) {
      updateCardDataByKey = make_shared<bool>(boost::any_cast<bool>(m["updateCardDataByKey"]));
    }
    if (m.find("updatePrivateDataByKey") != m.end() && !m["updatePrivateDataByKey"].empty()) {
      updatePrivateDataByKey = make_shared<bool>(boost::any_cast<bool>(m["updatePrivateDataByKey"]));
    }
  }


  virtual ~CreateMessageRequestMessagesContentDingNormalCardCardUpdateOptions() = default;
};
class CreateMessageRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig : public Darabonba::Model {
public:
  shared_ptr<long> interval{};
  shared_ptr<string> pullStrategy{};
  shared_ptr<string> timeUnit{};

  CreateMessageRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig() {}

  explicit CreateMessageRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interval) {
      res["interval"] = boost::any(*interval);
    }
    if (pullStrategy) {
      res["pullStrategy"] = boost::any(*pullStrategy);
    }
    if (timeUnit) {
      res["timeUnit"] = boost::any(*timeUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("interval") != m.end() && !m["interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["interval"]));
    }
    if (m.find("pullStrategy") != m.end() && !m["pullStrategy"].empty()) {
      pullStrategy = make_shared<string>(boost::any_cast<string>(m["pullStrategy"]));
    }
    if (m.find("timeUnit") != m.end() && !m["timeUnit"].empty()) {
      timeUnit = make_shared<string>(boost::any_cast<string>(m["timeUnit"]));
    }
  }


  virtual ~CreateMessageRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig() = default;
};
class CreateMessageRequestMessagesContentDingNormalCardDynamicDataSourceConfigs : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> constParams{};
  shared_ptr<string> dynamicDataSourceId{};
  shared_ptr<CreateMessageRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig> pullConfig{};

  CreateMessageRequestMessagesContentDingNormalCardDynamicDataSourceConfigs() {}

  explicit CreateMessageRequestMessagesContentDingNormalCardDynamicDataSourceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constParams) {
      res["constParams"] = boost::any(*constParams);
    }
    if (dynamicDataSourceId) {
      res["dynamicDataSourceId"] = boost::any(*dynamicDataSourceId);
    }
    if (pullConfig) {
      res["pullConfig"] = pullConfig ? boost::any(pullConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("constParams") != m.end() && !m["constParams"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["constParams"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      constParams = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("dynamicDataSourceId") != m.end() && !m["dynamicDataSourceId"].empty()) {
      dynamicDataSourceId = make_shared<string>(boost::any_cast<string>(m["dynamicDataSourceId"]));
    }
    if (m.find("pullConfig") != m.end() && !m["pullConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["pullConfig"].type()) {
        CreateMessageRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["pullConfig"]));
        pullConfig = make_shared<CreateMessageRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig>(model1);
      }
    }
  }


  virtual ~CreateMessageRequestMessagesContentDingNormalCardDynamicDataSourceConfigs() = default;
};
class CreateMessageRequestMessagesContentDingNormalCard : public Darabonba::Model {
public:
  shared_ptr<CreateMessageRequestMessagesContentDingNormalCardCardData> cardData{};
  shared_ptr<string> cardTemplateId{};
  shared_ptr<CreateMessageRequestMessagesContentDingNormalCardCardUpdateOptions> cardUpdateOptions{};
  shared_ptr<vector<CreateMessageRequestMessagesContentDingNormalCardDynamicDataSourceConfigs>> dynamicDataSourceConfigs{};
  shared_ptr<map<string, map<string, boost::any>>> privateData{};

  CreateMessageRequestMessagesContentDingNormalCard() {}

  explicit CreateMessageRequestMessagesContentDingNormalCard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardData) {
      res["cardData"] = cardData ? boost::any(cardData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cardTemplateId) {
      res["cardTemplateId"] = boost::any(*cardTemplateId);
    }
    if (cardUpdateOptions) {
      res["cardUpdateOptions"] = cardUpdateOptions ? boost::any(cardUpdateOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dynamicDataSourceConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*dynamicDataSourceConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dynamicDataSourceConfigs"] = boost::any(temp1);
    }
    if (privateData) {
      res["privateData"] = boost::any(*privateData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cardData") != m.end() && !m["cardData"].empty()) {
      if (typeid(map<string, boost::any>) == m["cardData"].type()) {
        CreateMessageRequestMessagesContentDingNormalCardCardData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cardData"]));
        cardData = make_shared<CreateMessageRequestMessagesContentDingNormalCardCardData>(model1);
      }
    }
    if (m.find("cardTemplateId") != m.end() && !m["cardTemplateId"].empty()) {
      cardTemplateId = make_shared<string>(boost::any_cast<string>(m["cardTemplateId"]));
    }
    if (m.find("cardUpdateOptions") != m.end() && !m["cardUpdateOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["cardUpdateOptions"].type()) {
        CreateMessageRequestMessagesContentDingNormalCardCardUpdateOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cardUpdateOptions"]));
        cardUpdateOptions = make_shared<CreateMessageRequestMessagesContentDingNormalCardCardUpdateOptions>(model1);
      }
    }
    if (m.find("dynamicDataSourceConfigs") != m.end() && !m["dynamicDataSourceConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["dynamicDataSourceConfigs"].type()) {
        vector<CreateMessageRequestMessagesContentDingNormalCardDynamicDataSourceConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dynamicDataSourceConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMessageRequestMessagesContentDingNormalCardDynamicDataSourceConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dynamicDataSourceConfigs = make_shared<vector<CreateMessageRequestMessagesContentDingNormalCardDynamicDataSourceConfigs>>(expect1);
      }
    }
    if (m.find("privateData") != m.end() && !m["privateData"].empty()) {
      map<string, map<string, boost::any>> map1 = boost::any_cast<map<string, map<string, boost::any>>>(m["privateData"]);
      map<string, map<string, boost::any>> toMap1;
      for (auto item:map1) {
        map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item.second);
        map<string, boost::any> toMap2;
        for (auto item:map2) {
           toMap2[item.first] = item.second;
        }
         toMap1[item.first] = toMap2;
      }
      privateData = make_shared<map<string, map<string, boost::any>>>(toMap1);
    }
  }


  virtual ~CreateMessageRequestMessagesContentDingNormalCard() = default;
};
class CreateMessageRequestMessagesContentMarkdown : public Darabonba::Model {
public:
  shared_ptr<string> value{};

  CreateMessageRequestMessagesContentMarkdown() {}

  explicit CreateMessageRequestMessagesContentMarkdown(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~CreateMessageRequestMessagesContentMarkdown() = default;
};
class CreateMessageRequestMessagesContentStructViewPartsDataPart : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};

  CreateMessageRequestMessagesContentStructViewPartsDataPart() {}

  explicit CreateMessageRequestMessagesContentStructViewPartsDataPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["data"]));
    }
  }


  virtual ~CreateMessageRequestMessagesContentStructViewPartsDataPart() = default;
};
class CreateMessageRequestMessagesContentStructViewPartsReasonPart : public Darabonba::Model {
public:
  shared_ptr<string> reason{};

  CreateMessageRequestMessagesContentStructViewPartsReasonPart() {}

  explicit CreateMessageRequestMessagesContentStructViewPartsReasonPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
  }


  virtual ~CreateMessageRequestMessagesContentStructViewPartsReasonPart() = default;
};
class CreateMessageRequestMessagesContentStructViewPartsRecommendPartRecommends : public Darabonba::Model {
public:
  shared_ptr<string> mobileUrl{};
  shared_ptr<string> text{};
  shared_ptr<string> url{};

  CreateMessageRequestMessagesContentStructViewPartsRecommendPartRecommends() {}

  explicit CreateMessageRequestMessagesContentStructViewPartsRecommendPartRecommends(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mobileUrl) {
      res["mobileUrl"] = boost::any(*mobileUrl);
    }
    if (text) {
      res["text"] = boost::any(*text);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("mobileUrl") != m.end() && !m["mobileUrl"].empty()) {
      mobileUrl = make_shared<string>(boost::any_cast<string>(m["mobileUrl"]));
    }
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~CreateMessageRequestMessagesContentStructViewPartsRecommendPartRecommends() = default;
};
class CreateMessageRequestMessagesContentStructViewPartsRecommendPart : public Darabonba::Model {
public:
  shared_ptr<vector<CreateMessageRequestMessagesContentStructViewPartsRecommendPartRecommends>> recommends{};

  CreateMessageRequestMessagesContentStructViewPartsRecommendPart() {}

  explicit CreateMessageRequestMessagesContentStructViewPartsRecommendPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommends) {
      vector<boost::any> temp1;
      for(auto item1:*recommends){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["recommends"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("recommends") != m.end() && !m["recommends"].empty()) {
      if (typeid(vector<boost::any>) == m["recommends"].type()) {
        vector<CreateMessageRequestMessagesContentStructViewPartsRecommendPartRecommends> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["recommends"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMessageRequestMessagesContentStructViewPartsRecommendPartRecommends model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recommends = make_shared<vector<CreateMessageRequestMessagesContentStructViewPartsRecommendPartRecommends>>(expect1);
      }
    }
  }


  virtual ~CreateMessageRequestMessagesContentStructViewPartsRecommendPart() = default;
};
class CreateMessageRequestMessagesContentStructViewPartsReferencePartReferences : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceCode{};
  shared_ptr<string> sourceIcon{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  CreateMessageRequestMessagesContentStructViewPartsReferencePartReferences() {}

  explicit CreateMessageRequestMessagesContentStructViewPartsReferencePartReferences(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceCode) {
      res["sourceCode"] = boost::any(*sourceCode);
    }
    if (sourceIcon) {
      res["sourceIcon"] = boost::any(*sourceIcon);
    }
    if (summary) {
      res["summary"] = boost::any(*summary);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceCode") != m.end() && !m["sourceCode"].empty()) {
      sourceCode = make_shared<string>(boost::any_cast<string>(m["sourceCode"]));
    }
    if (m.find("sourceIcon") != m.end() && !m["sourceIcon"].empty()) {
      sourceIcon = make_shared<string>(boost::any_cast<string>(m["sourceIcon"]));
    }
    if (m.find("summary") != m.end() && !m["summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["summary"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~CreateMessageRequestMessagesContentStructViewPartsReferencePartReferences() = default;
};
class CreateMessageRequestMessagesContentStructViewPartsReferencePart : public Darabonba::Model {
public:
  shared_ptr<vector<CreateMessageRequestMessagesContentStructViewPartsReferencePartReferences>> references{};

  CreateMessageRequestMessagesContentStructViewPartsReferencePart() {}

  explicit CreateMessageRequestMessagesContentStructViewPartsReferencePart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (references) {
      vector<boost::any> temp1;
      for(auto item1:*references){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["references"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("references") != m.end() && !m["references"].empty()) {
      if (typeid(vector<boost::any>) == m["references"].type()) {
        vector<CreateMessageRequestMessagesContentStructViewPartsReferencePartReferences> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["references"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMessageRequestMessagesContentStructViewPartsReferencePartReferences model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        references = make_shared<vector<CreateMessageRequestMessagesContentStructViewPartsReferencePartReferences>>(expect1);
      }
    }
  }


  virtual ~CreateMessageRequestMessagesContentStructViewPartsReferencePart() = default;
};
class CreateMessageRequestMessagesContentStructViewPartsTextPart : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  CreateMessageRequestMessagesContentStructViewPartsTextPart() {}

  explicit CreateMessageRequestMessagesContentStructViewPartsTextPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
  }


  virtual ~CreateMessageRequestMessagesContentStructViewPartsTextPart() = default;
};
class CreateMessageRequestMessagesContentStructViewParts : public Darabonba::Model {
public:
  shared_ptr<bool> append{};
  shared_ptr<CreateMessageRequestMessagesContentStructViewPartsDataPart> dataPart{};
  shared_ptr<bool> finish{};
  shared_ptr<string> partDesc{};
  shared_ptr<string> partId{};
  shared_ptr<CreateMessageRequestMessagesContentStructViewPartsReasonPart> reasonPart{};
  shared_ptr<CreateMessageRequestMessagesContentStructViewPartsRecommendPart> recommendPart{};
  shared_ptr<CreateMessageRequestMessagesContentStructViewPartsReferencePart> referencePart{};
  shared_ptr<CreateMessageRequestMessagesContentStructViewPartsTextPart> textPart{};
  shared_ptr<string> type{};

  CreateMessageRequestMessagesContentStructViewParts() {}

  explicit CreateMessageRequestMessagesContentStructViewParts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (append) {
      res["append"] = boost::any(*append);
    }
    if (dataPart) {
      res["dataPart"] = dataPart ? boost::any(dataPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (finish) {
      res["finish"] = boost::any(*finish);
    }
    if (partDesc) {
      res["partDesc"] = boost::any(*partDesc);
    }
    if (partId) {
      res["partId"] = boost::any(*partId);
    }
    if (reasonPart) {
      res["reasonPart"] = reasonPart ? boost::any(reasonPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recommendPart) {
      res["recommendPart"] = recommendPart ? boost::any(recommendPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referencePart) {
      res["referencePart"] = referencePart ? boost::any(referencePart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (textPart) {
      res["textPart"] = textPart ? boost::any(textPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("append") != m.end() && !m["append"].empty()) {
      append = make_shared<bool>(boost::any_cast<bool>(m["append"]));
    }
    if (m.find("dataPart") != m.end() && !m["dataPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["dataPart"].type()) {
        CreateMessageRequestMessagesContentStructViewPartsDataPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dataPart"]));
        dataPart = make_shared<CreateMessageRequestMessagesContentStructViewPartsDataPart>(model1);
      }
    }
    if (m.find("finish") != m.end() && !m["finish"].empty()) {
      finish = make_shared<bool>(boost::any_cast<bool>(m["finish"]));
    }
    if (m.find("partDesc") != m.end() && !m["partDesc"].empty()) {
      partDesc = make_shared<string>(boost::any_cast<string>(m["partDesc"]));
    }
    if (m.find("partId") != m.end() && !m["partId"].empty()) {
      partId = make_shared<string>(boost::any_cast<string>(m["partId"]));
    }
    if (m.find("reasonPart") != m.end() && !m["reasonPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["reasonPart"].type()) {
        CreateMessageRequestMessagesContentStructViewPartsReasonPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["reasonPart"]));
        reasonPart = make_shared<CreateMessageRequestMessagesContentStructViewPartsReasonPart>(model1);
      }
    }
    if (m.find("recommendPart") != m.end() && !m["recommendPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["recommendPart"].type()) {
        CreateMessageRequestMessagesContentStructViewPartsRecommendPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["recommendPart"]));
        recommendPart = make_shared<CreateMessageRequestMessagesContentStructViewPartsRecommendPart>(model1);
      }
    }
    if (m.find("referencePart") != m.end() && !m["referencePart"].empty()) {
      if (typeid(map<string, boost::any>) == m["referencePart"].type()) {
        CreateMessageRequestMessagesContentStructViewPartsReferencePart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["referencePart"]));
        referencePart = make_shared<CreateMessageRequestMessagesContentStructViewPartsReferencePart>(model1);
      }
    }
    if (m.find("textPart") != m.end() && !m["textPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["textPart"].type()) {
        CreateMessageRequestMessagesContentStructViewPartsTextPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["textPart"]));
        textPart = make_shared<CreateMessageRequestMessagesContentStructViewPartsTextPart>(model1);
      }
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateMessageRequestMessagesContentStructViewParts() = default;
};
class CreateMessageRequestMessagesContentStructView : public Darabonba::Model {
public:
  shared_ptr<vector<CreateMessageRequestMessagesContentStructViewParts>> parts{};

  CreateMessageRequestMessagesContentStructView() {}

  explicit CreateMessageRequestMessagesContentStructView(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parts) {
      vector<boost::any> temp1;
      for(auto item1:*parts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["parts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("parts") != m.end() && !m["parts"].empty()) {
      if (typeid(vector<boost::any>) == m["parts"].type()) {
        vector<CreateMessageRequestMessagesContentStructViewParts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["parts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMessageRequestMessagesContentStructViewParts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parts = make_shared<vector<CreateMessageRequestMessagesContentStructViewParts>>(expect1);
      }
    }
  }


  virtual ~CreateMessageRequestMessagesContentStructView() = default;
};
class CreateMessageRequestMessagesContentText : public Darabonba::Model {
public:
  shared_ptr<string> value{};

  CreateMessageRequestMessagesContentText() {}

  explicit CreateMessageRequestMessagesContentText(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~CreateMessageRequestMessagesContentText() = default;
};
class CreateMessageRequestMessagesContent : public Darabonba::Model {
public:
  shared_ptr<CreateMessageRequestMessagesContentCardCallback> cardCallback{};
  shared_ptr<CreateMessageRequestMessagesContentDingCard> dingCard{};
  shared_ptr<CreateMessageRequestMessagesContentDingNormalCard> dingNormalCard{};
  shared_ptr<CreateMessageRequestMessagesContentMarkdown> markdown{};
  shared_ptr<CreateMessageRequestMessagesContentStructView> structView{};
  shared_ptr<CreateMessageRequestMessagesContentText> text{};
  shared_ptr<string> type{};

  CreateMessageRequestMessagesContent() {}

  explicit CreateMessageRequestMessagesContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardCallback) {
      res["cardCallback"] = cardCallback ? boost::any(cardCallback->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dingCard) {
      res["dingCard"] = dingCard ? boost::any(dingCard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dingNormalCard) {
      res["dingNormalCard"] = dingNormalCard ? boost::any(dingNormalCard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (markdown) {
      res["markdown"] = markdown ? boost::any(markdown->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (structView) {
      res["structView"] = structView ? boost::any(structView->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (text) {
      res["text"] = text ? boost::any(text->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cardCallback") != m.end() && !m["cardCallback"].empty()) {
      if (typeid(map<string, boost::any>) == m["cardCallback"].type()) {
        CreateMessageRequestMessagesContentCardCallback model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cardCallback"]));
        cardCallback = make_shared<CreateMessageRequestMessagesContentCardCallback>(model1);
      }
    }
    if (m.find("dingCard") != m.end() && !m["dingCard"].empty()) {
      if (typeid(map<string, boost::any>) == m["dingCard"].type()) {
        CreateMessageRequestMessagesContentDingCard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dingCard"]));
        dingCard = make_shared<CreateMessageRequestMessagesContentDingCard>(model1);
      }
    }
    if (m.find("dingNormalCard") != m.end() && !m["dingNormalCard"].empty()) {
      if (typeid(map<string, boost::any>) == m["dingNormalCard"].type()) {
        CreateMessageRequestMessagesContentDingNormalCard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dingNormalCard"]));
        dingNormalCard = make_shared<CreateMessageRequestMessagesContentDingNormalCard>(model1);
      }
    }
    if (m.find("markdown") != m.end() && !m["markdown"].empty()) {
      if (typeid(map<string, boost::any>) == m["markdown"].type()) {
        CreateMessageRequestMessagesContentMarkdown model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["markdown"]));
        markdown = make_shared<CreateMessageRequestMessagesContentMarkdown>(model1);
      }
    }
    if (m.find("structView") != m.end() && !m["structView"].empty()) {
      if (typeid(map<string, boost::any>) == m["structView"].type()) {
        CreateMessageRequestMessagesContentStructView model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["structView"]));
        structView = make_shared<CreateMessageRequestMessagesContentStructView>(model1);
      }
    }
    if (m.find("text") != m.end() && !m["text"].empty()) {
      if (typeid(map<string, boost::any>) == m["text"].type()) {
        CreateMessageRequestMessagesContentText model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["text"]));
        text = make_shared<CreateMessageRequestMessagesContentText>(model1);
      }
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateMessageRequestMessagesContent() = default;
};
class CreateMessageRequestMessages : public Darabonba::Model {
public:
  shared_ptr<CreateMessageRequestMessagesContent> content{};
  shared_ptr<string> contentDesc{};
  shared_ptr<long> createAt{};
  shared_ptr<string> role{};

  CreateMessageRequestMessages() {}

  explicit CreateMessageRequestMessages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contentDesc) {
      res["contentDesc"] = boost::any(*contentDesc);
    }
    if (createAt) {
      res["createAt"] = boost::any(*createAt);
    }
    if (role) {
      res["role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      if (typeid(map<string, boost::any>) == m["content"].type()) {
        CreateMessageRequestMessagesContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["content"]));
        content = make_shared<CreateMessageRequestMessagesContent>(model1);
      }
    }
    if (m.find("contentDesc") != m.end() && !m["contentDesc"].empty()) {
      contentDesc = make_shared<string>(boost::any_cast<string>(m["contentDesc"]));
    }
    if (m.find("createAt") != m.end() && !m["createAt"].empty()) {
      createAt = make_shared<long>(boost::any_cast<long>(m["createAt"]));
    }
    if (m.find("role") != m.end() && !m["role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["role"]));
    }
  }


  virtual ~CreateMessageRequestMessages() = default;
};
class CreateMessageRequest : public Darabonba::Model {
public:
  shared_ptr<string> assistantId{};
  shared_ptr<vector<CreateMessageRequestMessages>> messages{};
  shared_ptr<string> originalAssistantId{};
  shared_ptr<string> sourceIdOfOriginalAssistantId{};
  shared_ptr<string> sourceTypeOfOriginalAssistantId{};
  shared_ptr<string> threadId{};

  CreateMessageRequest() {}

  explicit CreateMessageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assistantId) {
      res["assistantId"] = boost::any(*assistantId);
    }
    if (messages) {
      vector<boost::any> temp1;
      for(auto item1:*messages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["messages"] = boost::any(temp1);
    }
    if (originalAssistantId) {
      res["originalAssistantId"] = boost::any(*originalAssistantId);
    }
    if (sourceIdOfOriginalAssistantId) {
      res["sourceIdOfOriginalAssistantId"] = boost::any(*sourceIdOfOriginalAssistantId);
    }
    if (sourceTypeOfOriginalAssistantId) {
      res["sourceTypeOfOriginalAssistantId"] = boost::any(*sourceTypeOfOriginalAssistantId);
    }
    if (threadId) {
      res["threadId"] = boost::any(*threadId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assistantId") != m.end() && !m["assistantId"].empty()) {
      assistantId = make_shared<string>(boost::any_cast<string>(m["assistantId"]));
    }
    if (m.find("messages") != m.end() && !m["messages"].empty()) {
      if (typeid(vector<boost::any>) == m["messages"].type()) {
        vector<CreateMessageRequestMessages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["messages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMessageRequestMessages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        messages = make_shared<vector<CreateMessageRequestMessages>>(expect1);
      }
    }
    if (m.find("originalAssistantId") != m.end() && !m["originalAssistantId"].empty()) {
      originalAssistantId = make_shared<string>(boost::any_cast<string>(m["originalAssistantId"]));
    }
    if (m.find("sourceIdOfOriginalAssistantId") != m.end() && !m["sourceIdOfOriginalAssistantId"].empty()) {
      sourceIdOfOriginalAssistantId = make_shared<string>(boost::any_cast<string>(m["sourceIdOfOriginalAssistantId"]));
    }
    if (m.find("sourceTypeOfOriginalAssistantId") != m.end() && !m["sourceTypeOfOriginalAssistantId"].empty()) {
      sourceTypeOfOriginalAssistantId = make_shared<string>(boost::any_cast<string>(m["sourceTypeOfOriginalAssistantId"]));
    }
    if (m.find("threadId") != m.end() && !m["threadId"].empty()) {
      threadId = make_shared<string>(boost::any_cast<string>(m["threadId"]));
    }
  }


  virtual ~CreateMessageRequest() = default;
};
class CreateMessageResponseBodyMessagesContentCardCallback : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> relatedMessageId{};

  CreateMessageResponseBodyMessagesContentCardCallback() {}

  explicit CreateMessageResponseBodyMessagesContentCardCallback(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (relatedMessageId) {
      res["relatedMessageId"] = boost::any(*relatedMessageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("relatedMessageId") != m.end() && !m["relatedMessageId"].empty()) {
      relatedMessageId = make_shared<string>(boost::any_cast<string>(m["relatedMessageId"]));
    }
  }


  virtual ~CreateMessageResponseBodyMessagesContentCardCallback() = default;
};
class CreateMessageResponseBodyMessagesContentDingCard : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentType{};
  shared_ptr<bool> finished{};
  shared_ptr<string> templateId{};

  CreateMessageResponseBodyMessagesContentDingCard() {}

  explicit CreateMessageResponseBodyMessagesContentDingCard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (contentType) {
      res["contentType"] = boost::any(*contentType);
    }
    if (finished) {
      res["finished"] = boost::any(*finished);
    }
    if (templateId) {
      res["templateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("contentType") != m.end() && !m["contentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["contentType"]));
    }
    if (m.find("finished") != m.end() && !m["finished"].empty()) {
      finished = make_shared<bool>(boost::any_cast<bool>(m["finished"]));
    }
    if (m.find("templateId") != m.end() && !m["templateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["templateId"]));
    }
  }


  virtual ~CreateMessageResponseBodyMessagesContentDingCard() = default;
};
class CreateMessageResponseBodyMessagesContentDingNormalCardCardData : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> cardParamMap{};

  CreateMessageResponseBodyMessagesContentDingNormalCardCardData() {}

  explicit CreateMessageResponseBodyMessagesContentDingNormalCardCardData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardParamMap) {
      res["cardParamMap"] = boost::any(*cardParamMap);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cardParamMap") != m.end() && !m["cardParamMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["cardParamMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      cardParamMap = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~CreateMessageResponseBodyMessagesContentDingNormalCardCardData() = default;
};
class CreateMessageResponseBodyMessagesContentDingNormalCardCardUpdateOptions : public Darabonba::Model {
public:
  shared_ptr<bool> updateCardDataByKey{};
  shared_ptr<bool> updatePrivateDataByKey{};

  CreateMessageResponseBodyMessagesContentDingNormalCardCardUpdateOptions() {}

  explicit CreateMessageResponseBodyMessagesContentDingNormalCardCardUpdateOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateCardDataByKey) {
      res["updateCardDataByKey"] = boost::any(*updateCardDataByKey);
    }
    if (updatePrivateDataByKey) {
      res["updatePrivateDataByKey"] = boost::any(*updatePrivateDataByKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("updateCardDataByKey") != m.end() && !m["updateCardDataByKey"].empty()) {
      updateCardDataByKey = make_shared<bool>(boost::any_cast<bool>(m["updateCardDataByKey"]));
    }
    if (m.find("updatePrivateDataByKey") != m.end() && !m["updatePrivateDataByKey"].empty()) {
      updatePrivateDataByKey = make_shared<bool>(boost::any_cast<bool>(m["updatePrivateDataByKey"]));
    }
  }


  virtual ~CreateMessageResponseBodyMessagesContentDingNormalCardCardUpdateOptions() = default;
};
class CreateMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig : public Darabonba::Model {
public:
  shared_ptr<long> interval{};
  shared_ptr<string> pullStrategy{};
  shared_ptr<string> timeUnit{};

  CreateMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig() {}

  explicit CreateMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interval) {
      res["interval"] = boost::any(*interval);
    }
    if (pullStrategy) {
      res["pullStrategy"] = boost::any(*pullStrategy);
    }
    if (timeUnit) {
      res["timeUnit"] = boost::any(*timeUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("interval") != m.end() && !m["interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["interval"]));
    }
    if (m.find("pullStrategy") != m.end() && !m["pullStrategy"].empty()) {
      pullStrategy = make_shared<string>(boost::any_cast<string>(m["pullStrategy"]));
    }
    if (m.find("timeUnit") != m.end() && !m["timeUnit"].empty()) {
      timeUnit = make_shared<string>(boost::any_cast<string>(m["timeUnit"]));
    }
  }


  virtual ~CreateMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig() = default;
};
class CreateMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> constParams{};
  shared_ptr<string> dynamicDataSourceId{};
  shared_ptr<CreateMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig> pullConfig{};

  CreateMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs() {}

  explicit CreateMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constParams) {
      res["constParams"] = boost::any(*constParams);
    }
    if (dynamicDataSourceId) {
      res["dynamicDataSourceId"] = boost::any(*dynamicDataSourceId);
    }
    if (pullConfig) {
      res["pullConfig"] = pullConfig ? boost::any(pullConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("constParams") != m.end() && !m["constParams"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["constParams"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      constParams = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("dynamicDataSourceId") != m.end() && !m["dynamicDataSourceId"].empty()) {
      dynamicDataSourceId = make_shared<string>(boost::any_cast<string>(m["dynamicDataSourceId"]));
    }
    if (m.find("pullConfig") != m.end() && !m["pullConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["pullConfig"].type()) {
        CreateMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["pullConfig"]));
        pullConfig = make_shared<CreateMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig>(model1);
      }
    }
  }


  virtual ~CreateMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs() = default;
};
class CreateMessageResponseBodyMessagesContentDingNormalCard : public Darabonba::Model {
public:
  shared_ptr<CreateMessageResponseBodyMessagesContentDingNormalCardCardData> cardData{};
  shared_ptr<string> cardTemplateId{};
  shared_ptr<CreateMessageResponseBodyMessagesContentDingNormalCardCardUpdateOptions> cardUpdateOptions{};
  shared_ptr<vector<CreateMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs>> dynamicDataSourceConfigs{};
  shared_ptr<map<string, map<string, boost::any>>> privateData{};

  CreateMessageResponseBodyMessagesContentDingNormalCard() {}

  explicit CreateMessageResponseBodyMessagesContentDingNormalCard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardData) {
      res["cardData"] = cardData ? boost::any(cardData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cardTemplateId) {
      res["cardTemplateId"] = boost::any(*cardTemplateId);
    }
    if (cardUpdateOptions) {
      res["cardUpdateOptions"] = cardUpdateOptions ? boost::any(cardUpdateOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dynamicDataSourceConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*dynamicDataSourceConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dynamicDataSourceConfigs"] = boost::any(temp1);
    }
    if (privateData) {
      res["privateData"] = boost::any(*privateData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cardData") != m.end() && !m["cardData"].empty()) {
      if (typeid(map<string, boost::any>) == m["cardData"].type()) {
        CreateMessageResponseBodyMessagesContentDingNormalCardCardData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cardData"]));
        cardData = make_shared<CreateMessageResponseBodyMessagesContentDingNormalCardCardData>(model1);
      }
    }
    if (m.find("cardTemplateId") != m.end() && !m["cardTemplateId"].empty()) {
      cardTemplateId = make_shared<string>(boost::any_cast<string>(m["cardTemplateId"]));
    }
    if (m.find("cardUpdateOptions") != m.end() && !m["cardUpdateOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["cardUpdateOptions"].type()) {
        CreateMessageResponseBodyMessagesContentDingNormalCardCardUpdateOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cardUpdateOptions"]));
        cardUpdateOptions = make_shared<CreateMessageResponseBodyMessagesContentDingNormalCardCardUpdateOptions>(model1);
      }
    }
    if (m.find("dynamicDataSourceConfigs") != m.end() && !m["dynamicDataSourceConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["dynamicDataSourceConfigs"].type()) {
        vector<CreateMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dynamicDataSourceConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dynamicDataSourceConfigs = make_shared<vector<CreateMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs>>(expect1);
      }
    }
    if (m.find("privateData") != m.end() && !m["privateData"].empty()) {
      map<string, map<string, boost::any>> map1 = boost::any_cast<map<string, map<string, boost::any>>>(m["privateData"]);
      map<string, map<string, boost::any>> toMap1;
      for (auto item:map1) {
        map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item.second);
        map<string, boost::any> toMap2;
        for (auto item:map2) {
           toMap2[item.first] = item.second;
        }
         toMap1[item.first] = toMap2;
      }
      privateData = make_shared<map<string, map<string, boost::any>>>(toMap1);
    }
  }


  virtual ~CreateMessageResponseBodyMessagesContentDingNormalCard() = default;
};
class CreateMessageResponseBodyMessagesContentMarkdown : public Darabonba::Model {
public:
  shared_ptr<string> value{};

  CreateMessageResponseBodyMessagesContentMarkdown() {}

  explicit CreateMessageResponseBodyMessagesContentMarkdown(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~CreateMessageResponseBodyMessagesContentMarkdown() = default;
};
class CreateMessageResponseBodyMessagesContentStructViewPartsDataPart : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};

  CreateMessageResponseBodyMessagesContentStructViewPartsDataPart() {}

  explicit CreateMessageResponseBodyMessagesContentStructViewPartsDataPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["data"]));
    }
  }


  virtual ~CreateMessageResponseBodyMessagesContentStructViewPartsDataPart() = default;
};
class CreateMessageResponseBodyMessagesContentStructViewPartsReasonPart : public Darabonba::Model {
public:
  shared_ptr<string> reason{};

  CreateMessageResponseBodyMessagesContentStructViewPartsReasonPart() {}

  explicit CreateMessageResponseBodyMessagesContentStructViewPartsReasonPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
  }


  virtual ~CreateMessageResponseBodyMessagesContentStructViewPartsReasonPart() = default;
};
class CreateMessageResponseBodyMessagesContentStructViewPartsRecommendPartRecommends : public Darabonba::Model {
public:
  shared_ptr<string> mobileUrl{};
  shared_ptr<string> text{};
  shared_ptr<string> url{};

  CreateMessageResponseBodyMessagesContentStructViewPartsRecommendPartRecommends() {}

  explicit CreateMessageResponseBodyMessagesContentStructViewPartsRecommendPartRecommends(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mobileUrl) {
      res["mobileUrl"] = boost::any(*mobileUrl);
    }
    if (text) {
      res["text"] = boost::any(*text);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("mobileUrl") != m.end() && !m["mobileUrl"].empty()) {
      mobileUrl = make_shared<string>(boost::any_cast<string>(m["mobileUrl"]));
    }
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~CreateMessageResponseBodyMessagesContentStructViewPartsRecommendPartRecommends() = default;
};
class CreateMessageResponseBodyMessagesContentStructViewPartsRecommendPart : public Darabonba::Model {
public:
  shared_ptr<vector<CreateMessageResponseBodyMessagesContentStructViewPartsRecommendPartRecommends>> recommends{};

  CreateMessageResponseBodyMessagesContentStructViewPartsRecommendPart() {}

  explicit CreateMessageResponseBodyMessagesContentStructViewPartsRecommendPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommends) {
      vector<boost::any> temp1;
      for(auto item1:*recommends){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["recommends"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("recommends") != m.end() && !m["recommends"].empty()) {
      if (typeid(vector<boost::any>) == m["recommends"].type()) {
        vector<CreateMessageResponseBodyMessagesContentStructViewPartsRecommendPartRecommends> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["recommends"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMessageResponseBodyMessagesContentStructViewPartsRecommendPartRecommends model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recommends = make_shared<vector<CreateMessageResponseBodyMessagesContentStructViewPartsRecommendPartRecommends>>(expect1);
      }
    }
  }


  virtual ~CreateMessageResponseBodyMessagesContentStructViewPartsRecommendPart() = default;
};
class CreateMessageResponseBodyMessagesContentStructViewPartsReferencePartReferences : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceCode{};
  shared_ptr<string> sourceIcon{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  CreateMessageResponseBodyMessagesContentStructViewPartsReferencePartReferences() {}

  explicit CreateMessageResponseBodyMessagesContentStructViewPartsReferencePartReferences(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceCode) {
      res["sourceCode"] = boost::any(*sourceCode);
    }
    if (sourceIcon) {
      res["sourceIcon"] = boost::any(*sourceIcon);
    }
    if (summary) {
      res["summary"] = boost::any(*summary);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceCode") != m.end() && !m["sourceCode"].empty()) {
      sourceCode = make_shared<string>(boost::any_cast<string>(m["sourceCode"]));
    }
    if (m.find("sourceIcon") != m.end() && !m["sourceIcon"].empty()) {
      sourceIcon = make_shared<string>(boost::any_cast<string>(m["sourceIcon"]));
    }
    if (m.find("summary") != m.end() && !m["summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["summary"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~CreateMessageResponseBodyMessagesContentStructViewPartsReferencePartReferences() = default;
};
class CreateMessageResponseBodyMessagesContentStructViewPartsReferencePart : public Darabonba::Model {
public:
  shared_ptr<vector<CreateMessageResponseBodyMessagesContentStructViewPartsReferencePartReferences>> references{};

  CreateMessageResponseBodyMessagesContentStructViewPartsReferencePart() {}

  explicit CreateMessageResponseBodyMessagesContentStructViewPartsReferencePart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (references) {
      vector<boost::any> temp1;
      for(auto item1:*references){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["references"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("references") != m.end() && !m["references"].empty()) {
      if (typeid(vector<boost::any>) == m["references"].type()) {
        vector<CreateMessageResponseBodyMessagesContentStructViewPartsReferencePartReferences> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["references"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMessageResponseBodyMessagesContentStructViewPartsReferencePartReferences model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        references = make_shared<vector<CreateMessageResponseBodyMessagesContentStructViewPartsReferencePartReferences>>(expect1);
      }
    }
  }


  virtual ~CreateMessageResponseBodyMessagesContentStructViewPartsReferencePart() = default;
};
class CreateMessageResponseBodyMessagesContentStructViewPartsTextPart : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  CreateMessageResponseBodyMessagesContentStructViewPartsTextPart() {}

  explicit CreateMessageResponseBodyMessagesContentStructViewPartsTextPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
  }


  virtual ~CreateMessageResponseBodyMessagesContentStructViewPartsTextPart() = default;
};
class CreateMessageResponseBodyMessagesContentStructViewParts : public Darabonba::Model {
public:
  shared_ptr<bool> append{};
  shared_ptr<CreateMessageResponseBodyMessagesContentStructViewPartsDataPart> dataPart{};
  shared_ptr<bool> finish{};
  shared_ptr<string> partDesc{};
  shared_ptr<string> partId{};
  shared_ptr<CreateMessageResponseBodyMessagesContentStructViewPartsReasonPart> reasonPart{};
  shared_ptr<CreateMessageResponseBodyMessagesContentStructViewPartsRecommendPart> recommendPart{};
  shared_ptr<CreateMessageResponseBodyMessagesContentStructViewPartsReferencePart> referencePart{};
  shared_ptr<CreateMessageResponseBodyMessagesContentStructViewPartsTextPart> textPart{};
  shared_ptr<string> type{};

  CreateMessageResponseBodyMessagesContentStructViewParts() {}

  explicit CreateMessageResponseBodyMessagesContentStructViewParts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (append) {
      res["append"] = boost::any(*append);
    }
    if (dataPart) {
      res["dataPart"] = dataPart ? boost::any(dataPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (finish) {
      res["finish"] = boost::any(*finish);
    }
    if (partDesc) {
      res["partDesc"] = boost::any(*partDesc);
    }
    if (partId) {
      res["partId"] = boost::any(*partId);
    }
    if (reasonPart) {
      res["reasonPart"] = reasonPart ? boost::any(reasonPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recommendPart) {
      res["recommendPart"] = recommendPart ? boost::any(recommendPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referencePart) {
      res["referencePart"] = referencePart ? boost::any(referencePart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (textPart) {
      res["textPart"] = textPart ? boost::any(textPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("append") != m.end() && !m["append"].empty()) {
      append = make_shared<bool>(boost::any_cast<bool>(m["append"]));
    }
    if (m.find("dataPart") != m.end() && !m["dataPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["dataPart"].type()) {
        CreateMessageResponseBodyMessagesContentStructViewPartsDataPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dataPart"]));
        dataPart = make_shared<CreateMessageResponseBodyMessagesContentStructViewPartsDataPart>(model1);
      }
    }
    if (m.find("finish") != m.end() && !m["finish"].empty()) {
      finish = make_shared<bool>(boost::any_cast<bool>(m["finish"]));
    }
    if (m.find("partDesc") != m.end() && !m["partDesc"].empty()) {
      partDesc = make_shared<string>(boost::any_cast<string>(m["partDesc"]));
    }
    if (m.find("partId") != m.end() && !m["partId"].empty()) {
      partId = make_shared<string>(boost::any_cast<string>(m["partId"]));
    }
    if (m.find("reasonPart") != m.end() && !m["reasonPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["reasonPart"].type()) {
        CreateMessageResponseBodyMessagesContentStructViewPartsReasonPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["reasonPart"]));
        reasonPart = make_shared<CreateMessageResponseBodyMessagesContentStructViewPartsReasonPart>(model1);
      }
    }
    if (m.find("recommendPart") != m.end() && !m["recommendPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["recommendPart"].type()) {
        CreateMessageResponseBodyMessagesContentStructViewPartsRecommendPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["recommendPart"]));
        recommendPart = make_shared<CreateMessageResponseBodyMessagesContentStructViewPartsRecommendPart>(model1);
      }
    }
    if (m.find("referencePart") != m.end() && !m["referencePart"].empty()) {
      if (typeid(map<string, boost::any>) == m["referencePart"].type()) {
        CreateMessageResponseBodyMessagesContentStructViewPartsReferencePart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["referencePart"]));
        referencePart = make_shared<CreateMessageResponseBodyMessagesContentStructViewPartsReferencePart>(model1);
      }
    }
    if (m.find("textPart") != m.end() && !m["textPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["textPart"].type()) {
        CreateMessageResponseBodyMessagesContentStructViewPartsTextPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["textPart"]));
        textPart = make_shared<CreateMessageResponseBodyMessagesContentStructViewPartsTextPart>(model1);
      }
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateMessageResponseBodyMessagesContentStructViewParts() = default;
};
class CreateMessageResponseBodyMessagesContentStructView : public Darabonba::Model {
public:
  shared_ptr<vector<CreateMessageResponseBodyMessagesContentStructViewParts>> parts{};

  CreateMessageResponseBodyMessagesContentStructView() {}

  explicit CreateMessageResponseBodyMessagesContentStructView(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parts) {
      vector<boost::any> temp1;
      for(auto item1:*parts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["parts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("parts") != m.end() && !m["parts"].empty()) {
      if (typeid(vector<boost::any>) == m["parts"].type()) {
        vector<CreateMessageResponseBodyMessagesContentStructViewParts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["parts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMessageResponseBodyMessagesContentStructViewParts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parts = make_shared<vector<CreateMessageResponseBodyMessagesContentStructViewParts>>(expect1);
      }
    }
  }


  virtual ~CreateMessageResponseBodyMessagesContentStructView() = default;
};
class CreateMessageResponseBodyMessagesContentText : public Darabonba::Model {
public:
  shared_ptr<string> value{};

  CreateMessageResponseBodyMessagesContentText() {}

  explicit CreateMessageResponseBodyMessagesContentText(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~CreateMessageResponseBodyMessagesContentText() = default;
};
class CreateMessageResponseBodyMessagesContent : public Darabonba::Model {
public:
  shared_ptr<CreateMessageResponseBodyMessagesContentCardCallback> cardCallback{};
  shared_ptr<CreateMessageResponseBodyMessagesContentDingCard> dingCard{};
  shared_ptr<CreateMessageResponseBodyMessagesContentDingNormalCard> dingNormalCard{};
  shared_ptr<CreateMessageResponseBodyMessagesContentMarkdown> markdown{};
  shared_ptr<CreateMessageResponseBodyMessagesContentStructView> structView{};
  shared_ptr<CreateMessageResponseBodyMessagesContentText> text{};
  shared_ptr<string> type{};

  CreateMessageResponseBodyMessagesContent() {}

  explicit CreateMessageResponseBodyMessagesContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardCallback) {
      res["cardCallback"] = cardCallback ? boost::any(cardCallback->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dingCard) {
      res["dingCard"] = dingCard ? boost::any(dingCard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dingNormalCard) {
      res["dingNormalCard"] = dingNormalCard ? boost::any(dingNormalCard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (markdown) {
      res["markdown"] = markdown ? boost::any(markdown->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (structView) {
      res["structView"] = structView ? boost::any(structView->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (text) {
      res["text"] = text ? boost::any(text->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cardCallback") != m.end() && !m["cardCallback"].empty()) {
      if (typeid(map<string, boost::any>) == m["cardCallback"].type()) {
        CreateMessageResponseBodyMessagesContentCardCallback model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cardCallback"]));
        cardCallback = make_shared<CreateMessageResponseBodyMessagesContentCardCallback>(model1);
      }
    }
    if (m.find("dingCard") != m.end() && !m["dingCard"].empty()) {
      if (typeid(map<string, boost::any>) == m["dingCard"].type()) {
        CreateMessageResponseBodyMessagesContentDingCard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dingCard"]));
        dingCard = make_shared<CreateMessageResponseBodyMessagesContentDingCard>(model1);
      }
    }
    if (m.find("dingNormalCard") != m.end() && !m["dingNormalCard"].empty()) {
      if (typeid(map<string, boost::any>) == m["dingNormalCard"].type()) {
        CreateMessageResponseBodyMessagesContentDingNormalCard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dingNormalCard"]));
        dingNormalCard = make_shared<CreateMessageResponseBodyMessagesContentDingNormalCard>(model1);
      }
    }
    if (m.find("markdown") != m.end() && !m["markdown"].empty()) {
      if (typeid(map<string, boost::any>) == m["markdown"].type()) {
        CreateMessageResponseBodyMessagesContentMarkdown model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["markdown"]));
        markdown = make_shared<CreateMessageResponseBodyMessagesContentMarkdown>(model1);
      }
    }
    if (m.find("structView") != m.end() && !m["structView"].empty()) {
      if (typeid(map<string, boost::any>) == m["structView"].type()) {
        CreateMessageResponseBodyMessagesContentStructView model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["structView"]));
        structView = make_shared<CreateMessageResponseBodyMessagesContentStructView>(model1);
      }
    }
    if (m.find("text") != m.end() && !m["text"].empty()) {
      if (typeid(map<string, boost::any>) == m["text"].type()) {
        CreateMessageResponseBodyMessagesContentText model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["text"]));
        text = make_shared<CreateMessageResponseBodyMessagesContentText>(model1);
      }
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateMessageResponseBodyMessagesContent() = default;
};
class CreateMessageResponseBodyMessages : public Darabonba::Model {
public:
  shared_ptr<CreateMessageResponseBodyMessagesContent> content{};
  shared_ptr<string> contentDesc{};
  shared_ptr<long> createAt{};
  shared_ptr<string> id{};
  shared_ptr<string> role{};
  shared_ptr<string> runId{};
  shared_ptr<string> threadId{};

  CreateMessageResponseBodyMessages() {}

  explicit CreateMessageResponseBodyMessages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contentDesc) {
      res["contentDesc"] = boost::any(*contentDesc);
    }
    if (createAt) {
      res["createAt"] = boost::any(*createAt);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (role) {
      res["role"] = boost::any(*role);
    }
    if (runId) {
      res["runId"] = boost::any(*runId);
    }
    if (threadId) {
      res["threadId"] = boost::any(*threadId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      if (typeid(map<string, boost::any>) == m["content"].type()) {
        CreateMessageResponseBodyMessagesContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["content"]));
        content = make_shared<CreateMessageResponseBodyMessagesContent>(model1);
      }
    }
    if (m.find("contentDesc") != m.end() && !m["contentDesc"].empty()) {
      contentDesc = make_shared<string>(boost::any_cast<string>(m["contentDesc"]));
    }
    if (m.find("createAt") != m.end() && !m["createAt"].empty()) {
      createAt = make_shared<long>(boost::any_cast<long>(m["createAt"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("role") != m.end() && !m["role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["role"]));
    }
    if (m.find("runId") != m.end() && !m["runId"].empty()) {
      runId = make_shared<string>(boost::any_cast<string>(m["runId"]));
    }
    if (m.find("threadId") != m.end() && !m["threadId"].empty()) {
      threadId = make_shared<string>(boost::any_cast<string>(m["threadId"]));
    }
  }


  virtual ~CreateMessageResponseBodyMessages() = default;
};
class CreateMessageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<CreateMessageResponseBodyMessages>> messages{};
  shared_ptr<string> requestId{};

  CreateMessageResponseBody() {}

  explicit CreateMessageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messages) {
      vector<boost::any> temp1;
      for(auto item1:*messages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["messages"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("messages") != m.end() && !m["messages"].empty()) {
      if (typeid(vector<boost::any>) == m["messages"].type()) {
        vector<CreateMessageResponseBodyMessages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["messages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMessageResponseBodyMessages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        messages = make_shared<vector<CreateMessageResponseBodyMessages>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateMessageResponseBody() = default;
};
class CreateMessageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMessageResponseBody> body{};

  CreateMessageResponse() {}

  explicit CreateMessageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMessageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMessageResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMessageResponse() = default;
};
class CreateMultiDimTableFieldHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateMultiDimTableFieldHeadersAccountContext() {}

  explicit CreateMultiDimTableFieldHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateMultiDimTableFieldHeadersAccountContext() = default;
};
class CreateMultiDimTableFieldHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateMultiDimTableFieldHeadersAccountContext> accountContext{};

  CreateMultiDimTableFieldHeaders() {}

  explicit CreateMultiDimTableFieldHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateMultiDimTableFieldHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateMultiDimTableFieldHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateMultiDimTableFieldHeaders() = default;
};
class CreateMultiDimTableFieldShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateMultiDimTableFieldShrinkHeaders() {}

  explicit CreateMultiDimTableFieldShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateMultiDimTableFieldShrinkHeaders() = default;
};
class CreateMultiDimTableFieldRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateMultiDimTableFieldRequestTenantContext() {}

  explicit CreateMultiDimTableFieldRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateMultiDimTableFieldRequestTenantContext() = default;
};
class CreateMultiDimTableFieldRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<string> name{};
  shared_ptr<map<string, boost::any>> property{};
  shared_ptr<string> sheetIdOrName{};
  shared_ptr<CreateMultiDimTableFieldRequestTenantContext> tenantContext{};
  shared_ptr<string> type{};

  CreateMultiDimTableFieldRequest() {}

  explicit CreateMultiDimTableFieldRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (property) {
      res["Property"] = boost::any(*property);
    }
    if (sheetIdOrName) {
      res["SheetIdOrName"] = boost::any(*sheetIdOrName);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Property"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      property = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SheetIdOrName") != m.end() && !m["SheetIdOrName"].empty()) {
      sheetIdOrName = make_shared<string>(boost::any_cast<string>(m["SheetIdOrName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateMultiDimTableFieldRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateMultiDimTableFieldRequestTenantContext>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateMultiDimTableFieldRequest() = default;
};
class CreateMultiDimTableFieldShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<string> name{};
  shared_ptr<string> propertyShrink{};
  shared_ptr<string> sheetIdOrName{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> type{};

  CreateMultiDimTableFieldShrinkRequest() {}

  explicit CreateMultiDimTableFieldShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (propertyShrink) {
      res["Property"] = boost::any(*propertyShrink);
    }
    if (sheetIdOrName) {
      res["SheetIdOrName"] = boost::any(*sheetIdOrName);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      propertyShrink = make_shared<string>(boost::any_cast<string>(m["Property"]));
    }
    if (m.find("SheetIdOrName") != m.end() && !m["SheetIdOrName"].empty()) {
      sheetIdOrName = make_shared<string>(boost::any_cast<string>(m["SheetIdOrName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateMultiDimTableFieldShrinkRequest() = default;
};
class CreateMultiDimTableFieldResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<map<string, boost::any>> property{};
  shared_ptr<string> type{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  CreateMultiDimTableFieldResponseBody() {}

  explicit CreateMultiDimTableFieldResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (property) {
      res["Property"] = boost::any(*property);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Property"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      property = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~CreateMultiDimTableFieldResponseBody() = default;
};
class CreateMultiDimTableFieldResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMultiDimTableFieldResponseBody> body{};

  CreateMultiDimTableFieldResponse() {}

  explicit CreateMultiDimTableFieldResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMultiDimTableFieldResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMultiDimTableFieldResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMultiDimTableFieldResponse() = default;
};
class CreateOrUpdateFormDataHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateOrUpdateFormDataHeadersAccountContext() {}

  explicit CreateOrUpdateFormDataHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateOrUpdateFormDataHeadersAccountContext() = default;
};
class CreateOrUpdateFormDataHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateOrUpdateFormDataHeadersAccountContext> accountContext{};

  CreateOrUpdateFormDataHeaders() {}

  explicit CreateOrUpdateFormDataHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateOrUpdateFormDataHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateOrUpdateFormDataHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateFormDataHeaders() = default;
};
class CreateOrUpdateFormDataShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateOrUpdateFormDataShrinkHeaders() {}

  explicit CreateOrUpdateFormDataShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateOrUpdateFormDataShrinkHeaders() = default;
};
class CreateOrUpdateFormDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> formDataJson{};
  shared_ptr<string> formUuid{};
  shared_ptr<bool> noExecuteExpression{};
  shared_ptr<string> searchCondition{};
  shared_ptr<string> systemToken{};
  shared_ptr<string> userId{};

  CreateOrUpdateFormDataRequest() {}

  explicit CreateOrUpdateFormDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (formDataJson) {
      res["FormDataJson"] = boost::any(*formDataJson);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (noExecuteExpression) {
      res["NoExecuteExpression"] = boost::any(*noExecuteExpression);
    }
    if (searchCondition) {
      res["SearchCondition"] = boost::any(*searchCondition);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("FormDataJson") != m.end() && !m["FormDataJson"].empty()) {
      formDataJson = make_shared<string>(boost::any_cast<string>(m["FormDataJson"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("NoExecuteExpression") != m.end() && !m["NoExecuteExpression"].empty()) {
      noExecuteExpression = make_shared<bool>(boost::any_cast<bool>(m["NoExecuteExpression"]));
    }
    if (m.find("SearchCondition") != m.end() && !m["SearchCondition"].empty()) {
      searchCondition = make_shared<string>(boost::any_cast<string>(m["SearchCondition"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CreateOrUpdateFormDataRequest() = default;
};
class CreateOrUpdateFormDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> result{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  CreateOrUpdateFormDataResponseBody() {}

  explicit CreateOrUpdateFormDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["result"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      result = make_shared<vector<string>>(toVec1);
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~CreateOrUpdateFormDataResponseBody() = default;
};
class CreateOrUpdateFormDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrUpdateFormDataResponseBody> body{};

  CreateOrUpdateFormDataResponse() {}

  explicit CreateOrUpdateFormDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrUpdateFormDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrUpdateFormDataResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateFormDataResponse() = default;
};
class CreateOrgHonorTemplateHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateOrgHonorTemplateHeadersAccountContext() {}

  explicit CreateOrgHonorTemplateHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateOrgHonorTemplateHeadersAccountContext() = default;
};
class CreateOrgHonorTemplateHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateOrgHonorTemplateHeadersAccountContext> accountContext{};

  CreateOrgHonorTemplateHeaders() {}

  explicit CreateOrgHonorTemplateHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateOrgHonorTemplateHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateOrgHonorTemplateHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateOrgHonorTemplateHeaders() = default;
};
class CreateOrgHonorTemplateShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateOrgHonorTemplateShrinkHeaders() {}

  explicit CreateOrgHonorTemplateShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateOrgHonorTemplateShrinkHeaders() = default;
};
class CreateOrgHonorTemplateRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateOrgHonorTemplateRequestTenantContext() {}

  explicit CreateOrgHonorTemplateRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateOrgHonorTemplateRequestTenantContext() = default;
};
class CreateOrgHonorTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<CreateOrgHonorTemplateRequestTenantContext> tenantContext{};
  shared_ptr<string> avatarFrameMediaId{};
  shared_ptr<string> defaultBgColor{};
  shared_ptr<string> medalDesc{};
  shared_ptr<string> medalMediaId{};
  shared_ptr<string> medalName{};
  shared_ptr<long> orgId{};
  shared_ptr<string> userId{};

  CreateOrgHonorTemplateRequest() {}

  explicit CreateOrgHonorTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (avatarFrameMediaId) {
      res["avatarFrameMediaId"] = boost::any(*avatarFrameMediaId);
    }
    if (defaultBgColor) {
      res["defaultBgColor"] = boost::any(*defaultBgColor);
    }
    if (medalDesc) {
      res["medalDesc"] = boost::any(*medalDesc);
    }
    if (medalMediaId) {
      res["medalMediaId"] = boost::any(*medalMediaId);
    }
    if (medalName) {
      res["medalName"] = boost::any(*medalName);
    }
    if (orgId) {
      res["orgId"] = boost::any(*orgId);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateOrgHonorTemplateRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateOrgHonorTemplateRequestTenantContext>(model1);
      }
    }
    if (m.find("avatarFrameMediaId") != m.end() && !m["avatarFrameMediaId"].empty()) {
      avatarFrameMediaId = make_shared<string>(boost::any_cast<string>(m["avatarFrameMediaId"]));
    }
    if (m.find("defaultBgColor") != m.end() && !m["defaultBgColor"].empty()) {
      defaultBgColor = make_shared<string>(boost::any_cast<string>(m["defaultBgColor"]));
    }
    if (m.find("medalDesc") != m.end() && !m["medalDesc"].empty()) {
      medalDesc = make_shared<string>(boost::any_cast<string>(m["medalDesc"]));
    }
    if (m.find("medalMediaId") != m.end() && !m["medalMediaId"].empty()) {
      medalMediaId = make_shared<string>(boost::any_cast<string>(m["medalMediaId"]));
    }
    if (m.find("medalName") != m.end() && !m["medalName"].empty()) {
      medalName = make_shared<string>(boost::any_cast<string>(m["medalName"]));
    }
    if (m.find("orgId") != m.end() && !m["orgId"].empty()) {
      orgId = make_shared<long>(boost::any_cast<long>(m["orgId"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~CreateOrgHonorTemplateRequest() = default;
};
class CreateOrgHonorTemplateShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> avatarFrameMediaId{};
  shared_ptr<string> defaultBgColor{};
  shared_ptr<string> medalDesc{};
  shared_ptr<string> medalMediaId{};
  shared_ptr<string> medalName{};
  shared_ptr<long> orgId{};
  shared_ptr<string> userId{};

  CreateOrgHonorTemplateShrinkRequest() {}

  explicit CreateOrgHonorTemplateShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (avatarFrameMediaId) {
      res["avatarFrameMediaId"] = boost::any(*avatarFrameMediaId);
    }
    if (defaultBgColor) {
      res["defaultBgColor"] = boost::any(*defaultBgColor);
    }
    if (medalDesc) {
      res["medalDesc"] = boost::any(*medalDesc);
    }
    if (medalMediaId) {
      res["medalMediaId"] = boost::any(*medalMediaId);
    }
    if (medalName) {
      res["medalName"] = boost::any(*medalName);
    }
    if (orgId) {
      res["orgId"] = boost::any(*orgId);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("avatarFrameMediaId") != m.end() && !m["avatarFrameMediaId"].empty()) {
      avatarFrameMediaId = make_shared<string>(boost::any_cast<string>(m["avatarFrameMediaId"]));
    }
    if (m.find("defaultBgColor") != m.end() && !m["defaultBgColor"].empty()) {
      defaultBgColor = make_shared<string>(boost::any_cast<string>(m["defaultBgColor"]));
    }
    if (m.find("medalDesc") != m.end() && !m["medalDesc"].empty()) {
      medalDesc = make_shared<string>(boost::any_cast<string>(m["medalDesc"]));
    }
    if (m.find("medalMediaId") != m.end() && !m["medalMediaId"].empty()) {
      medalMediaId = make_shared<string>(boost::any_cast<string>(m["medalMediaId"]));
    }
    if (m.find("medalName") != m.end() && !m["medalName"].empty()) {
      medalName = make_shared<string>(boost::any_cast<string>(m["medalName"]));
    }
    if (m.find("orgId") != m.end() && !m["orgId"].empty()) {
      orgId = make_shared<long>(boost::any_cast<long>(m["orgId"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~CreateOrgHonorTemplateShrinkRequest() = default;
};
class CreateOrgHonorTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> honorId{};
  shared_ptr<string> requestId{};

  CreateOrgHonorTemplateResponseBody() {}

  explicit CreateOrgHonorTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (honorId) {
      res["honorId"] = boost::any(*honorId);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("honorId") != m.end() && !m["honorId"].empty()) {
      honorId = make_shared<string>(boost::any_cast<string>(m["honorId"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateOrgHonorTemplateResponseBody() = default;
};
class CreateOrgHonorTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrgHonorTemplateResponseBody> body{};

  CreateOrgHonorTemplateResponse() {}

  explicit CreateOrgHonorTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrgHonorTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrgHonorTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrgHonorTemplateResponse() = default;
};
class CreatePersonalTodoTaskHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreatePersonalTodoTaskHeadersAccountContext() {}

  explicit CreatePersonalTodoTaskHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreatePersonalTodoTaskHeadersAccountContext() = default;
};
class CreatePersonalTodoTaskHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreatePersonalTodoTaskHeadersAccountContext> accountContext{};

  CreatePersonalTodoTaskHeaders() {}

  explicit CreatePersonalTodoTaskHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreatePersonalTodoTaskHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreatePersonalTodoTaskHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreatePersonalTodoTaskHeaders() = default;
};
class CreatePersonalTodoTaskShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreatePersonalTodoTaskShrinkHeaders() {}

  explicit CreatePersonalTodoTaskShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreatePersonalTodoTaskShrinkHeaders() = default;
};
class CreatePersonalTodoTaskRequestNotifyConfigs : public Darabonba::Model {
public:
  shared_ptr<string> dingNotify{};

  CreatePersonalTodoTaskRequestNotifyConfigs() {}

  explicit CreatePersonalTodoTaskRequestNotifyConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dingNotify) {
      res["DingNotify"] = boost::any(*dingNotify);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DingNotify") != m.end() && !m["DingNotify"].empty()) {
      dingNotify = make_shared<string>(boost::any_cast<string>(m["DingNotify"]));
    }
  }


  virtual ~CreatePersonalTodoTaskRequestNotifyConfigs() = default;
};
class CreatePersonalTodoTaskRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreatePersonalTodoTaskRequestTenantContext() {}

  explicit CreatePersonalTodoTaskRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreatePersonalTodoTaskRequestTenantContext() = default;
};
class CreatePersonalTodoTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> dueTime{};
  shared_ptr<vector<string>> executorIds{};
  shared_ptr<CreatePersonalTodoTaskRequestNotifyConfigs> notifyConfigs{};
  shared_ptr<vector<string>> participantIds{};
  shared_ptr<long> reminderTimeStamp{};
  shared_ptr<string> subject{};
  shared_ptr<CreatePersonalTodoTaskRequestTenantContext> tenantContext{};

  CreatePersonalTodoTaskRequest() {}

  explicit CreatePersonalTodoTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dueTime) {
      res["DueTime"] = boost::any(*dueTime);
    }
    if (executorIds) {
      res["ExecutorIds"] = boost::any(*executorIds);
    }
    if (notifyConfigs) {
      res["NotifyConfigs"] = notifyConfigs ? boost::any(notifyConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (participantIds) {
      res["ParticipantIds"] = boost::any(*participantIds);
    }
    if (reminderTimeStamp) {
      res["ReminderTimeStamp"] = boost::any(*reminderTimeStamp);
    }
    if (subject) {
      res["Subject"] = boost::any(*subject);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DueTime") != m.end() && !m["DueTime"].empty()) {
      dueTime = make_shared<long>(boost::any_cast<long>(m["DueTime"]));
    }
    if (m.find("ExecutorIds") != m.end() && !m["ExecutorIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExecutorIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExecutorIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      executorIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NotifyConfigs") != m.end() && !m["NotifyConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyConfigs"].type()) {
        CreatePersonalTodoTaskRequestNotifyConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyConfigs"]));
        notifyConfigs = make_shared<CreatePersonalTodoTaskRequestNotifyConfigs>(model1);
      }
    }
    if (m.find("ParticipantIds") != m.end() && !m["ParticipantIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ParticipantIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ParticipantIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      participantIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ReminderTimeStamp") != m.end() && !m["ReminderTimeStamp"].empty()) {
      reminderTimeStamp = make_shared<long>(boost::any_cast<long>(m["ReminderTimeStamp"]));
    }
    if (m.find("Subject") != m.end() && !m["Subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["Subject"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreatePersonalTodoTaskRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreatePersonalTodoTaskRequestTenantContext>(model1);
      }
    }
  }


  virtual ~CreatePersonalTodoTaskRequest() = default;
};
class CreatePersonalTodoTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> dueTime{};
  shared_ptr<string> executorIdsShrink{};
  shared_ptr<string> notifyConfigsShrink{};
  shared_ptr<string> participantIdsShrink{};
  shared_ptr<long> reminderTimeStamp{};
  shared_ptr<string> subject{};
  shared_ptr<string> tenantContextShrink{};

  CreatePersonalTodoTaskShrinkRequest() {}

  explicit CreatePersonalTodoTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dueTime) {
      res["DueTime"] = boost::any(*dueTime);
    }
    if (executorIdsShrink) {
      res["ExecutorIds"] = boost::any(*executorIdsShrink);
    }
    if (notifyConfigsShrink) {
      res["NotifyConfigs"] = boost::any(*notifyConfigsShrink);
    }
    if (participantIdsShrink) {
      res["ParticipantIds"] = boost::any(*participantIdsShrink);
    }
    if (reminderTimeStamp) {
      res["ReminderTimeStamp"] = boost::any(*reminderTimeStamp);
    }
    if (subject) {
      res["Subject"] = boost::any(*subject);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DueTime") != m.end() && !m["DueTime"].empty()) {
      dueTime = make_shared<long>(boost::any_cast<long>(m["DueTime"]));
    }
    if (m.find("ExecutorIds") != m.end() && !m["ExecutorIds"].empty()) {
      executorIdsShrink = make_shared<string>(boost::any_cast<string>(m["ExecutorIds"]));
    }
    if (m.find("NotifyConfigs") != m.end() && !m["NotifyConfigs"].empty()) {
      notifyConfigsShrink = make_shared<string>(boost::any_cast<string>(m["NotifyConfigs"]));
    }
    if (m.find("ParticipantIds") != m.end() && !m["ParticipantIds"].empty()) {
      participantIdsShrink = make_shared<string>(boost::any_cast<string>(m["ParticipantIds"]));
    }
    if (m.find("ReminderTimeStamp") != m.end() && !m["ReminderTimeStamp"].empty()) {
      reminderTimeStamp = make_shared<long>(boost::any_cast<long>(m["ReminderTimeStamp"]));
    }
    if (m.find("Subject") != m.end() && !m["Subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["Subject"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~CreatePersonalTodoTaskShrinkRequest() = default;
};
class CreatePersonalTodoTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> createdTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  CreatePersonalTodoTaskResponseBody() {}

  explicit CreatePersonalTodoTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["createdTime"] = boost::any(*createdTime);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createdTime") != m.end() && !m["createdTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["createdTime"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~CreatePersonalTodoTaskResponseBody() = default;
};
class CreatePersonalTodoTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePersonalTodoTaskResponseBody> body{};

  CreatePersonalTodoTaskResponse() {}

  explicit CreatePersonalTodoTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePersonalTodoTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePersonalTodoTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePersonalTodoTaskResponse() = default;
};
class CreateReportHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateReportHeadersAccountContext() {}

  explicit CreateReportHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateReportHeadersAccountContext() = default;
};
class CreateReportHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateReportHeadersAccountContext> accountContext{};

  CreateReportHeaders() {}

  explicit CreateReportHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateReportHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateReportHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateReportHeaders() = default;
};
class CreateReportShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateReportShrinkHeaders() {}

  explicit CreateReportShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateReportShrinkHeaders() = default;
};
class CreateReportRequestContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentType{};
  shared_ptr<string> key{};
  shared_ptr<long> sort{};
  shared_ptr<long> type{};

  CreateReportRequestContents() {}

  explicit CreateReportRequestContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<long>(boost::any_cast<long>(m["Sort"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~CreateReportRequestContents() = default;
};
class CreateReportRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateReportRequestTenantContext() {}

  explicit CreateReportRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateReportRequestTenantContext() = default;
};
class CreateReportRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateReportRequestContents>> contents{};
  shared_ptr<string> ddFrom{};
  shared_ptr<string> templateId{};
  shared_ptr<CreateReportRequestTenantContext> tenantContext{};
  shared_ptr<bool> toChat{};
  shared_ptr<vector<string>> toCids{};
  shared_ptr<vector<string>> toUserids{};

  CreateReportRequest() {}

  explicit CreateReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contents) {
      vector<boost::any> temp1;
      for(auto item1:*contents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contents"] = boost::any(temp1);
    }
    if (ddFrom) {
      res["DdFrom"] = boost::any(*ddFrom);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (toChat) {
      res["ToChat"] = boost::any(*toChat);
    }
    if (toCids) {
      res["ToCids"] = boost::any(*toCids);
    }
    if (toUserids) {
      res["ToUserids"] = boost::any(*toUserids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      if (typeid(vector<boost::any>) == m["Contents"].type()) {
        vector<CreateReportRequestContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateReportRequestContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contents = make_shared<vector<CreateReportRequestContents>>(expect1);
      }
    }
    if (m.find("DdFrom") != m.end() && !m["DdFrom"].empty()) {
      ddFrom = make_shared<string>(boost::any_cast<string>(m["DdFrom"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateReportRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateReportRequestTenantContext>(model1);
      }
    }
    if (m.find("ToChat") != m.end() && !m["ToChat"].empty()) {
      toChat = make_shared<bool>(boost::any_cast<bool>(m["ToChat"]));
    }
    if (m.find("ToCids") != m.end() && !m["ToCids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ToCids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ToCids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      toCids = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ToUserids") != m.end() && !m["ToUserids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ToUserids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ToUserids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      toUserids = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateReportRequest() = default;
};
class CreateReportShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> contentsShrink{};
  shared_ptr<string> ddFrom{};
  shared_ptr<string> templateId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<bool> toChat{};
  shared_ptr<string> toCidsShrink{};
  shared_ptr<string> toUseridsShrink{};

  CreateReportShrinkRequest() {}

  explicit CreateReportShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentsShrink) {
      res["Contents"] = boost::any(*contentsShrink);
    }
    if (ddFrom) {
      res["DdFrom"] = boost::any(*ddFrom);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (toChat) {
      res["ToChat"] = boost::any(*toChat);
    }
    if (toCidsShrink) {
      res["ToCids"] = boost::any(*toCidsShrink);
    }
    if (toUseridsShrink) {
      res["ToUserids"] = boost::any(*toUseridsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      contentsShrink = make_shared<string>(boost::any_cast<string>(m["Contents"]));
    }
    if (m.find("DdFrom") != m.end() && !m["DdFrom"].empty()) {
      ddFrom = make_shared<string>(boost::any_cast<string>(m["DdFrom"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("ToChat") != m.end() && !m["ToChat"].empty()) {
      toChat = make_shared<bool>(boost::any_cast<bool>(m["ToChat"]));
    }
    if (m.find("ToCids") != m.end() && !m["ToCids"].empty()) {
      toCidsShrink = make_shared<string>(boost::any_cast<string>(m["ToCids"]));
    }
    if (m.find("ToUserids") != m.end() && !m["ToUserids"].empty()) {
      toUseridsShrink = make_shared<string>(boost::any_cast<string>(m["ToUserids"]));
    }
  }


  virtual ~CreateReportShrinkRequest() = default;
};
class CreateReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateReportResponseBody() {}

  explicit CreateReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateReportResponseBody() = default;
};
class CreateReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateReportResponseBody> body{};

  CreateReportResponse() {}

  explicit CreateReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateReportResponseBody>(model1);
      }
    }
  }


  virtual ~CreateReportResponse() = default;
};
class CreateRunHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountId{};

  CreateRunHeaders() {}

  explicit CreateRunHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateRunHeaders() = default;
};
class CreateRunRequest : public Darabonba::Model {
public:
  shared_ptr<string> assistantId{};
  shared_ptr<string> originalAssistantId{};
  shared_ptr<string> sourceIdOfOriginalAssistantId{};
  shared_ptr<string> sourceTypeOfOriginalAssistantId{};
  shared_ptr<bool> stream{};
  shared_ptr<string> threadId{};

  CreateRunRequest() {}

  explicit CreateRunRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assistantId) {
      res["assistantId"] = boost::any(*assistantId);
    }
    if (originalAssistantId) {
      res["originalAssistantId"] = boost::any(*originalAssistantId);
    }
    if (sourceIdOfOriginalAssistantId) {
      res["sourceIdOfOriginalAssistantId"] = boost::any(*sourceIdOfOriginalAssistantId);
    }
    if (sourceTypeOfOriginalAssistantId) {
      res["sourceTypeOfOriginalAssistantId"] = boost::any(*sourceTypeOfOriginalAssistantId);
    }
    if (stream) {
      res["stream"] = boost::any(*stream);
    }
    if (threadId) {
      res["threadId"] = boost::any(*threadId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assistantId") != m.end() && !m["assistantId"].empty()) {
      assistantId = make_shared<string>(boost::any_cast<string>(m["assistantId"]));
    }
    if (m.find("originalAssistantId") != m.end() && !m["originalAssistantId"].empty()) {
      originalAssistantId = make_shared<string>(boost::any_cast<string>(m["originalAssistantId"]));
    }
    if (m.find("sourceIdOfOriginalAssistantId") != m.end() && !m["sourceIdOfOriginalAssistantId"].empty()) {
      sourceIdOfOriginalAssistantId = make_shared<string>(boost::any_cast<string>(m["sourceIdOfOriginalAssistantId"]));
    }
    if (m.find("sourceTypeOfOriginalAssistantId") != m.end() && !m["sourceTypeOfOriginalAssistantId"].empty()) {
      sourceTypeOfOriginalAssistantId = make_shared<string>(boost::any_cast<string>(m["sourceTypeOfOriginalAssistantId"]));
    }
    if (m.find("stream") != m.end() && !m["stream"].empty()) {
      stream = make_shared<bool>(boost::any_cast<bool>(m["stream"]));
    }
    if (m.find("threadId") != m.end() && !m["threadId"].empty()) {
      threadId = make_shared<string>(boost::any_cast<string>(m["threadId"]));
    }
  }


  virtual ~CreateRunRequest() = default;
};
class CreateRunResponseBodyMessagesContentCardCallback : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> relatedMessageId{};

  CreateRunResponseBodyMessagesContentCardCallback() {}

  explicit CreateRunResponseBodyMessagesContentCardCallback(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (relatedMessageId) {
      res["relatedMessageId"] = boost::any(*relatedMessageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("relatedMessageId") != m.end() && !m["relatedMessageId"].empty()) {
      relatedMessageId = make_shared<string>(boost::any_cast<string>(m["relatedMessageId"]));
    }
  }


  virtual ~CreateRunResponseBodyMessagesContentCardCallback() = default;
};
class CreateRunResponseBodyMessagesContentDingCard : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentType{};
  shared_ptr<bool> finished{};
  shared_ptr<string> templateId{};

  CreateRunResponseBodyMessagesContentDingCard() {}

  explicit CreateRunResponseBodyMessagesContentDingCard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (contentType) {
      res["contentType"] = boost::any(*contentType);
    }
    if (finished) {
      res["finished"] = boost::any(*finished);
    }
    if (templateId) {
      res["templateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("contentType") != m.end() && !m["contentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["contentType"]));
    }
    if (m.find("finished") != m.end() && !m["finished"].empty()) {
      finished = make_shared<bool>(boost::any_cast<bool>(m["finished"]));
    }
    if (m.find("templateId") != m.end() && !m["templateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["templateId"]));
    }
  }


  virtual ~CreateRunResponseBodyMessagesContentDingCard() = default;
};
class CreateRunResponseBodyMessagesContentDingNormalCardCardData : public Darabonba::Model {
public:
  shared_ptr<boost::any> cardParamMap{};

  CreateRunResponseBodyMessagesContentDingNormalCardCardData() {}

  explicit CreateRunResponseBodyMessagesContentDingNormalCardCardData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardParamMap) {
      res["cardParamMap"] = boost::any(*cardParamMap);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cardParamMap") != m.end() && !m["cardParamMap"].empty()) {
      cardParamMap = make_shared<boost::any>(boost::any_cast<boost::any>(m["cardParamMap"]));
    }
  }


  virtual ~CreateRunResponseBodyMessagesContentDingNormalCardCardData() = default;
};
class CreateRunResponseBodyMessagesContentDingNormalCardCardUpdateOptions : public Darabonba::Model {
public:
  shared_ptr<bool> updateCardDataByKey{};
  shared_ptr<bool> updatePrivateDataByKey{};

  CreateRunResponseBodyMessagesContentDingNormalCardCardUpdateOptions() {}

  explicit CreateRunResponseBodyMessagesContentDingNormalCardCardUpdateOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateCardDataByKey) {
      res["updateCardDataByKey"] = boost::any(*updateCardDataByKey);
    }
    if (updatePrivateDataByKey) {
      res["updatePrivateDataByKey"] = boost::any(*updatePrivateDataByKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("updateCardDataByKey") != m.end() && !m["updateCardDataByKey"].empty()) {
      updateCardDataByKey = make_shared<bool>(boost::any_cast<bool>(m["updateCardDataByKey"]));
    }
    if (m.find("updatePrivateDataByKey") != m.end() && !m["updatePrivateDataByKey"].empty()) {
      updatePrivateDataByKey = make_shared<bool>(boost::any_cast<bool>(m["updatePrivateDataByKey"]));
    }
  }


  virtual ~CreateRunResponseBodyMessagesContentDingNormalCardCardUpdateOptions() = default;
};
class CreateRunResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig : public Darabonba::Model {
public:
  shared_ptr<long> interval{};
  shared_ptr<string> pullStrategy{};
  shared_ptr<string> timeUnit{};

  CreateRunResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig() {}

  explicit CreateRunResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interval) {
      res["interval"] = boost::any(*interval);
    }
    if (pullStrategy) {
      res["pullStrategy"] = boost::any(*pullStrategy);
    }
    if (timeUnit) {
      res["timeUnit"] = boost::any(*timeUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("interval") != m.end() && !m["interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["interval"]));
    }
    if (m.find("pullStrategy") != m.end() && !m["pullStrategy"].empty()) {
      pullStrategy = make_shared<string>(boost::any_cast<string>(m["pullStrategy"]));
    }
    if (m.find("timeUnit") != m.end() && !m["timeUnit"].empty()) {
      timeUnit = make_shared<string>(boost::any_cast<string>(m["timeUnit"]));
    }
  }


  virtual ~CreateRunResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig() = default;
};
class CreateRunResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> constParams{};
  shared_ptr<string> dynamicDataSourceId{};
  shared_ptr<CreateRunResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig> pullConfig{};

  CreateRunResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs() {}

  explicit CreateRunResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constParams) {
      res["constParams"] = boost::any(*constParams);
    }
    if (dynamicDataSourceId) {
      res["dynamicDataSourceId"] = boost::any(*dynamicDataSourceId);
    }
    if (pullConfig) {
      res["pullConfig"] = pullConfig ? boost::any(pullConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("constParams") != m.end() && !m["constParams"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["constParams"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      constParams = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("dynamicDataSourceId") != m.end() && !m["dynamicDataSourceId"].empty()) {
      dynamicDataSourceId = make_shared<string>(boost::any_cast<string>(m["dynamicDataSourceId"]));
    }
    if (m.find("pullConfig") != m.end() && !m["pullConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["pullConfig"].type()) {
        CreateRunResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["pullConfig"]));
        pullConfig = make_shared<CreateRunResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig>(model1);
      }
    }
  }


  virtual ~CreateRunResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs() = default;
};
class CreateRunResponseBodyMessagesContentDingNormalCard : public Darabonba::Model {
public:
  shared_ptr<CreateRunResponseBodyMessagesContentDingNormalCardCardData> cardData{};
  shared_ptr<string> cardTemplateId{};
  shared_ptr<CreateRunResponseBodyMessagesContentDingNormalCardCardUpdateOptions> cardUpdateOptions{};
  shared_ptr<vector<CreateRunResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs>> dynamicDataSourceConfigs{};
  shared_ptr<map<string, map<string, boost::any>>> privateData{};

  CreateRunResponseBodyMessagesContentDingNormalCard() {}

  explicit CreateRunResponseBodyMessagesContentDingNormalCard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardData) {
      res["cardData"] = cardData ? boost::any(cardData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cardTemplateId) {
      res["cardTemplateId"] = boost::any(*cardTemplateId);
    }
    if (cardUpdateOptions) {
      res["cardUpdateOptions"] = cardUpdateOptions ? boost::any(cardUpdateOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dynamicDataSourceConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*dynamicDataSourceConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dynamicDataSourceConfigs"] = boost::any(temp1);
    }
    if (privateData) {
      res["privateData"] = boost::any(*privateData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cardData") != m.end() && !m["cardData"].empty()) {
      if (typeid(map<string, boost::any>) == m["cardData"].type()) {
        CreateRunResponseBodyMessagesContentDingNormalCardCardData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cardData"]));
        cardData = make_shared<CreateRunResponseBodyMessagesContentDingNormalCardCardData>(model1);
      }
    }
    if (m.find("cardTemplateId") != m.end() && !m["cardTemplateId"].empty()) {
      cardTemplateId = make_shared<string>(boost::any_cast<string>(m["cardTemplateId"]));
    }
    if (m.find("cardUpdateOptions") != m.end() && !m["cardUpdateOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["cardUpdateOptions"].type()) {
        CreateRunResponseBodyMessagesContentDingNormalCardCardUpdateOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cardUpdateOptions"]));
        cardUpdateOptions = make_shared<CreateRunResponseBodyMessagesContentDingNormalCardCardUpdateOptions>(model1);
      }
    }
    if (m.find("dynamicDataSourceConfigs") != m.end() && !m["dynamicDataSourceConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["dynamicDataSourceConfigs"].type()) {
        vector<CreateRunResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dynamicDataSourceConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRunResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dynamicDataSourceConfigs = make_shared<vector<CreateRunResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs>>(expect1);
      }
    }
    if (m.find("privateData") != m.end() && !m["privateData"].empty()) {
      map<string, map<string, boost::any>> map1 = boost::any_cast<map<string, map<string, boost::any>>>(m["privateData"]);
      map<string, map<string, boost::any>> toMap1;
      for (auto item:map1) {
        map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item.second);
        map<string, boost::any> toMap2;
        for (auto item:map2) {
           toMap2[item.first] = item.second;
        }
         toMap1[item.first] = toMap2;
      }
      privateData = make_shared<map<string, map<string, boost::any>>>(toMap1);
    }
  }


  virtual ~CreateRunResponseBodyMessagesContentDingNormalCard() = default;
};
class CreateRunResponseBodyMessagesContentMarkdown : public Darabonba::Model {
public:
  shared_ptr<string> value{};

  CreateRunResponseBodyMessagesContentMarkdown() {}

  explicit CreateRunResponseBodyMessagesContentMarkdown(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~CreateRunResponseBodyMessagesContentMarkdown() = default;
};
class CreateRunResponseBodyMessagesContentStructViewPartsDataPart : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};

  CreateRunResponseBodyMessagesContentStructViewPartsDataPart() {}

  explicit CreateRunResponseBodyMessagesContentStructViewPartsDataPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["data"]));
    }
  }


  virtual ~CreateRunResponseBodyMessagesContentStructViewPartsDataPart() = default;
};
class CreateRunResponseBodyMessagesContentStructViewPartsReasonPart : public Darabonba::Model {
public:
  shared_ptr<string> reason{};

  CreateRunResponseBodyMessagesContentStructViewPartsReasonPart() {}

  explicit CreateRunResponseBodyMessagesContentStructViewPartsReasonPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
  }


  virtual ~CreateRunResponseBodyMessagesContentStructViewPartsReasonPart() = default;
};
class CreateRunResponseBodyMessagesContentStructViewPartsRecommendPartRecommends : public Darabonba::Model {
public:
  shared_ptr<string> mobileUrl{};
  shared_ptr<string> text{};
  shared_ptr<string> url{};

  CreateRunResponseBodyMessagesContentStructViewPartsRecommendPartRecommends() {}

  explicit CreateRunResponseBodyMessagesContentStructViewPartsRecommendPartRecommends(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mobileUrl) {
      res["mobileUrl"] = boost::any(*mobileUrl);
    }
    if (text) {
      res["text"] = boost::any(*text);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("mobileUrl") != m.end() && !m["mobileUrl"].empty()) {
      mobileUrl = make_shared<string>(boost::any_cast<string>(m["mobileUrl"]));
    }
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~CreateRunResponseBodyMessagesContentStructViewPartsRecommendPartRecommends() = default;
};
class CreateRunResponseBodyMessagesContentStructViewPartsRecommendPart : public Darabonba::Model {
public:
  shared_ptr<vector<CreateRunResponseBodyMessagesContentStructViewPartsRecommendPartRecommends>> recommends{};

  CreateRunResponseBodyMessagesContentStructViewPartsRecommendPart() {}

  explicit CreateRunResponseBodyMessagesContentStructViewPartsRecommendPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommends) {
      vector<boost::any> temp1;
      for(auto item1:*recommends){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["recommends"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("recommends") != m.end() && !m["recommends"].empty()) {
      if (typeid(vector<boost::any>) == m["recommends"].type()) {
        vector<CreateRunResponseBodyMessagesContentStructViewPartsRecommendPartRecommends> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["recommends"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRunResponseBodyMessagesContentStructViewPartsRecommendPartRecommends model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recommends = make_shared<vector<CreateRunResponseBodyMessagesContentStructViewPartsRecommendPartRecommends>>(expect1);
      }
    }
  }


  virtual ~CreateRunResponseBodyMessagesContentStructViewPartsRecommendPart() = default;
};
class CreateRunResponseBodyMessagesContentStructViewPartsReferencePartReferences : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceCode{};
  shared_ptr<string> sourceIcon{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  CreateRunResponseBodyMessagesContentStructViewPartsReferencePartReferences() {}

  explicit CreateRunResponseBodyMessagesContentStructViewPartsReferencePartReferences(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceCode) {
      res["sourceCode"] = boost::any(*sourceCode);
    }
    if (sourceIcon) {
      res["sourceIcon"] = boost::any(*sourceIcon);
    }
    if (summary) {
      res["summary"] = boost::any(*summary);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceCode") != m.end() && !m["sourceCode"].empty()) {
      sourceCode = make_shared<string>(boost::any_cast<string>(m["sourceCode"]));
    }
    if (m.find("sourceIcon") != m.end() && !m["sourceIcon"].empty()) {
      sourceIcon = make_shared<string>(boost::any_cast<string>(m["sourceIcon"]));
    }
    if (m.find("summary") != m.end() && !m["summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["summary"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~CreateRunResponseBodyMessagesContentStructViewPartsReferencePartReferences() = default;
};
class CreateRunResponseBodyMessagesContentStructViewPartsReferencePart : public Darabonba::Model {
public:
  shared_ptr<vector<CreateRunResponseBodyMessagesContentStructViewPartsReferencePartReferences>> references{};

  CreateRunResponseBodyMessagesContentStructViewPartsReferencePart() {}

  explicit CreateRunResponseBodyMessagesContentStructViewPartsReferencePart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (references) {
      vector<boost::any> temp1;
      for(auto item1:*references){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["references"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("references") != m.end() && !m["references"].empty()) {
      if (typeid(vector<boost::any>) == m["references"].type()) {
        vector<CreateRunResponseBodyMessagesContentStructViewPartsReferencePartReferences> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["references"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRunResponseBodyMessagesContentStructViewPartsReferencePartReferences model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        references = make_shared<vector<CreateRunResponseBodyMessagesContentStructViewPartsReferencePartReferences>>(expect1);
      }
    }
  }


  virtual ~CreateRunResponseBodyMessagesContentStructViewPartsReferencePart() = default;
};
class CreateRunResponseBodyMessagesContentStructViewPartsTextPart : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  CreateRunResponseBodyMessagesContentStructViewPartsTextPart() {}

  explicit CreateRunResponseBodyMessagesContentStructViewPartsTextPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
  }


  virtual ~CreateRunResponseBodyMessagesContentStructViewPartsTextPart() = default;
};
class CreateRunResponseBodyMessagesContentStructViewParts : public Darabonba::Model {
public:
  shared_ptr<bool> append{};
  shared_ptr<CreateRunResponseBodyMessagesContentStructViewPartsDataPart> dataPart{};
  shared_ptr<bool> finish{};
  shared_ptr<string> partDesc{};
  shared_ptr<string> partId{};
  shared_ptr<CreateRunResponseBodyMessagesContentStructViewPartsReasonPart> reasonPart{};
  shared_ptr<CreateRunResponseBodyMessagesContentStructViewPartsRecommendPart> recommendPart{};
  shared_ptr<CreateRunResponseBodyMessagesContentStructViewPartsReferencePart> referencePart{};
  shared_ptr<CreateRunResponseBodyMessagesContentStructViewPartsTextPart> textPart{};
  shared_ptr<string> type{};

  CreateRunResponseBodyMessagesContentStructViewParts() {}

  explicit CreateRunResponseBodyMessagesContentStructViewParts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (append) {
      res["append"] = boost::any(*append);
    }
    if (dataPart) {
      res["dataPart"] = dataPart ? boost::any(dataPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (finish) {
      res["finish"] = boost::any(*finish);
    }
    if (partDesc) {
      res["partDesc"] = boost::any(*partDesc);
    }
    if (partId) {
      res["partId"] = boost::any(*partId);
    }
    if (reasonPart) {
      res["reasonPart"] = reasonPart ? boost::any(reasonPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recommendPart) {
      res["recommendPart"] = recommendPart ? boost::any(recommendPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referencePart) {
      res["referencePart"] = referencePart ? boost::any(referencePart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (textPart) {
      res["textPart"] = textPart ? boost::any(textPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("append") != m.end() && !m["append"].empty()) {
      append = make_shared<bool>(boost::any_cast<bool>(m["append"]));
    }
    if (m.find("dataPart") != m.end() && !m["dataPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["dataPart"].type()) {
        CreateRunResponseBodyMessagesContentStructViewPartsDataPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dataPart"]));
        dataPart = make_shared<CreateRunResponseBodyMessagesContentStructViewPartsDataPart>(model1);
      }
    }
    if (m.find("finish") != m.end() && !m["finish"].empty()) {
      finish = make_shared<bool>(boost::any_cast<bool>(m["finish"]));
    }
    if (m.find("partDesc") != m.end() && !m["partDesc"].empty()) {
      partDesc = make_shared<string>(boost::any_cast<string>(m["partDesc"]));
    }
    if (m.find("partId") != m.end() && !m["partId"].empty()) {
      partId = make_shared<string>(boost::any_cast<string>(m["partId"]));
    }
    if (m.find("reasonPart") != m.end() && !m["reasonPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["reasonPart"].type()) {
        CreateRunResponseBodyMessagesContentStructViewPartsReasonPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["reasonPart"]));
        reasonPart = make_shared<CreateRunResponseBodyMessagesContentStructViewPartsReasonPart>(model1);
      }
    }
    if (m.find("recommendPart") != m.end() && !m["recommendPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["recommendPart"].type()) {
        CreateRunResponseBodyMessagesContentStructViewPartsRecommendPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["recommendPart"]));
        recommendPart = make_shared<CreateRunResponseBodyMessagesContentStructViewPartsRecommendPart>(model1);
      }
    }
    if (m.find("referencePart") != m.end() && !m["referencePart"].empty()) {
      if (typeid(map<string, boost::any>) == m["referencePart"].type()) {
        CreateRunResponseBodyMessagesContentStructViewPartsReferencePart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["referencePart"]));
        referencePart = make_shared<CreateRunResponseBodyMessagesContentStructViewPartsReferencePart>(model1);
      }
    }
    if (m.find("textPart") != m.end() && !m["textPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["textPart"].type()) {
        CreateRunResponseBodyMessagesContentStructViewPartsTextPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["textPart"]));
        textPart = make_shared<CreateRunResponseBodyMessagesContentStructViewPartsTextPart>(model1);
      }
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateRunResponseBodyMessagesContentStructViewParts() = default;
};
class CreateRunResponseBodyMessagesContentStructView : public Darabonba::Model {
public:
  shared_ptr<vector<CreateRunResponseBodyMessagesContentStructViewParts>> parts{};

  CreateRunResponseBodyMessagesContentStructView() {}

  explicit CreateRunResponseBodyMessagesContentStructView(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parts) {
      vector<boost::any> temp1;
      for(auto item1:*parts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["parts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("parts") != m.end() && !m["parts"].empty()) {
      if (typeid(vector<boost::any>) == m["parts"].type()) {
        vector<CreateRunResponseBodyMessagesContentStructViewParts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["parts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRunResponseBodyMessagesContentStructViewParts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parts = make_shared<vector<CreateRunResponseBodyMessagesContentStructViewParts>>(expect1);
      }
    }
  }


  virtual ~CreateRunResponseBodyMessagesContentStructView() = default;
};
class CreateRunResponseBodyMessagesContentText : public Darabonba::Model {
public:
  shared_ptr<string> value{};

  CreateRunResponseBodyMessagesContentText() {}

  explicit CreateRunResponseBodyMessagesContentText(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~CreateRunResponseBodyMessagesContentText() = default;
};
class CreateRunResponseBodyMessagesContent : public Darabonba::Model {
public:
  shared_ptr<CreateRunResponseBodyMessagesContentCardCallback> cardCallback{};
  shared_ptr<CreateRunResponseBodyMessagesContentDingCard> dingCard{};
  shared_ptr<CreateRunResponseBodyMessagesContentDingNormalCard> dingNormalCard{};
  shared_ptr<CreateRunResponseBodyMessagesContentMarkdown> markdown{};
  shared_ptr<CreateRunResponseBodyMessagesContentStructView> structView{};
  shared_ptr<CreateRunResponseBodyMessagesContentText> text{};
  shared_ptr<string> type{};

  CreateRunResponseBodyMessagesContent() {}

  explicit CreateRunResponseBodyMessagesContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardCallback) {
      res["cardCallback"] = cardCallback ? boost::any(cardCallback->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dingCard) {
      res["dingCard"] = dingCard ? boost::any(dingCard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dingNormalCard) {
      res["dingNormalCard"] = dingNormalCard ? boost::any(dingNormalCard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (markdown) {
      res["markdown"] = markdown ? boost::any(markdown->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (structView) {
      res["structView"] = structView ? boost::any(structView->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (text) {
      res["text"] = text ? boost::any(text->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cardCallback") != m.end() && !m["cardCallback"].empty()) {
      if (typeid(map<string, boost::any>) == m["cardCallback"].type()) {
        CreateRunResponseBodyMessagesContentCardCallback model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cardCallback"]));
        cardCallback = make_shared<CreateRunResponseBodyMessagesContentCardCallback>(model1);
      }
    }
    if (m.find("dingCard") != m.end() && !m["dingCard"].empty()) {
      if (typeid(map<string, boost::any>) == m["dingCard"].type()) {
        CreateRunResponseBodyMessagesContentDingCard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dingCard"]));
        dingCard = make_shared<CreateRunResponseBodyMessagesContentDingCard>(model1);
      }
    }
    if (m.find("dingNormalCard") != m.end() && !m["dingNormalCard"].empty()) {
      if (typeid(map<string, boost::any>) == m["dingNormalCard"].type()) {
        CreateRunResponseBodyMessagesContentDingNormalCard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dingNormalCard"]));
        dingNormalCard = make_shared<CreateRunResponseBodyMessagesContentDingNormalCard>(model1);
      }
    }
    if (m.find("markdown") != m.end() && !m["markdown"].empty()) {
      if (typeid(map<string, boost::any>) == m["markdown"].type()) {
        CreateRunResponseBodyMessagesContentMarkdown model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["markdown"]));
        markdown = make_shared<CreateRunResponseBodyMessagesContentMarkdown>(model1);
      }
    }
    if (m.find("structView") != m.end() && !m["structView"].empty()) {
      if (typeid(map<string, boost::any>) == m["structView"].type()) {
        CreateRunResponseBodyMessagesContentStructView model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["structView"]));
        structView = make_shared<CreateRunResponseBodyMessagesContentStructView>(model1);
      }
    }
    if (m.find("text") != m.end() && !m["text"].empty()) {
      if (typeid(map<string, boost::any>) == m["text"].type()) {
        CreateRunResponseBodyMessagesContentText model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["text"]));
        text = make_shared<CreateRunResponseBodyMessagesContentText>(model1);
      }
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateRunResponseBodyMessagesContent() = default;
};
class CreateRunResponseBodyMessages : public Darabonba::Model {
public:
  shared_ptr<CreateRunResponseBodyMessagesContent> content{};
  shared_ptr<string> contentDesc{};
  shared_ptr<long> createAt{};
  shared_ptr<string> id{};
  shared_ptr<string> role{};
  shared_ptr<string> runId{};
  shared_ptr<string> threadId{};

  CreateRunResponseBodyMessages() {}

  explicit CreateRunResponseBodyMessages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contentDesc) {
      res["contentDesc"] = boost::any(*contentDesc);
    }
    if (createAt) {
      res["createAt"] = boost::any(*createAt);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (role) {
      res["role"] = boost::any(*role);
    }
    if (runId) {
      res["runId"] = boost::any(*runId);
    }
    if (threadId) {
      res["threadId"] = boost::any(*threadId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      if (typeid(map<string, boost::any>) == m["content"].type()) {
        CreateRunResponseBodyMessagesContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["content"]));
        content = make_shared<CreateRunResponseBodyMessagesContent>(model1);
      }
    }
    if (m.find("contentDesc") != m.end() && !m["contentDesc"].empty()) {
      contentDesc = make_shared<string>(boost::any_cast<string>(m["contentDesc"]));
    }
    if (m.find("createAt") != m.end() && !m["createAt"].empty()) {
      createAt = make_shared<long>(boost::any_cast<long>(m["createAt"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("role") != m.end() && !m["role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["role"]));
    }
    if (m.find("runId") != m.end() && !m["runId"].empty()) {
      runId = make_shared<string>(boost::any_cast<string>(m["runId"]));
    }
    if (m.find("threadId") != m.end() && !m["threadId"].empty()) {
      threadId = make_shared<string>(boost::any_cast<string>(m["threadId"]));
    }
  }


  virtual ~CreateRunResponseBodyMessages() = default;
};
class CreateRunResponseBodyRun : public Darabonba::Model {
public:
  shared_ptr<long> cancelledAt{};
  shared_ptr<long> completedAt{};
  shared_ptr<long> createAt{};
  shared_ptr<long> expiresAt{};
  shared_ptr<long> failedAt{};
  shared_ptr<string> id{};
  shared_ptr<string> lastErrorMsg{};
  shared_ptr<long> startedAt{};
  shared_ptr<string> status{};
  shared_ptr<string> threadId{};

  CreateRunResponseBodyRun() {}

  explicit CreateRunResponseBodyRun(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cancelledAt) {
      res["cancelledAt"] = boost::any(*cancelledAt);
    }
    if (completedAt) {
      res["completedAt"] = boost::any(*completedAt);
    }
    if (createAt) {
      res["createAt"] = boost::any(*createAt);
    }
    if (expiresAt) {
      res["expiresAt"] = boost::any(*expiresAt);
    }
    if (failedAt) {
      res["failedAt"] = boost::any(*failedAt);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (lastErrorMsg) {
      res["lastErrorMsg"] = boost::any(*lastErrorMsg);
    }
    if (startedAt) {
      res["startedAt"] = boost::any(*startedAt);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (threadId) {
      res["threadId"] = boost::any(*threadId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cancelledAt") != m.end() && !m["cancelledAt"].empty()) {
      cancelledAt = make_shared<long>(boost::any_cast<long>(m["cancelledAt"]));
    }
    if (m.find("completedAt") != m.end() && !m["completedAt"].empty()) {
      completedAt = make_shared<long>(boost::any_cast<long>(m["completedAt"]));
    }
    if (m.find("createAt") != m.end() && !m["createAt"].empty()) {
      createAt = make_shared<long>(boost::any_cast<long>(m["createAt"]));
    }
    if (m.find("expiresAt") != m.end() && !m["expiresAt"].empty()) {
      expiresAt = make_shared<long>(boost::any_cast<long>(m["expiresAt"]));
    }
    if (m.find("failedAt") != m.end() && !m["failedAt"].empty()) {
      failedAt = make_shared<long>(boost::any_cast<long>(m["failedAt"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("lastErrorMsg") != m.end() && !m["lastErrorMsg"].empty()) {
      lastErrorMsg = make_shared<string>(boost::any_cast<string>(m["lastErrorMsg"]));
    }
    if (m.find("startedAt") != m.end() && !m["startedAt"].empty()) {
      startedAt = make_shared<long>(boost::any_cast<long>(m["startedAt"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("threadId") != m.end() && !m["threadId"].empty()) {
      threadId = make_shared<string>(boost::any_cast<string>(m["threadId"]));
    }
  }


  virtual ~CreateRunResponseBodyRun() = default;
};
class CreateRunResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<CreateRunResponseBodyMessages>> messages{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateRunResponseBodyRun> run{};

  CreateRunResponseBody() {}

  explicit CreateRunResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messages) {
      vector<boost::any> temp1;
      for(auto item1:*messages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["messages"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (run) {
      res["run"] = run ? boost::any(run->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("messages") != m.end() && !m["messages"].empty()) {
      if (typeid(vector<boost::any>) == m["messages"].type()) {
        vector<CreateRunResponseBodyMessages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["messages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRunResponseBodyMessages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        messages = make_shared<vector<CreateRunResponseBodyMessages>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("run") != m.end() && !m["run"].empty()) {
      if (typeid(map<string, boost::any>) == m["run"].type()) {
        CreateRunResponseBodyRun model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["run"]));
        run = make_shared<CreateRunResponseBodyRun>(model1);
      }
    }
  }


  virtual ~CreateRunResponseBody() = default;
};
class CreateRunResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRunResponseBody> body{};

  CreateRunResponse() {}

  explicit CreateRunResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRunResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRunResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRunResponse() = default;
};
class CreateScenegroupHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateScenegroupHeadersAccountContext() {}

  explicit CreateScenegroupHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateScenegroupHeadersAccountContext() = default;
};
class CreateScenegroupHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateScenegroupHeadersAccountContext> accountContext{};

  CreateScenegroupHeaders() {}

  explicit CreateScenegroupHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateScenegroupHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateScenegroupHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateScenegroupHeaders() = default;
};
class CreateScenegroupShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateScenegroupShrinkHeaders() {}

  explicit CreateScenegroupShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateScenegroupShrinkHeaders() = default;
};
class CreateScenegroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> addFriendForbidden{};
  shared_ptr<long> allMembersCanCreateCalendar{};
  shared_ptr<long> allMembersCanCreateMcsConf{};
  shared_ptr<long> chatBannedType{};
  shared_ptr<long> groupEmailDisabled{};
  shared_ptr<long> groupLiveSwitch{};
  shared_ptr<string> icon{};
  shared_ptr<long> managementType{};
  shared_ptr<long> membersToAdminChat{};
  shared_ptr<long> mentionAllAuthority{};
  shared_ptr<long> onlyAdminCanDing{};
  shared_ptr<long> onlyAdminCanSetMsgTop{};
  shared_ptr<long> searchable{};
  shared_ptr<long> showHistoryType{};
  shared_ptr<string> subadminIds{};
  shared_ptr<string> templateId{};
  shared_ptr<string> title{};
  shared_ptr<string> userIds{};
  shared_ptr<string> uuid{};
  shared_ptr<long> validationType{};

  CreateScenegroupRequest() {}

  explicit CreateScenegroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addFriendForbidden) {
      res["AddFriendForbidden"] = boost::any(*addFriendForbidden);
    }
    if (allMembersCanCreateCalendar) {
      res["AllMembersCanCreateCalendar"] = boost::any(*allMembersCanCreateCalendar);
    }
    if (allMembersCanCreateMcsConf) {
      res["AllMembersCanCreateMcsConf"] = boost::any(*allMembersCanCreateMcsConf);
    }
    if (chatBannedType) {
      res["ChatBannedType"] = boost::any(*chatBannedType);
    }
    if (groupEmailDisabled) {
      res["GroupEmailDisabled"] = boost::any(*groupEmailDisabled);
    }
    if (groupLiveSwitch) {
      res["GroupLiveSwitch"] = boost::any(*groupLiveSwitch);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (managementType) {
      res["ManagementType"] = boost::any(*managementType);
    }
    if (membersToAdminChat) {
      res["MembersToAdminChat"] = boost::any(*membersToAdminChat);
    }
    if (mentionAllAuthority) {
      res["MentionAllAuthority"] = boost::any(*mentionAllAuthority);
    }
    if (onlyAdminCanDing) {
      res["OnlyAdminCanDing"] = boost::any(*onlyAdminCanDing);
    }
    if (onlyAdminCanSetMsgTop) {
      res["OnlyAdminCanSetMsgTop"] = boost::any(*onlyAdminCanSetMsgTop);
    }
    if (searchable) {
      res["Searchable"] = boost::any(*searchable);
    }
    if (showHistoryType) {
      res["ShowHistoryType"] = boost::any(*showHistoryType);
    }
    if (subadminIds) {
      res["SubadminIds"] = boost::any(*subadminIds);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (validationType) {
      res["ValidationType"] = boost::any(*validationType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddFriendForbidden") != m.end() && !m["AddFriendForbidden"].empty()) {
      addFriendForbidden = make_shared<long>(boost::any_cast<long>(m["AddFriendForbidden"]));
    }
    if (m.find("AllMembersCanCreateCalendar") != m.end() && !m["AllMembersCanCreateCalendar"].empty()) {
      allMembersCanCreateCalendar = make_shared<long>(boost::any_cast<long>(m["AllMembersCanCreateCalendar"]));
    }
    if (m.find("AllMembersCanCreateMcsConf") != m.end() && !m["AllMembersCanCreateMcsConf"].empty()) {
      allMembersCanCreateMcsConf = make_shared<long>(boost::any_cast<long>(m["AllMembersCanCreateMcsConf"]));
    }
    if (m.find("ChatBannedType") != m.end() && !m["ChatBannedType"].empty()) {
      chatBannedType = make_shared<long>(boost::any_cast<long>(m["ChatBannedType"]));
    }
    if (m.find("GroupEmailDisabled") != m.end() && !m["GroupEmailDisabled"].empty()) {
      groupEmailDisabled = make_shared<long>(boost::any_cast<long>(m["GroupEmailDisabled"]));
    }
    if (m.find("GroupLiveSwitch") != m.end() && !m["GroupLiveSwitch"].empty()) {
      groupLiveSwitch = make_shared<long>(boost::any_cast<long>(m["GroupLiveSwitch"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("ManagementType") != m.end() && !m["ManagementType"].empty()) {
      managementType = make_shared<long>(boost::any_cast<long>(m["ManagementType"]));
    }
    if (m.find("MembersToAdminChat") != m.end() && !m["MembersToAdminChat"].empty()) {
      membersToAdminChat = make_shared<long>(boost::any_cast<long>(m["MembersToAdminChat"]));
    }
    if (m.find("MentionAllAuthority") != m.end() && !m["MentionAllAuthority"].empty()) {
      mentionAllAuthority = make_shared<long>(boost::any_cast<long>(m["MentionAllAuthority"]));
    }
    if (m.find("OnlyAdminCanDing") != m.end() && !m["OnlyAdminCanDing"].empty()) {
      onlyAdminCanDing = make_shared<long>(boost::any_cast<long>(m["OnlyAdminCanDing"]));
    }
    if (m.find("OnlyAdminCanSetMsgTop") != m.end() && !m["OnlyAdminCanSetMsgTop"].empty()) {
      onlyAdminCanSetMsgTop = make_shared<long>(boost::any_cast<long>(m["OnlyAdminCanSetMsgTop"]));
    }
    if (m.find("Searchable") != m.end() && !m["Searchable"].empty()) {
      searchable = make_shared<long>(boost::any_cast<long>(m["Searchable"]));
    }
    if (m.find("ShowHistoryType") != m.end() && !m["ShowHistoryType"].empty()) {
      showHistoryType = make_shared<long>(boost::any_cast<long>(m["ShowHistoryType"]));
    }
    if (m.find("SubadminIds") != m.end() && !m["SubadminIds"].empty()) {
      subadminIds = make_shared<string>(boost::any_cast<string>(m["SubadminIds"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      userIds = make_shared<string>(boost::any_cast<string>(m["UserIds"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("ValidationType") != m.end() && !m["ValidationType"].empty()) {
      validationType = make_shared<long>(boost::any_cast<long>(m["ValidationType"]));
    }
  }


  virtual ~CreateScenegroupRequest() = default;
};
class CreateScenegroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> openConversationId{};
  shared_ptr<string> requestId{};

  CreateScenegroupResponseBody() {}

  explicit CreateScenegroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openConversationId) {
      res["openConversationId"] = boost::any(*openConversationId);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("openConversationId") != m.end() && !m["openConversationId"].empty()) {
      openConversationId = make_shared<string>(boost::any_cast<string>(m["openConversationId"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateScenegroupResponseBody() = default;
};
class CreateScenegroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateScenegroupResponseBody> body{};

  CreateScenegroupResponse() {}

  explicit CreateScenegroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateScenegroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateScenegroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateScenegroupResponse() = default;
};
class CreateScheduleConferenceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateScheduleConferenceHeadersAccountContext() {}

  explicit CreateScheduleConferenceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateScheduleConferenceHeadersAccountContext() = default;
};
class CreateScheduleConferenceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateScheduleConferenceHeadersAccountContext> accountContext{};

  CreateScheduleConferenceHeaders() {}

  explicit CreateScheduleConferenceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateScheduleConferenceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateScheduleConferenceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateScheduleConferenceHeaders() = default;
};
class CreateScheduleConferenceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateScheduleConferenceShrinkHeaders() {}

  explicit CreateScheduleConferenceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateScheduleConferenceShrinkHeaders() = default;
};
class CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfOpenRecordSetting : public Darabonba::Model {
public:
  shared_ptr<bool> isFollowHost{};
  shared_ptr<string> mode{};
  shared_ptr<long> recordAutoStart{};
  shared_ptr<long> recordAutoStartType{};

  CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfOpenRecordSetting() {}

  explicit CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfOpenRecordSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isFollowHost) {
      res["IsFollowHost"] = boost::any(*isFollowHost);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (recordAutoStart) {
      res["RecordAutoStart"] = boost::any(*recordAutoStart);
    }
    if (recordAutoStartType) {
      res["RecordAutoStartType"] = boost::any(*recordAutoStartType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsFollowHost") != m.end() && !m["IsFollowHost"].empty()) {
      isFollowHost = make_shared<bool>(boost::any_cast<bool>(m["IsFollowHost"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("RecordAutoStart") != m.end() && !m["RecordAutoStart"].empty()) {
      recordAutoStart = make_shared<long>(boost::any_cast<long>(m["RecordAutoStart"]));
    }
    if (m.find("RecordAutoStartType") != m.end() && !m["RecordAutoStartType"].empty()) {
      recordAutoStartType = make_shared<long>(boost::any_cast<long>(m["RecordAutoStartType"]));
    }
  }


  virtual ~CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfOpenRecordSetting() = default;
};
class CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings : public Darabonba::Model {
public:
  shared_ptr<long> autoOpenMode{};
  shared_ptr<string> coolAppCode{};
  shared_ptr<string> extensionAppBizData{};

  CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings() {}

  explicit CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoOpenMode) {
      res["AutoOpenMode"] = boost::any(*autoOpenMode);
    }
    if (coolAppCode) {
      res["CoolAppCode"] = boost::any(*coolAppCode);
    }
    if (extensionAppBizData) {
      res["ExtensionAppBizData"] = boost::any(*extensionAppBizData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoOpenMode") != m.end() && !m["AutoOpenMode"].empty()) {
      autoOpenMode = make_shared<long>(boost::any_cast<long>(m["AutoOpenMode"]));
    }
    if (m.find("CoolAppCode") != m.end() && !m["CoolAppCode"].empty()) {
      coolAppCode = make_shared<string>(boost::any_cast<string>(m["CoolAppCode"]));
    }
    if (m.find("ExtensionAppBizData") != m.end() && !m["ExtensionAppBizData"].empty()) {
      extensionAppBizData = make_shared<string>(boost::any_cast<string>(m["ExtensionAppBizData"]));
    }
  }


  virtual ~CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings() = default;
};
class CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSetting : public Darabonba::Model {
public:
  shared_ptr<string> cloudRecordOwnerUserId{};
  shared_ptr<long> enableChat{};
  shared_ptr<bool> enableWebAnonymousJoin{};
  shared_ptr<long> joinBeforeHost{};
  shared_ptr<long> lockMediaStatusMicMute{};
  shared_ptr<long> lockNick{};
  shared_ptr<string> minutesOwnerUserId{};
  shared_ptr<vector<CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings>> moziConfExtensionAppSettings{};
  shared_ptr<bool> pushAllMeetingRecords{};
  shared_ptr<bool> pushCloudRecordCard{};
  shared_ptr<bool> pushMinutesCard{};
  shared_ptr<long> waitingRoom{};

  CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSetting() {}

  explicit CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudRecordOwnerUserId) {
      res["CloudRecordOwnerUserId"] = boost::any(*cloudRecordOwnerUserId);
    }
    if (enableChat) {
      res["EnableChat"] = boost::any(*enableChat);
    }
    if (enableWebAnonymousJoin) {
      res["EnableWebAnonymousJoin"] = boost::any(*enableWebAnonymousJoin);
    }
    if (joinBeforeHost) {
      res["JoinBeforeHost"] = boost::any(*joinBeforeHost);
    }
    if (lockMediaStatusMicMute) {
      res["LockMediaStatusMicMute"] = boost::any(*lockMediaStatusMicMute);
    }
    if (lockNick) {
      res["LockNick"] = boost::any(*lockNick);
    }
    if (minutesOwnerUserId) {
      res["MinutesOwnerUserId"] = boost::any(*minutesOwnerUserId);
    }
    if (moziConfExtensionAppSettings) {
      vector<boost::any> temp1;
      for(auto item1:*moziConfExtensionAppSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MoziConfExtensionAppSettings"] = boost::any(temp1);
    }
    if (pushAllMeetingRecords) {
      res["PushAllMeetingRecords"] = boost::any(*pushAllMeetingRecords);
    }
    if (pushCloudRecordCard) {
      res["PushCloudRecordCard"] = boost::any(*pushCloudRecordCard);
    }
    if (pushMinutesCard) {
      res["PushMinutesCard"] = boost::any(*pushMinutesCard);
    }
    if (waitingRoom) {
      res["WaitingRoom"] = boost::any(*waitingRoom);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloudRecordOwnerUserId") != m.end() && !m["CloudRecordOwnerUserId"].empty()) {
      cloudRecordOwnerUserId = make_shared<string>(boost::any_cast<string>(m["CloudRecordOwnerUserId"]));
    }
    if (m.find("EnableChat") != m.end() && !m["EnableChat"].empty()) {
      enableChat = make_shared<long>(boost::any_cast<long>(m["EnableChat"]));
    }
    if (m.find("EnableWebAnonymousJoin") != m.end() && !m["EnableWebAnonymousJoin"].empty()) {
      enableWebAnonymousJoin = make_shared<bool>(boost::any_cast<bool>(m["EnableWebAnonymousJoin"]));
    }
    if (m.find("JoinBeforeHost") != m.end() && !m["JoinBeforeHost"].empty()) {
      joinBeforeHost = make_shared<long>(boost::any_cast<long>(m["JoinBeforeHost"]));
    }
    if (m.find("LockMediaStatusMicMute") != m.end() && !m["LockMediaStatusMicMute"].empty()) {
      lockMediaStatusMicMute = make_shared<long>(boost::any_cast<long>(m["LockMediaStatusMicMute"]));
    }
    if (m.find("LockNick") != m.end() && !m["LockNick"].empty()) {
      lockNick = make_shared<long>(boost::any_cast<long>(m["LockNick"]));
    }
    if (m.find("MinutesOwnerUserId") != m.end() && !m["MinutesOwnerUserId"].empty()) {
      minutesOwnerUserId = make_shared<string>(boost::any_cast<string>(m["MinutesOwnerUserId"]));
    }
    if (m.find("MoziConfExtensionAppSettings") != m.end() && !m["MoziConfExtensionAppSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["MoziConfExtensionAppSettings"].type()) {
        vector<CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MoziConfExtensionAppSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        moziConfExtensionAppSettings = make_shared<vector<CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings>>(expect1);
      }
    }
    if (m.find("PushAllMeetingRecords") != m.end() && !m["PushAllMeetingRecords"].empty()) {
      pushAllMeetingRecords = make_shared<bool>(boost::any_cast<bool>(m["PushAllMeetingRecords"]));
    }
    if (m.find("PushCloudRecordCard") != m.end() && !m["PushCloudRecordCard"].empty()) {
      pushCloudRecordCard = make_shared<bool>(boost::any_cast<bool>(m["PushCloudRecordCard"]));
    }
    if (m.find("PushMinutesCard") != m.end() && !m["PushMinutesCard"].empty()) {
      pushMinutesCard = make_shared<bool>(boost::any_cast<bool>(m["PushMinutesCard"]));
    }
    if (m.find("WaitingRoom") != m.end() && !m["WaitingRoom"].empty()) {
      waitingRoom = make_shared<long>(boost::any_cast<long>(m["WaitingRoom"]));
    }
  }


  virtual ~CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSetting() = default;
};
class CreateScheduleConferenceRequestScheduleConfSettingModel : public Darabonba::Model {
public:
  shared_ptr<vector<string>> cohostUserIds{};
  shared_ptr<string> confAllowedCorpId{};
  shared_ptr<string> hostUserId{};
  shared_ptr<long> lockRoom{};
  shared_ptr<CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfOpenRecordSetting> moziConfOpenRecordSetting{};
  shared_ptr<CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSetting> moziConfVirtualExtraSetting{};
  shared_ptr<long> muteOnJoin{};
  shared_ptr<long> screenShareForbidden{};

  CreateScheduleConferenceRequestScheduleConfSettingModel() {}

  explicit CreateScheduleConferenceRequestScheduleConfSettingModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cohostUserIds) {
      res["CohostUserIds"] = boost::any(*cohostUserIds);
    }
    if (confAllowedCorpId) {
      res["ConfAllowedCorpId"] = boost::any(*confAllowedCorpId);
    }
    if (hostUserId) {
      res["HostUserId"] = boost::any(*hostUserId);
    }
    if (lockRoom) {
      res["LockRoom"] = boost::any(*lockRoom);
    }
    if (moziConfOpenRecordSetting) {
      res["MoziConfOpenRecordSetting"] = moziConfOpenRecordSetting ? boost::any(moziConfOpenRecordSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (moziConfVirtualExtraSetting) {
      res["MoziConfVirtualExtraSetting"] = moziConfVirtualExtraSetting ? boost::any(moziConfVirtualExtraSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muteOnJoin) {
      res["MuteOnJoin"] = boost::any(*muteOnJoin);
    }
    if (screenShareForbidden) {
      res["ScreenShareForbidden"] = boost::any(*screenShareForbidden);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CohostUserIds") != m.end() && !m["CohostUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CohostUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CohostUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cohostUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ConfAllowedCorpId") != m.end() && !m["ConfAllowedCorpId"].empty()) {
      confAllowedCorpId = make_shared<string>(boost::any_cast<string>(m["ConfAllowedCorpId"]));
    }
    if (m.find("HostUserId") != m.end() && !m["HostUserId"].empty()) {
      hostUserId = make_shared<string>(boost::any_cast<string>(m["HostUserId"]));
    }
    if (m.find("LockRoom") != m.end() && !m["LockRoom"].empty()) {
      lockRoom = make_shared<long>(boost::any_cast<long>(m["LockRoom"]));
    }
    if (m.find("MoziConfOpenRecordSetting") != m.end() && !m["MoziConfOpenRecordSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["MoziConfOpenRecordSetting"].type()) {
        CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfOpenRecordSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MoziConfOpenRecordSetting"]));
        moziConfOpenRecordSetting = make_shared<CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfOpenRecordSetting>(model1);
      }
    }
    if (m.find("MoziConfVirtualExtraSetting") != m.end() && !m["MoziConfVirtualExtraSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["MoziConfVirtualExtraSetting"].type()) {
        CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MoziConfVirtualExtraSetting"]));
        moziConfVirtualExtraSetting = make_shared<CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSetting>(model1);
      }
    }
    if (m.find("MuteOnJoin") != m.end() && !m["MuteOnJoin"].empty()) {
      muteOnJoin = make_shared<long>(boost::any_cast<long>(m["MuteOnJoin"]));
    }
    if (m.find("ScreenShareForbidden") != m.end() && !m["ScreenShareForbidden"].empty()) {
      screenShareForbidden = make_shared<long>(boost::any_cast<long>(m["ScreenShareForbidden"]));
    }
  }


  virtual ~CreateScheduleConferenceRequestScheduleConfSettingModel() = default;
};
class CreateScheduleConferenceRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateScheduleConferenceRequestTenantContext() {}

  explicit CreateScheduleConferenceRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateScheduleConferenceRequestTenantContext() = default;
};
class CreateScheduleConferenceRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<CreateScheduleConferenceRequestScheduleConfSettingModel> scheduleConfSettingModel{};
  shared_ptr<long> startTime{};
  shared_ptr<CreateScheduleConferenceRequestTenantContext> tenantContext{};
  shared_ptr<string> title{};

  CreateScheduleConferenceRequest() {}

  explicit CreateScheduleConferenceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (scheduleConfSettingModel) {
      res["ScheduleConfSettingModel"] = scheduleConfSettingModel ? boost::any(scheduleConfSettingModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ScheduleConfSettingModel") != m.end() && !m["ScheduleConfSettingModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfSettingModel"].type()) {
        CreateScheduleConferenceRequestScheduleConfSettingModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfSettingModel"]));
        scheduleConfSettingModel = make_shared<CreateScheduleConferenceRequestScheduleConfSettingModel>(model1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateScheduleConferenceRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateScheduleConferenceRequestTenantContext>(model1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~CreateScheduleConferenceRequest() = default;
};
class CreateScheduleConferenceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> scheduleConfSettingModelShrink{};
  shared_ptr<long> startTime{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> title{};

  CreateScheduleConferenceShrinkRequest() {}

  explicit CreateScheduleConferenceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (scheduleConfSettingModelShrink) {
      res["ScheduleConfSettingModel"] = boost::any(*scheduleConfSettingModelShrink);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ScheduleConfSettingModel") != m.end() && !m["ScheduleConfSettingModel"].empty()) {
      scheduleConfSettingModelShrink = make_shared<string>(boost::any_cast<string>(m["ScheduleConfSettingModel"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~CreateScheduleConferenceShrinkRequest() = default;
};
class CreateScheduleConferenceResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> phones{};
  shared_ptr<string> requestId{};
  shared_ptr<string> roomCode{};
  shared_ptr<string> scheduleConferenceId{};
  shared_ptr<string> url{};

  CreateScheduleConferenceResponseBody() {}

  explicit CreateScheduleConferenceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phones) {
      res["phones"] = boost::any(*phones);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (roomCode) {
      res["roomCode"] = boost::any(*roomCode);
    }
    if (scheduleConferenceId) {
      res["scheduleConferenceId"] = boost::any(*scheduleConferenceId);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("phones") != m.end() && !m["phones"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["phones"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["phones"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      phones = make_shared<vector<string>>(toVec1);
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("roomCode") != m.end() && !m["roomCode"].empty()) {
      roomCode = make_shared<string>(boost::any_cast<string>(m["roomCode"]));
    }
    if (m.find("scheduleConferenceId") != m.end() && !m["scheduleConferenceId"].empty()) {
      scheduleConferenceId = make_shared<string>(boost::any_cast<string>(m["scheduleConferenceId"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~CreateScheduleConferenceResponseBody() = default;
};
class CreateScheduleConferenceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateScheduleConferenceResponseBody> body{};

  CreateScheduleConferenceResponse() {}

  explicit CreateScheduleConferenceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateScheduleConferenceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateScheduleConferenceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateScheduleConferenceResponse() = default;
};
class CreateSearchDomeHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> userToken{};

  CreateSearchDomeHeadersAccountContext() {}

  explicit CreateSearchDomeHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userToken) {
      res["userToken"] = boost::any(*userToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("userToken") != m.end() && !m["userToken"].empty()) {
      userToken = make_shared<string>(boost::any_cast<string>(m["userToken"]));
    }
  }


  virtual ~CreateSearchDomeHeadersAccountContext() = default;
};
class CreateSearchDomeHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateSearchDomeHeadersAccountContext> accountContext{};

  CreateSearchDomeHeaders() {}

  explicit CreateSearchDomeHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateSearchDomeHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateSearchDomeHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateSearchDomeHeaders() = default;
};
class CreateSearchDomeShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateSearchDomeShrinkHeaders() {}

  explicit CreateSearchDomeShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateSearchDomeShrinkHeaders() = default;
};
class CreateSearchDomeRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateSearchDomeRequestTenantContext() {}

  explicit CreateSearchDomeRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateSearchDomeRequestTenantContext() = default;
};
class CreateSearchDomeRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> endTime{};
  shared_ptr<string> resId{};
  shared_ptr<long> startTime{};
  shared_ptr<CreateSearchDomeRequestTenantContext> tenantContext{};
  shared_ptr<vector<string>> userIdList{};

  CreateSearchDomeRequest() {}

  explicit CreateSearchDomeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (resId) {
      res["ResId"] = boost::any(*resId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userIdList) {
      res["UserIdList"] = boost::any(*userIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ResId") != m.end() && !m["ResId"].empty()) {
      resId = make_shared<string>(boost::any_cast<string>(m["ResId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateSearchDomeRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateSearchDomeRequestTenantContext>(model1);
      }
    }
    if (m.find("UserIdList") != m.end() && !m["UserIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateSearchDomeRequest() = default;
};
class CreateSearchDomeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> endTime{};
  shared_ptr<string> resId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> userIdListShrink{};

  CreateSearchDomeShrinkRequest() {}

  explicit CreateSearchDomeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (resId) {
      res["ResId"] = boost::any(*resId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (userIdListShrink) {
      res["UserIdList"] = boost::any(*userIdListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ResId") != m.end() && !m["ResId"].empty()) {
      resId = make_shared<string>(boost::any_cast<string>(m["ResId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("UserIdList") != m.end() && !m["UserIdList"].empty()) {
      userIdListShrink = make_shared<string>(boost::any_cast<string>(m["UserIdList"]));
    }
  }


  virtual ~CreateSearchDomeShrinkRequest() = default;
};
class CreateSearchDomeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<boost::any>> arguments{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  CreateSearchDomeResponseBody() {}

  explicit CreateSearchDomeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arguments) {
      res["arguments"] = boost::any(*arguments);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arguments") != m.end() && !m["arguments"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["arguments"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["arguments"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      arguments = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~CreateSearchDomeResponseBody() = default;
};
class CreateSearchDomeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSearchDomeResponseBody> body{};

  CreateSearchDomeResponse() {}

  explicit CreateSearchDomeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSearchDomeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSearchDomeResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSearchDomeResponse() = default;
};
class CreateSearchKeywordHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> userToken{};

  CreateSearchKeywordHeadersAccountContext() {}

  explicit CreateSearchKeywordHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userToken) {
      res["userToken"] = boost::any(*userToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("userToken") != m.end() && !m["userToken"].empty()) {
      userToken = make_shared<string>(boost::any_cast<string>(m["userToken"]));
    }
  }


  virtual ~CreateSearchKeywordHeadersAccountContext() = default;
};
class CreateSearchKeywordHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateSearchKeywordHeadersAccountContext> accountContext{};

  CreateSearchKeywordHeaders() {}

  explicit CreateSearchKeywordHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateSearchKeywordHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateSearchKeywordHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateSearchKeywordHeaders() = default;
};
class CreateSearchKeywordShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateSearchKeywordShrinkHeaders() {}

  explicit CreateSearchKeywordShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateSearchKeywordShrinkHeaders() = default;
};
class CreateSearchKeywordRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateSearchKeywordRequestTenantContext() {}

  explicit CreateSearchKeywordRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateSearchKeywordRequestTenantContext() = default;
};
class CreateSearchKeywordRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> endTime{};
  shared_ptr<string> resId{};
  shared_ptr<long> startTime{};
  shared_ptr<CreateSearchKeywordRequestTenantContext> tenantContext{};
  shared_ptr<vector<string>> userIdList{};

  CreateSearchKeywordRequest() {}

  explicit CreateSearchKeywordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (resId) {
      res["ResId"] = boost::any(*resId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userIdList) {
      res["UserIdList"] = boost::any(*userIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ResId") != m.end() && !m["ResId"].empty()) {
      resId = make_shared<string>(boost::any_cast<string>(m["ResId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateSearchKeywordRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateSearchKeywordRequestTenantContext>(model1);
      }
    }
    if (m.find("UserIdList") != m.end() && !m["UserIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateSearchKeywordRequest() = default;
};
class CreateSearchKeywordShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> endTime{};
  shared_ptr<string> resId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> userIdListShrink{};

  CreateSearchKeywordShrinkRequest() {}

  explicit CreateSearchKeywordShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (resId) {
      res["ResId"] = boost::any(*resId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (userIdListShrink) {
      res["UserIdList"] = boost::any(*userIdListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ResId") != m.end() && !m["ResId"].empty()) {
      resId = make_shared<string>(boost::any_cast<string>(m["ResId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("UserIdList") != m.end() && !m["UserIdList"].empty()) {
      userIdListShrink = make_shared<string>(boost::any_cast<string>(m["UserIdList"]));
    }
  }


  virtual ~CreateSearchKeywordShrinkRequest() = default;
};
class CreateSearchKeywordResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<boost::any>> arguments{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  CreateSearchKeywordResponseBody() {}

  explicit CreateSearchKeywordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arguments) {
      res["arguments"] = boost::any(*arguments);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arguments") != m.end() && !m["arguments"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["arguments"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["arguments"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      arguments = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~CreateSearchKeywordResponseBody() = default;
};
class CreateSearchKeywordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSearchKeywordResponseBody> body{};

  CreateSearchKeywordResponse() {}

  explicit CreateSearchKeywordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSearchKeywordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSearchKeywordResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSearchKeywordResponse() = default;
};
class CreateSheetHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateSheetHeadersAccountContext() {}

  explicit CreateSheetHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateSheetHeadersAccountContext() = default;
};
class CreateSheetHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateSheetHeadersAccountContext> accountContext{};

  CreateSheetHeaders() {}

  explicit CreateSheetHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateSheetHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateSheetHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateSheetHeaders() = default;
};
class CreateSheetShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateSheetShrinkHeaders() {}

  explicit CreateSheetShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateSheetShrinkHeaders() = default;
};
class CreateSheetRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateSheetRequestTenantContext() {}

  explicit CreateSheetRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateSheetRequestTenantContext() = default;
};
class CreateSheetRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<CreateSheetRequestTenantContext> tenantContext{};
  shared_ptr<string> workbookId{};

  CreateSheetRequest() {}

  explicit CreateSheetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateSheetRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateSheetRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~CreateSheetRequest() = default;
};
class CreateSheetShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workbookId{};

  CreateSheetShrinkRequest() {}

  explicit CreateSheetShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~CreateSheetShrinkRequest() = default;
};
class CreateSheetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> visibility{};

  CreateSheetResponseBody() {}

  explicit CreateSheetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (visibility) {
      res["visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("visibility") != m.end() && !m["visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["visibility"]));
    }
  }


  virtual ~CreateSheetResponseBody() = default;
};
class CreateSheetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSheetResponseBody> body{};

  CreateSheetResponse() {}

  explicit CreateSheetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSheetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSheetResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSheetResponse() = default;
};
class CreateSubscribedCalendarHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateSubscribedCalendarHeadersAccountContext() {}

  explicit CreateSubscribedCalendarHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateSubscribedCalendarHeadersAccountContext() = default;
};
class CreateSubscribedCalendarHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateSubscribedCalendarHeadersAccountContext> accountContext{};

  CreateSubscribedCalendarHeaders() {}

  explicit CreateSubscribedCalendarHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateSubscribedCalendarHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateSubscribedCalendarHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateSubscribedCalendarHeaders() = default;
};
class CreateSubscribedCalendarShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateSubscribedCalendarShrinkHeaders() {}

  explicit CreateSubscribedCalendarShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateSubscribedCalendarShrinkHeaders() = default;
};
class CreateSubscribedCalendarRequestSubscribeScope : public Darabonba::Model {
public:
  shared_ptr<vector<string>> corpIds{};
  shared_ptr<vector<string>> openConversationIds{};
  shared_ptr<vector<string>> userIds{};

  CreateSubscribedCalendarRequestSubscribeScope() {}

  explicit CreateSubscribedCalendarRequestSubscribeScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpIds) {
      res["CorpIds"] = boost::any(*corpIds);
    }
    if (openConversationIds) {
      res["OpenConversationIds"] = boost::any(*openConversationIds);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpIds") != m.end() && !m["CorpIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CorpIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CorpIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      corpIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OpenConversationIds") != m.end() && !m["OpenConversationIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OpenConversationIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OpenConversationIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      openConversationIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateSubscribedCalendarRequestSubscribeScope() = default;
};
class CreateSubscribedCalendarRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<vector<string>> managers{};
  shared_ptr<string> name{};
  shared_ptr<CreateSubscribedCalendarRequestSubscribeScope> subscribeScope{};

  CreateSubscribedCalendarRequest() {}

  explicit CreateSubscribedCalendarRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (managers) {
      res["Managers"] = boost::any(*managers);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (subscribeScope) {
      res["SubscribeScope"] = subscribeScope ? boost::any(subscribeScope->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Managers") != m.end() && !m["Managers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Managers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Managers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      managers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SubscribeScope") != m.end() && !m["SubscribeScope"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscribeScope"].type()) {
        CreateSubscribedCalendarRequestSubscribeScope model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscribeScope"]));
        subscribeScope = make_shared<CreateSubscribedCalendarRequestSubscribeScope>(model1);
      }
    }
  }


  virtual ~CreateSubscribedCalendarRequest() = default;
};
class CreateSubscribedCalendarShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> managersShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> subscribeScopeShrink{};

  CreateSubscribedCalendarShrinkRequest() {}

  explicit CreateSubscribedCalendarShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (managersShrink) {
      res["Managers"] = boost::any(*managersShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (subscribeScopeShrink) {
      res["SubscribeScope"] = boost::any(*subscribeScopeShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Managers") != m.end() && !m["Managers"].empty()) {
      managersShrink = make_shared<string>(boost::any_cast<string>(m["Managers"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SubscribeScope") != m.end() && !m["SubscribeScope"].empty()) {
      subscribeScopeShrink = make_shared<string>(boost::any_cast<string>(m["SubscribeScope"]));
    }
  }


  virtual ~CreateSubscribedCalendarShrinkRequest() = default;
};
class CreateSubscribedCalendarResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> calendarId{};
  shared_ptr<string> requestId{};

  CreateSubscribedCalendarResponseBody() {}

  explicit CreateSubscribedCalendarResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calendarId) {
      res["calendarId"] = boost::any(*calendarId);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("calendarId") != m.end() && !m["calendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["calendarId"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateSubscribedCalendarResponseBody() = default;
};
class CreateSubscribedCalendarResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSubscribedCalendarResponseBody> body{};

  CreateSubscribedCalendarResponse() {}

  explicit CreateSubscribedCalendarResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSubscribedCalendarResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSubscribedCalendarResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSubscribedCalendarResponse() = default;
};
class CreateThreadHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountId{};

  CreateThreadHeaders() {}

  explicit CreateThreadHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateThreadHeaders() = default;
};
class CreateThreadRequest : public Darabonba::Model {
public:
  shared_ptr<string> assistantId{};
  shared_ptr<string> originalAssistantId{};
  shared_ptr<string> sourceIdOfOriginalAssistantId{};
  shared_ptr<long> sourceTypeOfOriginalAssistantId{};

  CreateThreadRequest() {}

  explicit CreateThreadRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assistantId) {
      res["assistantId"] = boost::any(*assistantId);
    }
    if (originalAssistantId) {
      res["originalAssistantId"] = boost::any(*originalAssistantId);
    }
    if (sourceIdOfOriginalAssistantId) {
      res["sourceIdOfOriginalAssistantId"] = boost::any(*sourceIdOfOriginalAssistantId);
    }
    if (sourceTypeOfOriginalAssistantId) {
      res["sourceTypeOfOriginalAssistantId"] = boost::any(*sourceTypeOfOriginalAssistantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assistantId") != m.end() && !m["assistantId"].empty()) {
      assistantId = make_shared<string>(boost::any_cast<string>(m["assistantId"]));
    }
    if (m.find("originalAssistantId") != m.end() && !m["originalAssistantId"].empty()) {
      originalAssistantId = make_shared<string>(boost::any_cast<string>(m["originalAssistantId"]));
    }
    if (m.find("sourceIdOfOriginalAssistantId") != m.end() && !m["sourceIdOfOriginalAssistantId"].empty()) {
      sourceIdOfOriginalAssistantId = make_shared<string>(boost::any_cast<string>(m["sourceIdOfOriginalAssistantId"]));
    }
    if (m.find("sourceTypeOfOriginalAssistantId") != m.end() && !m["sourceTypeOfOriginalAssistantId"].empty()) {
      sourceTypeOfOriginalAssistantId = make_shared<long>(boost::any_cast<long>(m["sourceTypeOfOriginalAssistantId"]));
    }
  }


  virtual ~CreateThreadRequest() = default;
};
class CreateThreadResponseBodyThread : public Darabonba::Model {
public:
  shared_ptr<long> createAt{};
  shared_ptr<string> id{};

  CreateThreadResponseBodyThread() {}

  explicit CreateThreadResponseBodyThread(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createAt) {
      res["createAt"] = boost::any(*createAt);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createAt") != m.end() && !m["createAt"].empty()) {
      createAt = make_shared<long>(boost::any_cast<long>(m["createAt"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
  }


  virtual ~CreateThreadResponseBodyThread() = default;
};
class CreateThreadResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateThreadResponseBodyThread> thread{};

  CreateThreadResponseBody() {}

  explicit CreateThreadResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (thread) {
      res["thread"] = thread ? boost::any(thread->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("thread") != m.end() && !m["thread"].empty()) {
      if (typeid(map<string, boost::any>) == m["thread"].type()) {
        CreateThreadResponseBodyThread model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["thread"]));
        thread = make_shared<CreateThreadResponseBodyThread>(model1);
      }
    }
  }


  virtual ~CreateThreadResponseBody() = default;
};
class CreateThreadResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateThreadResponseBody> body{};

  CreateThreadResponse() {}

  explicit CreateThreadResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateThreadResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateThreadResponseBody>(model1);
      }
    }
  }


  virtual ~CreateThreadResponse() = default;
};
class CreateTicketHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateTicketHeadersAccountContext() {}

  explicit CreateTicketHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateTicketHeadersAccountContext() = default;
};
class CreateTicketHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateTicketHeadersAccountContext> accountContext{};

  CreateTicketHeaders() {}

  explicit CreateTicketHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateTicketHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateTicketHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateTicketHeaders() = default;
};
class CreateTicketShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateTicketShrinkHeaders() {}

  explicit CreateTicketShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateTicketShrinkHeaders() = default;
};
class CreateTicketRequestNotify : public Darabonba::Model {
public:
  shared_ptr<vector<string>> groupNoticeReceiverUserIds{};
  shared_ptr<bool> noticeAllGroupMember{};
  shared_ptr<vector<string>> workNoticeReceiverUserIds{};

  CreateTicketRequestNotify() {}

  explicit CreateTicketRequestNotify(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupNoticeReceiverUserIds) {
      res["GroupNoticeReceiverUserIds"] = boost::any(*groupNoticeReceiverUserIds);
    }
    if (noticeAllGroupMember) {
      res["NoticeAllGroupMember"] = boost::any(*noticeAllGroupMember);
    }
    if (workNoticeReceiverUserIds) {
      res["WorkNoticeReceiverUserIds"] = boost::any(*workNoticeReceiverUserIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupNoticeReceiverUserIds") != m.end() && !m["GroupNoticeReceiverUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupNoticeReceiverUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupNoticeReceiverUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupNoticeReceiverUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NoticeAllGroupMember") != m.end() && !m["NoticeAllGroupMember"].empty()) {
      noticeAllGroupMember = make_shared<bool>(boost::any_cast<bool>(m["NoticeAllGroupMember"]));
    }
    if (m.find("WorkNoticeReceiverUserIds") != m.end() && !m["WorkNoticeReceiverUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WorkNoticeReceiverUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WorkNoticeReceiverUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      workNoticeReceiverUserIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateTicketRequestNotify() = default;
};
class CreateTicketRequestSceneContextGroupMsgs : public Darabonba::Model {
public:
  shared_ptr<bool> anchor{};
  shared_ptr<string> openMsgId{};

  CreateTicketRequestSceneContextGroupMsgs() {}

  explicit CreateTicketRequestSceneContextGroupMsgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anchor) {
      res["Anchor"] = boost::any(*anchor);
    }
    if (openMsgId) {
      res["OpenMsgId"] = boost::any(*openMsgId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Anchor") != m.end() && !m["Anchor"].empty()) {
      anchor = make_shared<bool>(boost::any_cast<bool>(m["Anchor"]));
    }
    if (m.find("OpenMsgId") != m.end() && !m["OpenMsgId"].empty()) {
      openMsgId = make_shared<string>(boost::any_cast<string>(m["OpenMsgId"]));
    }
  }


  virtual ~CreateTicketRequestSceneContextGroupMsgs() = default;
};
class CreateTicketRequestSceneContext : public Darabonba::Model {
public:
  shared_ptr<vector<CreateTicketRequestSceneContextGroupMsgs>> groupMsgs{};
  shared_ptr<string> openConversationId{};
  shared_ptr<vector<string>> relevantorUserIds{};
  shared_ptr<string> topicId{};

  CreateTicketRequestSceneContext() {}

  explicit CreateTicketRequestSceneContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupMsgs) {
      vector<boost::any> temp1;
      for(auto item1:*groupMsgs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupMsgs"] = boost::any(temp1);
    }
    if (openConversationId) {
      res["OpenConversationId"] = boost::any(*openConversationId);
    }
    if (relevantorUserIds) {
      res["RelevantorUserIds"] = boost::any(*relevantorUserIds);
    }
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupMsgs") != m.end() && !m["GroupMsgs"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupMsgs"].type()) {
        vector<CreateTicketRequestSceneContextGroupMsgs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupMsgs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTicketRequestSceneContextGroupMsgs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupMsgs = make_shared<vector<CreateTicketRequestSceneContextGroupMsgs>>(expect1);
      }
    }
    if (m.find("OpenConversationId") != m.end() && !m["OpenConversationId"].empty()) {
      openConversationId = make_shared<string>(boost::any_cast<string>(m["OpenConversationId"]));
    }
    if (m.find("RelevantorUserIds") != m.end() && !m["RelevantorUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RelevantorUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RelevantorUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      relevantorUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<string>(boost::any_cast<string>(m["TopicId"]));
    }
  }


  virtual ~CreateTicketRequestSceneContext() = default;
};
class CreateTicketRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateTicketRequestTenantContext() {}

  explicit CreateTicketRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateTicketRequestTenantContext() = default;
};
class CreateTicketRequest : public Darabonba::Model {
public:
  shared_ptr<string> customFields{};
  shared_ptr<CreateTicketRequestNotify> notify{};
  shared_ptr<string> openTeamId{};
  shared_ptr<string> openTemplateBizId{};
  shared_ptr<vector<string>> processorUserIds{};
  shared_ptr<string> scene{};
  shared_ptr<CreateTicketRequestSceneContext> sceneContext{};
  shared_ptr<CreateTicketRequestTenantContext> tenantContext{};
  shared_ptr<string> title{};

  CreateTicketRequest() {}

  explicit CreateTicketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customFields) {
      res["CustomFields"] = boost::any(*customFields);
    }
    if (notify) {
      res["Notify"] = notify ? boost::any(notify->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (openTeamId) {
      res["OpenTeamId"] = boost::any(*openTeamId);
    }
    if (openTemplateBizId) {
      res["OpenTemplateBizId"] = boost::any(*openTemplateBizId);
    }
    if (processorUserIds) {
      res["ProcessorUserIds"] = boost::any(*processorUserIds);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (sceneContext) {
      res["SceneContext"] = sceneContext ? boost::any(sceneContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomFields") != m.end() && !m["CustomFields"].empty()) {
      customFields = make_shared<string>(boost::any_cast<string>(m["CustomFields"]));
    }
    if (m.find("Notify") != m.end() && !m["Notify"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notify"].type()) {
        CreateTicketRequestNotify model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notify"]));
        notify = make_shared<CreateTicketRequestNotify>(model1);
      }
    }
    if (m.find("OpenTeamId") != m.end() && !m["OpenTeamId"].empty()) {
      openTeamId = make_shared<string>(boost::any_cast<string>(m["OpenTeamId"]));
    }
    if (m.find("OpenTemplateBizId") != m.end() && !m["OpenTemplateBizId"].empty()) {
      openTemplateBizId = make_shared<string>(boost::any_cast<string>(m["OpenTemplateBizId"]));
    }
    if (m.find("ProcessorUserIds") != m.end() && !m["ProcessorUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProcessorUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProcessorUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      processorUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("SceneContext") != m.end() && !m["SceneContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["SceneContext"].type()) {
        CreateTicketRequestSceneContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SceneContext"]));
        sceneContext = make_shared<CreateTicketRequestSceneContext>(model1);
      }
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateTicketRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateTicketRequestTenantContext>(model1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~CreateTicketRequest() = default;
};
class CreateTicketShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> customFields{};
  shared_ptr<string> notifyShrink{};
  shared_ptr<string> openTeamId{};
  shared_ptr<string> openTemplateBizId{};
  shared_ptr<string> processorUserIdsShrink{};
  shared_ptr<string> scene{};
  shared_ptr<string> sceneContextShrink{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> title{};

  CreateTicketShrinkRequest() {}

  explicit CreateTicketShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customFields) {
      res["CustomFields"] = boost::any(*customFields);
    }
    if (notifyShrink) {
      res["Notify"] = boost::any(*notifyShrink);
    }
    if (openTeamId) {
      res["OpenTeamId"] = boost::any(*openTeamId);
    }
    if (openTemplateBizId) {
      res["OpenTemplateBizId"] = boost::any(*openTemplateBizId);
    }
    if (processorUserIdsShrink) {
      res["ProcessorUserIds"] = boost::any(*processorUserIdsShrink);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (sceneContextShrink) {
      res["SceneContext"] = boost::any(*sceneContextShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomFields") != m.end() && !m["CustomFields"].empty()) {
      customFields = make_shared<string>(boost::any_cast<string>(m["CustomFields"]));
    }
    if (m.find("Notify") != m.end() && !m["Notify"].empty()) {
      notifyShrink = make_shared<string>(boost::any_cast<string>(m["Notify"]));
    }
    if (m.find("OpenTeamId") != m.end() && !m["OpenTeamId"].empty()) {
      openTeamId = make_shared<string>(boost::any_cast<string>(m["OpenTeamId"]));
    }
    if (m.find("OpenTemplateBizId") != m.end() && !m["OpenTemplateBizId"].empty()) {
      openTemplateBizId = make_shared<string>(boost::any_cast<string>(m["OpenTemplateBizId"]));
    }
    if (m.find("ProcessorUserIds") != m.end() && !m["ProcessorUserIds"].empty()) {
      processorUserIdsShrink = make_shared<string>(boost::any_cast<string>(m["ProcessorUserIds"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("SceneContext") != m.end() && !m["SceneContext"].empty()) {
      sceneContextShrink = make_shared<string>(boost::any_cast<string>(m["SceneContext"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~CreateTicketShrinkRequest() = default;
};
class CreateTicketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> openTicketId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  CreateTicketResponseBody() {}

  explicit CreateTicketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openTicketId) {
      res["openTicketId"] = boost::any(*openTicketId);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("openTicketId") != m.end() && !m["openTicketId"].empty()) {
      openTicketId = make_shared<string>(boost::any_cast<string>(m["openTicketId"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~CreateTicketResponseBody() = default;
};
class CreateTicketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTicketResponseBody> body{};

  CreateTicketResponse() {}

  explicit CreateTicketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTicketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTicketResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTicketResponse() = default;
};
class CreateTodoTaskHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateTodoTaskHeadersAccountContext() {}

  explicit CreateTodoTaskHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateTodoTaskHeadersAccountContext() = default;
};
class CreateTodoTaskHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateTodoTaskHeadersAccountContext> accountContext{};

  CreateTodoTaskHeaders() {}

  explicit CreateTodoTaskHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateTodoTaskHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateTodoTaskHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateTodoTaskHeaders() = default;
};
class CreateTodoTaskShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateTodoTaskShrinkHeaders() {}

  explicit CreateTodoTaskShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateTodoTaskShrinkHeaders() = default;
};
class CreateTodoTaskRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateTodoTaskRequestTenantContext() {}

  explicit CreateTodoTaskRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateTodoTaskRequestTenantContext() = default;
};
class CreateTodoTaskRequestActionListParam : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<map<string, string>> header{};

  CreateTodoTaskRequestActionListParam() {}

  explicit CreateTodoTaskRequestActionListParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (header) {
      res["header"] = boost::any(*header);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("header") != m.end() && !m["header"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["header"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      header = make_shared<map<string, string>>(toMap1);
    }
  }


  virtual ~CreateTodoTaskRequestActionListParam() = default;
};
class CreateTodoTaskRequestActionList : public Darabonba::Model {
public:
  shared_ptr<string> actionKey{};
  shared_ptr<long> actionType{};
  shared_ptr<long> buttonStyleType{};
  shared_ptr<CreateTodoTaskRequestActionListParam> param{};
  shared_ptr<string> pcUrl{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  CreateTodoTaskRequestActionList() {}

  explicit CreateTodoTaskRequestActionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionKey) {
      res["actionKey"] = boost::any(*actionKey);
    }
    if (actionType) {
      res["actionType"] = boost::any(*actionType);
    }
    if (buttonStyleType) {
      res["buttonStyleType"] = boost::any(*buttonStyleType);
    }
    if (param) {
      res["param"] = param ? boost::any(param->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pcUrl) {
      res["pcUrl"] = boost::any(*pcUrl);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actionKey") != m.end() && !m["actionKey"].empty()) {
      actionKey = make_shared<string>(boost::any_cast<string>(m["actionKey"]));
    }
    if (m.find("actionType") != m.end() && !m["actionType"].empty()) {
      actionType = make_shared<long>(boost::any_cast<long>(m["actionType"]));
    }
    if (m.find("buttonStyleType") != m.end() && !m["buttonStyleType"].empty()) {
      buttonStyleType = make_shared<long>(boost::any_cast<long>(m["buttonStyleType"]));
    }
    if (m.find("param") != m.end() && !m["param"].empty()) {
      if (typeid(map<string, boost::any>) == m["param"].type()) {
        CreateTodoTaskRequestActionListParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["param"]));
        param = make_shared<CreateTodoTaskRequestActionListParam>(model1);
      }
    }
    if (m.find("pcUrl") != m.end() && !m["pcUrl"].empty()) {
      pcUrl = make_shared<string>(boost::any_cast<string>(m["pcUrl"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~CreateTodoTaskRequestActionList() = default;
};
class CreateTodoTaskRequestContentFieldList : public Darabonba::Model {
public:
  shared_ptr<string> fieldKey{};
  shared_ptr<string> fieldValue{};

  CreateTodoTaskRequestContentFieldList() {}

  explicit CreateTodoTaskRequestContentFieldList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldKey) {
      res["fieldKey"] = boost::any(*fieldKey);
    }
    if (fieldValue) {
      res["fieldValue"] = boost::any(*fieldValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldKey") != m.end() && !m["fieldKey"].empty()) {
      fieldKey = make_shared<string>(boost::any_cast<string>(m["fieldKey"]));
    }
    if (m.find("fieldValue") != m.end() && !m["fieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["fieldValue"]));
    }
  }


  virtual ~CreateTodoTaskRequestContentFieldList() = default;
};
class CreateTodoTaskRequestDetailUrl : public Darabonba::Model {
public:
  shared_ptr<string> appUrl{};
  shared_ptr<string> pcUrl{};

  CreateTodoTaskRequestDetailUrl() {}

  explicit CreateTodoTaskRequestDetailUrl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appUrl) {
      res["appUrl"] = boost::any(*appUrl);
    }
    if (pcUrl) {
      res["pcUrl"] = boost::any(*pcUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("appUrl") != m.end() && !m["appUrl"].empty()) {
      appUrl = make_shared<string>(boost::any_cast<string>(m["appUrl"]));
    }
    if (m.find("pcUrl") != m.end() && !m["pcUrl"].empty()) {
      pcUrl = make_shared<string>(boost::any_cast<string>(m["pcUrl"]));
    }
  }


  virtual ~CreateTodoTaskRequestDetailUrl() = default;
};
class CreateTodoTaskRequestNotifyConfigs : public Darabonba::Model {
public:
  shared_ptr<string> dingNotify{};

  CreateTodoTaskRequestNotifyConfigs() {}

  explicit CreateTodoTaskRequestNotifyConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dingNotify) {
      res["dingNotify"] = boost::any(*dingNotify);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dingNotify") != m.end() && !m["dingNotify"].empty()) {
      dingNotify = make_shared<string>(boost::any_cast<string>(m["dingNotify"]));
    }
  }


  virtual ~CreateTodoTaskRequestNotifyConfigs() = default;
};
class CreateTodoTaskRequest : public Darabonba::Model {
public:
  shared_ptr<CreateTodoTaskRequestTenantContext> tenantContext{};
  shared_ptr<vector<CreateTodoTaskRequestActionList>> actionList{};
  shared_ptr<vector<CreateTodoTaskRequestContentFieldList>> contentFieldList{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<CreateTodoTaskRequestDetailUrl> detailUrl{};
  shared_ptr<long> dueTime{};
  shared_ptr<vector<string>> executorIds{};
  shared_ptr<bool> isOnlyShowExecutor{};
  shared_ptr<CreateTodoTaskRequestNotifyConfigs> notifyConfigs{};
  shared_ptr<string> operatorId{};
  shared_ptr<vector<string>> participantIds{};
  shared_ptr<long> priority{};
  shared_ptr<string> sourceId{};
  shared_ptr<string> subject{};

  CreateTodoTaskRequest() {}

  explicit CreateTodoTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (actionList) {
      vector<boost::any> temp1;
      for(auto item1:*actionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["actionList"] = boost::any(temp1);
    }
    if (contentFieldList) {
      vector<boost::any> temp1;
      for(auto item1:*contentFieldList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["contentFieldList"] = boost::any(temp1);
    }
    if (creatorId) {
      res["creatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (detailUrl) {
      res["detailUrl"] = detailUrl ? boost::any(detailUrl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dueTime) {
      res["dueTime"] = boost::any(*dueTime);
    }
    if (executorIds) {
      res["executorIds"] = boost::any(*executorIds);
    }
    if (isOnlyShowExecutor) {
      res["isOnlyShowExecutor"] = boost::any(*isOnlyShowExecutor);
    }
    if (notifyConfigs) {
      res["notifyConfigs"] = notifyConfigs ? boost::any(notifyConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (operatorId) {
      res["operatorId"] = boost::any(*operatorId);
    }
    if (participantIds) {
      res["participantIds"] = boost::any(*participantIds);
    }
    if (priority) {
      res["priority"] = boost::any(*priority);
    }
    if (sourceId) {
      res["sourceId"] = boost::any(*sourceId);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateTodoTaskRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateTodoTaskRequestTenantContext>(model1);
      }
    }
    if (m.find("actionList") != m.end() && !m["actionList"].empty()) {
      if (typeid(vector<boost::any>) == m["actionList"].type()) {
        vector<CreateTodoTaskRequestActionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["actionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTodoTaskRequestActionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        actionList = make_shared<vector<CreateTodoTaskRequestActionList>>(expect1);
      }
    }
    if (m.find("contentFieldList") != m.end() && !m["contentFieldList"].empty()) {
      if (typeid(vector<boost::any>) == m["contentFieldList"].type()) {
        vector<CreateTodoTaskRequestContentFieldList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["contentFieldList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTodoTaskRequestContentFieldList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contentFieldList = make_shared<vector<CreateTodoTaskRequestContentFieldList>>(expect1);
      }
    }
    if (m.find("creatorId") != m.end() && !m["creatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["creatorId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("detailUrl") != m.end() && !m["detailUrl"].empty()) {
      if (typeid(map<string, boost::any>) == m["detailUrl"].type()) {
        CreateTodoTaskRequestDetailUrl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["detailUrl"]));
        detailUrl = make_shared<CreateTodoTaskRequestDetailUrl>(model1);
      }
    }
    if (m.find("dueTime") != m.end() && !m["dueTime"].empty()) {
      dueTime = make_shared<long>(boost::any_cast<long>(m["dueTime"]));
    }
    if (m.find("executorIds") != m.end() && !m["executorIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["executorIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["executorIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      executorIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("isOnlyShowExecutor") != m.end() && !m["isOnlyShowExecutor"].empty()) {
      isOnlyShowExecutor = make_shared<bool>(boost::any_cast<bool>(m["isOnlyShowExecutor"]));
    }
    if (m.find("notifyConfigs") != m.end() && !m["notifyConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["notifyConfigs"].type()) {
        CreateTodoTaskRequestNotifyConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["notifyConfigs"]));
        notifyConfigs = make_shared<CreateTodoTaskRequestNotifyConfigs>(model1);
      }
    }
    if (m.find("operatorId") != m.end() && !m["operatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["operatorId"]));
    }
    if (m.find("participantIds") != m.end() && !m["participantIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["participantIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["participantIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      participantIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("priority") != m.end() && !m["priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["priority"]));
    }
    if (m.find("sourceId") != m.end() && !m["sourceId"].empty()) {
      sourceId = make_shared<string>(boost::any_cast<string>(m["sourceId"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
  }


  virtual ~CreateTodoTaskRequest() = default;
};
class CreateTodoTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> actionListShrink{};
  shared_ptr<string> contentFieldListShrink{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<string> detailUrlShrink{};
  shared_ptr<long> dueTime{};
  shared_ptr<string> executorIdsShrink{};
  shared_ptr<bool> isOnlyShowExecutor{};
  shared_ptr<string> notifyConfigsShrink{};
  shared_ptr<string> operatorId{};
  shared_ptr<string> participantIdsShrink{};
  shared_ptr<long> priority{};
  shared_ptr<string> sourceId{};
  shared_ptr<string> subject{};

  CreateTodoTaskShrinkRequest() {}

  explicit CreateTodoTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (actionListShrink) {
      res["actionList"] = boost::any(*actionListShrink);
    }
    if (contentFieldListShrink) {
      res["contentFieldList"] = boost::any(*contentFieldListShrink);
    }
    if (creatorId) {
      res["creatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (detailUrlShrink) {
      res["detailUrl"] = boost::any(*detailUrlShrink);
    }
    if (dueTime) {
      res["dueTime"] = boost::any(*dueTime);
    }
    if (executorIdsShrink) {
      res["executorIds"] = boost::any(*executorIdsShrink);
    }
    if (isOnlyShowExecutor) {
      res["isOnlyShowExecutor"] = boost::any(*isOnlyShowExecutor);
    }
    if (notifyConfigsShrink) {
      res["notifyConfigs"] = boost::any(*notifyConfigsShrink);
    }
    if (operatorId) {
      res["operatorId"] = boost::any(*operatorId);
    }
    if (participantIdsShrink) {
      res["participantIds"] = boost::any(*participantIdsShrink);
    }
    if (priority) {
      res["priority"] = boost::any(*priority);
    }
    if (sourceId) {
      res["sourceId"] = boost::any(*sourceId);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("actionList") != m.end() && !m["actionList"].empty()) {
      actionListShrink = make_shared<string>(boost::any_cast<string>(m["actionList"]));
    }
    if (m.find("contentFieldList") != m.end() && !m["contentFieldList"].empty()) {
      contentFieldListShrink = make_shared<string>(boost::any_cast<string>(m["contentFieldList"]));
    }
    if (m.find("creatorId") != m.end() && !m["creatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["creatorId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("detailUrl") != m.end() && !m["detailUrl"].empty()) {
      detailUrlShrink = make_shared<string>(boost::any_cast<string>(m["detailUrl"]));
    }
    if (m.find("dueTime") != m.end() && !m["dueTime"].empty()) {
      dueTime = make_shared<long>(boost::any_cast<long>(m["dueTime"]));
    }
    if (m.find("executorIds") != m.end() && !m["executorIds"].empty()) {
      executorIdsShrink = make_shared<string>(boost::any_cast<string>(m["executorIds"]));
    }
    if (m.find("isOnlyShowExecutor") != m.end() && !m["isOnlyShowExecutor"].empty()) {
      isOnlyShowExecutor = make_shared<bool>(boost::any_cast<bool>(m["isOnlyShowExecutor"]));
    }
    if (m.find("notifyConfigs") != m.end() && !m["notifyConfigs"].empty()) {
      notifyConfigsShrink = make_shared<string>(boost::any_cast<string>(m["notifyConfigs"]));
    }
    if (m.find("operatorId") != m.end() && !m["operatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["operatorId"]));
    }
    if (m.find("participantIds") != m.end() && !m["participantIds"].empty()) {
      participantIdsShrink = make_shared<string>(boost::any_cast<string>(m["participantIds"]));
    }
    if (m.find("priority") != m.end() && !m["priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["priority"]));
    }
    if (m.find("sourceId") != m.end() && !m["sourceId"].empty()) {
      sourceId = make_shared<string>(boost::any_cast<string>(m["sourceId"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
  }


  virtual ~CreateTodoTaskShrinkRequest() = default;
};
class CreateTodoTaskResponseBodyContentFieldList : public Darabonba::Model {
public:
  shared_ptr<string> fieldKey{};
  shared_ptr<string> fieldValue{};

  CreateTodoTaskResponseBodyContentFieldList() {}

  explicit CreateTodoTaskResponseBodyContentFieldList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldKey) {
      res["fieldKey"] = boost::any(*fieldKey);
    }
    if (fieldValue) {
      res["fieldValue"] = boost::any(*fieldValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldKey") != m.end() && !m["fieldKey"].empty()) {
      fieldKey = make_shared<string>(boost::any_cast<string>(m["fieldKey"]));
    }
    if (m.find("fieldValue") != m.end() && !m["fieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["fieldValue"]));
    }
  }


  virtual ~CreateTodoTaskResponseBodyContentFieldList() = default;
};
class CreateTodoTaskResponseBodyDetailUrl : public Darabonba::Model {
public:
  shared_ptr<string> appUrl{};
  shared_ptr<string> pcUrl{};

  CreateTodoTaskResponseBodyDetailUrl() {}

  explicit CreateTodoTaskResponseBodyDetailUrl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appUrl) {
      res["appUrl"] = boost::any(*appUrl);
    }
    if (pcUrl) {
      res["pcUrl"] = boost::any(*pcUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("appUrl") != m.end() && !m["appUrl"].empty()) {
      appUrl = make_shared<string>(boost::any_cast<string>(m["appUrl"]));
    }
    if (m.find("pcUrl") != m.end() && !m["pcUrl"].empty()) {
      pcUrl = make_shared<string>(boost::any_cast<string>(m["pcUrl"]));
    }
  }


  virtual ~CreateTodoTaskResponseBodyDetailUrl() = default;
};
class CreateTodoTaskResponseBodyNotifyConfigs : public Darabonba::Model {
public:
  shared_ptr<string> dingNotify{};

  CreateTodoTaskResponseBodyNotifyConfigs() {}

  explicit CreateTodoTaskResponseBodyNotifyConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dingNotify) {
      res["dingNotify"] = boost::any(*dingNotify);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dingNotify") != m.end() && !m["dingNotify"].empty()) {
      dingNotify = make_shared<string>(boost::any_cast<string>(m["dingNotify"]));
    }
  }


  virtual ~CreateTodoTaskResponseBodyNotifyConfigs() = default;
};
class CreateTodoTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bizTag{};
  shared_ptr<vector<CreateTodoTaskResponseBodyContentFieldList>> contentFieldList{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<CreateTodoTaskResponseBodyDetailUrl> detailUrl{};
  shared_ptr<bool> done{};
  shared_ptr<long> dueTime{};
  shared_ptr<vector<string>> executorIds{};
  shared_ptr<long> finishTime{};
  shared_ptr<string> id{};
  shared_ptr<bool> isOnlyShowExecutor{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<CreateTodoTaskResponseBodyNotifyConfigs> notifyConfigs{};
  shared_ptr<vector<string>> participantIds{};
  shared_ptr<long> priority{};
  shared_ptr<string> requestId{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> subject{};

  CreateTodoTaskResponseBody() {}

  explicit CreateTodoTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizTag) {
      res["bizTag"] = boost::any(*bizTag);
    }
    if (contentFieldList) {
      vector<boost::any> temp1;
      for(auto item1:*contentFieldList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["contentFieldList"] = boost::any(temp1);
    }
    if (createdTime) {
      res["createdTime"] = boost::any(*createdTime);
    }
    if (creatorId) {
      res["creatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (detailUrl) {
      res["detailUrl"] = detailUrl ? boost::any(detailUrl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (done) {
      res["done"] = boost::any(*done);
    }
    if (dueTime) {
      res["dueTime"] = boost::any(*dueTime);
    }
    if (executorIds) {
      res["executorIds"] = boost::any(*executorIds);
    }
    if (finishTime) {
      res["finishTime"] = boost::any(*finishTime);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isOnlyShowExecutor) {
      res["isOnlyShowExecutor"] = boost::any(*isOnlyShowExecutor);
    }
    if (modifiedTime) {
      res["modifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["modifierId"] = boost::any(*modifierId);
    }
    if (notifyConfigs) {
      res["notifyConfigs"] = notifyConfigs ? boost::any(notifyConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (participantIds) {
      res["participantIds"] = boost::any(*participantIds);
    }
    if (priority) {
      res["priority"] = boost::any(*priority);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (sourceId) {
      res["sourceId"] = boost::any(*sourceId);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bizTag") != m.end() && !m["bizTag"].empty()) {
      bizTag = make_shared<string>(boost::any_cast<string>(m["bizTag"]));
    }
    if (m.find("contentFieldList") != m.end() && !m["contentFieldList"].empty()) {
      if (typeid(vector<boost::any>) == m["contentFieldList"].type()) {
        vector<CreateTodoTaskResponseBodyContentFieldList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["contentFieldList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTodoTaskResponseBodyContentFieldList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contentFieldList = make_shared<vector<CreateTodoTaskResponseBodyContentFieldList>>(expect1);
      }
    }
    if (m.find("createdTime") != m.end() && !m["createdTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["createdTime"]));
    }
    if (m.find("creatorId") != m.end() && !m["creatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["creatorId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("detailUrl") != m.end() && !m["detailUrl"].empty()) {
      if (typeid(map<string, boost::any>) == m["detailUrl"].type()) {
        CreateTodoTaskResponseBodyDetailUrl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["detailUrl"]));
        detailUrl = make_shared<CreateTodoTaskResponseBodyDetailUrl>(model1);
      }
    }
    if (m.find("done") != m.end() && !m["done"].empty()) {
      done = make_shared<bool>(boost::any_cast<bool>(m["done"]));
    }
    if (m.find("dueTime") != m.end() && !m["dueTime"].empty()) {
      dueTime = make_shared<long>(boost::any_cast<long>(m["dueTime"]));
    }
    if (m.find("executorIds") != m.end() && !m["executorIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["executorIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["executorIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      executorIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("finishTime") != m.end() && !m["finishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["finishTime"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("isOnlyShowExecutor") != m.end() && !m["isOnlyShowExecutor"].empty()) {
      isOnlyShowExecutor = make_shared<bool>(boost::any_cast<bool>(m["isOnlyShowExecutor"]));
    }
    if (m.find("modifiedTime") != m.end() && !m["modifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["modifiedTime"]));
    }
    if (m.find("modifierId") != m.end() && !m["modifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["modifierId"]));
    }
    if (m.find("notifyConfigs") != m.end() && !m["notifyConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["notifyConfigs"].type()) {
        CreateTodoTaskResponseBodyNotifyConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["notifyConfigs"]));
        notifyConfigs = make_shared<CreateTodoTaskResponseBodyNotifyConfigs>(model1);
      }
    }
    if (m.find("participantIds") != m.end() && !m["participantIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["participantIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["participantIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      participantIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("priority") != m.end() && !m["priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["priority"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("sourceId") != m.end() && !m["sourceId"].empty()) {
      sourceId = make_shared<string>(boost::any_cast<string>(m["sourceId"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
  }


  virtual ~CreateTodoTaskResponseBody() = default;
};
class CreateTodoTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTodoTaskResponseBody> body{};

  CreateTodoTaskResponse() {}

  explicit CreateTodoTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTodoTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTodoTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTodoTaskResponse() = default;
};
class CreateVideoConferenceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateVideoConferenceHeadersAccountContext() {}

  explicit CreateVideoConferenceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateVideoConferenceHeadersAccountContext() = default;
};
class CreateVideoConferenceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateVideoConferenceHeadersAccountContext> accountContext{};

  CreateVideoConferenceHeaders() {}

  explicit CreateVideoConferenceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateVideoConferenceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateVideoConferenceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateVideoConferenceHeaders() = default;
};
class CreateVideoConferenceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateVideoConferenceShrinkHeaders() {}

  explicit CreateVideoConferenceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateVideoConferenceShrinkHeaders() = default;
};
class CreateVideoConferenceRequest : public Darabonba::Model {
public:
  shared_ptr<string> confTitle{};
  shared_ptr<bool> inviteCaller{};
  shared_ptr<vector<string>> inviteUserIds{};

  CreateVideoConferenceRequest() {}

  explicit CreateVideoConferenceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (confTitle) {
      res["ConfTitle"] = boost::any(*confTitle);
    }
    if (inviteCaller) {
      res["InviteCaller"] = boost::any(*inviteCaller);
    }
    if (inviteUserIds) {
      res["InviteUserIds"] = boost::any(*inviteUserIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfTitle") != m.end() && !m["ConfTitle"].empty()) {
      confTitle = make_shared<string>(boost::any_cast<string>(m["ConfTitle"]));
    }
    if (m.find("InviteCaller") != m.end() && !m["InviteCaller"].empty()) {
      inviteCaller = make_shared<bool>(boost::any_cast<bool>(m["InviteCaller"]));
    }
    if (m.find("InviteUserIds") != m.end() && !m["InviteUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InviteUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InviteUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      inviteUserIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateVideoConferenceRequest() = default;
};
class CreateVideoConferenceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> confTitle{};
  shared_ptr<bool> inviteCaller{};
  shared_ptr<string> inviteUserIdsShrink{};

  CreateVideoConferenceShrinkRequest() {}

  explicit CreateVideoConferenceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (confTitle) {
      res["ConfTitle"] = boost::any(*confTitle);
    }
    if (inviteCaller) {
      res["InviteCaller"] = boost::any(*inviteCaller);
    }
    if (inviteUserIdsShrink) {
      res["InviteUserIds"] = boost::any(*inviteUserIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfTitle") != m.end() && !m["ConfTitle"].empty()) {
      confTitle = make_shared<string>(boost::any_cast<string>(m["ConfTitle"]));
    }
    if (m.find("InviteCaller") != m.end() && !m["InviteCaller"].empty()) {
      inviteCaller = make_shared<bool>(boost::any_cast<bool>(m["InviteCaller"]));
    }
    if (m.find("InviteUserIds") != m.end() && !m["InviteUserIds"].empty()) {
      inviteUserIdsShrink = make_shared<string>(boost::any_cast<string>(m["InviteUserIds"]));
    }
  }


  virtual ~CreateVideoConferenceShrinkRequest() = default;
};
class CreateVideoConferenceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> conferenceId{};
  shared_ptr<string> conferencePassword{};
  shared_ptr<string> externalLinkUrl{};
  shared_ptr<string> hostPassword{};
  shared_ptr<vector<string>> phoneNumbers{};
  shared_ptr<string> requestId{};
  shared_ptr<string> roomCode{};

  CreateVideoConferenceResponseBody() {}

  explicit CreateVideoConferenceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    if (conferencePassword) {
      res["conferencePassword"] = boost::any(*conferencePassword);
    }
    if (externalLinkUrl) {
      res["externalLinkUrl"] = boost::any(*externalLinkUrl);
    }
    if (hostPassword) {
      res["hostPassword"] = boost::any(*hostPassword);
    }
    if (phoneNumbers) {
      res["phoneNumbers"] = boost::any(*phoneNumbers);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (roomCode) {
      res["roomCode"] = boost::any(*roomCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
    if (m.find("conferencePassword") != m.end() && !m["conferencePassword"].empty()) {
      conferencePassword = make_shared<string>(boost::any_cast<string>(m["conferencePassword"]));
    }
    if (m.find("externalLinkUrl") != m.end() && !m["externalLinkUrl"].empty()) {
      externalLinkUrl = make_shared<string>(boost::any_cast<string>(m["externalLinkUrl"]));
    }
    if (m.find("hostPassword") != m.end() && !m["hostPassword"].empty()) {
      hostPassword = make_shared<string>(boost::any_cast<string>(m["hostPassword"]));
    }
    if (m.find("phoneNumbers") != m.end() && !m["phoneNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["phoneNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["phoneNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      phoneNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("roomCode") != m.end() && !m["roomCode"].empty()) {
      roomCode = make_shared<string>(boost::any_cast<string>(m["roomCode"]));
    }
  }


  virtual ~CreateVideoConferenceResponseBody() = default;
};
class CreateVideoConferenceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVideoConferenceResponseBody> body{};

  CreateVideoConferenceResponse() {}

  explicit CreateVideoConferenceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVideoConferenceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVideoConferenceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVideoConferenceResponse() = default;
};
class CreateWorkspaceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateWorkspaceHeadersAccountContext() {}

  explicit CreateWorkspaceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateWorkspaceHeadersAccountContext() = default;
};
class CreateWorkspaceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateWorkspaceHeadersAccountContext> accountContext{};

  CreateWorkspaceHeaders() {}

  explicit CreateWorkspaceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateWorkspaceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateWorkspaceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateWorkspaceHeaders() = default;
};
class CreateWorkspaceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateWorkspaceShrinkHeaders() {}

  explicit CreateWorkspaceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateWorkspaceShrinkHeaders() = default;
};
class CreateWorkspaceRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateWorkspaceRequestTenantContext() {}

  explicit CreateWorkspaceRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateWorkspaceRequestTenantContext() = default;
};
class CreateWorkspaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<CreateWorkspaceRequestTenantContext> tenantContext{};

  CreateWorkspaceRequest() {}

  explicit CreateWorkspaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateWorkspaceRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateWorkspaceRequestTenantContext>(model1);
      }
    }
  }


  virtual ~CreateWorkspaceRequest() = default;
};
class CreateWorkspaceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> tenantContextShrink{};

  CreateWorkspaceShrinkRequest() {}

  explicit CreateWorkspaceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~CreateWorkspaceShrinkRequest() = default;
};
class CreateWorkspaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  CreateWorkspaceResponseBody() {}

  explicit CreateWorkspaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["workspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
    if (m.find("workspaceId") != m.end() && !m["workspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["workspaceId"]));
    }
  }


  virtual ~CreateWorkspaceResponseBody() = default;
};
class CreateWorkspaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWorkspaceResponseBody> body{};

  CreateWorkspaceResponse() {}

  explicit CreateWorkspaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWorkspaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWorkspaceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWorkspaceResponse() = default;
};
class CreateWorkspaceDocHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateWorkspaceDocHeadersAccountContext() {}

  explicit CreateWorkspaceDocHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateWorkspaceDocHeadersAccountContext() = default;
};
class CreateWorkspaceDocHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateWorkspaceDocHeadersAccountContext> accountContext{};

  CreateWorkspaceDocHeaders() {}

  explicit CreateWorkspaceDocHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateWorkspaceDocHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateWorkspaceDocHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateWorkspaceDocHeaders() = default;
};
class CreateWorkspaceDocShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateWorkspaceDocShrinkHeaders() {}

  explicit CreateWorkspaceDocShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateWorkspaceDocShrinkHeaders() = default;
};
class CreateWorkspaceDocRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateWorkspaceDocRequestTenantContext() {}

  explicit CreateWorkspaceDocRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateWorkspaceDocRequestTenantContext() = default;
};
class CreateWorkspaceDocRequest : public Darabonba::Model {
public:
  shared_ptr<string> docType{};
  shared_ptr<string> name{};
  shared_ptr<string> parentNodeId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateType{};
  shared_ptr<CreateWorkspaceDocRequestTenantContext> tenantContext{};
  shared_ptr<string> workspaceId{};

  CreateWorkspaceDocRequest() {}

  explicit CreateWorkspaceDocRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentNodeId) {
      res["ParentNodeId"] = boost::any(*parentNodeId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentNodeId") != m.end() && !m["ParentNodeId"].empty()) {
      parentNodeId = make_shared<string>(boost::any_cast<string>(m["ParentNodeId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateWorkspaceDocRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateWorkspaceDocRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateWorkspaceDocRequest() = default;
};
class CreateWorkspaceDocShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> docType{};
  shared_ptr<string> name{};
  shared_ptr<string> parentNodeId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateType{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workspaceId{};

  CreateWorkspaceDocShrinkRequest() {}

  explicit CreateWorkspaceDocShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentNodeId) {
      res["ParentNodeId"] = boost::any(*parentNodeId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentNodeId") != m.end() && !m["ParentNodeId"].empty()) {
      parentNodeId = make_shared<string>(boost::any_cast<string>(m["ParentNodeId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateWorkspaceDocShrinkRequest() = default;
};
class CreateWorkspaceDocResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dentryUuid{};
  shared_ptr<string> docKey{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> url{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};
  shared_ptr<string> workspaceId{};

  CreateWorkspaceDocResponseBody() {}

  explicit CreateWorkspaceDocResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryUuid) {
      res["dentryUuid"] = boost::any(*dentryUuid);
    }
    if (docKey) {
      res["docKey"] = boost::any(*docKey);
    }
    if (nodeId) {
      res["nodeId"] = boost::any(*nodeId);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    if (workspaceId) {
      res["workspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dentryUuid") != m.end() && !m["dentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["dentryUuid"]));
    }
    if (m.find("docKey") != m.end() && !m["docKey"].empty()) {
      docKey = make_shared<string>(boost::any_cast<string>(m["docKey"]));
    }
    if (m.find("nodeId") != m.end() && !m["nodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["nodeId"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
    if (m.find("workspaceId") != m.end() && !m["workspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["workspaceId"]));
    }
  }


  virtual ~CreateWorkspaceDocResponseBody() = default;
};
class CreateWorkspaceDocResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWorkspaceDocResponseBody> body{};

  CreateWorkspaceDocResponse() {}

  explicit CreateWorkspaceDocResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWorkspaceDocResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWorkspaceDocResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWorkspaceDocResponse() = default;
};
class DeleteColumnsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteColumnsHeadersAccountContext() {}

  explicit DeleteColumnsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteColumnsHeadersAccountContext() = default;
};
class DeleteColumnsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteColumnsHeadersAccountContext> accountContext{};

  DeleteColumnsHeaders() {}

  explicit DeleteColumnsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteColumnsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteColumnsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteColumnsHeaders() = default;
};
class DeleteColumnsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteColumnsShrinkHeaders() {}

  explicit DeleteColumnsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteColumnsShrinkHeaders() = default;
};
class DeleteColumnsRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DeleteColumnsRequestTenantContext() {}

  explicit DeleteColumnsRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DeleteColumnsRequestTenantContext() = default;
};
class DeleteColumnsRequest : public Darabonba::Model {
public:
  shared_ptr<long> column{};
  shared_ptr<long> columnCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<DeleteColumnsRequestTenantContext> tenantContext{};
  shared_ptr<string> workbookId{};

  DeleteColumnsRequest() {}

  explicit DeleteColumnsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (column) {
      res["Column"] = boost::any(*column);
    }
    if (columnCount) {
      res["ColumnCount"] = boost::any(*columnCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Column") != m.end() && !m["Column"].empty()) {
      column = make_shared<long>(boost::any_cast<long>(m["Column"]));
    }
    if (m.find("ColumnCount") != m.end() && !m["ColumnCount"].empty()) {
      columnCount = make_shared<long>(boost::any_cast<long>(m["ColumnCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DeleteColumnsRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DeleteColumnsRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~DeleteColumnsRequest() = default;
};
class DeleteColumnsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> column{};
  shared_ptr<long> columnCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workbookId{};

  DeleteColumnsShrinkRequest() {}

  explicit DeleteColumnsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (column) {
      res["Column"] = boost::any(*column);
    }
    if (columnCount) {
      res["ColumnCount"] = boost::any(*columnCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Column") != m.end() && !m["Column"].empty()) {
      column = make_shared<long>(boost::any_cast<long>(m["Column"]));
    }
    if (m.find("ColumnCount") != m.end() && !m["ColumnCount"].empty()) {
      columnCount = make_shared<long>(boost::any_cast<long>(m["ColumnCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~DeleteColumnsShrinkRequest() = default;
};
class DeleteColumnsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  DeleteColumnsResponseBody() {}

  explicit DeleteColumnsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeleteColumnsResponseBody() = default;
};
class DeleteColumnsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteColumnsResponseBody> body{};

  DeleteColumnsResponse() {}

  explicit DeleteColumnsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteColumnsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteColumnsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteColumnsResponse() = default;
};
class DeleteDentryHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteDentryHeadersAccountContext() {}

  explicit DeleteDentryHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteDentryHeadersAccountContext() = default;
};
class DeleteDentryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteDentryHeadersAccountContext> accountContext{};

  DeleteDentryHeaders() {}

  explicit DeleteDentryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteDentryHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteDentryHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteDentryHeaders() = default;
};
class DeleteDentryShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteDentryShrinkHeaders() {}

  explicit DeleteDentryShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteDentryShrinkHeaders() = default;
};
class DeleteDentryRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DeleteDentryRequestTenantContext() {}

  explicit DeleteDentryRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DeleteDentryRequestTenantContext() = default;
};
class DeleteDentryRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryId{};
  shared_ptr<string> spaceId{};
  shared_ptr<DeleteDentryRequestTenantContext> tenantContext{};
  shared_ptr<bool> toRecycleBin{};

  DeleteDentryRequest() {}

  explicit DeleteDentryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryId) {
      res["DentryId"] = boost::any(*dentryId);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (toRecycleBin) {
      res["ToRecycleBin"] = boost::any(*toRecycleBin);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryId") != m.end() && !m["DentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["DentryId"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DeleteDentryRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DeleteDentryRequestTenantContext>(model1);
      }
    }
    if (m.find("ToRecycleBin") != m.end() && !m["ToRecycleBin"].empty()) {
      toRecycleBin = make_shared<bool>(boost::any_cast<bool>(m["ToRecycleBin"]));
    }
  }


  virtual ~DeleteDentryRequest() = default;
};
class DeleteDentryShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryId{};
  shared_ptr<string> spaceId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<bool> toRecycleBin{};

  DeleteDentryShrinkRequest() {}

  explicit DeleteDentryShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryId) {
      res["DentryId"] = boost::any(*dentryId);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (toRecycleBin) {
      res["ToRecycleBin"] = boost::any(*toRecycleBin);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryId") != m.end() && !m["DentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["DentryId"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("ToRecycleBin") != m.end() && !m["ToRecycleBin"].empty()) {
      toRecycleBin = make_shared<bool>(boost::any_cast<bool>(m["ToRecycleBin"]));
    }
  }


  virtual ~DeleteDentryShrinkRequest() = default;
};
class DeleteDentryResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> async{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  DeleteDentryResponseBody() {}

  explicit DeleteDentryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["async"] = boost::any(*async);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("async") != m.end() && !m["async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["async"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~DeleteDentryResponseBody() = default;
};
class DeleteDentryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDentryResponseBody> body{};

  DeleteDentryResponse() {}

  explicit DeleteDentryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDentryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDentryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDentryResponse() = default;
};
class DeleteDriveSpaceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteDriveSpaceHeadersAccountContext() {}

  explicit DeleteDriveSpaceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteDriveSpaceHeadersAccountContext() = default;
};
class DeleteDriveSpaceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteDriveSpaceHeadersAccountContext> accountContext{};

  DeleteDriveSpaceHeaders() {}

  explicit DeleteDriveSpaceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteDriveSpaceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteDriveSpaceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteDriveSpaceHeaders() = default;
};
class DeleteDriveSpaceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteDriveSpaceShrinkHeaders() {}

  explicit DeleteDriveSpaceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteDriveSpaceShrinkHeaders() = default;
};
class DeleteDriveSpaceRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DeleteDriveSpaceRequestTenantContext() {}

  explicit DeleteDriveSpaceRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DeleteDriveSpaceRequestTenantContext() = default;
};
class DeleteDriveSpaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> spaceId{};
  shared_ptr<DeleteDriveSpaceRequestTenantContext> tenantContext{};

  DeleteDriveSpaceRequest() {}

  explicit DeleteDriveSpaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DeleteDriveSpaceRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DeleteDriveSpaceRequestTenantContext>(model1);
      }
    }
  }


  virtual ~DeleteDriveSpaceRequest() = default;
};
class DeleteDriveSpaceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> spaceId{};
  shared_ptr<string> tenantContextShrink{};

  DeleteDriveSpaceShrinkRequest() {}

  explicit DeleteDriveSpaceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~DeleteDriveSpaceShrinkRequest() = default;
};
class DeleteDriveSpaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  DeleteDriveSpaceResponseBody() {}

  explicit DeleteDriveSpaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~DeleteDriveSpaceResponseBody() = default;
};
class DeleteDriveSpaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDriveSpaceResponseBody> body{};

  DeleteDriveSpaceResponse() {}

  explicit DeleteDriveSpaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDriveSpaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDriveSpaceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDriveSpaceResponse() = default;
};
class DeleteEventHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteEventHeadersAccountContext() {}

  explicit DeleteEventHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteEventHeadersAccountContext() = default;
};
class DeleteEventHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteEventHeadersAccountContext> accountContext{};

  DeleteEventHeaders() {}

  explicit DeleteEventHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteEventHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteEventHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteEventHeaders() = default;
};
class DeleteEventShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteEventShrinkHeaders() {}

  explicit DeleteEventShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteEventShrinkHeaders() = default;
};
class DeleteEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> calendarId{};
  shared_ptr<string> eventId{};
  shared_ptr<bool> pushNotification{};

  DeleteEventRequest() {}

  explicit DeleteEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (pushNotification) {
      res["pushNotification"] = boost::any(*pushNotification);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("pushNotification") != m.end() && !m["pushNotification"].empty()) {
      pushNotification = make_shared<bool>(boost::any_cast<bool>(m["pushNotification"]));
    }
  }


  virtual ~DeleteEventRequest() = default;
};
class DeleteEventResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};

  DeleteEventResponseBodyContent() {}

  explicit DeleteEventResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["data"]));
    }
  }


  virtual ~DeleteEventResponseBodyContent() = default;
};
class DeleteEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeleteEventResponseBodyContent> content{};
  shared_ptr<string> errorCode{};
  shared_ptr<map<string, boost::any>> errorCtx{};
  shared_ptr<string> errorMsg{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteEventResponseBody() {}

  explicit DeleteEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorCtx) {
      res["errorCtx"] = boost::any(*errorCtx);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      if (typeid(map<string, boost::any>) == m["content"].type()) {
        DeleteEventResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["content"]));
        content = make_shared<DeleteEventResponseBodyContent>(model1);
      }
    }
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorCtx") != m.end() && !m["errorCtx"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["errorCtx"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      errorCtx = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["httpStatusCode"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteEventResponseBody() = default;
};
class DeleteEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEventResponseBody> body{};

  DeleteEventResponse() {}

  explicit DeleteEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEventResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEventResponse() = default;
};
class DeleteFormDataHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteFormDataHeadersAccountContext() {}

  explicit DeleteFormDataHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteFormDataHeadersAccountContext() = default;
};
class DeleteFormDataHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteFormDataHeadersAccountContext> accountContext{};

  DeleteFormDataHeaders() {}

  explicit DeleteFormDataHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteFormDataHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteFormDataHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteFormDataHeaders() = default;
};
class DeleteFormDataShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteFormDataShrinkHeaders() {}

  explicit DeleteFormDataShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteFormDataShrinkHeaders() = default;
};
class DeleteFormDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> formInstanceId{};
  shared_ptr<string> language{};
  shared_ptr<string> systemToken{};

  DeleteFormDataRequest() {}

  explicit DeleteFormDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (formInstanceId) {
      res["FormInstanceId"] = boost::any(*formInstanceId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("FormInstanceId") != m.end() && !m["FormInstanceId"].empty()) {
      formInstanceId = make_shared<string>(boost::any_cast<string>(m["FormInstanceId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~DeleteFormDataRequest() = default;
};
class DeleteFormDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  DeleteFormDataResponseBody() {}

  explicit DeleteFormDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~DeleteFormDataResponseBody() = default;
};
class DeleteFormDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFormDataResponseBody> body{};

  DeleteFormDataResponse() {}

  explicit DeleteFormDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFormDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFormDataResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFormDataResponse() = default;
};
class DeleteInstanceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteInstanceHeadersAccountContext() {}

  explicit DeleteInstanceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteInstanceHeadersAccountContext() = default;
};
class DeleteInstanceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteInstanceHeadersAccountContext> accountContext{};

  DeleteInstanceHeaders() {}

  explicit DeleteInstanceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteInstanceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteInstanceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteInstanceHeaders() = default;
};
class DeleteInstanceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteInstanceShrinkHeaders() {}

  explicit DeleteInstanceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteInstanceShrinkHeaders() = default;
};
class DeleteInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> language{};
  shared_ptr<string> processInstanceId{};
  shared_ptr<string> systemToken{};

  DeleteInstanceRequest() {}

  explicit DeleteInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (processInstanceId) {
      res["ProcessInstanceId"] = boost::any(*processInstanceId);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("ProcessInstanceId") != m.end() && !m["ProcessInstanceId"].empty()) {
      processInstanceId = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceId"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~DeleteInstanceRequest() = default;
};
class DeleteInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  DeleteInstanceResponseBody() {}

  explicit DeleteInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~DeleteInstanceResponseBody() = default;
};
class DeleteInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteInstanceResponseBody> body{};

  DeleteInstanceResponse() {}

  explicit DeleteInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteInstanceResponse() = default;
};
class DeleteLiveHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteLiveHeadersAccountContext() {}

  explicit DeleteLiveHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteLiveHeadersAccountContext() = default;
};
class DeleteLiveHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteLiveHeadersAccountContext> accountContext{};

  DeleteLiveHeaders() {}

  explicit DeleteLiveHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteLiveHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteLiveHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteLiveHeaders() = default;
};
class DeleteLiveShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteLiveShrinkHeaders() {}

  explicit DeleteLiveShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteLiveShrinkHeaders() = default;
};
class DeleteLiveRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DeleteLiveRequestTenantContext() {}

  explicit DeleteLiveRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DeleteLiveRequestTenantContext() = default;
};
class DeleteLiveRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveId{};
  shared_ptr<DeleteLiveRequestTenantContext> tenantContext{};

  DeleteLiveRequest() {}

  explicit DeleteLiveRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveId) {
      res["LiveId"] = boost::any(*liveId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveId") != m.end() && !m["LiveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["LiveId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DeleteLiveRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DeleteLiveRequestTenantContext>(model1);
      }
    }
  }


  virtual ~DeleteLiveRequest() = default;
};
class DeleteLiveShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveId{};
  shared_ptr<string> tenantContextShrink{};

  DeleteLiveShrinkRequest() {}

  explicit DeleteLiveShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveId) {
      res["LiveId"] = boost::any(*liveId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveId") != m.end() && !m["LiveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["LiveId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~DeleteLiveShrinkRequest() = default;
};
class DeleteLiveResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteLiveResponseBody() {}

  explicit DeleteLiveResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteLiveResponseBody() = default;
};
class DeleteLiveResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveResponseBody> body{};

  DeleteLiveResponse() {}

  explicit DeleteLiveResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveResponse() = default;
};
class DeleteMeetingRoomHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteMeetingRoomHeadersAccountContext() {}

  explicit DeleteMeetingRoomHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteMeetingRoomHeadersAccountContext() = default;
};
class DeleteMeetingRoomHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteMeetingRoomHeadersAccountContext> accountContext{};

  DeleteMeetingRoomHeaders() {}

  explicit DeleteMeetingRoomHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteMeetingRoomHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteMeetingRoomHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteMeetingRoomHeaders() = default;
};
class DeleteMeetingRoomShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteMeetingRoomShrinkHeaders() {}

  explicit DeleteMeetingRoomShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteMeetingRoomShrinkHeaders() = default;
};
class DeleteMeetingRoomRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DeleteMeetingRoomRequestTenantContext() {}

  explicit DeleteMeetingRoomRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DeleteMeetingRoomRequestTenantContext() = default;
};
class DeleteMeetingRoomRequest : public Darabonba::Model {
public:
  shared_ptr<string> roomId{};
  shared_ptr<DeleteMeetingRoomRequestTenantContext> tenantContext{};

  DeleteMeetingRoomRequest() {}

  explicit DeleteMeetingRoomRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DeleteMeetingRoomRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DeleteMeetingRoomRequestTenantContext>(model1);
      }
    }
  }


  virtual ~DeleteMeetingRoomRequest() = default;
};
class DeleteMeetingRoomShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> roomId{};
  shared_ptr<string> tenantContextShrink{};

  DeleteMeetingRoomShrinkRequest() {}

  explicit DeleteMeetingRoomShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~DeleteMeetingRoomShrinkRequest() = default;
};
class DeleteMeetingRoomResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteMeetingRoomResponseBody() {}

  explicit DeleteMeetingRoomResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~DeleteMeetingRoomResponseBody() = default;
};
class DeleteMeetingRoomResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMeetingRoomResponseBody> body{};

  DeleteMeetingRoomResponse() {}

  explicit DeleteMeetingRoomResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMeetingRoomResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMeetingRoomResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMeetingRoomResponse() = default;
};
class DeleteMeetingRoomGroupHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteMeetingRoomGroupHeadersAccountContext() {}

  explicit DeleteMeetingRoomGroupHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteMeetingRoomGroupHeadersAccountContext() = default;
};
class DeleteMeetingRoomGroupHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteMeetingRoomGroupHeadersAccountContext> accountContext{};

  DeleteMeetingRoomGroupHeaders() {}

  explicit DeleteMeetingRoomGroupHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteMeetingRoomGroupHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteMeetingRoomGroupHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteMeetingRoomGroupHeaders() = default;
};
class DeleteMeetingRoomGroupShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteMeetingRoomGroupShrinkHeaders() {}

  explicit DeleteMeetingRoomGroupShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteMeetingRoomGroupShrinkHeaders() = default;
};
class DeleteMeetingRoomGroupRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DeleteMeetingRoomGroupRequestTenantContext() {}

  explicit DeleteMeetingRoomGroupRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DeleteMeetingRoomGroupRequestTenantContext() = default;
};
class DeleteMeetingRoomGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<DeleteMeetingRoomGroupRequestTenantContext> tenantContext{};

  DeleteMeetingRoomGroupRequest() {}

  explicit DeleteMeetingRoomGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DeleteMeetingRoomGroupRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DeleteMeetingRoomGroupRequestTenantContext>(model1);
      }
    }
  }


  virtual ~DeleteMeetingRoomGroupRequest() = default;
};
class DeleteMeetingRoomGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> tenantContextShrink{};

  DeleteMeetingRoomGroupShrinkRequest() {}

  explicit DeleteMeetingRoomGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~DeleteMeetingRoomGroupShrinkRequest() = default;
};
class DeleteMeetingRoomGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteMeetingRoomGroupResponseBody() {}

  explicit DeleteMeetingRoomGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~DeleteMeetingRoomGroupResponseBody() = default;
};
class DeleteMeetingRoomGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMeetingRoomGroupResponseBody> body{};

  DeleteMeetingRoomGroupResponse() {}

  explicit DeleteMeetingRoomGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMeetingRoomGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMeetingRoomGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMeetingRoomGroupResponse() = default;
};
class DeleteMultiDimTableFieldHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteMultiDimTableFieldHeadersAccountContext() {}

  explicit DeleteMultiDimTableFieldHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteMultiDimTableFieldHeadersAccountContext() = default;
};
class DeleteMultiDimTableFieldHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteMultiDimTableFieldHeadersAccountContext> accountContext{};

  DeleteMultiDimTableFieldHeaders() {}

  explicit DeleteMultiDimTableFieldHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteMultiDimTableFieldHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteMultiDimTableFieldHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteMultiDimTableFieldHeaders() = default;
};
class DeleteMultiDimTableFieldShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteMultiDimTableFieldShrinkHeaders() {}

  explicit DeleteMultiDimTableFieldShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteMultiDimTableFieldShrinkHeaders() = default;
};
class DeleteMultiDimTableFieldRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DeleteMultiDimTableFieldRequestTenantContext() {}

  explicit DeleteMultiDimTableFieldRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DeleteMultiDimTableFieldRequestTenantContext() = default;
};
class DeleteMultiDimTableFieldRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<string> fieldIdOrName{};
  shared_ptr<string> sheetIdOrName{};
  shared_ptr<DeleteMultiDimTableFieldRequestTenantContext> tenantContext{};

  DeleteMultiDimTableFieldRequest() {}

  explicit DeleteMultiDimTableFieldRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (fieldIdOrName) {
      res["FieldIdOrName"] = boost::any(*fieldIdOrName);
    }
    if (sheetIdOrName) {
      res["SheetIdOrName"] = boost::any(*sheetIdOrName);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("FieldIdOrName") != m.end() && !m["FieldIdOrName"].empty()) {
      fieldIdOrName = make_shared<string>(boost::any_cast<string>(m["FieldIdOrName"]));
    }
    if (m.find("SheetIdOrName") != m.end() && !m["SheetIdOrName"].empty()) {
      sheetIdOrName = make_shared<string>(boost::any_cast<string>(m["SheetIdOrName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DeleteMultiDimTableFieldRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DeleteMultiDimTableFieldRequestTenantContext>(model1);
      }
    }
  }


  virtual ~DeleteMultiDimTableFieldRequest() = default;
};
class DeleteMultiDimTableFieldShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<string> fieldIdOrName{};
  shared_ptr<string> sheetIdOrName{};
  shared_ptr<string> tenantContextShrink{};

  DeleteMultiDimTableFieldShrinkRequest() {}

  explicit DeleteMultiDimTableFieldShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (fieldIdOrName) {
      res["FieldIdOrName"] = boost::any(*fieldIdOrName);
    }
    if (sheetIdOrName) {
      res["SheetIdOrName"] = boost::any(*sheetIdOrName);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("FieldIdOrName") != m.end() && !m["FieldIdOrName"].empty()) {
      fieldIdOrName = make_shared<string>(boost::any_cast<string>(m["FieldIdOrName"]));
    }
    if (m.find("SheetIdOrName") != m.end() && !m["SheetIdOrName"].empty()) {
      sheetIdOrName = make_shared<string>(boost::any_cast<string>(m["SheetIdOrName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~DeleteMultiDimTableFieldShrinkRequest() = default;
};
class DeleteMultiDimTableFieldResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  DeleteMultiDimTableFieldResponseBody() {}

  explicit DeleteMultiDimTableFieldResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~DeleteMultiDimTableFieldResponseBody() = default;
};
class DeleteMultiDimTableFieldResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMultiDimTableFieldResponseBody> body{};

  DeleteMultiDimTableFieldResponse() {}

  explicit DeleteMultiDimTableFieldResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMultiDimTableFieldResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMultiDimTableFieldResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMultiDimTableFieldResponse() = default;
};
class DeleteMultiDimTableRecordsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteMultiDimTableRecordsHeadersAccountContext() {}

  explicit DeleteMultiDimTableRecordsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteMultiDimTableRecordsHeadersAccountContext() = default;
};
class DeleteMultiDimTableRecordsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteMultiDimTableRecordsHeadersAccountContext> accountContext{};

  DeleteMultiDimTableRecordsHeaders() {}

  explicit DeleteMultiDimTableRecordsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteMultiDimTableRecordsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteMultiDimTableRecordsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteMultiDimTableRecordsHeaders() = default;
};
class DeleteMultiDimTableRecordsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteMultiDimTableRecordsShrinkHeaders() {}

  explicit DeleteMultiDimTableRecordsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteMultiDimTableRecordsShrinkHeaders() = default;
};
class DeleteMultiDimTableRecordsRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DeleteMultiDimTableRecordsRequestTenantContext() {}

  explicit DeleteMultiDimTableRecordsRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DeleteMultiDimTableRecordsRequestTenantContext() = default;
};
class DeleteMultiDimTableRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<vector<string>> recordIds{};
  shared_ptr<string> sheetIdOrName{};
  shared_ptr<DeleteMultiDimTableRecordsRequestTenantContext> tenantContext{};

  DeleteMultiDimTableRecordsRequest() {}

  explicit DeleteMultiDimTableRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (recordIds) {
      res["RecordIds"] = boost::any(*recordIds);
    }
    if (sheetIdOrName) {
      res["SheetIdOrName"] = boost::any(*sheetIdOrName);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("RecordIds") != m.end() && !m["RecordIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecordIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecordIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recordIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SheetIdOrName") != m.end() && !m["SheetIdOrName"].empty()) {
      sheetIdOrName = make_shared<string>(boost::any_cast<string>(m["SheetIdOrName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DeleteMultiDimTableRecordsRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DeleteMultiDimTableRecordsRequestTenantContext>(model1);
      }
    }
  }


  virtual ~DeleteMultiDimTableRecordsRequest() = default;
};
class DeleteMultiDimTableRecordsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<string> recordIdsShrink{};
  shared_ptr<string> sheetIdOrName{};
  shared_ptr<string> tenantContextShrink{};

  DeleteMultiDimTableRecordsShrinkRequest() {}

  explicit DeleteMultiDimTableRecordsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (recordIdsShrink) {
      res["RecordIds"] = boost::any(*recordIdsShrink);
    }
    if (sheetIdOrName) {
      res["SheetIdOrName"] = boost::any(*sheetIdOrName);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("RecordIds") != m.end() && !m["RecordIds"].empty()) {
      recordIdsShrink = make_shared<string>(boost::any_cast<string>(m["RecordIds"]));
    }
    if (m.find("SheetIdOrName") != m.end() && !m["SheetIdOrName"].empty()) {
      sheetIdOrName = make_shared<string>(boost::any_cast<string>(m["SheetIdOrName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~DeleteMultiDimTableRecordsShrinkRequest() = default;
};
class DeleteMultiDimTableRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  DeleteMultiDimTableRecordsResponseBody() {}

  explicit DeleteMultiDimTableRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~DeleteMultiDimTableRecordsResponseBody() = default;
};
class DeleteMultiDimTableRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMultiDimTableRecordsResponseBody> body{};

  DeleteMultiDimTableRecordsResponse() {}

  explicit DeleteMultiDimTableRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMultiDimTableRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMultiDimTableRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMultiDimTableRecordsResponse() = default;
};
class DeletePermissionHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeletePermissionHeadersAccountContext() {}

  explicit DeletePermissionHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeletePermissionHeadersAccountContext() = default;
};
class DeletePermissionHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeletePermissionHeadersAccountContext> accountContext{};

  DeletePermissionHeaders() {}

  explicit DeletePermissionHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeletePermissionHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeletePermissionHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeletePermissionHeaders() = default;
};
class DeletePermissionShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeletePermissionShrinkHeaders() {}

  explicit DeletePermissionShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeletePermissionShrinkHeaders() = default;
};
class DeletePermissionRequestMembers : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<string> id{};
  shared_ptr<string> type{};

  DeletePermissionRequestMembers() {}

  explicit DeletePermissionRequestMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DeletePermissionRequestMembers() = default;
};
class DeletePermissionRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DeletePermissionRequestTenantContext() {}

  explicit DeletePermissionRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DeletePermissionRequestTenantContext() = default;
};
class DeletePermissionRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryUuid{};
  shared_ptr<vector<DeletePermissionRequestMembers>> members{};
  shared_ptr<string> roleId{};
  shared_ptr<DeletePermissionRequestTenantContext> tenantContext{};

  DeletePermissionRequest() {}

  explicit DeletePermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryUuid) {
      res["DentryUuid"] = boost::any(*dentryUuid);
    }
    if (members) {
      vector<boost::any> temp1;
      for(auto item1:*members){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Members"] = boost::any(temp1);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryUuid") != m.end() && !m["DentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["DentryUuid"]));
    }
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      if (typeid(vector<boost::any>) == m["Members"].type()) {
        vector<DeletePermissionRequestMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Members"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeletePermissionRequestMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        members = make_shared<vector<DeletePermissionRequestMembers>>(expect1);
      }
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DeletePermissionRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DeletePermissionRequestTenantContext>(model1);
      }
    }
  }


  virtual ~DeletePermissionRequest() = default;
};
class DeletePermissionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryUuid{};
  shared_ptr<string> membersShrink{};
  shared_ptr<string> roleId{};
  shared_ptr<string> tenantContextShrink{};

  DeletePermissionShrinkRequest() {}

  explicit DeletePermissionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryUuid) {
      res["DentryUuid"] = boost::any(*dentryUuid);
    }
    if (membersShrink) {
      res["Members"] = boost::any(*membersShrink);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryUuid") != m.end() && !m["DentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["DentryUuid"]));
    }
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      membersShrink = make_shared<string>(boost::any_cast<string>(m["Members"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~DeletePermissionShrinkRequest() = default;
};
class DeletePermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  DeletePermissionResponseBody() {}

  explicit DeletePermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~DeletePermissionResponseBody() = default;
};
class DeletePermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePermissionResponseBody> body{};

  DeletePermissionResponse() {}

  explicit DeletePermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePermissionResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePermissionResponse() = default;
};
class DeleteRowsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteRowsHeadersAccountContext() {}

  explicit DeleteRowsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteRowsHeadersAccountContext() = default;
};
class DeleteRowsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteRowsHeadersAccountContext> accountContext{};

  DeleteRowsHeaders() {}

  explicit DeleteRowsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteRowsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteRowsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteRowsHeaders() = default;
};
class DeleteRowsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteRowsShrinkHeaders() {}

  explicit DeleteRowsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteRowsShrinkHeaders() = default;
};
class DeleteRowsRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DeleteRowsRequestTenantContext() {}

  explicit DeleteRowsRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DeleteRowsRequestTenantContext() = default;
};
class DeleteRowsRequest : public Darabonba::Model {
public:
  shared_ptr<long> row{};
  shared_ptr<long> rowCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<DeleteRowsRequestTenantContext> tenantContext{};
  shared_ptr<string> workbookId{};

  DeleteRowsRequest() {}

  explicit DeleteRowsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (row) {
      res["Row"] = boost::any(*row);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Row") != m.end() && !m["Row"].empty()) {
      row = make_shared<long>(boost::any_cast<long>(m["Row"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["RowCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DeleteRowsRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DeleteRowsRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~DeleteRowsRequest() = default;
};
class DeleteRowsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> row{};
  shared_ptr<long> rowCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workbookId{};

  DeleteRowsShrinkRequest() {}

  explicit DeleteRowsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (row) {
      res["Row"] = boost::any(*row);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Row") != m.end() && !m["Row"].empty()) {
      row = make_shared<long>(boost::any_cast<long>(m["Row"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["RowCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~DeleteRowsShrinkRequest() = default;
};
class DeleteRowsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  DeleteRowsResponseBody() {}

  explicit DeleteRowsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeleteRowsResponseBody() = default;
};
class DeleteRowsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRowsResponseBody> body{};

  DeleteRowsResponse() {}

  explicit DeleteRowsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRowsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRowsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRowsResponse() = default;
};
class DeleteScenegroupMemberHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteScenegroupMemberHeadersAccountContext() {}

  explicit DeleteScenegroupMemberHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteScenegroupMemberHeadersAccountContext() = default;
};
class DeleteScenegroupMemberHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteScenegroupMemberHeadersAccountContext> accountContext{};

  DeleteScenegroupMemberHeaders() {}

  explicit DeleteScenegroupMemberHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteScenegroupMemberHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteScenegroupMemberHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteScenegroupMemberHeaders() = default;
};
class DeleteScenegroupMemberShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteScenegroupMemberShrinkHeaders() {}

  explicit DeleteScenegroupMemberShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteScenegroupMemberShrinkHeaders() = default;
};
class DeleteScenegroupMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> openConversationId{};
  shared_ptr<string> userIds{};

  DeleteScenegroupMemberRequest() {}

  explicit DeleteScenegroupMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openConversationId) {
      res["OpenConversationId"] = boost::any(*openConversationId);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpenConversationId") != m.end() && !m["OpenConversationId"].empty()) {
      openConversationId = make_shared<string>(boost::any_cast<string>(m["OpenConversationId"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      userIds = make_shared<string>(boost::any_cast<string>(m["UserIds"]));
    }
  }


  virtual ~DeleteScenegroupMemberRequest() = default;
};
class DeleteScenegroupMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteScenegroupMemberResponseBody() {}

  explicit DeleteScenegroupMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteScenegroupMemberResponseBody() = default;
};
class DeleteScenegroupMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteScenegroupMemberResponseBody> body{};

  DeleteScenegroupMemberResponse() {}

  explicit DeleteScenegroupMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteScenegroupMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteScenegroupMemberResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteScenegroupMemberResponse() = default;
};
class DeleteSheetHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteSheetHeadersAccountContext() {}

  explicit DeleteSheetHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteSheetHeadersAccountContext() = default;
};
class DeleteSheetHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteSheetHeadersAccountContext> accountContext{};

  DeleteSheetHeaders() {}

  explicit DeleteSheetHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteSheetHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteSheetHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteSheetHeaders() = default;
};
class DeleteSheetShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteSheetShrinkHeaders() {}

  explicit DeleteSheetShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteSheetShrinkHeaders() = default;
};
class DeleteSheetRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DeleteSheetRequestTenantContext() {}

  explicit DeleteSheetRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DeleteSheetRequestTenantContext() = default;
};
class DeleteSheetRequest : public Darabonba::Model {
public:
  shared_ptr<string> sheetId{};
  shared_ptr<DeleteSheetRequestTenantContext> tenantContext{};
  shared_ptr<string> workbookId{};

  DeleteSheetRequest() {}

  explicit DeleteSheetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DeleteSheetRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DeleteSheetRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~DeleteSheetRequest() = default;
};
class DeleteSheetShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workbookId{};

  DeleteSheetShrinkRequest() {}

  explicit DeleteSheetShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~DeleteSheetShrinkRequest() = default;
};
class DeleteSheetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteSheetResponseBody() {}

  explicit DeleteSheetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteSheetResponseBody() = default;
};
class DeleteSheetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSheetResponseBody> body{};

  DeleteSheetResponse() {}

  explicit DeleteSheetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSheetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSheetResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSheetResponse() = default;
};
class DeleteSubscribedCalendarHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteSubscribedCalendarHeadersAccountContext() {}

  explicit DeleteSubscribedCalendarHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteSubscribedCalendarHeadersAccountContext() = default;
};
class DeleteSubscribedCalendarHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteSubscribedCalendarHeadersAccountContext> accountContext{};

  DeleteSubscribedCalendarHeaders() {}

  explicit DeleteSubscribedCalendarHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteSubscribedCalendarHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteSubscribedCalendarHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteSubscribedCalendarHeaders() = default;
};
class DeleteSubscribedCalendarShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteSubscribedCalendarShrinkHeaders() {}

  explicit DeleteSubscribedCalendarShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteSubscribedCalendarShrinkHeaders() = default;
};
class DeleteSubscribedCalendarRequest : public Darabonba::Model {
public:
  shared_ptr<string> calendarId{};

  DeleteSubscribedCalendarRequest() {}

  explicit DeleteSubscribedCalendarRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
  }


  virtual ~DeleteSubscribedCalendarRequest() = default;
};
class DeleteSubscribedCalendarResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> result{};
  shared_ptr<string> requestId{};

  DeleteSubscribedCalendarResponseBody() {}

  explicit DeleteSubscribedCalendarResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeleteSubscribedCalendarResponseBody() = default;
};
class DeleteSubscribedCalendarResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSubscribedCalendarResponseBody> body{};

  DeleteSubscribedCalendarResponse() {}

  explicit DeleteSubscribedCalendarResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSubscribedCalendarResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSubscribedCalendarResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSubscribedCalendarResponse() = default;
};
class DeleteTodoTaskHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteTodoTaskHeadersAccountContext() {}

  explicit DeleteTodoTaskHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteTodoTaskHeadersAccountContext() = default;
};
class DeleteTodoTaskHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteTodoTaskHeadersAccountContext> accountContext{};

  DeleteTodoTaskHeaders() {}

  explicit DeleteTodoTaskHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteTodoTaskHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteTodoTaskHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteTodoTaskHeaders() = default;
};
class DeleteTodoTaskShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteTodoTaskShrinkHeaders() {}

  explicit DeleteTodoTaskShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteTodoTaskShrinkHeaders() = default;
};
class DeleteTodoTaskRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DeleteTodoTaskRequestTenantContext() {}

  explicit DeleteTodoTaskRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DeleteTodoTaskRequestTenantContext() = default;
};
class DeleteTodoTaskRequest : public Darabonba::Model {
public:
  shared_ptr<DeleteTodoTaskRequestTenantContext> tenantContext{};
  shared_ptr<string> operatorId{};
  shared_ptr<string> taskId{};

  DeleteTodoTaskRequest() {}

  explicit DeleteTodoTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (operatorId) {
      res["operatorId"] = boost::any(*operatorId);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DeleteTodoTaskRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DeleteTodoTaskRequestTenantContext>(model1);
      }
    }
    if (m.find("operatorId") != m.end() && !m["operatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["operatorId"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
  }


  virtual ~DeleteTodoTaskRequest() = default;
};
class DeleteTodoTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> operatorId{};
  shared_ptr<string> taskId{};

  DeleteTodoTaskShrinkRequest() {}

  explicit DeleteTodoTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (operatorId) {
      res["operatorId"] = boost::any(*operatorId);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("operatorId") != m.end() && !m["operatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["operatorId"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
  }


  virtual ~DeleteTodoTaskShrinkRequest() = default;
};
class DeleteTodoTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteTodoTaskResponseBody() {}

  explicit DeleteTodoTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~DeleteTodoTaskResponseBody() = default;
};
class DeleteTodoTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTodoTaskResponseBody> body{};

  DeleteTodoTaskResponse() {}

  explicit DeleteTodoTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTodoTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTodoTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTodoTaskResponse() = default;
};
class DeleteWorkspaceDocMembersHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteWorkspaceDocMembersHeadersAccountContext() {}

  explicit DeleteWorkspaceDocMembersHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteWorkspaceDocMembersHeadersAccountContext() = default;
};
class DeleteWorkspaceDocMembersHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteWorkspaceDocMembersHeadersAccountContext> accountContext{};

  DeleteWorkspaceDocMembersHeaders() {}

  explicit DeleteWorkspaceDocMembersHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteWorkspaceDocMembersHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteWorkspaceDocMembersHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteWorkspaceDocMembersHeaders() = default;
};
class DeleteWorkspaceDocMembersShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteWorkspaceDocMembersShrinkHeaders() {}

  explicit DeleteWorkspaceDocMembersShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteWorkspaceDocMembersShrinkHeaders() = default;
};
class DeleteWorkspaceDocMembersRequestMembers : public Darabonba::Model {
public:
  shared_ptr<string> memberId{};
  shared_ptr<string> memberType{};

  DeleteWorkspaceDocMembersRequestMembers() {}

  explicit DeleteWorkspaceDocMembersRequestMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberId) {
      res["MemberId"] = boost::any(*memberId);
    }
    if (memberType) {
      res["MemberType"] = boost::any(*memberType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemberId") != m.end() && !m["MemberId"].empty()) {
      memberId = make_shared<string>(boost::any_cast<string>(m["MemberId"]));
    }
    if (m.find("MemberType") != m.end() && !m["MemberType"].empty()) {
      memberType = make_shared<string>(boost::any_cast<string>(m["MemberType"]));
    }
  }


  virtual ~DeleteWorkspaceDocMembersRequestMembers() = default;
};
class DeleteWorkspaceDocMembersRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DeleteWorkspaceDocMembersRequestTenantContext() {}

  explicit DeleteWorkspaceDocMembersRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DeleteWorkspaceDocMembersRequestTenantContext() = default;
};
class DeleteWorkspaceDocMembersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteWorkspaceDocMembersRequestMembers>> members{};
  shared_ptr<string> nodeId{};
  shared_ptr<DeleteWorkspaceDocMembersRequestTenantContext> tenantContext{};
  shared_ptr<string> workspaceId{};

  DeleteWorkspaceDocMembersRequest() {}

  explicit DeleteWorkspaceDocMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (members) {
      vector<boost::any> temp1;
      for(auto item1:*members){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Members"] = boost::any(temp1);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      if (typeid(vector<boost::any>) == m["Members"].type()) {
        vector<DeleteWorkspaceDocMembersRequestMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Members"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteWorkspaceDocMembersRequestMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        members = make_shared<vector<DeleteWorkspaceDocMembersRequestMembers>>(expect1);
      }
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DeleteWorkspaceDocMembersRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DeleteWorkspaceDocMembersRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteWorkspaceDocMembersRequest() = default;
};
class DeleteWorkspaceDocMembersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> membersShrink{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workspaceId{};

  DeleteWorkspaceDocMembersShrinkRequest() {}

  explicit DeleteWorkspaceDocMembersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (membersShrink) {
      res["Members"] = boost::any(*membersShrink);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      membersShrink = make_shared<string>(boost::any_cast<string>(m["Members"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteWorkspaceDocMembersShrinkRequest() = default;
};
class DeleteWorkspaceDocMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteWorkspaceDocMembersResponseBody() {}

  explicit DeleteWorkspaceDocMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeleteWorkspaceDocMembersResponseBody() = default;
};
class DeleteWorkspaceDocMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWorkspaceDocMembersResponseBody> body{};

  DeleteWorkspaceDocMembersResponse() {}

  explicit DeleteWorkspaceDocMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWorkspaceDocMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWorkspaceDocMembersResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWorkspaceDocMembersResponse() = default;
};
class DeleteWorkspaceMembersHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteWorkspaceMembersHeadersAccountContext() {}

  explicit DeleteWorkspaceMembersHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteWorkspaceMembersHeadersAccountContext() = default;
};
class DeleteWorkspaceMembersHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteWorkspaceMembersHeadersAccountContext> accountContext{};

  DeleteWorkspaceMembersHeaders() {}

  explicit DeleteWorkspaceMembersHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteWorkspaceMembersHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteWorkspaceMembersHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteWorkspaceMembersHeaders() = default;
};
class DeleteWorkspaceMembersShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteWorkspaceMembersShrinkHeaders() {}

  explicit DeleteWorkspaceMembersShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteWorkspaceMembersShrinkHeaders() = default;
};
class DeleteWorkspaceMembersRequestMembers : public Darabonba::Model {
public:
  shared_ptr<string> memberId{};
  shared_ptr<string> memberType{};

  DeleteWorkspaceMembersRequestMembers() {}

  explicit DeleteWorkspaceMembersRequestMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberId) {
      res["MemberId"] = boost::any(*memberId);
    }
    if (memberType) {
      res["MemberType"] = boost::any(*memberType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemberId") != m.end() && !m["MemberId"].empty()) {
      memberId = make_shared<string>(boost::any_cast<string>(m["MemberId"]));
    }
    if (m.find("MemberType") != m.end() && !m["MemberType"].empty()) {
      memberType = make_shared<string>(boost::any_cast<string>(m["MemberType"]));
    }
  }


  virtual ~DeleteWorkspaceMembersRequestMembers() = default;
};
class DeleteWorkspaceMembersRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DeleteWorkspaceMembersRequestTenantContext() {}

  explicit DeleteWorkspaceMembersRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DeleteWorkspaceMembersRequestTenantContext() = default;
};
class DeleteWorkspaceMembersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteWorkspaceMembersRequestMembers>> members{};
  shared_ptr<DeleteWorkspaceMembersRequestTenantContext> tenantContext{};
  shared_ptr<string> workspaceId{};

  DeleteWorkspaceMembersRequest() {}

  explicit DeleteWorkspaceMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (members) {
      vector<boost::any> temp1;
      for(auto item1:*members){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Members"] = boost::any(temp1);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      if (typeid(vector<boost::any>) == m["Members"].type()) {
        vector<DeleteWorkspaceMembersRequestMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Members"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteWorkspaceMembersRequestMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        members = make_shared<vector<DeleteWorkspaceMembersRequestMembers>>(expect1);
      }
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DeleteWorkspaceMembersRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DeleteWorkspaceMembersRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteWorkspaceMembersRequest() = default;
};
class DeleteWorkspaceMembersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> membersShrink{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workspaceId{};

  DeleteWorkspaceMembersShrinkRequest() {}

  explicit DeleteWorkspaceMembersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (membersShrink) {
      res["Members"] = boost::any(*membersShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      membersShrink = make_shared<string>(boost::any_cast<string>(m["Members"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteWorkspaceMembersShrinkRequest() = default;
};
class DeleteWorkspaceMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteWorkspaceMembersResponseBody() {}

  explicit DeleteWorkspaceMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeleteWorkspaceMembersResponseBody() = default;
};
class DeleteWorkspaceMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWorkspaceMembersResponseBody> body{};

  DeleteWorkspaceMembersResponse() {}

  explicit DeleteWorkspaceMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWorkspaceMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWorkspaceMembersResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWorkspaceMembersResponse() = default;
};
class DocBlocksQueryHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DocBlocksQueryHeadersAccountContext() {}

  explicit DocBlocksQueryHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DocBlocksQueryHeadersAccountContext() = default;
};
class DocBlocksQueryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DocBlocksQueryHeadersAccountContext> accountContext{};

  DocBlocksQueryHeaders() {}

  explicit DocBlocksQueryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DocBlocksQueryHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DocBlocksQueryHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DocBlocksQueryHeaders() = default;
};
class DocBlocksQueryShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DocBlocksQueryShrinkHeaders() {}

  explicit DocBlocksQueryShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DocBlocksQueryShrinkHeaders() = default;
};
class DocBlocksQueryRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DocBlocksQueryRequestTenantContext() {}

  explicit DocBlocksQueryRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DocBlocksQueryRequestTenantContext() = default;
};
class DocBlocksQueryRequest : public Darabonba::Model {
public:
  shared_ptr<string> blockType{};
  shared_ptr<string> docKey{};
  shared_ptr<long> endIndex{};
  shared_ptr<long> startIndex{};
  shared_ptr<DocBlocksQueryRequestTenantContext> tenantContext{};

  DocBlocksQueryRequest() {}

  explicit DocBlocksQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockType) {
      res["BlockType"] = boost::any(*blockType);
    }
    if (docKey) {
      res["DocKey"] = boost::any(*docKey);
    }
    if (endIndex) {
      res["EndIndex"] = boost::any(*endIndex);
    }
    if (startIndex) {
      res["StartIndex"] = boost::any(*startIndex);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockType") != m.end() && !m["BlockType"].empty()) {
      blockType = make_shared<string>(boost::any_cast<string>(m["BlockType"]));
    }
    if (m.find("DocKey") != m.end() && !m["DocKey"].empty()) {
      docKey = make_shared<string>(boost::any_cast<string>(m["DocKey"]));
    }
    if (m.find("EndIndex") != m.end() && !m["EndIndex"].empty()) {
      endIndex = make_shared<long>(boost::any_cast<long>(m["EndIndex"]));
    }
    if (m.find("StartIndex") != m.end() && !m["StartIndex"].empty()) {
      startIndex = make_shared<long>(boost::any_cast<long>(m["StartIndex"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DocBlocksQueryRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DocBlocksQueryRequestTenantContext>(model1);
      }
    }
  }


  virtual ~DocBlocksQueryRequest() = default;
};
class DocBlocksQueryShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> blockType{};
  shared_ptr<string> docKey{};
  shared_ptr<long> endIndex{};
  shared_ptr<long> startIndex{};
  shared_ptr<string> tenantContextShrink{};

  DocBlocksQueryShrinkRequest() {}

  explicit DocBlocksQueryShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockType) {
      res["BlockType"] = boost::any(*blockType);
    }
    if (docKey) {
      res["DocKey"] = boost::any(*docKey);
    }
    if (endIndex) {
      res["EndIndex"] = boost::any(*endIndex);
    }
    if (startIndex) {
      res["StartIndex"] = boost::any(*startIndex);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockType") != m.end() && !m["BlockType"].empty()) {
      blockType = make_shared<string>(boost::any_cast<string>(m["BlockType"]));
    }
    if (m.find("DocKey") != m.end() && !m["DocKey"].empty()) {
      docKey = make_shared<string>(boost::any_cast<string>(m["DocKey"]));
    }
    if (m.find("EndIndex") != m.end() && !m["EndIndex"].empty()) {
      endIndex = make_shared<long>(boost::any_cast<long>(m["EndIndex"]));
    }
    if (m.find("StartIndex") != m.end() && !m["StartIndex"].empty()) {
      startIndex = make_shared<long>(boost::any_cast<long>(m["StartIndex"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~DocBlocksQueryShrinkRequest() = default;
};
class DocBlocksQueryResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<boost::any>> data{};

  DocBlocksQueryResponseBodyResult() {}

  explicit DocBlocksQueryResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      data = make_shared<vector<boost::any>>(toVec1);
    }
  }


  virtual ~DocBlocksQueryResponseBodyResult() = default;
};
class DocBlocksQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DocBlocksQueryResponseBodyResult> result{};
  shared_ptr<bool> success{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  DocBlocksQueryResponseBody() {}

  explicit DocBlocksQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        DocBlocksQueryResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<DocBlocksQueryResponseBodyResult>(model1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~DocBlocksQueryResponseBody() = default;
};
class DocBlocksQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DocBlocksQueryResponseBody> body{};

  DocBlocksQueryResponse() {}

  explicit DocBlocksQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DocBlocksQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DocBlocksQueryResponseBody>(model1);
      }
    }
  }


  virtual ~DocBlocksQueryResponse() = default;
};
class DocUpdateContentHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DocUpdateContentHeadersAccountContext() {}

  explicit DocUpdateContentHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DocUpdateContentHeadersAccountContext() = default;
};
class DocUpdateContentHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DocUpdateContentHeadersAccountContext> accountContext{};

  DocUpdateContentHeaders() {}

  explicit DocUpdateContentHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DocUpdateContentHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DocUpdateContentHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DocUpdateContentHeaders() = default;
};
class DocUpdateContentShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DocUpdateContentShrinkHeaders() {}

  explicit DocUpdateContentShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DocUpdateContentShrinkHeaders() = default;
};
class DocUpdateContentRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DocUpdateContentRequestTenantContext() {}

  explicit DocUpdateContentRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DocUpdateContentRequestTenantContext() = default;
};
class DocUpdateContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> dataType{};
  shared_ptr<string> docKey{};
  shared_ptr<DocUpdateContentRequestTenantContext> tenantContext{};

  DocUpdateContentRequest() {}

  explicit DocUpdateContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (docKey) {
      res["DocKey"] = boost::any(*docKey);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("DocKey") != m.end() && !m["DocKey"].empty()) {
      docKey = make_shared<string>(boost::any_cast<string>(m["DocKey"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DocUpdateContentRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DocUpdateContentRequestTenantContext>(model1);
      }
    }
  }


  virtual ~DocUpdateContentRequest() = default;
};
class DocUpdateContentShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> dataType{};
  shared_ptr<string> docKey{};
  shared_ptr<string> tenantContextShrink{};

  DocUpdateContentShrinkRequest() {}

  explicit DocUpdateContentShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (docKey) {
      res["DocKey"] = boost::any(*docKey);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("DocKey") != m.end() && !m["DocKey"].empty()) {
      docKey = make_shared<string>(boost::any_cast<string>(m["DocKey"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~DocUpdateContentShrinkRequest() = default;
};
class DocUpdateContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> value{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  DocUpdateContentResponseBody() {}

  explicit DocUpdateContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<bool>(boost::any_cast<bool>(m["value"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~DocUpdateContentResponseBody() = default;
};
class DocUpdateContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DocUpdateContentResponseBody> body{};

  DocUpdateContentResponse() {}

  explicit DocUpdateContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DocUpdateContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DocUpdateContentResponseBody>(model1);
      }
    }
  }


  virtual ~DocUpdateContentResponse() = default;
};
class ExecuteBatchTaskHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ExecuteBatchTaskHeadersAccountContext() {}

  explicit ExecuteBatchTaskHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ExecuteBatchTaskHeadersAccountContext() = default;
};
class ExecuteBatchTaskHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ExecuteBatchTaskHeadersAccountContext> accountContext{};

  ExecuteBatchTaskHeaders() {}

  explicit ExecuteBatchTaskHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ExecuteBatchTaskHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ExecuteBatchTaskHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ExecuteBatchTaskHeaders() = default;
};
class ExecuteBatchTaskShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ExecuteBatchTaskShrinkHeaders() {}

  explicit ExecuteBatchTaskShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ExecuteBatchTaskShrinkHeaders() = default;
};
class ExecuteBatchTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> outResult{};
  shared_ptr<string> remark{};
  shared_ptr<string> systemToken{};
  shared_ptr<string> taskInformationList{};

  ExecuteBatchTaskRequest() {}

  explicit ExecuteBatchTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (outResult) {
      res["OutResult"] = boost::any(*outResult);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    if (taskInformationList) {
      res["TaskInformationList"] = boost::any(*taskInformationList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("OutResult") != m.end() && !m["OutResult"].empty()) {
      outResult = make_shared<string>(boost::any_cast<string>(m["OutResult"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
    if (m.find("TaskInformationList") != m.end() && !m["TaskInformationList"].empty()) {
      taskInformationList = make_shared<string>(boost::any_cast<string>(m["TaskInformationList"]));
    }
  }


  virtual ~ExecuteBatchTaskRequest() = default;
};
class ExecuteBatchTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> failNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> successNumber{};
  shared_ptr<long> total{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  ExecuteBatchTaskResponseBody() {}

  explicit ExecuteBatchTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failNumber) {
      res["failNumber"] = boost::any(*failNumber);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (successNumber) {
      res["successNumber"] = boost::any(*successNumber);
    }
    if (total) {
      res["total"] = boost::any(*total);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("failNumber") != m.end() && !m["failNumber"].empty()) {
      failNumber = make_shared<long>(boost::any_cast<long>(m["failNumber"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("successNumber") != m.end() && !m["successNumber"].empty()) {
      successNumber = make_shared<long>(boost::any_cast<long>(m["successNumber"]));
    }
    if (m.find("total") != m.end() && !m["total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["total"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~ExecuteBatchTaskResponseBody() = default;
};
class ExecuteBatchTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExecuteBatchTaskResponseBody> body{};

  ExecuteBatchTaskResponse() {}

  explicit ExecuteBatchTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecuteBatchTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecuteBatchTaskResponseBody>(model1);
      }
    }
  }


  virtual ~ExecuteBatchTaskResponse() = default;
};
class ExecutePlatformTaskHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ExecutePlatformTaskHeadersAccountContext() {}

  explicit ExecutePlatformTaskHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ExecutePlatformTaskHeadersAccountContext() = default;
};
class ExecutePlatformTaskHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ExecutePlatformTaskHeadersAccountContext> accountContext{};

  ExecutePlatformTaskHeaders() {}

  explicit ExecutePlatformTaskHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ExecutePlatformTaskHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ExecutePlatformTaskHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ExecutePlatformTaskHeaders() = default;
};
class ExecutePlatformTaskShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ExecutePlatformTaskShrinkHeaders() {}

  explicit ExecutePlatformTaskShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ExecutePlatformTaskShrinkHeaders() = default;
};
class ExecutePlatformTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> formDataJson{};
  shared_ptr<string> language{};
  shared_ptr<string> noExecuteExpressions{};
  shared_ptr<string> outResult{};
  shared_ptr<string> processInstanceId{};
  shared_ptr<string> remark{};
  shared_ptr<string> systemToken{};

  ExecutePlatformTaskRequest() {}

  explicit ExecutePlatformTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (formDataJson) {
      res["FormDataJson"] = boost::any(*formDataJson);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (noExecuteExpressions) {
      res["NoExecuteExpressions"] = boost::any(*noExecuteExpressions);
    }
    if (outResult) {
      res["OutResult"] = boost::any(*outResult);
    }
    if (processInstanceId) {
      res["ProcessInstanceId"] = boost::any(*processInstanceId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("FormDataJson") != m.end() && !m["FormDataJson"].empty()) {
      formDataJson = make_shared<string>(boost::any_cast<string>(m["FormDataJson"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("NoExecuteExpressions") != m.end() && !m["NoExecuteExpressions"].empty()) {
      noExecuteExpressions = make_shared<string>(boost::any_cast<string>(m["NoExecuteExpressions"]));
    }
    if (m.find("OutResult") != m.end() && !m["OutResult"].empty()) {
      outResult = make_shared<string>(boost::any_cast<string>(m["OutResult"]));
    }
    if (m.find("ProcessInstanceId") != m.end() && !m["ProcessInstanceId"].empty()) {
      processInstanceId = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~ExecutePlatformTaskRequest() = default;
};
class ExecutePlatformTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  ExecutePlatformTaskResponseBody() {}

  explicit ExecutePlatformTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~ExecutePlatformTaskResponseBody() = default;
};
class ExecutePlatformTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExecutePlatformTaskResponseBody> body{};

  ExecutePlatformTaskResponse() {}

  explicit ExecutePlatformTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecutePlatformTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecutePlatformTaskResponseBody>(model1);
      }
    }
  }


  virtual ~ExecutePlatformTaskResponse() = default;
};
class ExecuteTaskHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ExecuteTaskHeadersAccountContext() {}

  explicit ExecuteTaskHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ExecuteTaskHeadersAccountContext() = default;
};
class ExecuteTaskHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ExecuteTaskHeadersAccountContext> accountContext{};

  ExecuteTaskHeaders() {}

  explicit ExecuteTaskHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ExecuteTaskHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ExecuteTaskHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ExecuteTaskHeaders() = default;
};
class ExecuteTaskShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ExecuteTaskShrinkHeaders() {}

  explicit ExecuteTaskShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ExecuteTaskShrinkHeaders() = default;
};
class ExecuteTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> digitalSignUrl{};
  shared_ptr<string> formDataJson{};
  shared_ptr<string> language{};
  shared_ptr<string> noExecuteExpressions{};
  shared_ptr<string> outResult{};
  shared_ptr<string> processInstanceId{};
  shared_ptr<string> remark{};
  shared_ptr<string> systemToken{};
  shared_ptr<long> taskId{};

  ExecuteTaskRequest() {}

  explicit ExecuteTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (digitalSignUrl) {
      res["DigitalSignUrl"] = boost::any(*digitalSignUrl);
    }
    if (formDataJson) {
      res["FormDataJson"] = boost::any(*formDataJson);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (noExecuteExpressions) {
      res["NoExecuteExpressions"] = boost::any(*noExecuteExpressions);
    }
    if (outResult) {
      res["OutResult"] = boost::any(*outResult);
    }
    if (processInstanceId) {
      res["ProcessInstanceId"] = boost::any(*processInstanceId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("DigitalSignUrl") != m.end() && !m["DigitalSignUrl"].empty()) {
      digitalSignUrl = make_shared<string>(boost::any_cast<string>(m["DigitalSignUrl"]));
    }
    if (m.find("FormDataJson") != m.end() && !m["FormDataJson"].empty()) {
      formDataJson = make_shared<string>(boost::any_cast<string>(m["FormDataJson"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("NoExecuteExpressions") != m.end() && !m["NoExecuteExpressions"].empty()) {
      noExecuteExpressions = make_shared<string>(boost::any_cast<string>(m["NoExecuteExpressions"]));
    }
    if (m.find("OutResult") != m.end() && !m["OutResult"].empty()) {
      outResult = make_shared<string>(boost::any_cast<string>(m["OutResult"]));
    }
    if (m.find("ProcessInstanceId") != m.end() && !m["ProcessInstanceId"].empty()) {
      processInstanceId = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~ExecuteTaskRequest() = default;
};
class ExecuteTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  ExecuteTaskResponseBody() {}

  explicit ExecuteTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~ExecuteTaskResponseBody() = default;
};
class ExecuteTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExecuteTaskResponseBody> body{};

  ExecuteTaskResponse() {}

  explicit ExecuteTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecuteTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecuteTaskResponseBody>(model1);
      }
    }
  }


  virtual ~ExecuteTaskResponse() = default;
};
class ExpandGroupCapacityHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ExpandGroupCapacityHeadersAccountContext() {}

  explicit ExpandGroupCapacityHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ExpandGroupCapacityHeadersAccountContext() = default;
};
class ExpandGroupCapacityHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ExpandGroupCapacityHeadersAccountContext> accountContext{};

  ExpandGroupCapacityHeaders() {}

  explicit ExpandGroupCapacityHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ExpandGroupCapacityHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ExpandGroupCapacityHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ExpandGroupCapacityHeaders() = default;
};
class ExpandGroupCapacityShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ExpandGroupCapacityShrinkHeaders() {}

  explicit ExpandGroupCapacityShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ExpandGroupCapacityShrinkHeaders() = default;
};
class ExpandGroupCapacityRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  ExpandGroupCapacityRequestTenantContext() {}

  explicit ExpandGroupCapacityRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~ExpandGroupCapacityRequestTenantContext() = default;
};
class ExpandGroupCapacityRequest : public Darabonba::Model {
public:
  shared_ptr<string> openConversationId{};
  shared_ptr<ExpandGroupCapacityRequestTenantContext> tenantContext{};

  ExpandGroupCapacityRequest() {}

  explicit ExpandGroupCapacityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openConversationId) {
      res["OpenConversationId"] = boost::any(*openConversationId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpenConversationId") != m.end() && !m["OpenConversationId"].empty()) {
      openConversationId = make_shared<string>(boost::any_cast<string>(m["OpenConversationId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        ExpandGroupCapacityRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<ExpandGroupCapacityRequestTenantContext>(model1);
      }
    }
  }


  virtual ~ExpandGroupCapacityRequest() = default;
};
class ExpandGroupCapacityShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> openConversationId{};
  shared_ptr<string> tenantContextShrink{};

  ExpandGroupCapacityShrinkRequest() {}

  explicit ExpandGroupCapacityShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openConversationId) {
      res["OpenConversationId"] = boost::any(*openConversationId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpenConversationId") != m.end() && !m["OpenConversationId"].empty()) {
      openConversationId = make_shared<string>(boost::any_cast<string>(m["OpenConversationId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~ExpandGroupCapacityShrinkRequest() = default;
};
class ExpandGroupCapacityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  ExpandGroupCapacityResponseBody() {}

  explicit ExpandGroupCapacityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~ExpandGroupCapacityResponseBody() = default;
};
class ExpandGroupCapacityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExpandGroupCapacityResponseBody> body{};

  ExpandGroupCapacityResponse() {}

  explicit ExpandGroupCapacityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExpandGroupCapacityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExpandGroupCapacityResponseBody>(model1);
      }
    }
  }


  virtual ~ExpandGroupCapacityResponse() = default;
};
class FinishTicketHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  FinishTicketHeadersAccountContext() {}

  explicit FinishTicketHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~FinishTicketHeadersAccountContext() = default;
};
class FinishTicketHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<FinishTicketHeadersAccountContext> accountContext{};

  FinishTicketHeaders() {}

  explicit FinishTicketHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        FinishTicketHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<FinishTicketHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~FinishTicketHeaders() = default;
};
class FinishTicketShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  FinishTicketShrinkHeaders() {}

  explicit FinishTicketShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~FinishTicketShrinkHeaders() = default;
};
class FinishTicketRequestNotify : public Darabonba::Model {
public:
  shared_ptr<vector<string>> groupNoticeReceiverUserIds{};
  shared_ptr<bool> noticeAllGroupMember{};
  shared_ptr<vector<string>> workNoticeReceiverUserIds{};

  FinishTicketRequestNotify() {}

  explicit FinishTicketRequestNotify(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupNoticeReceiverUserIds) {
      res["GroupNoticeReceiverUserIds"] = boost::any(*groupNoticeReceiverUserIds);
    }
    if (noticeAllGroupMember) {
      res["NoticeAllGroupMember"] = boost::any(*noticeAllGroupMember);
    }
    if (workNoticeReceiverUserIds) {
      res["WorkNoticeReceiverUserIds"] = boost::any(*workNoticeReceiverUserIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupNoticeReceiverUserIds") != m.end() && !m["GroupNoticeReceiverUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupNoticeReceiverUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupNoticeReceiverUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupNoticeReceiverUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NoticeAllGroupMember") != m.end() && !m["NoticeAllGroupMember"].empty()) {
      noticeAllGroupMember = make_shared<bool>(boost::any_cast<bool>(m["NoticeAllGroupMember"]));
    }
    if (m.find("WorkNoticeReceiverUserIds") != m.end() && !m["WorkNoticeReceiverUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WorkNoticeReceiverUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WorkNoticeReceiverUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      workNoticeReceiverUserIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~FinishTicketRequestNotify() = default;
};
class FinishTicketRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  FinishTicketRequestTenantContext() {}

  explicit FinishTicketRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~FinishTicketRequestTenantContext() = default;
};
class FinishTicketRequestTicketMemoAttachments : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> key{};

  FinishTicketRequestTicketMemoAttachments() {}

  explicit FinishTicketRequestTicketMemoAttachments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~FinishTicketRequestTicketMemoAttachments() = default;
};
class FinishTicketRequestTicketMemo : public Darabonba::Model {
public:
  shared_ptr<vector<FinishTicketRequestTicketMemoAttachments>> attachments{};
  shared_ptr<string> memo{};

  FinishTicketRequestTicketMemo() {}

  explicit FinishTicketRequestTicketMemo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachments) {
      vector<boost::any> temp1;
      for(auto item1:*attachments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attachments"] = boost::any(temp1);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attachments") != m.end() && !m["Attachments"].empty()) {
      if (typeid(vector<boost::any>) == m["Attachments"].type()) {
        vector<FinishTicketRequestTicketMemoAttachments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attachments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FinishTicketRequestTicketMemoAttachments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attachments = make_shared<vector<FinishTicketRequestTicketMemoAttachments>>(expect1);
      }
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
  }


  virtual ~FinishTicketRequestTicketMemo() = default;
};
class FinishTicketRequest : public Darabonba::Model {
public:
  shared_ptr<FinishTicketRequestNotify> notify{};
  shared_ptr<string> openTeamId{};
  shared_ptr<string> openTicketId{};
  shared_ptr<FinishTicketRequestTenantContext> tenantContext{};
  shared_ptr<FinishTicketRequestTicketMemo> ticketMemo{};

  FinishTicketRequest() {}

  explicit FinishTicketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notify) {
      res["Notify"] = notify ? boost::any(notify->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (openTeamId) {
      res["OpenTeamId"] = boost::any(*openTeamId);
    }
    if (openTicketId) {
      res["OpenTicketId"] = boost::any(*openTicketId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ticketMemo) {
      res["TicketMemo"] = ticketMemo ? boost::any(ticketMemo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Notify") != m.end() && !m["Notify"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notify"].type()) {
        FinishTicketRequestNotify model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notify"]));
        notify = make_shared<FinishTicketRequestNotify>(model1);
      }
    }
    if (m.find("OpenTeamId") != m.end() && !m["OpenTeamId"].empty()) {
      openTeamId = make_shared<string>(boost::any_cast<string>(m["OpenTeamId"]));
    }
    if (m.find("OpenTicketId") != m.end() && !m["OpenTicketId"].empty()) {
      openTicketId = make_shared<string>(boost::any_cast<string>(m["OpenTicketId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        FinishTicketRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<FinishTicketRequestTenantContext>(model1);
      }
    }
    if (m.find("TicketMemo") != m.end() && !m["TicketMemo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TicketMemo"].type()) {
        FinishTicketRequestTicketMemo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TicketMemo"]));
        ticketMemo = make_shared<FinishTicketRequestTicketMemo>(model1);
      }
    }
  }


  virtual ~FinishTicketRequest() = default;
};
class FinishTicketShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> notifyShrink{};
  shared_ptr<string> openTeamId{};
  shared_ptr<string> openTicketId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> ticketMemoShrink{};

  FinishTicketShrinkRequest() {}

  explicit FinishTicketShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notifyShrink) {
      res["Notify"] = boost::any(*notifyShrink);
    }
    if (openTeamId) {
      res["OpenTeamId"] = boost::any(*openTeamId);
    }
    if (openTicketId) {
      res["OpenTicketId"] = boost::any(*openTicketId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (ticketMemoShrink) {
      res["TicketMemo"] = boost::any(*ticketMemoShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Notify") != m.end() && !m["Notify"].empty()) {
      notifyShrink = make_shared<string>(boost::any_cast<string>(m["Notify"]));
    }
    if (m.find("OpenTeamId") != m.end() && !m["OpenTeamId"].empty()) {
      openTeamId = make_shared<string>(boost::any_cast<string>(m["OpenTeamId"]));
    }
    if (m.find("OpenTicketId") != m.end() && !m["OpenTicketId"].empty()) {
      openTicketId = make_shared<string>(boost::any_cast<string>(m["OpenTicketId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("TicketMemo") != m.end() && !m["TicketMemo"].empty()) {
      ticketMemoShrink = make_shared<string>(boost::any_cast<string>(m["TicketMemo"]));
    }
  }


  virtual ~FinishTicketShrinkRequest() = default;
};
class FinishTicketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  FinishTicketResponseBody() {}

  explicit FinishTicketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~FinishTicketResponseBody() = default;
};
class FinishTicketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FinishTicketResponseBody> body{};

  FinishTicketResponse() {}

  explicit FinishTicketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FinishTicketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FinishTicketResponseBody>(model1);
      }
    }
  }


  virtual ~FinishTicketResponse() = default;
};
class GetActivityListHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetActivityListHeadersAccountContext() {}

  explicit GetActivityListHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetActivityListHeadersAccountContext() = default;
};
class GetActivityListHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetActivityListHeadersAccountContext> accountContext{};

  GetActivityListHeaders() {}

  explicit GetActivityListHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetActivityListHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetActivityListHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetActivityListHeaders() = default;
};
class GetActivityListShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetActivityListShrinkHeaders() {}

  explicit GetActivityListShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetActivityListShrinkHeaders() = default;
};
class GetActivityListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> language{};
  shared_ptr<string> processCode{};
  shared_ptr<string> systemToken{};

  GetActivityListRequest() {}

  explicit GetActivityListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (processCode) {
      res["ProcessCode"] = boost::any(*processCode);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("ProcessCode") != m.end() && !m["ProcessCode"].empty()) {
      processCode = make_shared<string>(boost::any_cast<string>(m["ProcessCode"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~GetActivityListRequest() = default;
};
class GetActivityListResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> activityId{};
  shared_ptr<string> activityName{};
  shared_ptr<string> activityNameInEnglish{};

  GetActivityListResponseBodyResult() {}

  explicit GetActivityListResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityId) {
      res["ActivityId"] = boost::any(*activityId);
    }
    if (activityName) {
      res["ActivityName"] = boost::any(*activityName);
    }
    if (activityNameInEnglish) {
      res["ActivityNameInEnglish"] = boost::any(*activityNameInEnglish);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityId") != m.end() && !m["ActivityId"].empty()) {
      activityId = make_shared<string>(boost::any_cast<string>(m["ActivityId"]));
    }
    if (m.find("ActivityName") != m.end() && !m["ActivityName"].empty()) {
      activityName = make_shared<string>(boost::any_cast<string>(m["ActivityName"]));
    }
    if (m.find("ActivityNameInEnglish") != m.end() && !m["ActivityNameInEnglish"].empty()) {
      activityNameInEnglish = make_shared<string>(boost::any_cast<string>(m["ActivityNameInEnglish"]));
    }
  }


  virtual ~GetActivityListResponseBodyResult() = default;
};
class GetActivityListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetActivityListResponseBodyResult>> result{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetActivityListResponseBody() {}

  explicit GetActivityListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<GetActivityListResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetActivityListResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<GetActivityListResponseBodyResult>>(expect1);
      }
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetActivityListResponseBody() = default;
};
class GetActivityListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetActivityListResponseBody> body{};

  GetActivityListResponse() {}

  explicit GetActivityListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetActivityListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetActivityListResponseBody>(model1);
      }
    }
  }


  virtual ~GetActivityListResponse() = default;
};
class GetAllSheetsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetAllSheetsHeadersAccountContext() {}

  explicit GetAllSheetsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetAllSheetsHeadersAccountContext() = default;
};
class GetAllSheetsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetAllSheetsHeadersAccountContext> accountContext{};

  GetAllSheetsHeaders() {}

  explicit GetAllSheetsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetAllSheetsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetAllSheetsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetAllSheetsHeaders() = default;
};
class GetAllSheetsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetAllSheetsShrinkHeaders() {}

  explicit GetAllSheetsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetAllSheetsShrinkHeaders() = default;
};
class GetAllSheetsRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetAllSheetsRequestTenantContext() {}

  explicit GetAllSheetsRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetAllSheetsRequestTenantContext() = default;
};
class GetAllSheetsRequest : public Darabonba::Model {
public:
  shared_ptr<GetAllSheetsRequestTenantContext> tenantContext{};
  shared_ptr<string> workbookId{};

  GetAllSheetsRequest() {}

  explicit GetAllSheetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetAllSheetsRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetAllSheetsRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~GetAllSheetsRequest() = default;
};
class GetAllSheetsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workbookId{};

  GetAllSheetsShrinkRequest() {}

  explicit GetAllSheetsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~GetAllSheetsShrinkRequest() = default;
};
class GetAllSheetsResponseBodyValue : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  GetAllSheetsResponseBodyValue() {}

  explicit GetAllSheetsResponseBodyValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetAllSheetsResponseBodyValue() = default;
};
class GetAllSheetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetAllSheetsResponseBodyValue>> value{};

  GetAllSheetsResponseBody() {}

  explicit GetAllSheetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (value) {
      vector<boost::any> temp1;
      for(auto item1:*value){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["value"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      if (typeid(vector<boost::any>) == m["value"].type()) {
        vector<GetAllSheetsResponseBodyValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["value"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAllSheetsResponseBodyValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        value = make_shared<vector<GetAllSheetsResponseBodyValue>>(expect1);
      }
    }
  }


  virtual ~GetAllSheetsResponseBody() = default;
};
class GetAllSheetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAllSheetsResponseBody> body{};

  GetAllSheetsResponse() {}

  explicit GetAllSheetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAllSheetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAllSheetsResponseBody>(model1);
      }
    }
  }


  virtual ~GetAllSheetsResponse() = default;
};
class GetAssistantCapabilityHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountId{};

  GetAssistantCapabilityHeaders() {}

  explicit GetAssistantCapabilityHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetAssistantCapabilityHeaders() = default;
};
class GetAssistantCapabilityRequestMessagesContentCardCallback : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> relatedMessageId{};

  GetAssistantCapabilityRequestMessagesContentCardCallback() {}

  explicit GetAssistantCapabilityRequestMessagesContentCardCallback(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (relatedMessageId) {
      res["relatedMessageId"] = boost::any(*relatedMessageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("relatedMessageId") != m.end() && !m["relatedMessageId"].empty()) {
      relatedMessageId = make_shared<string>(boost::any_cast<string>(m["relatedMessageId"]));
    }
  }


  virtual ~GetAssistantCapabilityRequestMessagesContentCardCallback() = default;
};
class GetAssistantCapabilityRequestMessagesContentDingCard : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentType{};
  shared_ptr<bool> finished{};
  shared_ptr<string> templateId{};

  GetAssistantCapabilityRequestMessagesContentDingCard() {}

  explicit GetAssistantCapabilityRequestMessagesContentDingCard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (contentType) {
      res["contentType"] = boost::any(*contentType);
    }
    if (finished) {
      res["finished"] = boost::any(*finished);
    }
    if (templateId) {
      res["templateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("contentType") != m.end() && !m["contentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["contentType"]));
    }
    if (m.find("finished") != m.end() && !m["finished"].empty()) {
      finished = make_shared<bool>(boost::any_cast<bool>(m["finished"]));
    }
    if (m.find("templateId") != m.end() && !m["templateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["templateId"]));
    }
  }


  virtual ~GetAssistantCapabilityRequestMessagesContentDingCard() = default;
};
class GetAssistantCapabilityRequestMessagesContentDingNormalCardCardData : public Darabonba::Model {
public:
  shared_ptr<boost::any> cardParamMap{};

  GetAssistantCapabilityRequestMessagesContentDingNormalCardCardData() {}

  explicit GetAssistantCapabilityRequestMessagesContentDingNormalCardCardData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardParamMap) {
      res["cardParamMap"] = boost::any(*cardParamMap);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cardParamMap") != m.end() && !m["cardParamMap"].empty()) {
      cardParamMap = make_shared<boost::any>(boost::any_cast<boost::any>(m["cardParamMap"]));
    }
  }


  virtual ~GetAssistantCapabilityRequestMessagesContentDingNormalCardCardData() = default;
};
class GetAssistantCapabilityRequestMessagesContentDingNormalCardCardUpdateOptions : public Darabonba::Model {
public:
  shared_ptr<bool> updateCardDataByKey{};
  shared_ptr<bool> updatePrivateDataByKey{};

  GetAssistantCapabilityRequestMessagesContentDingNormalCardCardUpdateOptions() {}

  explicit GetAssistantCapabilityRequestMessagesContentDingNormalCardCardUpdateOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateCardDataByKey) {
      res["updateCardDataByKey"] = boost::any(*updateCardDataByKey);
    }
    if (updatePrivateDataByKey) {
      res["updatePrivateDataByKey"] = boost::any(*updatePrivateDataByKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("updateCardDataByKey") != m.end() && !m["updateCardDataByKey"].empty()) {
      updateCardDataByKey = make_shared<bool>(boost::any_cast<bool>(m["updateCardDataByKey"]));
    }
    if (m.find("updatePrivateDataByKey") != m.end() && !m["updatePrivateDataByKey"].empty()) {
      updatePrivateDataByKey = make_shared<bool>(boost::any_cast<bool>(m["updatePrivateDataByKey"]));
    }
  }


  virtual ~GetAssistantCapabilityRequestMessagesContentDingNormalCardCardUpdateOptions() = default;
};
class GetAssistantCapabilityRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig : public Darabonba::Model {
public:
  shared_ptr<long> interval{};
  shared_ptr<string> pullStrategy{};
  shared_ptr<string> timeUnit{};

  GetAssistantCapabilityRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig() {}

  explicit GetAssistantCapabilityRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interval) {
      res["interval"] = boost::any(*interval);
    }
    if (pullStrategy) {
      res["pullStrategy"] = boost::any(*pullStrategy);
    }
    if (timeUnit) {
      res["timeUnit"] = boost::any(*timeUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("interval") != m.end() && !m["interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["interval"]));
    }
    if (m.find("pullStrategy") != m.end() && !m["pullStrategy"].empty()) {
      pullStrategy = make_shared<string>(boost::any_cast<string>(m["pullStrategy"]));
    }
    if (m.find("timeUnit") != m.end() && !m["timeUnit"].empty()) {
      timeUnit = make_shared<string>(boost::any_cast<string>(m["timeUnit"]));
    }
  }


  virtual ~GetAssistantCapabilityRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig() = default;
};
class GetAssistantCapabilityRequestMessagesContentDingNormalCardDynamicDataSourceConfigs : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> constParams{};
  shared_ptr<string> dynamicDataSourceId{};
  shared_ptr<GetAssistantCapabilityRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig> pullConfig{};

  GetAssistantCapabilityRequestMessagesContentDingNormalCardDynamicDataSourceConfigs() {}

  explicit GetAssistantCapabilityRequestMessagesContentDingNormalCardDynamicDataSourceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constParams) {
      res["constParams"] = boost::any(*constParams);
    }
    if (dynamicDataSourceId) {
      res["dynamicDataSourceId"] = boost::any(*dynamicDataSourceId);
    }
    if (pullConfig) {
      res["pullConfig"] = pullConfig ? boost::any(pullConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("constParams") != m.end() && !m["constParams"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["constParams"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      constParams = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("dynamicDataSourceId") != m.end() && !m["dynamicDataSourceId"].empty()) {
      dynamicDataSourceId = make_shared<string>(boost::any_cast<string>(m["dynamicDataSourceId"]));
    }
    if (m.find("pullConfig") != m.end() && !m["pullConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["pullConfig"].type()) {
        GetAssistantCapabilityRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["pullConfig"]));
        pullConfig = make_shared<GetAssistantCapabilityRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig>(model1);
      }
    }
  }


  virtual ~GetAssistantCapabilityRequestMessagesContentDingNormalCardDynamicDataSourceConfigs() = default;
};
class GetAssistantCapabilityRequestMessagesContentDingNormalCard : public Darabonba::Model {
public:
  shared_ptr<GetAssistantCapabilityRequestMessagesContentDingNormalCardCardData> cardData{};
  shared_ptr<string> cardTemplateId{};
  shared_ptr<GetAssistantCapabilityRequestMessagesContentDingNormalCardCardUpdateOptions> cardUpdateOptions{};
  shared_ptr<vector<GetAssistantCapabilityRequestMessagesContentDingNormalCardDynamicDataSourceConfigs>> dynamicDataSourceConfigs{};
  shared_ptr<map<string, boost::any>> privateData{};

  GetAssistantCapabilityRequestMessagesContentDingNormalCard() {}

  explicit GetAssistantCapabilityRequestMessagesContentDingNormalCard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardData) {
      res["cardData"] = cardData ? boost::any(cardData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cardTemplateId) {
      res["cardTemplateId"] = boost::any(*cardTemplateId);
    }
    if (cardUpdateOptions) {
      res["cardUpdateOptions"] = cardUpdateOptions ? boost::any(cardUpdateOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dynamicDataSourceConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*dynamicDataSourceConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dynamicDataSourceConfigs"] = boost::any(temp1);
    }
    if (privateData) {
      res["privateData"] = boost::any(*privateData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cardData") != m.end() && !m["cardData"].empty()) {
      if (typeid(map<string, boost::any>) == m["cardData"].type()) {
        GetAssistantCapabilityRequestMessagesContentDingNormalCardCardData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cardData"]));
        cardData = make_shared<GetAssistantCapabilityRequestMessagesContentDingNormalCardCardData>(model1);
      }
    }
    if (m.find("cardTemplateId") != m.end() && !m["cardTemplateId"].empty()) {
      cardTemplateId = make_shared<string>(boost::any_cast<string>(m["cardTemplateId"]));
    }
    if (m.find("cardUpdateOptions") != m.end() && !m["cardUpdateOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["cardUpdateOptions"].type()) {
        GetAssistantCapabilityRequestMessagesContentDingNormalCardCardUpdateOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cardUpdateOptions"]));
        cardUpdateOptions = make_shared<GetAssistantCapabilityRequestMessagesContentDingNormalCardCardUpdateOptions>(model1);
      }
    }
    if (m.find("dynamicDataSourceConfigs") != m.end() && !m["dynamicDataSourceConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["dynamicDataSourceConfigs"].type()) {
        vector<GetAssistantCapabilityRequestMessagesContentDingNormalCardDynamicDataSourceConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dynamicDataSourceConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAssistantCapabilityRequestMessagesContentDingNormalCardDynamicDataSourceConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dynamicDataSourceConfigs = make_shared<vector<GetAssistantCapabilityRequestMessagesContentDingNormalCardDynamicDataSourceConfigs>>(expect1);
      }
    }
    if (m.find("privateData") != m.end() && !m["privateData"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["privateData"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      privateData = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~GetAssistantCapabilityRequestMessagesContentDingNormalCard() = default;
};
class GetAssistantCapabilityRequestMessagesContentMarkdown : public Darabonba::Model {
public:
  shared_ptr<string> value{};

  GetAssistantCapabilityRequestMessagesContentMarkdown() {}

  explicit GetAssistantCapabilityRequestMessagesContentMarkdown(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~GetAssistantCapabilityRequestMessagesContentMarkdown() = default;
};
class GetAssistantCapabilityRequestMessagesContentStructViewPartsDataPart : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};

  GetAssistantCapabilityRequestMessagesContentStructViewPartsDataPart() {}

  explicit GetAssistantCapabilityRequestMessagesContentStructViewPartsDataPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["data"]));
    }
  }


  virtual ~GetAssistantCapabilityRequestMessagesContentStructViewPartsDataPart() = default;
};
class GetAssistantCapabilityRequestMessagesContentStructViewPartsReasonPart : public Darabonba::Model {
public:
  shared_ptr<string> reason{};

  GetAssistantCapabilityRequestMessagesContentStructViewPartsReasonPart() {}

  explicit GetAssistantCapabilityRequestMessagesContentStructViewPartsReasonPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
  }


  virtual ~GetAssistantCapabilityRequestMessagesContentStructViewPartsReasonPart() = default;
};
class GetAssistantCapabilityRequestMessagesContentStructViewPartsRecommendPartRecommends : public Darabonba::Model {
public:
  shared_ptr<string> mobileUrl{};
  shared_ptr<string> text{};
  shared_ptr<string> url{};

  GetAssistantCapabilityRequestMessagesContentStructViewPartsRecommendPartRecommends() {}

  explicit GetAssistantCapabilityRequestMessagesContentStructViewPartsRecommendPartRecommends(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mobileUrl) {
      res["mobileUrl"] = boost::any(*mobileUrl);
    }
    if (text) {
      res["text"] = boost::any(*text);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("mobileUrl") != m.end() && !m["mobileUrl"].empty()) {
      mobileUrl = make_shared<string>(boost::any_cast<string>(m["mobileUrl"]));
    }
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~GetAssistantCapabilityRequestMessagesContentStructViewPartsRecommendPartRecommends() = default;
};
class GetAssistantCapabilityRequestMessagesContentStructViewPartsRecommendPart : public Darabonba::Model {
public:
  shared_ptr<vector<GetAssistantCapabilityRequestMessagesContentStructViewPartsRecommendPartRecommends>> recommends{};

  GetAssistantCapabilityRequestMessagesContentStructViewPartsRecommendPart() {}

  explicit GetAssistantCapabilityRequestMessagesContentStructViewPartsRecommendPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommends) {
      vector<boost::any> temp1;
      for(auto item1:*recommends){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["recommends"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("recommends") != m.end() && !m["recommends"].empty()) {
      if (typeid(vector<boost::any>) == m["recommends"].type()) {
        vector<GetAssistantCapabilityRequestMessagesContentStructViewPartsRecommendPartRecommends> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["recommends"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAssistantCapabilityRequestMessagesContentStructViewPartsRecommendPartRecommends model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recommends = make_shared<vector<GetAssistantCapabilityRequestMessagesContentStructViewPartsRecommendPartRecommends>>(expect1);
      }
    }
  }


  virtual ~GetAssistantCapabilityRequestMessagesContentStructViewPartsRecommendPart() = default;
};
class GetAssistantCapabilityRequestMessagesContentStructViewPartsReferencePartReferences : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceCode{};
  shared_ptr<string> sourceIcon{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  GetAssistantCapabilityRequestMessagesContentStructViewPartsReferencePartReferences() {}

  explicit GetAssistantCapabilityRequestMessagesContentStructViewPartsReferencePartReferences(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceCode) {
      res["sourceCode"] = boost::any(*sourceCode);
    }
    if (sourceIcon) {
      res["sourceIcon"] = boost::any(*sourceIcon);
    }
    if (summary) {
      res["summary"] = boost::any(*summary);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceCode") != m.end() && !m["sourceCode"].empty()) {
      sourceCode = make_shared<string>(boost::any_cast<string>(m["sourceCode"]));
    }
    if (m.find("sourceIcon") != m.end() && !m["sourceIcon"].empty()) {
      sourceIcon = make_shared<string>(boost::any_cast<string>(m["sourceIcon"]));
    }
    if (m.find("summary") != m.end() && !m["summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["summary"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~GetAssistantCapabilityRequestMessagesContentStructViewPartsReferencePartReferences() = default;
};
class GetAssistantCapabilityRequestMessagesContentStructViewPartsReferencePart : public Darabonba::Model {
public:
  shared_ptr<vector<GetAssistantCapabilityRequestMessagesContentStructViewPartsReferencePartReferences>> references{};

  GetAssistantCapabilityRequestMessagesContentStructViewPartsReferencePart() {}

  explicit GetAssistantCapabilityRequestMessagesContentStructViewPartsReferencePart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (references) {
      vector<boost::any> temp1;
      for(auto item1:*references){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["references"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("references") != m.end() && !m["references"].empty()) {
      if (typeid(vector<boost::any>) == m["references"].type()) {
        vector<GetAssistantCapabilityRequestMessagesContentStructViewPartsReferencePartReferences> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["references"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAssistantCapabilityRequestMessagesContentStructViewPartsReferencePartReferences model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        references = make_shared<vector<GetAssistantCapabilityRequestMessagesContentStructViewPartsReferencePartReferences>>(expect1);
      }
    }
  }


  virtual ~GetAssistantCapabilityRequestMessagesContentStructViewPartsReferencePart() = default;
};
class GetAssistantCapabilityRequestMessagesContentStructViewPartsTextPart : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  GetAssistantCapabilityRequestMessagesContentStructViewPartsTextPart() {}

  explicit GetAssistantCapabilityRequestMessagesContentStructViewPartsTextPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
  }


  virtual ~GetAssistantCapabilityRequestMessagesContentStructViewPartsTextPart() = default;
};
class GetAssistantCapabilityRequestMessagesContentStructViewParts : public Darabonba::Model {
public:
  shared_ptr<bool> append{};
  shared_ptr<GetAssistantCapabilityRequestMessagesContentStructViewPartsDataPart> dataPart{};
  shared_ptr<bool> finish{};
  shared_ptr<string> partDesc{};
  shared_ptr<string> partId{};
  shared_ptr<GetAssistantCapabilityRequestMessagesContentStructViewPartsReasonPart> reasonPart{};
  shared_ptr<GetAssistantCapabilityRequestMessagesContentStructViewPartsRecommendPart> recommendPart{};
  shared_ptr<GetAssistantCapabilityRequestMessagesContentStructViewPartsReferencePart> referencePart{};
  shared_ptr<GetAssistantCapabilityRequestMessagesContentStructViewPartsTextPart> textPart{};
  shared_ptr<string> type{};

  GetAssistantCapabilityRequestMessagesContentStructViewParts() {}

  explicit GetAssistantCapabilityRequestMessagesContentStructViewParts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (append) {
      res["append"] = boost::any(*append);
    }
    if (dataPart) {
      res["dataPart"] = dataPart ? boost::any(dataPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (finish) {
      res["finish"] = boost::any(*finish);
    }
    if (partDesc) {
      res["partDesc"] = boost::any(*partDesc);
    }
    if (partId) {
      res["partId"] = boost::any(*partId);
    }
    if (reasonPart) {
      res["reasonPart"] = reasonPart ? boost::any(reasonPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recommendPart) {
      res["recommendPart"] = recommendPart ? boost::any(recommendPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referencePart) {
      res["referencePart"] = referencePart ? boost::any(referencePart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (textPart) {
      res["textPart"] = textPart ? boost::any(textPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("append") != m.end() && !m["append"].empty()) {
      append = make_shared<bool>(boost::any_cast<bool>(m["append"]));
    }
    if (m.find("dataPart") != m.end() && !m["dataPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["dataPart"].type()) {
        GetAssistantCapabilityRequestMessagesContentStructViewPartsDataPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dataPart"]));
        dataPart = make_shared<GetAssistantCapabilityRequestMessagesContentStructViewPartsDataPart>(model1);
      }
    }
    if (m.find("finish") != m.end() && !m["finish"].empty()) {
      finish = make_shared<bool>(boost::any_cast<bool>(m["finish"]));
    }
    if (m.find("partDesc") != m.end() && !m["partDesc"].empty()) {
      partDesc = make_shared<string>(boost::any_cast<string>(m["partDesc"]));
    }
    if (m.find("partId") != m.end() && !m["partId"].empty()) {
      partId = make_shared<string>(boost::any_cast<string>(m["partId"]));
    }
    if (m.find("reasonPart") != m.end() && !m["reasonPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["reasonPart"].type()) {
        GetAssistantCapabilityRequestMessagesContentStructViewPartsReasonPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["reasonPart"]));
        reasonPart = make_shared<GetAssistantCapabilityRequestMessagesContentStructViewPartsReasonPart>(model1);
      }
    }
    if (m.find("recommendPart") != m.end() && !m["recommendPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["recommendPart"].type()) {
        GetAssistantCapabilityRequestMessagesContentStructViewPartsRecommendPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["recommendPart"]));
        recommendPart = make_shared<GetAssistantCapabilityRequestMessagesContentStructViewPartsRecommendPart>(model1);
      }
    }
    if (m.find("referencePart") != m.end() && !m["referencePart"].empty()) {
      if (typeid(map<string, boost::any>) == m["referencePart"].type()) {
        GetAssistantCapabilityRequestMessagesContentStructViewPartsReferencePart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["referencePart"]));
        referencePart = make_shared<GetAssistantCapabilityRequestMessagesContentStructViewPartsReferencePart>(model1);
      }
    }
    if (m.find("textPart") != m.end() && !m["textPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["textPart"].type()) {
        GetAssistantCapabilityRequestMessagesContentStructViewPartsTextPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["textPart"]));
        textPart = make_shared<GetAssistantCapabilityRequestMessagesContentStructViewPartsTextPart>(model1);
      }
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~GetAssistantCapabilityRequestMessagesContentStructViewParts() = default;
};
class GetAssistantCapabilityRequestMessagesContentStructView : public Darabonba::Model {
public:
  shared_ptr<vector<GetAssistantCapabilityRequestMessagesContentStructViewParts>> parts{};

  GetAssistantCapabilityRequestMessagesContentStructView() {}

  explicit GetAssistantCapabilityRequestMessagesContentStructView(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parts) {
      vector<boost::any> temp1;
      for(auto item1:*parts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["parts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("parts") != m.end() && !m["parts"].empty()) {
      if (typeid(vector<boost::any>) == m["parts"].type()) {
        vector<GetAssistantCapabilityRequestMessagesContentStructViewParts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["parts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAssistantCapabilityRequestMessagesContentStructViewParts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parts = make_shared<vector<GetAssistantCapabilityRequestMessagesContentStructViewParts>>(expect1);
      }
    }
  }


  virtual ~GetAssistantCapabilityRequestMessagesContentStructView() = default;
};
class GetAssistantCapabilityRequestMessagesContentText : public Darabonba::Model {
public:
  shared_ptr<string> value{};

  GetAssistantCapabilityRequestMessagesContentText() {}

  explicit GetAssistantCapabilityRequestMessagesContentText(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~GetAssistantCapabilityRequestMessagesContentText() = default;
};
class GetAssistantCapabilityRequestMessagesContent : public Darabonba::Model {
public:
  shared_ptr<GetAssistantCapabilityRequestMessagesContentCardCallback> cardCallback{};
  shared_ptr<GetAssistantCapabilityRequestMessagesContentDingCard> dingCard{};
  shared_ptr<GetAssistantCapabilityRequestMessagesContentDingNormalCard> dingNormalCard{};
  shared_ptr<GetAssistantCapabilityRequestMessagesContentMarkdown> markdown{};
  shared_ptr<GetAssistantCapabilityRequestMessagesContentStructView> structView{};
  shared_ptr<GetAssistantCapabilityRequestMessagesContentText> text{};
  shared_ptr<string> type{};

  GetAssistantCapabilityRequestMessagesContent() {}

  explicit GetAssistantCapabilityRequestMessagesContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardCallback) {
      res["cardCallback"] = cardCallback ? boost::any(cardCallback->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dingCard) {
      res["dingCard"] = dingCard ? boost::any(dingCard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dingNormalCard) {
      res["dingNormalCard"] = dingNormalCard ? boost::any(dingNormalCard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (markdown) {
      res["markdown"] = markdown ? boost::any(markdown->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (structView) {
      res["structView"] = structView ? boost::any(structView->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (text) {
      res["text"] = text ? boost::any(text->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cardCallback") != m.end() && !m["cardCallback"].empty()) {
      if (typeid(map<string, boost::any>) == m["cardCallback"].type()) {
        GetAssistantCapabilityRequestMessagesContentCardCallback model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cardCallback"]));
        cardCallback = make_shared<GetAssistantCapabilityRequestMessagesContentCardCallback>(model1);
      }
    }
    if (m.find("dingCard") != m.end() && !m["dingCard"].empty()) {
      if (typeid(map<string, boost::any>) == m["dingCard"].type()) {
        GetAssistantCapabilityRequestMessagesContentDingCard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dingCard"]));
        dingCard = make_shared<GetAssistantCapabilityRequestMessagesContentDingCard>(model1);
      }
    }
    if (m.find("dingNormalCard") != m.end() && !m["dingNormalCard"].empty()) {
      if (typeid(map<string, boost::any>) == m["dingNormalCard"].type()) {
        GetAssistantCapabilityRequestMessagesContentDingNormalCard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dingNormalCard"]));
        dingNormalCard = make_shared<GetAssistantCapabilityRequestMessagesContentDingNormalCard>(model1);
      }
    }
    if (m.find("markdown") != m.end() && !m["markdown"].empty()) {
      if (typeid(map<string, boost::any>) == m["markdown"].type()) {
        GetAssistantCapabilityRequestMessagesContentMarkdown model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["markdown"]));
        markdown = make_shared<GetAssistantCapabilityRequestMessagesContentMarkdown>(model1);
      }
    }
    if (m.find("structView") != m.end() && !m["structView"].empty()) {
      if (typeid(map<string, boost::any>) == m["structView"].type()) {
        GetAssistantCapabilityRequestMessagesContentStructView model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["structView"]));
        structView = make_shared<GetAssistantCapabilityRequestMessagesContentStructView>(model1);
      }
    }
    if (m.find("text") != m.end() && !m["text"].empty()) {
      if (typeid(map<string, boost::any>) == m["text"].type()) {
        GetAssistantCapabilityRequestMessagesContentText model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["text"]));
        text = make_shared<GetAssistantCapabilityRequestMessagesContentText>(model1);
      }
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~GetAssistantCapabilityRequestMessagesContent() = default;
};
class GetAssistantCapabilityRequestMessages : public Darabonba::Model {
public:
  shared_ptr<GetAssistantCapabilityRequestMessagesContent> content{};
  shared_ptr<string> contentDesc{};
  shared_ptr<long> createAt{};
  shared_ptr<string> role{};

  GetAssistantCapabilityRequestMessages() {}

  explicit GetAssistantCapabilityRequestMessages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contentDesc) {
      res["contentDesc"] = boost::any(*contentDesc);
    }
    if (createAt) {
      res["createAt"] = boost::any(*createAt);
    }
    if (role) {
      res["role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      if (typeid(map<string, boost::any>) == m["content"].type()) {
        GetAssistantCapabilityRequestMessagesContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["content"]));
        content = make_shared<GetAssistantCapabilityRequestMessagesContent>(model1);
      }
    }
    if (m.find("contentDesc") != m.end() && !m["contentDesc"].empty()) {
      contentDesc = make_shared<string>(boost::any_cast<string>(m["contentDesc"]));
    }
    if (m.find("createAt") != m.end() && !m["createAt"].empty()) {
      createAt = make_shared<long>(boost::any_cast<long>(m["createAt"]));
    }
    if (m.find("role") != m.end() && !m["role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["role"]));
    }
  }


  virtual ~GetAssistantCapabilityRequestMessages() = default;
};
class GetAssistantCapabilityRequest : public Darabonba::Model {
public:
  shared_ptr<string> assistantId{};
  shared_ptr<vector<GetAssistantCapabilityRequestMessages>> messages{};
  shared_ptr<string> originalAssistantId{};
  shared_ptr<string> protocol{};
  shared_ptr<string> sourceIdOfOriginalAssistantId{};
  shared_ptr<string> sourceTypeOfOriginalAssistantId{};
  shared_ptr<string> threadId{};
  shared_ptr<long> timeout{};

  GetAssistantCapabilityRequest() {}

  explicit GetAssistantCapabilityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assistantId) {
      res["assistantId"] = boost::any(*assistantId);
    }
    if (messages) {
      vector<boost::any> temp1;
      for(auto item1:*messages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["messages"] = boost::any(temp1);
    }
    if (originalAssistantId) {
      res["originalAssistantId"] = boost::any(*originalAssistantId);
    }
    if (protocol) {
      res["protocol"] = boost::any(*protocol);
    }
    if (sourceIdOfOriginalAssistantId) {
      res["sourceIdOfOriginalAssistantId"] = boost::any(*sourceIdOfOriginalAssistantId);
    }
    if (sourceTypeOfOriginalAssistantId) {
      res["sourceTypeOfOriginalAssistantId"] = boost::any(*sourceTypeOfOriginalAssistantId);
    }
    if (threadId) {
      res["threadId"] = boost::any(*threadId);
    }
    if (timeout) {
      res["timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assistantId") != m.end() && !m["assistantId"].empty()) {
      assistantId = make_shared<string>(boost::any_cast<string>(m["assistantId"]));
    }
    if (m.find("messages") != m.end() && !m["messages"].empty()) {
      if (typeid(vector<boost::any>) == m["messages"].type()) {
        vector<GetAssistantCapabilityRequestMessages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["messages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAssistantCapabilityRequestMessages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        messages = make_shared<vector<GetAssistantCapabilityRequestMessages>>(expect1);
      }
    }
    if (m.find("originalAssistantId") != m.end() && !m["originalAssistantId"].empty()) {
      originalAssistantId = make_shared<string>(boost::any_cast<string>(m["originalAssistantId"]));
    }
    if (m.find("protocol") != m.end() && !m["protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["protocol"]));
    }
    if (m.find("sourceIdOfOriginalAssistantId") != m.end() && !m["sourceIdOfOriginalAssistantId"].empty()) {
      sourceIdOfOriginalAssistantId = make_shared<string>(boost::any_cast<string>(m["sourceIdOfOriginalAssistantId"]));
    }
    if (m.find("sourceTypeOfOriginalAssistantId") != m.end() && !m["sourceTypeOfOriginalAssistantId"].empty()) {
      sourceTypeOfOriginalAssistantId = make_shared<string>(boost::any_cast<string>(m["sourceTypeOfOriginalAssistantId"]));
    }
    if (m.find("threadId") != m.end() && !m["threadId"].empty()) {
      threadId = make_shared<string>(boost::any_cast<string>(m["threadId"]));
    }
    if (m.find("timeout") != m.end() && !m["timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["timeout"]));
    }
  }


  virtual ~GetAssistantCapabilityRequest() = default;
};
class GetAssistantCapabilityResponseBodyCapabilityAssessmentCapabilityList : public Darabonba::Model {
public:
  shared_ptr<string> capabilityOverview{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};

  GetAssistantCapabilityResponseBodyCapabilityAssessmentCapabilityList() {}

  explicit GetAssistantCapabilityResponseBodyCapabilityAssessmentCapabilityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capabilityOverview) {
      res["capabilityOverview"] = boost::any(*capabilityOverview);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("capabilityOverview") != m.end() && !m["capabilityOverview"].empty()) {
      capabilityOverview = make_shared<string>(boost::any_cast<string>(m["capabilityOverview"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~GetAssistantCapabilityResponseBodyCapabilityAssessmentCapabilityList() = default;
};
class GetAssistantCapabilityResponseBodyCapabilityAssessment : public Darabonba::Model {
public:
  shared_ptr<string> briefCapability{};
  shared_ptr<vector<GetAssistantCapabilityResponseBodyCapabilityAssessmentCapabilityList>> capabilityList{};

  GetAssistantCapabilityResponseBodyCapabilityAssessment() {}

  explicit GetAssistantCapabilityResponseBodyCapabilityAssessment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (briefCapability) {
      res["briefCapability"] = boost::any(*briefCapability);
    }
    if (capabilityList) {
      vector<boost::any> temp1;
      for(auto item1:*capabilityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["capabilityList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("briefCapability") != m.end() && !m["briefCapability"].empty()) {
      briefCapability = make_shared<string>(boost::any_cast<string>(m["briefCapability"]));
    }
    if (m.find("capabilityList") != m.end() && !m["capabilityList"].empty()) {
      if (typeid(vector<boost::any>) == m["capabilityList"].type()) {
        vector<GetAssistantCapabilityResponseBodyCapabilityAssessmentCapabilityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["capabilityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAssistantCapabilityResponseBodyCapabilityAssessmentCapabilityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        capabilityList = make_shared<vector<GetAssistantCapabilityResponseBodyCapabilityAssessmentCapabilityList>>(expect1);
      }
    }
  }


  virtual ~GetAssistantCapabilityResponseBodyCapabilityAssessment() = default;
};
class GetAssistantCapabilityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> assistantDescription{};
  shared_ptr<bool> canHandle{};
  shared_ptr<GetAssistantCapabilityResponseBodyCapabilityAssessment> capabilityAssessment{};
  shared_ptr<string> requestId{};

  GetAssistantCapabilityResponseBody() {}

  explicit GetAssistantCapabilityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assistantDescription) {
      res["assistantDescription"] = boost::any(*assistantDescription);
    }
    if (canHandle) {
      res["canHandle"] = boost::any(*canHandle);
    }
    if (capabilityAssessment) {
      res["capabilityAssessment"] = capabilityAssessment ? boost::any(capabilityAssessment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assistantDescription") != m.end() && !m["assistantDescription"].empty()) {
      assistantDescription = make_shared<string>(boost::any_cast<string>(m["assistantDescription"]));
    }
    if (m.find("canHandle") != m.end() && !m["canHandle"].empty()) {
      canHandle = make_shared<bool>(boost::any_cast<bool>(m["canHandle"]));
    }
    if (m.find("capabilityAssessment") != m.end() && !m["capabilityAssessment"].empty()) {
      if (typeid(map<string, boost::any>) == m["capabilityAssessment"].type()) {
        GetAssistantCapabilityResponseBodyCapabilityAssessment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["capabilityAssessment"]));
        capabilityAssessment = make_shared<GetAssistantCapabilityResponseBodyCapabilityAssessment>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetAssistantCapabilityResponseBody() = default;
};
class GetAssistantCapabilityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAssistantCapabilityResponseBody> body{};

  GetAssistantCapabilityResponse() {}

  explicit GetAssistantCapabilityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAssistantCapabilityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAssistantCapabilityResponseBody>(model1);
      }
    }
  }


  virtual ~GetAssistantCapabilityResponse() = default;
};
class GetConversaionSpaceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetConversaionSpaceHeadersAccountContext() {}

  explicit GetConversaionSpaceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetConversaionSpaceHeadersAccountContext() = default;
};
class GetConversaionSpaceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetConversaionSpaceHeadersAccountContext> accountContext{};

  GetConversaionSpaceHeaders() {}

  explicit GetConversaionSpaceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetConversaionSpaceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetConversaionSpaceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetConversaionSpaceHeaders() = default;
};
class GetConversaionSpaceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetConversaionSpaceShrinkHeaders() {}

  explicit GetConversaionSpaceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetConversaionSpaceShrinkHeaders() = default;
};
class GetConversaionSpaceRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetConversaionSpaceRequestTenantContext() {}

  explicit GetConversaionSpaceRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetConversaionSpaceRequestTenantContext() = default;
};
class GetConversaionSpaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> openConversationId{};
  shared_ptr<GetConversaionSpaceRequestTenantContext> tenantContext{};

  GetConversaionSpaceRequest() {}

  explicit GetConversaionSpaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openConversationId) {
      res["OpenConversationId"] = boost::any(*openConversationId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpenConversationId") != m.end() && !m["OpenConversationId"].empty()) {
      openConversationId = make_shared<string>(boost::any_cast<string>(m["OpenConversationId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetConversaionSpaceRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetConversaionSpaceRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetConversaionSpaceRequest() = default;
};
class GetConversaionSpaceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> openConversationId{};
  shared_ptr<string> tenantContextShrink{};

  GetConversaionSpaceShrinkRequest() {}

  explicit GetConversaionSpaceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openConversationId) {
      res["OpenConversationId"] = boost::any(*openConversationId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpenConversationId") != m.end() && !m["OpenConversationId"].empty()) {
      openConversationId = make_shared<string>(boost::any_cast<string>(m["OpenConversationId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetConversaionSpaceShrinkRequest() = default;
};
class GetConversaionSpaceResponseBodySpace : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> spaceId{};

  GetConversaionSpaceResponseBodySpace() {}

  explicit GetConversaionSpaceResponseBodySpace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
  }


  virtual ~GetConversaionSpaceResponseBodySpace() = default;
};
class GetConversaionSpaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetConversaionSpaceResponseBodySpace> space{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetConversaionSpaceResponseBody() {}

  explicit GetConversaionSpaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (space) {
      res["space"] = space ? boost::any(space->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("space") != m.end() && !m["space"].empty()) {
      if (typeid(map<string, boost::any>) == m["space"].type()) {
        GetConversaionSpaceResponseBodySpace model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["space"]));
        space = make_shared<GetConversaionSpaceResponseBodySpace>(model1);
      }
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetConversaionSpaceResponseBody() = default;
};
class GetConversaionSpaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetConversaionSpaceResponseBody> body{};

  GetConversaionSpaceResponse() {}

  explicit GetConversaionSpaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetConversaionSpaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetConversaionSpaceResponseBody>(model1);
      }
    }
  }


  virtual ~GetConversaionSpaceResponse() = default;
};
class GetCorpAccomplishmentTasksHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetCorpAccomplishmentTasksHeadersAccountContext() {}

  explicit GetCorpAccomplishmentTasksHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetCorpAccomplishmentTasksHeadersAccountContext() = default;
};
class GetCorpAccomplishmentTasksHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetCorpAccomplishmentTasksHeadersAccountContext> accountContext{};

  GetCorpAccomplishmentTasksHeaders() {}

  explicit GetCorpAccomplishmentTasksHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetCorpAccomplishmentTasksHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetCorpAccomplishmentTasksHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetCorpAccomplishmentTasksHeaders() = default;
};
class GetCorpAccomplishmentTasksShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetCorpAccomplishmentTasksShrinkHeaders() {}

  explicit GetCorpAccomplishmentTasksShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetCorpAccomplishmentTasksShrinkHeaders() = default;
};
class GetCorpAccomplishmentTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> appTypes{};
  shared_ptr<string> corpId{};
  shared_ptr<long> createFromTimeGMT{};
  shared_ptr<long> createToTimeGMT{};
  shared_ptr<string> keyword{};
  shared_ptr<string> language{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> processCodes{};
  shared_ptr<string> token{};

  GetCorpAccomplishmentTasksRequest() {}

  explicit GetCorpAccomplishmentTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appTypes) {
      res["AppTypes"] = boost::any(*appTypes);
    }
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (createFromTimeGMT) {
      res["CreateFromTimeGMT"] = boost::any(*createFromTimeGMT);
    }
    if (createToTimeGMT) {
      res["CreateToTimeGMT"] = boost::any(*createToTimeGMT);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (processCodes) {
      res["ProcessCodes"] = boost::any(*processCodes);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppTypes") != m.end() && !m["AppTypes"].empty()) {
      appTypes = make_shared<string>(boost::any_cast<string>(m["AppTypes"]));
    }
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("CreateFromTimeGMT") != m.end() && !m["CreateFromTimeGMT"].empty()) {
      createFromTimeGMT = make_shared<long>(boost::any_cast<long>(m["CreateFromTimeGMT"]));
    }
    if (m.find("CreateToTimeGMT") != m.end() && !m["CreateToTimeGMT"].empty()) {
      createToTimeGMT = make_shared<long>(boost::any_cast<long>(m["CreateToTimeGMT"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProcessCodes") != m.end() && !m["ProcessCodes"].empty()) {
      processCodes = make_shared<string>(boost::any_cast<string>(m["ProcessCodes"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~GetCorpAccomplishmentTasksRequest() = default;
};
class GetCorpAccomplishmentTasksResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> activeTimeGMT{};
  shared_ptr<string> actualActionerId{};
  shared_ptr<string> appType{};
  shared_ptr<string> createTimeGMT{};
  shared_ptr<string> finishTimeGMT{};
  shared_ptr<string> originatorEmail{};
  shared_ptr<string> originatorId{};
  shared_ptr<string> originatorName{};
  shared_ptr<string> originatorNameInEnglish{};
  shared_ptr<string> originatorNickName{};
  shared_ptr<string> originatorNickNameInEnglish{};
  shared_ptr<string> originatorPhoto{};
  shared_ptr<string> outResult{};
  shared_ptr<string> outResultName{};
  shared_ptr<string> processInstanceId{};
  shared_ptr<string> title{};

  GetCorpAccomplishmentTasksResponseBodyData() {}

  explicit GetCorpAccomplishmentTasksResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeTimeGMT) {
      res["ActiveTimeGMT"] = boost::any(*activeTimeGMT);
    }
    if (actualActionerId) {
      res["ActualActionerId"] = boost::any(*actualActionerId);
    }
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (createTimeGMT) {
      res["CreateTimeGMT"] = boost::any(*createTimeGMT);
    }
    if (finishTimeGMT) {
      res["FinishTimeGMT"] = boost::any(*finishTimeGMT);
    }
    if (originatorEmail) {
      res["OriginatorEmail"] = boost::any(*originatorEmail);
    }
    if (originatorId) {
      res["OriginatorId"] = boost::any(*originatorId);
    }
    if (originatorName) {
      res["OriginatorName"] = boost::any(*originatorName);
    }
    if (originatorNameInEnglish) {
      res["OriginatorNameInEnglish"] = boost::any(*originatorNameInEnglish);
    }
    if (originatorNickName) {
      res["OriginatorNickName"] = boost::any(*originatorNickName);
    }
    if (originatorNickNameInEnglish) {
      res["OriginatorNickNameInEnglish"] = boost::any(*originatorNickNameInEnglish);
    }
    if (originatorPhoto) {
      res["OriginatorPhoto"] = boost::any(*originatorPhoto);
    }
    if (outResult) {
      res["OutResult"] = boost::any(*outResult);
    }
    if (outResultName) {
      res["OutResultName"] = boost::any(*outResultName);
    }
    if (processInstanceId) {
      res["ProcessInstanceId"] = boost::any(*processInstanceId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveTimeGMT") != m.end() && !m["ActiveTimeGMT"].empty()) {
      activeTimeGMT = make_shared<string>(boost::any_cast<string>(m["ActiveTimeGMT"]));
    }
    if (m.find("ActualActionerId") != m.end() && !m["ActualActionerId"].empty()) {
      actualActionerId = make_shared<string>(boost::any_cast<string>(m["ActualActionerId"]));
    }
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("CreateTimeGMT") != m.end() && !m["CreateTimeGMT"].empty()) {
      createTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateTimeGMT"]));
    }
    if (m.find("FinishTimeGMT") != m.end() && !m["FinishTimeGMT"].empty()) {
      finishTimeGMT = make_shared<string>(boost::any_cast<string>(m["FinishTimeGMT"]));
    }
    if (m.find("OriginatorEmail") != m.end() && !m["OriginatorEmail"].empty()) {
      originatorEmail = make_shared<string>(boost::any_cast<string>(m["OriginatorEmail"]));
    }
    if (m.find("OriginatorId") != m.end() && !m["OriginatorId"].empty()) {
      originatorId = make_shared<string>(boost::any_cast<string>(m["OriginatorId"]));
    }
    if (m.find("OriginatorName") != m.end() && !m["OriginatorName"].empty()) {
      originatorName = make_shared<string>(boost::any_cast<string>(m["OriginatorName"]));
    }
    if (m.find("OriginatorNameInEnglish") != m.end() && !m["OriginatorNameInEnglish"].empty()) {
      originatorNameInEnglish = make_shared<string>(boost::any_cast<string>(m["OriginatorNameInEnglish"]));
    }
    if (m.find("OriginatorNickName") != m.end() && !m["OriginatorNickName"].empty()) {
      originatorNickName = make_shared<string>(boost::any_cast<string>(m["OriginatorNickName"]));
    }
    if (m.find("OriginatorNickNameInEnglish") != m.end() && !m["OriginatorNickNameInEnglish"].empty()) {
      originatorNickNameInEnglish = make_shared<string>(boost::any_cast<string>(m["OriginatorNickNameInEnglish"]));
    }
    if (m.find("OriginatorPhoto") != m.end() && !m["OriginatorPhoto"].empty()) {
      originatorPhoto = make_shared<string>(boost::any_cast<string>(m["OriginatorPhoto"]));
    }
    if (m.find("OutResult") != m.end() && !m["OutResult"].empty()) {
      outResult = make_shared<string>(boost::any_cast<string>(m["OutResult"]));
    }
    if (m.find("OutResultName") != m.end() && !m["OutResultName"].empty()) {
      outResultName = make_shared<string>(boost::any_cast<string>(m["OutResultName"]));
    }
    if (m.find("ProcessInstanceId") != m.end() && !m["ProcessInstanceId"].empty()) {
      processInstanceId = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GetCorpAccomplishmentTasksResponseBodyData() = default;
};
class GetCorpAccomplishmentTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetCorpAccomplishmentTasksResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetCorpAccomplishmentTasksResponseBody() {}

  explicit GetCorpAccomplishmentTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<GetCorpAccomplishmentTasksResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCorpAccomplishmentTasksResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetCorpAccomplishmentTasksResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetCorpAccomplishmentTasksResponseBody() = default;
};
class GetCorpAccomplishmentTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCorpAccomplishmentTasksResponseBody> body{};

  GetCorpAccomplishmentTasksResponse() {}

  explicit GetCorpAccomplishmentTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCorpAccomplishmentTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCorpAccomplishmentTasksResponseBody>(model1);
      }
    }
  }


  virtual ~GetCorpAccomplishmentTasksResponse() = default;
};
class GetCorpTasksHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetCorpTasksHeadersAccountContext() {}

  explicit GetCorpTasksHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetCorpTasksHeadersAccountContext() = default;
};
class GetCorpTasksHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetCorpTasksHeadersAccountContext> accountContext{};

  GetCorpTasksHeaders() {}

  explicit GetCorpTasksHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetCorpTasksHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetCorpTasksHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetCorpTasksHeaders() = default;
};
class GetCorpTasksShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetCorpTasksShrinkHeaders() {}

  explicit GetCorpTasksShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetCorpTasksShrinkHeaders() = default;
};
class GetCorpTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> appTypes{};
  shared_ptr<string> corpId{};
  shared_ptr<long> createFromTimeGMT{};
  shared_ptr<long> createToTimeGMT{};
  shared_ptr<string> keyword{};
  shared_ptr<string> language{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> processCodes{};
  shared_ptr<string> token{};

  GetCorpTasksRequest() {}

  explicit GetCorpTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appTypes) {
      res["AppTypes"] = boost::any(*appTypes);
    }
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (createFromTimeGMT) {
      res["CreateFromTimeGMT"] = boost::any(*createFromTimeGMT);
    }
    if (createToTimeGMT) {
      res["CreateToTimeGMT"] = boost::any(*createToTimeGMT);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (processCodes) {
      res["ProcessCodes"] = boost::any(*processCodes);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppTypes") != m.end() && !m["AppTypes"].empty()) {
      appTypes = make_shared<string>(boost::any_cast<string>(m["AppTypes"]));
    }
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("CreateFromTimeGMT") != m.end() && !m["CreateFromTimeGMT"].empty()) {
      createFromTimeGMT = make_shared<long>(boost::any_cast<long>(m["CreateFromTimeGMT"]));
    }
    if (m.find("CreateToTimeGMT") != m.end() && !m["CreateToTimeGMT"].empty()) {
      createToTimeGMT = make_shared<long>(boost::any_cast<long>(m["CreateToTimeGMT"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProcessCodes") != m.end() && !m["ProcessCodes"].empty()) {
      processCodes = make_shared<string>(boost::any_cast<string>(m["ProcessCodes"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~GetCorpTasksRequest() = default;
};
class GetCorpTasksResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> activeTimeGMT{};
  shared_ptr<string> actualActionerId{};
  shared_ptr<string> appType{};
  shared_ptr<string> createTimeGMT{};
  shared_ptr<string> finishTimeGMT{};
  shared_ptr<string> originatorEmail{};
  shared_ptr<string> originatorId{};
  shared_ptr<string> originatorName{};
  shared_ptr<string> originatorNameInEnglish{};
  shared_ptr<string> originatorNickName{};
  shared_ptr<string> originatorNickNameEn{};
  shared_ptr<string> originatorNickNameInEnglish{};
  shared_ptr<string> originatorPhoto{};
  shared_ptr<string> outResult{};
  shared_ptr<string> outResultName{};
  shared_ptr<string> processInstanceId{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskType{};
  shared_ptr<string> title{};
  shared_ptr<string> titleInEnglish{};

  GetCorpTasksResponseBodyData() {}

  explicit GetCorpTasksResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeTimeGMT) {
      res["ActiveTimeGMT"] = boost::any(*activeTimeGMT);
    }
    if (actualActionerId) {
      res["ActualActionerId"] = boost::any(*actualActionerId);
    }
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (createTimeGMT) {
      res["CreateTimeGMT"] = boost::any(*createTimeGMT);
    }
    if (finishTimeGMT) {
      res["FinishTimeGMT"] = boost::any(*finishTimeGMT);
    }
    if (originatorEmail) {
      res["OriginatorEmail"] = boost::any(*originatorEmail);
    }
    if (originatorId) {
      res["OriginatorId"] = boost::any(*originatorId);
    }
    if (originatorName) {
      res["OriginatorName"] = boost::any(*originatorName);
    }
    if (originatorNameInEnglish) {
      res["OriginatorNameInEnglish"] = boost::any(*originatorNameInEnglish);
    }
    if (originatorNickName) {
      res["OriginatorNickName"] = boost::any(*originatorNickName);
    }
    if (originatorNickNameEn) {
      res["OriginatorNickNameEn"] = boost::any(*originatorNickNameEn);
    }
    if (originatorNickNameInEnglish) {
      res["OriginatorNickNameInEnglish"] = boost::any(*originatorNickNameInEnglish);
    }
    if (originatorPhoto) {
      res["OriginatorPhoto"] = boost::any(*originatorPhoto);
    }
    if (outResult) {
      res["OutResult"] = boost::any(*outResult);
    }
    if (outResultName) {
      res["OutResultName"] = boost::any(*outResultName);
    }
    if (processInstanceId) {
      res["ProcessInstanceId"] = boost::any(*processInstanceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (titleInEnglish) {
      res["TitleInEnglish"] = boost::any(*titleInEnglish);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveTimeGMT") != m.end() && !m["ActiveTimeGMT"].empty()) {
      activeTimeGMT = make_shared<string>(boost::any_cast<string>(m["ActiveTimeGMT"]));
    }
    if (m.find("ActualActionerId") != m.end() && !m["ActualActionerId"].empty()) {
      actualActionerId = make_shared<string>(boost::any_cast<string>(m["ActualActionerId"]));
    }
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("CreateTimeGMT") != m.end() && !m["CreateTimeGMT"].empty()) {
      createTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateTimeGMT"]));
    }
    if (m.find("FinishTimeGMT") != m.end() && !m["FinishTimeGMT"].empty()) {
      finishTimeGMT = make_shared<string>(boost::any_cast<string>(m["FinishTimeGMT"]));
    }
    if (m.find("OriginatorEmail") != m.end() && !m["OriginatorEmail"].empty()) {
      originatorEmail = make_shared<string>(boost::any_cast<string>(m["OriginatorEmail"]));
    }
    if (m.find("OriginatorId") != m.end() && !m["OriginatorId"].empty()) {
      originatorId = make_shared<string>(boost::any_cast<string>(m["OriginatorId"]));
    }
    if (m.find("OriginatorName") != m.end() && !m["OriginatorName"].empty()) {
      originatorName = make_shared<string>(boost::any_cast<string>(m["OriginatorName"]));
    }
    if (m.find("OriginatorNameInEnglish") != m.end() && !m["OriginatorNameInEnglish"].empty()) {
      originatorNameInEnglish = make_shared<string>(boost::any_cast<string>(m["OriginatorNameInEnglish"]));
    }
    if (m.find("OriginatorNickName") != m.end() && !m["OriginatorNickName"].empty()) {
      originatorNickName = make_shared<string>(boost::any_cast<string>(m["OriginatorNickName"]));
    }
    if (m.find("OriginatorNickNameEn") != m.end() && !m["OriginatorNickNameEn"].empty()) {
      originatorNickNameEn = make_shared<string>(boost::any_cast<string>(m["OriginatorNickNameEn"]));
    }
    if (m.find("OriginatorNickNameInEnglish") != m.end() && !m["OriginatorNickNameInEnglish"].empty()) {
      originatorNickNameInEnglish = make_shared<string>(boost::any_cast<string>(m["OriginatorNickNameInEnglish"]));
    }
    if (m.find("OriginatorPhoto") != m.end() && !m["OriginatorPhoto"].empty()) {
      originatorPhoto = make_shared<string>(boost::any_cast<string>(m["OriginatorPhoto"]));
    }
    if (m.find("OutResult") != m.end() && !m["OutResult"].empty()) {
      outResult = make_shared<string>(boost::any_cast<string>(m["OutResult"]));
    }
    if (m.find("OutResultName") != m.end() && !m["OutResultName"].empty()) {
      outResultName = make_shared<string>(boost::any_cast<string>(m["OutResultName"]));
    }
    if (m.find("ProcessInstanceId") != m.end() && !m["ProcessInstanceId"].empty()) {
      processInstanceId = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("TitleInEnglish") != m.end() && !m["TitleInEnglish"].empty()) {
      titleInEnglish = make_shared<string>(boost::any_cast<string>(m["TitleInEnglish"]));
    }
  }


  virtual ~GetCorpTasksResponseBodyData() = default;
};
class GetCorpTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetCorpTasksResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetCorpTasksResponseBody() {}

  explicit GetCorpTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<GetCorpTasksResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCorpTasksResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetCorpTasksResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetCorpTasksResponseBody() = default;
};
class GetCorpTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCorpTasksResponseBody> body{};

  GetCorpTasksResponse() {}

  explicit GetCorpTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCorpTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCorpTasksResponseBody>(model1);
      }
    }
  }


  virtual ~GetCorpTasksResponse() = default;
};
class GetDeptNoHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetDeptNoHeadersAccountContext() {}

  explicit GetDeptNoHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetDeptNoHeadersAccountContext() = default;
};
class GetDeptNoHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetDeptNoHeadersAccountContext> accountContext{};

  GetDeptNoHeaders() {}

  explicit GetDeptNoHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetDeptNoHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetDeptNoHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetDeptNoHeaders() = default;
};
class GetDeptNoShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetDeptNoShrinkHeaders() {}

  explicit GetDeptNoShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetDeptNoShrinkHeaders() = default;
};
class GetDeptNoRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetDeptNoRequestTenantContext() {}

  explicit GetDeptNoRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetDeptNoRequestTenantContext() = default;
};
class GetDeptNoRequest : public Darabonba::Model {
public:
  shared_ptr<GetDeptNoRequestTenantContext> tenantContext{};
  shared_ptr<string> deptId{};

  GetDeptNoRequest() {}

  explicit GetDeptNoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deptId) {
      res["deptId"] = boost::any(*deptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetDeptNoRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetDeptNoRequestTenantContext>(model1);
      }
    }
    if (m.find("deptId") != m.end() && !m["deptId"].empty()) {
      deptId = make_shared<string>(boost::any_cast<string>(m["deptId"]));
    }
  }


  virtual ~GetDeptNoRequest() = default;
};
class GetDeptNoShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> deptId{};

  GetDeptNoShrinkRequest() {}

  explicit GetDeptNoShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (deptId) {
      res["deptId"] = boost::any(*deptId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("deptId") != m.end() && !m["deptId"].empty()) {
      deptId = make_shared<string>(boost::any_cast<string>(m["deptId"]));
    }
  }


  virtual ~GetDeptNoShrinkRequest() = default;
};
class GetDeptNoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> deptNo{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetDeptNoResponseBody() {}

  explicit GetDeptNoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deptNo) {
      res["deptNo"] = boost::any(*deptNo);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("deptNo") != m.end() && !m["deptNo"].empty()) {
      deptNo = make_shared<string>(boost::any_cast<string>(m["deptNo"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetDeptNoResponseBody() = default;
};
class GetDeptNoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDeptNoResponseBody> body{};

  GetDeptNoResponse() {}

  explicit GetDeptNoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDeptNoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDeptNoResponseBody>(model1);
      }
    }
  }


  virtual ~GetDeptNoResponse() = default;
};
class GetDocContentHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetDocContentHeadersAccountContext() {}

  explicit GetDocContentHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetDocContentHeadersAccountContext() = default;
};
class GetDocContentHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetDocContentHeadersAccountContext> accountContext{};

  GetDocContentHeaders() {}

  explicit GetDocContentHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetDocContentHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetDocContentHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetDocContentHeaders() = default;
};
class GetDocContentShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetDocContentShrinkHeaders() {}

  explicit GetDocContentShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetDocContentShrinkHeaders() = default;
};
class GetDocContentRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetDocContentRequestTenantContext() {}

  explicit GetDocContentRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetDocContentRequestTenantContext() = default;
};
class GetDocContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryUuid{};
  shared_ptr<string> targetFormat{};
  shared_ptr<GetDocContentRequestTenantContext> tenantContext{};
  shared_ptr<string> userToken{};

  GetDocContentRequest() {}

  explicit GetDocContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryUuid) {
      res["DentryUuid"] = boost::any(*dentryUuid);
    }
    if (targetFormat) {
      res["TargetFormat"] = boost::any(*targetFormat);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userToken) {
      res["userToken"] = boost::any(*userToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryUuid") != m.end() && !m["DentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["DentryUuid"]));
    }
    if (m.find("TargetFormat") != m.end() && !m["TargetFormat"].empty()) {
      targetFormat = make_shared<string>(boost::any_cast<string>(m["TargetFormat"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetDocContentRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetDocContentRequestTenantContext>(model1);
      }
    }
    if (m.find("userToken") != m.end() && !m["userToken"].empty()) {
      userToken = make_shared<string>(boost::any_cast<string>(m["userToken"]));
    }
  }


  virtual ~GetDocContentRequest() = default;
};
class GetDocContentShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryUuid{};
  shared_ptr<string> targetFormat{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> userToken{};

  GetDocContentShrinkRequest() {}

  explicit GetDocContentShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryUuid) {
      res["DentryUuid"] = boost::any(*dentryUuid);
    }
    if (targetFormat) {
      res["TargetFormat"] = boost::any(*targetFormat);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (userToken) {
      res["userToken"] = boost::any(*userToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryUuid") != m.end() && !m["DentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["DentryUuid"]));
    }
    if (m.find("TargetFormat") != m.end() && !m["TargetFormat"].empty()) {
      targetFormat = make_shared<string>(boost::any_cast<string>(m["TargetFormat"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("userToken") != m.end() && !m["userToken"].empty()) {
      userToken = make_shared<string>(boost::any_cast<string>(m["userToken"]));
    }
  }


  virtual ~GetDocContentShrinkRequest() = default;
};
class GetDocContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> taskId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetDocContentResponseBody() {}

  explicit GetDocContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["taskId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetDocContentResponseBody() = default;
};
class GetDocContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDocContentResponseBody> body{};

  GetDocContentResponse() {}

  explicit GetDocContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDocContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDocContentResponseBody>(model1);
      }
    }
  }


  virtual ~GetDocContentResponse() = default;
};
class GetDocContentTakIdHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetDocContentTakIdHeadersAccountContext() {}

  explicit GetDocContentTakIdHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetDocContentTakIdHeadersAccountContext() = default;
};
class GetDocContentTakIdHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetDocContentTakIdHeadersAccountContext> accountContext{};

  GetDocContentTakIdHeaders() {}

  explicit GetDocContentTakIdHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetDocContentTakIdHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetDocContentTakIdHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetDocContentTakIdHeaders() = default;
};
class GetDocContentTakIdShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetDocContentTakIdShrinkHeaders() {}

  explicit GetDocContentTakIdShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetDocContentTakIdShrinkHeaders() = default;
};
class GetDocContentTakIdRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetDocContentTakIdRequestTenantContext() {}

  explicit GetDocContentTakIdRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetDocContentTakIdRequestTenantContext() = default;
};
class GetDocContentTakIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryUuid{};
  shared_ptr<bool> generateCp{};
  shared_ptr<string> targetFormat{};
  shared_ptr<GetDocContentTakIdRequestTenantContext> tenantContext{};

  GetDocContentTakIdRequest() {}

  explicit GetDocContentTakIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryUuid) {
      res["DentryUuid"] = boost::any(*dentryUuid);
    }
    if (generateCp) {
      res["GenerateCp"] = boost::any(*generateCp);
    }
    if (targetFormat) {
      res["TargetFormat"] = boost::any(*targetFormat);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryUuid") != m.end() && !m["DentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["DentryUuid"]));
    }
    if (m.find("GenerateCp") != m.end() && !m["GenerateCp"].empty()) {
      generateCp = make_shared<bool>(boost::any_cast<bool>(m["GenerateCp"]));
    }
    if (m.find("TargetFormat") != m.end() && !m["TargetFormat"].empty()) {
      targetFormat = make_shared<string>(boost::any_cast<string>(m["TargetFormat"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetDocContentTakIdRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetDocContentTakIdRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetDocContentTakIdRequest() = default;
};
class GetDocContentTakIdShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryUuid{};
  shared_ptr<bool> generateCp{};
  shared_ptr<string> targetFormat{};
  shared_ptr<string> tenantContextShrink{};

  GetDocContentTakIdShrinkRequest() {}

  explicit GetDocContentTakIdShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryUuid) {
      res["DentryUuid"] = boost::any(*dentryUuid);
    }
    if (generateCp) {
      res["GenerateCp"] = boost::any(*generateCp);
    }
    if (targetFormat) {
      res["TargetFormat"] = boost::any(*targetFormat);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryUuid") != m.end() && !m["DentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["DentryUuid"]));
    }
    if (m.find("GenerateCp") != m.end() && !m["GenerateCp"].empty()) {
      generateCp = make_shared<bool>(boost::any_cast<bool>(m["GenerateCp"]));
    }
    if (m.find("TargetFormat") != m.end() && !m["TargetFormat"].empty()) {
      targetFormat = make_shared<string>(boost::any_cast<string>(m["TargetFormat"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetDocContentTakIdShrinkRequest() = default;
};
class GetDocContentTakIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> taskId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetDocContentTakIdResponseBody() {}

  explicit GetDocContentTakIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["taskId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetDocContentTakIdResponseBody() = default;
};
class GetDocContentTakIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDocContentTakIdResponseBody> body{};

  GetDocContentTakIdResponse() {}

  explicit GetDocContentTakIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDocContentTakIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDocContentTakIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetDocContentTakIdResponse() = default;
};
class GetEventHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetEventHeadersAccountContext() {}

  explicit GetEventHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetEventHeadersAccountContext() = default;
};
class GetEventHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetEventHeadersAccountContext> accountContext{};

  GetEventHeaders() {}

  explicit GetEventHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetEventHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetEventHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetEventHeaders() = default;
};
class GetEventShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetEventShrinkHeaders() {}

  explicit GetEventShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetEventShrinkHeaders() = default;
};
class GetEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> calendarId{};
  shared_ptr<string> eventId{};
  shared_ptr<long> maxAttendees{};

  GetEventRequest() {}

  explicit GetEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (maxAttendees) {
      res["MaxAttendees"] = boost::any(*maxAttendees);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("MaxAttendees") != m.end() && !m["MaxAttendees"].empty()) {
      maxAttendees = make_shared<long>(boost::any_cast<long>(m["MaxAttendees"]));
    }
  }


  virtual ~GetEventRequest() = default;
};
class GetEventResponseBodyAttendees : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> id{};
  shared_ptr<bool> isOptional{};
  shared_ptr<string> responseStatus{};
  shared_ptr<bool> self{};

  GetEventResponseBodyAttendees() {}

  explicit GetEventResponseBodyAttendees(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isOptional) {
      res["IsOptional"] = boost::any(*isOptional);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (self) {
      res["Self"] = boost::any(*self);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IsOptional") != m.end() && !m["IsOptional"].empty()) {
      isOptional = make_shared<bool>(boost::any_cast<bool>(m["IsOptional"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("Self") != m.end() && !m["Self"].empty()) {
      self = make_shared<bool>(boost::any_cast<bool>(m["Self"]));
    }
  }


  virtual ~GetEventResponseBodyAttendees() = default;
};
class GetEventResponseBodyCategories : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};

  GetEventResponseBodyCategories() {}

  explicit GetEventResponseBodyCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
  }


  virtual ~GetEventResponseBodyCategories() = default;
};
class GetEventResponseBodyEnd : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  GetEventResponseBodyEnd() {}

  explicit GetEventResponseBodyEnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~GetEventResponseBodyEnd() = default;
};
class GetEventResponseBodyExtendedPropertiesSharedProperties : public Darabonba::Model {
public:
  shared_ptr<string> belongCorpId{};
  shared_ptr<string> sourceOpenCid{};

  GetEventResponseBodyExtendedPropertiesSharedProperties() {}

  explicit GetEventResponseBodyExtendedPropertiesSharedProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (belongCorpId) {
      res["BelongCorpId"] = boost::any(*belongCorpId);
    }
    if (sourceOpenCid) {
      res["SourceOpenCid"] = boost::any(*sourceOpenCid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BelongCorpId") != m.end() && !m["BelongCorpId"].empty()) {
      belongCorpId = make_shared<string>(boost::any_cast<string>(m["BelongCorpId"]));
    }
    if (m.find("SourceOpenCid") != m.end() && !m["SourceOpenCid"].empty()) {
      sourceOpenCid = make_shared<string>(boost::any_cast<string>(m["SourceOpenCid"]));
    }
  }


  virtual ~GetEventResponseBodyExtendedPropertiesSharedProperties() = default;
};
class GetEventResponseBodyExtendedProperties : public Darabonba::Model {
public:
  shared_ptr<GetEventResponseBodyExtendedPropertiesSharedProperties> sharedProperties{};

  GetEventResponseBodyExtendedProperties() {}

  explicit GetEventResponseBodyExtendedProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sharedProperties) {
      res["SharedProperties"] = sharedProperties ? boost::any(sharedProperties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SharedProperties") != m.end() && !m["SharedProperties"].empty()) {
      if (typeid(map<string, boost::any>) == m["SharedProperties"].type()) {
        GetEventResponseBodyExtendedPropertiesSharedProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SharedProperties"]));
        sharedProperties = make_shared<GetEventResponseBodyExtendedPropertiesSharedProperties>(model1);
      }
    }
  }


  virtual ~GetEventResponseBodyExtendedProperties() = default;
};
class GetEventResponseBodyLocation : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<vector<string>> meetingRooms{};

  GetEventResponseBodyLocation() {}

  explicit GetEventResponseBodyLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (meetingRooms) {
      res["MeetingRooms"] = boost::any(*meetingRooms);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("MeetingRooms") != m.end() && !m["MeetingRooms"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MeetingRooms"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MeetingRooms"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      meetingRooms = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetEventResponseBodyLocation() = default;
};
class GetEventResponseBodyMeetingRooms : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> responseStatus{};
  shared_ptr<string> roomId{};

  GetEventResponseBodyMeetingRooms() {}

  explicit GetEventResponseBodyMeetingRooms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
  }


  virtual ~GetEventResponseBodyMeetingRooms() = default;
};
class GetEventResponseBodyOnlineMeetingInfo : public Darabonba::Model {
public:
  shared_ptr<string> conferenceId{};
  shared_ptr<map<string, boost::any>> extraInfo{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  GetEventResponseBodyOnlineMeetingInfo() {}

  explicit GetEventResponseBodyOnlineMeetingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conferenceId) {
      res["ConferenceId"] = boost::any(*conferenceId);
    }
    if (extraInfo) {
      res["ExtraInfo"] = boost::any(*extraInfo);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConferenceId") != m.end() && !m["ConferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["ConferenceId"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetEventResponseBodyOnlineMeetingInfo() = default;
};
class GetEventResponseBodyOrganizer : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> id{};
  shared_ptr<string> responseStatus{};
  shared_ptr<bool> self{};

  GetEventResponseBodyOrganizer() {}

  explicit GetEventResponseBodyOrganizer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (self) {
      res["Self"] = boost::any(*self);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("Self") != m.end() && !m["Self"].empty()) {
      self = make_shared<bool>(boost::any_cast<bool>(m["Self"]));
    }
  }


  virtual ~GetEventResponseBodyOrganizer() = default;
};
class GetEventResponseBodyOriginStart : public Darabonba::Model {
public:
  shared_ptr<string> dateTime{};

  GetEventResponseBodyOriginStart() {}

  explicit GetEventResponseBodyOriginStart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
  }


  virtual ~GetEventResponseBodyOriginStart() = default;
};
class GetEventResponseBodyRecurrencePattern : public Darabonba::Model {
public:
  shared_ptr<long> dayOfMonth{};
  shared_ptr<string> daysOfWeek{};
  shared_ptr<string> index{};
  shared_ptr<long> interval{};
  shared_ptr<string> type{};

  GetEventResponseBodyRecurrencePattern() {}

  explicit GetEventResponseBodyRecurrencePattern(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dayOfMonth) {
      res["DayOfMonth"] = boost::any(*dayOfMonth);
    }
    if (daysOfWeek) {
      res["DaysOfWeek"] = boost::any(*daysOfWeek);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DayOfMonth") != m.end() && !m["DayOfMonth"].empty()) {
      dayOfMonth = make_shared<long>(boost::any_cast<long>(m["DayOfMonth"]));
    }
    if (m.find("DaysOfWeek") != m.end() && !m["DaysOfWeek"].empty()) {
      daysOfWeek = make_shared<string>(boost::any_cast<string>(m["DaysOfWeek"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetEventResponseBodyRecurrencePattern() = default;
};
class GetEventResponseBodyRecurrenceRange : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<long> numberOfOccurrences{};
  shared_ptr<string> type{};

  GetEventResponseBodyRecurrenceRange() {}

  explicit GetEventResponseBodyRecurrenceRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (numberOfOccurrences) {
      res["NumberOfOccurrences"] = boost::any(*numberOfOccurrences);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("NumberOfOccurrences") != m.end() && !m["NumberOfOccurrences"].empty()) {
      numberOfOccurrences = make_shared<long>(boost::any_cast<long>(m["NumberOfOccurrences"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetEventResponseBodyRecurrenceRange() = default;
};
class GetEventResponseBodyRecurrence : public Darabonba::Model {
public:
  shared_ptr<GetEventResponseBodyRecurrencePattern> pattern{};
  shared_ptr<GetEventResponseBodyRecurrenceRange> range{};

  GetEventResponseBodyRecurrence() {}

  explicit GetEventResponseBodyRecurrence(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pattern) {
      res["Pattern"] = pattern ? boost::any(pattern->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (range) {
      res["Range"] = range ? boost::any(range->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pattern"].type()) {
        GetEventResponseBodyRecurrencePattern model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pattern"]));
        pattern = make_shared<GetEventResponseBodyRecurrencePattern>(model1);
      }
    }
    if (m.find("Range") != m.end() && !m["Range"].empty()) {
      if (typeid(map<string, boost::any>) == m["Range"].type()) {
        GetEventResponseBodyRecurrenceRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Range"]));
        range = make_shared<GetEventResponseBodyRecurrenceRange>(model1);
      }
    }
  }


  virtual ~GetEventResponseBodyRecurrence() = default;
};
class GetEventResponseBodyReminders : public Darabonba::Model {
public:
  shared_ptr<string> method{};
  shared_ptr<string> minutes{};

  GetEventResponseBodyReminders() {}

  explicit GetEventResponseBodyReminders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (minutes) {
      res["Minutes"] = boost::any(*minutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Minutes") != m.end() && !m["Minutes"].empty()) {
      minutes = make_shared<string>(boost::any_cast<string>(m["Minutes"]));
    }
  }


  virtual ~GetEventResponseBodyReminders() = default;
};
class GetEventResponseBodyRichTextDescription : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  GetEventResponseBodyRichTextDescription() {}

  explicit GetEventResponseBodyRichTextDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~GetEventResponseBodyRichTextDescription() = default;
};
class GetEventResponseBodyStart : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  GetEventResponseBodyStart() {}

  explicit GetEventResponseBodyStart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~GetEventResponseBodyStart() = default;
};
class GetEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetEventResponseBodyAttendees>> attendees{};
  shared_ptr<vector<GetEventResponseBodyCategories>> categories{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<GetEventResponseBodyEnd> end{};
  shared_ptr<GetEventResponseBodyExtendedProperties> extendedProperties{};
  shared_ptr<string> id{};
  shared_ptr<bool> isAllDay{};
  shared_ptr<GetEventResponseBodyLocation> location{};
  shared_ptr<vector<GetEventResponseBodyMeetingRooms>> meetingRooms{};
  shared_ptr<GetEventResponseBodyOnlineMeetingInfo> onlineMeetingInfo{};
  shared_ptr<GetEventResponseBodyOrganizer> organizer{};
  shared_ptr<GetEventResponseBodyOriginStart> originStart{};
  shared_ptr<GetEventResponseBodyRecurrence> recurrence{};
  shared_ptr<vector<GetEventResponseBodyReminders>> reminders{};
  shared_ptr<string> requestId{};
  shared_ptr<GetEventResponseBodyRichTextDescription> richTextDescription{};
  shared_ptr<string> seriesMasterId{};
  shared_ptr<GetEventResponseBodyStart> start{};
  shared_ptr<string> status{};
  shared_ptr<string> summary{};
  shared_ptr<string> updateTime{};

  GetEventResponseBody() {}

  explicit GetEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendees) {
      vector<boost::any> temp1;
      for(auto item1:*attendees){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["attendees"] = boost::any(temp1);
    }
    if (categories) {
      vector<boost::any> temp1;
      for(auto item1:*categories){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["categories"] = boost::any(temp1);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (end) {
      res["end"] = end ? boost::any(end->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extendedProperties) {
      res["extendedProperties"] = extendedProperties ? boost::any(extendedProperties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isAllDay) {
      res["isAllDay"] = boost::any(*isAllDay);
    }
    if (location) {
      res["location"] = location ? boost::any(location->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (meetingRooms) {
      vector<boost::any> temp1;
      for(auto item1:*meetingRooms){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["meetingRooms"] = boost::any(temp1);
    }
    if (onlineMeetingInfo) {
      res["onlineMeetingInfo"] = onlineMeetingInfo ? boost::any(onlineMeetingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (organizer) {
      res["organizer"] = organizer ? boost::any(organizer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (originStart) {
      res["originStart"] = originStart ? boost::any(originStart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recurrence) {
      res["recurrence"] = recurrence ? boost::any(recurrence->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reminders) {
      vector<boost::any> temp1;
      for(auto item1:*reminders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["reminders"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (richTextDescription) {
      res["richTextDescription"] = richTextDescription ? boost::any(richTextDescription->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (seriesMasterId) {
      res["seriesMasterId"] = boost::any(*seriesMasterId);
    }
    if (start) {
      res["start"] = start ? boost::any(start->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (summary) {
      res["summary"] = boost::any(*summary);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("attendees") != m.end() && !m["attendees"].empty()) {
      if (typeid(vector<boost::any>) == m["attendees"].type()) {
        vector<GetEventResponseBodyAttendees> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["attendees"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEventResponseBodyAttendees model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attendees = make_shared<vector<GetEventResponseBodyAttendees>>(expect1);
      }
    }
    if (m.find("categories") != m.end() && !m["categories"].empty()) {
      if (typeid(vector<boost::any>) == m["categories"].type()) {
        vector<GetEventResponseBodyCategories> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["categories"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEventResponseBodyCategories model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        categories = make_shared<vector<GetEventResponseBodyCategories>>(expect1);
      }
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("end") != m.end() && !m["end"].empty()) {
      if (typeid(map<string, boost::any>) == m["end"].type()) {
        GetEventResponseBodyEnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["end"]));
        end = make_shared<GetEventResponseBodyEnd>(model1);
      }
    }
    if (m.find("extendedProperties") != m.end() && !m["extendedProperties"].empty()) {
      if (typeid(map<string, boost::any>) == m["extendedProperties"].type()) {
        GetEventResponseBodyExtendedProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["extendedProperties"]));
        extendedProperties = make_shared<GetEventResponseBodyExtendedProperties>(model1);
      }
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("isAllDay") != m.end() && !m["isAllDay"].empty()) {
      isAllDay = make_shared<bool>(boost::any_cast<bool>(m["isAllDay"]));
    }
    if (m.find("location") != m.end() && !m["location"].empty()) {
      if (typeid(map<string, boost::any>) == m["location"].type()) {
        GetEventResponseBodyLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["location"]));
        location = make_shared<GetEventResponseBodyLocation>(model1);
      }
    }
    if (m.find("meetingRooms") != m.end() && !m["meetingRooms"].empty()) {
      if (typeid(vector<boost::any>) == m["meetingRooms"].type()) {
        vector<GetEventResponseBodyMeetingRooms> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["meetingRooms"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEventResponseBodyMeetingRooms model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        meetingRooms = make_shared<vector<GetEventResponseBodyMeetingRooms>>(expect1);
      }
    }
    if (m.find("onlineMeetingInfo") != m.end() && !m["onlineMeetingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["onlineMeetingInfo"].type()) {
        GetEventResponseBodyOnlineMeetingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["onlineMeetingInfo"]));
        onlineMeetingInfo = make_shared<GetEventResponseBodyOnlineMeetingInfo>(model1);
      }
    }
    if (m.find("organizer") != m.end() && !m["organizer"].empty()) {
      if (typeid(map<string, boost::any>) == m["organizer"].type()) {
        GetEventResponseBodyOrganizer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["organizer"]));
        organizer = make_shared<GetEventResponseBodyOrganizer>(model1);
      }
    }
    if (m.find("originStart") != m.end() && !m["originStart"].empty()) {
      if (typeid(map<string, boost::any>) == m["originStart"].type()) {
        GetEventResponseBodyOriginStart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["originStart"]));
        originStart = make_shared<GetEventResponseBodyOriginStart>(model1);
      }
    }
    if (m.find("recurrence") != m.end() && !m["recurrence"].empty()) {
      if (typeid(map<string, boost::any>) == m["recurrence"].type()) {
        GetEventResponseBodyRecurrence model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["recurrence"]));
        recurrence = make_shared<GetEventResponseBodyRecurrence>(model1);
      }
    }
    if (m.find("reminders") != m.end() && !m["reminders"].empty()) {
      if (typeid(vector<boost::any>) == m["reminders"].type()) {
        vector<GetEventResponseBodyReminders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["reminders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEventResponseBodyReminders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reminders = make_shared<vector<GetEventResponseBodyReminders>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("richTextDescription") != m.end() && !m["richTextDescription"].empty()) {
      if (typeid(map<string, boost::any>) == m["richTextDescription"].type()) {
        GetEventResponseBodyRichTextDescription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["richTextDescription"]));
        richTextDescription = make_shared<GetEventResponseBodyRichTextDescription>(model1);
      }
    }
    if (m.find("seriesMasterId") != m.end() && !m["seriesMasterId"].empty()) {
      seriesMasterId = make_shared<string>(boost::any_cast<string>(m["seriesMasterId"]));
    }
    if (m.find("start") != m.end() && !m["start"].empty()) {
      if (typeid(map<string, boost::any>) == m["start"].type()) {
        GetEventResponseBodyStart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["start"]));
        start = make_shared<GetEventResponseBodyStart>(model1);
      }
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("summary") != m.end() && !m["summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["summary"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["updateTime"]));
    }
  }


  virtual ~GetEventResponseBody() = default;
};
class GetEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEventResponseBody> body{};

  GetEventResponse() {}

  explicit GetEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEventResponseBody>(model1);
      }
    }
  }


  virtual ~GetEventResponse() = default;
};
class GetFieldDefByUuidHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetFieldDefByUuidHeadersAccountContext() {}

  explicit GetFieldDefByUuidHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetFieldDefByUuidHeadersAccountContext() = default;
};
class GetFieldDefByUuidHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetFieldDefByUuidHeadersAccountContext> accountContext{};

  GetFieldDefByUuidHeaders() {}

  explicit GetFieldDefByUuidHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetFieldDefByUuidHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetFieldDefByUuidHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetFieldDefByUuidHeaders() = default;
};
class GetFieldDefByUuidShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetFieldDefByUuidShrinkHeaders() {}

  explicit GetFieldDefByUuidShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetFieldDefByUuidShrinkHeaders() = default;
};
class GetFieldDefByUuidRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> formUuid{};
  shared_ptr<string> systemToken{};

  GetFieldDefByUuidRequest() {}

  explicit GetFieldDefByUuidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~GetFieldDefByUuidRequest() = default;
};
class GetFieldDefByUuidResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> behavior{};
  shared_ptr<string> children{};
  shared_ptr<string> componentName{};
  shared_ptr<string> fieldId{};
  shared_ptr<boost::any> label{};
  shared_ptr<boost::any> props{};
  shared_ptr<bool> success{};

  GetFieldDefByUuidResponseBodyResult() {}

  explicit GetFieldDefByUuidResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (behavior) {
      res["Behavior"] = boost::any(*behavior);
    }
    if (children) {
      res["Children"] = boost::any(*children);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (fieldId) {
      res["FieldId"] = boost::any(*fieldId);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (props) {
      res["Props"] = boost::any(*props);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Behavior") != m.end() && !m["Behavior"].empty()) {
      behavior = make_shared<string>(boost::any_cast<string>(m["Behavior"]));
    }
    if (m.find("Children") != m.end() && !m["Children"].empty()) {
      children = make_shared<string>(boost::any_cast<string>(m["Children"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("FieldId") != m.end() && !m["FieldId"].empty()) {
      fieldId = make_shared<string>(boost::any_cast<string>(m["FieldId"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<boost::any>(boost::any_cast<boost::any>(m["Label"]));
    }
    if (m.find("Props") != m.end() && !m["Props"].empty()) {
      props = make_shared<boost::any>(boost::any_cast<boost::any>(m["Props"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetFieldDefByUuidResponseBodyResult() = default;
};
class GetFieldDefByUuidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetFieldDefByUuidResponseBodyResult>> result{};
  shared_ptr<bool> success{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetFieldDefByUuidResponseBody() {}

  explicit GetFieldDefByUuidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<GetFieldDefByUuidResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetFieldDefByUuidResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<GetFieldDefByUuidResponseBodyResult>>(expect1);
      }
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetFieldDefByUuidResponseBody() = default;
};
class GetFieldDefByUuidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetFieldDefByUuidResponseBody> body{};

  GetFieldDefByUuidResponse() {}

  explicit GetFieldDefByUuidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFieldDefByUuidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFieldDefByUuidResponseBody>(model1);
      }
    }
  }


  virtual ~GetFieldDefByUuidResponse() = default;
};
class GetFileDownloadInfoHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetFileDownloadInfoHeadersAccountContext() {}

  explicit GetFileDownloadInfoHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetFileDownloadInfoHeadersAccountContext() = default;
};
class GetFileDownloadInfoHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetFileDownloadInfoHeadersAccountContext> accountContext{};

  GetFileDownloadInfoHeaders() {}

  explicit GetFileDownloadInfoHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetFileDownloadInfoHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetFileDownloadInfoHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetFileDownloadInfoHeaders() = default;
};
class GetFileDownloadInfoShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetFileDownloadInfoShrinkHeaders() {}

  explicit GetFileDownloadInfoShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetFileDownloadInfoShrinkHeaders() = default;
};
class GetFileDownloadInfoRequestOption : public Darabonba::Model {
public:
  shared_ptr<bool> preferIntranet{};
  shared_ptr<long> version{};

  GetFileDownloadInfoRequestOption() {}

  explicit GetFileDownloadInfoRequestOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preferIntranet) {
      res["PreferIntranet"] = boost::any(*preferIntranet);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreferIntranet") != m.end() && !m["PreferIntranet"].empty()) {
      preferIntranet = make_shared<bool>(boost::any_cast<bool>(m["PreferIntranet"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~GetFileDownloadInfoRequestOption() = default;
};
class GetFileDownloadInfoRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetFileDownloadInfoRequestTenantContext() {}

  explicit GetFileDownloadInfoRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetFileDownloadInfoRequestTenantContext() = default;
};
class GetFileDownloadInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryId{};
  shared_ptr<GetFileDownloadInfoRequestOption> option{};
  shared_ptr<string> spaceId{};
  shared_ptr<GetFileDownloadInfoRequestTenantContext> tenantContext{};

  GetFileDownloadInfoRequest() {}

  explicit GetFileDownloadInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryId) {
      res["DentryId"] = boost::any(*dentryId);
    }
    if (option) {
      res["Option"] = option ? boost::any(option->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryId") != m.end() && !m["DentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["DentryId"]));
    }
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      if (typeid(map<string, boost::any>) == m["Option"].type()) {
        GetFileDownloadInfoRequestOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Option"]));
        option = make_shared<GetFileDownloadInfoRequestOption>(model1);
      }
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetFileDownloadInfoRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetFileDownloadInfoRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetFileDownloadInfoRequest() = default;
};
class GetFileDownloadInfoShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryId{};
  shared_ptr<string> optionShrink{};
  shared_ptr<string> spaceId{};
  shared_ptr<string> tenantContextShrink{};

  GetFileDownloadInfoShrinkRequest() {}

  explicit GetFileDownloadInfoShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryId) {
      res["DentryId"] = boost::any(*dentryId);
    }
    if (optionShrink) {
      res["Option"] = boost::any(*optionShrink);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryId") != m.end() && !m["DentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["DentryId"]));
    }
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      optionShrink = make_shared<string>(boost::any_cast<string>(m["Option"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetFileDownloadInfoShrinkRequest() = default;
};
class GetFileDownloadInfoResponseBodyHeaderSignatureInfo : public Darabonba::Model {
public:
  shared_ptr<long> expirationSeconds{};
  shared_ptr<map<string, string>> headers{};
  shared_ptr<vector<string>> internalResourceUrls{};
  shared_ptr<string> region{};
  shared_ptr<vector<string>> resourceUrls{};

  GetFileDownloadInfoResponseBodyHeaderSignatureInfo() {}

  explicit GetFileDownloadInfoResponseBodyHeaderSignatureInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expirationSeconds) {
      res["ExpirationSeconds"] = boost::any(*expirationSeconds);
    }
    if (headers) {
      res["Headers"] = boost::any(*headers);
    }
    if (internalResourceUrls) {
      res["InternalResourceUrls"] = boost::any(*internalResourceUrls);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceUrls) {
      res["ResourceUrls"] = boost::any(*resourceUrls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpirationSeconds") != m.end() && !m["ExpirationSeconds"].empty()) {
      expirationSeconds = make_shared<long>(boost::any_cast<long>(m["ExpirationSeconds"]));
    }
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("InternalResourceUrls") != m.end() && !m["InternalResourceUrls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InternalResourceUrls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InternalResourceUrls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      internalResourceUrls = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceUrls") != m.end() && !m["ResourceUrls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceUrls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceUrls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceUrls = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetFileDownloadInfoResponseBodyHeaderSignatureInfo() = default;
};
class GetFileDownloadInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetFileDownloadInfoResponseBodyHeaderSignatureInfo> headerSignatureInfo{};
  shared_ptr<string> protocol{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetFileDownloadInfoResponseBody() {}

  explicit GetFileDownloadInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerSignatureInfo) {
      res["headerSignatureInfo"] = headerSignatureInfo ? boost::any(headerSignatureInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (protocol) {
      res["protocol"] = boost::any(*protocol);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headerSignatureInfo") != m.end() && !m["headerSignatureInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["headerSignatureInfo"].type()) {
        GetFileDownloadInfoResponseBodyHeaderSignatureInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["headerSignatureInfo"]));
        headerSignatureInfo = make_shared<GetFileDownloadInfoResponseBodyHeaderSignatureInfo>(model1);
      }
    }
    if (m.find("protocol") != m.end() && !m["protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["protocol"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetFileDownloadInfoResponseBody() = default;
};
class GetFileDownloadInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetFileDownloadInfoResponseBody> body{};

  GetFileDownloadInfoResponse() {}

  explicit GetFileDownloadInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFileDownloadInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFileDownloadInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetFileDownloadInfoResponse() = default;
};
class GetFileUploadInfoHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetFileUploadInfoHeadersAccountContext() {}

  explicit GetFileUploadInfoHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetFileUploadInfoHeadersAccountContext() = default;
};
class GetFileUploadInfoHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetFileUploadInfoHeadersAccountContext> accountContext{};

  GetFileUploadInfoHeaders() {}

  explicit GetFileUploadInfoHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetFileUploadInfoHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetFileUploadInfoHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetFileUploadInfoHeaders() = default;
};
class GetFileUploadInfoShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetFileUploadInfoShrinkHeaders() {}

  explicit GetFileUploadInfoShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetFileUploadInfoShrinkHeaders() = default;
};
class GetFileUploadInfoRequestOptionPreCheckParam : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> size{};

  GetFileUploadInfoRequestOptionPreCheckParam() {}

  explicit GetFileUploadInfoRequestOptionPreCheckParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~GetFileUploadInfoRequestOptionPreCheckParam() = default;
};
class GetFileUploadInfoRequestOption : public Darabonba::Model {
public:
  shared_ptr<GetFileUploadInfoRequestOptionPreCheckParam> preCheckParam{};
  shared_ptr<bool> preferIntranet{};
  shared_ptr<string> preferRegion{};
  shared_ptr<string> storageDriver{};

  GetFileUploadInfoRequestOption() {}

  explicit GetFileUploadInfoRequestOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preCheckParam) {
      res["PreCheckParam"] = preCheckParam ? boost::any(preCheckParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (preferIntranet) {
      res["PreferIntranet"] = boost::any(*preferIntranet);
    }
    if (preferRegion) {
      res["PreferRegion"] = boost::any(*preferRegion);
    }
    if (storageDriver) {
      res["StorageDriver"] = boost::any(*storageDriver);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreCheckParam") != m.end() && !m["PreCheckParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["PreCheckParam"].type()) {
        GetFileUploadInfoRequestOptionPreCheckParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PreCheckParam"]));
        preCheckParam = make_shared<GetFileUploadInfoRequestOptionPreCheckParam>(model1);
      }
    }
    if (m.find("PreferIntranet") != m.end() && !m["PreferIntranet"].empty()) {
      preferIntranet = make_shared<bool>(boost::any_cast<bool>(m["PreferIntranet"]));
    }
    if (m.find("PreferRegion") != m.end() && !m["PreferRegion"].empty()) {
      preferRegion = make_shared<string>(boost::any_cast<string>(m["PreferRegion"]));
    }
    if (m.find("StorageDriver") != m.end() && !m["StorageDriver"].empty()) {
      storageDriver = make_shared<string>(boost::any_cast<string>(m["StorageDriver"]));
    }
  }


  virtual ~GetFileUploadInfoRequestOption() = default;
};
class GetFileUploadInfoRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetFileUploadInfoRequestTenantContext() {}

  explicit GetFileUploadInfoRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetFileUploadInfoRequestTenantContext() = default;
};
class GetFileUploadInfoRequest : public Darabonba::Model {
public:
  shared_ptr<GetFileUploadInfoRequestOption> option{};
  shared_ptr<string> parentDentryUuid{};
  shared_ptr<string> protocol{};
  shared_ptr<GetFileUploadInfoRequestTenantContext> tenantContext{};

  GetFileUploadInfoRequest() {}

  explicit GetFileUploadInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (option) {
      res["Option"] = option ? boost::any(option->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parentDentryUuid) {
      res["ParentDentryUuid"] = boost::any(*parentDentryUuid);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      if (typeid(map<string, boost::any>) == m["Option"].type()) {
        GetFileUploadInfoRequestOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Option"]));
        option = make_shared<GetFileUploadInfoRequestOption>(model1);
      }
    }
    if (m.find("ParentDentryUuid") != m.end() && !m["ParentDentryUuid"].empty()) {
      parentDentryUuid = make_shared<string>(boost::any_cast<string>(m["ParentDentryUuid"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetFileUploadInfoRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetFileUploadInfoRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetFileUploadInfoRequest() = default;
};
class GetFileUploadInfoShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> optionShrink{};
  shared_ptr<string> parentDentryUuid{};
  shared_ptr<string> protocol{};
  shared_ptr<string> tenantContextShrink{};

  GetFileUploadInfoShrinkRequest() {}

  explicit GetFileUploadInfoShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (optionShrink) {
      res["Option"] = boost::any(*optionShrink);
    }
    if (parentDentryUuid) {
      res["ParentDentryUuid"] = boost::any(*parentDentryUuid);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      optionShrink = make_shared<string>(boost::any_cast<string>(m["Option"]));
    }
    if (m.find("ParentDentryUuid") != m.end() && !m["ParentDentryUuid"].empty()) {
      parentDentryUuid = make_shared<string>(boost::any_cast<string>(m["ParentDentryUuid"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetFileUploadInfoShrinkRequest() = default;
};
class GetFileUploadInfoResponseBodyHeaderSignatureInfo : public Darabonba::Model {
public:
  shared_ptr<long> expirationSeconds{};
  shared_ptr<map<string, string>> headers{};
  shared_ptr<vector<string>> internalResourceUrls{};
  shared_ptr<string> region{};
  shared_ptr<vector<string>> resourceUrls{};

  GetFileUploadInfoResponseBodyHeaderSignatureInfo() {}

  explicit GetFileUploadInfoResponseBodyHeaderSignatureInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expirationSeconds) {
      res["ExpirationSeconds"] = boost::any(*expirationSeconds);
    }
    if (headers) {
      res["Headers"] = boost::any(*headers);
    }
    if (internalResourceUrls) {
      res["InternalResourceUrls"] = boost::any(*internalResourceUrls);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceUrls) {
      res["ResourceUrls"] = boost::any(*resourceUrls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpirationSeconds") != m.end() && !m["ExpirationSeconds"].empty()) {
      expirationSeconds = make_shared<long>(boost::any_cast<long>(m["ExpirationSeconds"]));
    }
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("InternalResourceUrls") != m.end() && !m["InternalResourceUrls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InternalResourceUrls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InternalResourceUrls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      internalResourceUrls = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceUrls") != m.end() && !m["ResourceUrls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceUrls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceUrls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceUrls = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetFileUploadInfoResponseBodyHeaderSignatureInfo() = default;
};
class GetFileUploadInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetFileUploadInfoResponseBodyHeaderSignatureInfo> headerSignatureInfo{};
  shared_ptr<string> protocol{};
  shared_ptr<string> requestId{};
  shared_ptr<string> storageDriver{};
  shared_ptr<string> uploadKey{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetFileUploadInfoResponseBody() {}

  explicit GetFileUploadInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerSignatureInfo) {
      res["headerSignatureInfo"] = headerSignatureInfo ? boost::any(headerSignatureInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (protocol) {
      res["protocol"] = boost::any(*protocol);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (storageDriver) {
      res["storageDriver"] = boost::any(*storageDriver);
    }
    if (uploadKey) {
      res["uploadKey"] = boost::any(*uploadKey);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headerSignatureInfo") != m.end() && !m["headerSignatureInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["headerSignatureInfo"].type()) {
        GetFileUploadInfoResponseBodyHeaderSignatureInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["headerSignatureInfo"]));
        headerSignatureInfo = make_shared<GetFileUploadInfoResponseBodyHeaderSignatureInfo>(model1);
      }
    }
    if (m.find("protocol") != m.end() && !m["protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["protocol"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("storageDriver") != m.end() && !m["storageDriver"].empty()) {
      storageDriver = make_shared<string>(boost::any_cast<string>(m["storageDriver"]));
    }
    if (m.find("uploadKey") != m.end() && !m["uploadKey"].empty()) {
      uploadKey = make_shared<string>(boost::any_cast<string>(m["uploadKey"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetFileUploadInfoResponseBody() = default;
};
class GetFileUploadInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetFileUploadInfoResponseBody> body{};

  GetFileUploadInfoResponse() {}

  explicit GetFileUploadInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFileUploadInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFileUploadInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetFileUploadInfoResponse() = default;
};
class GetFormComponentDefinitionListHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetFormComponentDefinitionListHeadersAccountContext() {}

  explicit GetFormComponentDefinitionListHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetFormComponentDefinitionListHeadersAccountContext() = default;
};
class GetFormComponentDefinitionListHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetFormComponentDefinitionListHeadersAccountContext> accountContext{};

  GetFormComponentDefinitionListHeaders() {}

  explicit GetFormComponentDefinitionListHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetFormComponentDefinitionListHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetFormComponentDefinitionListHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetFormComponentDefinitionListHeaders() = default;
};
class GetFormComponentDefinitionListShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetFormComponentDefinitionListShrinkHeaders() {}

  explicit GetFormComponentDefinitionListShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetFormComponentDefinitionListShrinkHeaders() = default;
};
class GetFormComponentDefinitionListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> formUuid{};
  shared_ptr<string> language{};
  shared_ptr<string> systemToken{};

  GetFormComponentDefinitionListRequest() {}

  explicit GetFormComponentDefinitionListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~GetFormComponentDefinitionListRequest() = default;
};
class GetFormComponentDefinitionListResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> componentName{};
  shared_ptr<string> fieldId{};
  shared_ptr<string> label{};
  shared_ptr<string> parentId{};

  GetFormComponentDefinitionListResponseBodyResult() {}

  explicit GetFormComponentDefinitionListResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (fieldId) {
      res["FieldId"] = boost::any(*fieldId);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("FieldId") != m.end() && !m["FieldId"].empty()) {
      fieldId = make_shared<string>(boost::any_cast<string>(m["FieldId"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
  }


  virtual ~GetFormComponentDefinitionListResponseBodyResult() = default;
};
class GetFormComponentDefinitionListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetFormComponentDefinitionListResponseBodyResult>> result{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetFormComponentDefinitionListResponseBody() {}

  explicit GetFormComponentDefinitionListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<GetFormComponentDefinitionListResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetFormComponentDefinitionListResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<GetFormComponentDefinitionListResponseBodyResult>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetFormComponentDefinitionListResponseBody() = default;
};
class GetFormComponentDefinitionListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetFormComponentDefinitionListResponseBody> body{};

  GetFormComponentDefinitionListResponse() {}

  explicit GetFormComponentDefinitionListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFormComponentDefinitionListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFormComponentDefinitionListResponseBody>(model1);
      }
    }
  }


  virtual ~GetFormComponentDefinitionListResponse() = default;
};
class GetFormDataByIDHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetFormDataByIDHeadersAccountContext() {}

  explicit GetFormDataByIDHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetFormDataByIDHeadersAccountContext() = default;
};
class GetFormDataByIDHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetFormDataByIDHeadersAccountContext> accountContext{};

  GetFormDataByIDHeaders() {}

  explicit GetFormDataByIDHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetFormDataByIDHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetFormDataByIDHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetFormDataByIDHeaders() = default;
};
class GetFormDataByIDShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetFormDataByIDShrinkHeaders() {}

  explicit GetFormDataByIDShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetFormDataByIDShrinkHeaders() = default;
};
class GetFormDataByIDRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> id{};
  shared_ptr<string> language{};
  shared_ptr<string> systemToken{};

  GetFormDataByIDRequest() {}

  explicit GetFormDataByIDRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~GetFormDataByIDRequest() = default;
};
class GetFormDataByIDResponseBodyOriginatorName : public Darabonba::Model {
public:
  shared_ptr<string> nameInChinese{};
  shared_ptr<string> nameInEnglish{};
  shared_ptr<string> type{};

  GetFormDataByIDResponseBodyOriginatorName() {}

  explicit GetFormDataByIDResponseBodyOriginatorName(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameInChinese) {
      res["NameInChinese"] = boost::any(*nameInChinese);
    }
    if (nameInEnglish) {
      res["NameInEnglish"] = boost::any(*nameInEnglish);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameInChinese") != m.end() && !m["NameInChinese"].empty()) {
      nameInChinese = make_shared<string>(boost::any_cast<string>(m["NameInChinese"]));
    }
    if (m.find("NameInEnglish") != m.end() && !m["NameInEnglish"].empty()) {
      nameInEnglish = make_shared<string>(boost::any_cast<string>(m["NameInEnglish"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetFormDataByIDResponseBodyOriginatorName() = default;
};
class GetFormDataByIDResponseBodyOriginator : public Darabonba::Model {
public:
  shared_ptr<string> departmentName{};
  shared_ptr<string> email{};
  shared_ptr<GetFormDataByIDResponseBodyOriginatorName> name{};
  shared_ptr<string> userId{};

  GetFormDataByIDResponseBodyOriginator() {}

  explicit GetFormDataByIDResponseBodyOriginator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (departmentName) {
      res["DepartmentName"] = boost::any(*departmentName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (name) {
      res["Name"] = name ? boost::any(name->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DepartmentName") != m.end() && !m["DepartmentName"].empty()) {
      departmentName = make_shared<string>(boost::any_cast<string>(m["DepartmentName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      if (typeid(map<string, boost::any>) == m["Name"].type()) {
        GetFormDataByIDResponseBodyOriginatorName model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Name"]));
        name = make_shared<GetFormDataByIDResponseBodyOriginatorName>(model1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetFormDataByIDResponseBodyOriginator() = default;
};
class GetFormDataByIDResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> formData{};
  shared_ptr<string> formInstId{};
  shared_ptr<string> modifiedTimeGMT{};
  shared_ptr<GetFormDataByIDResponseBodyOriginator> originator{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetFormDataByIDResponseBody() {}

  explicit GetFormDataByIDResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (formData) {
      res["formData"] = boost::any(*formData);
    }
    if (formInstId) {
      res["formInstId"] = boost::any(*formInstId);
    }
    if (modifiedTimeGMT) {
      res["modifiedTimeGMT"] = boost::any(*modifiedTimeGMT);
    }
    if (originator) {
      res["originator"] = originator ? boost::any(originator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("formData") != m.end() && !m["formData"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["formData"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      formData = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("formInstId") != m.end() && !m["formInstId"].empty()) {
      formInstId = make_shared<string>(boost::any_cast<string>(m["formInstId"]));
    }
    if (m.find("modifiedTimeGMT") != m.end() && !m["modifiedTimeGMT"].empty()) {
      modifiedTimeGMT = make_shared<string>(boost::any_cast<string>(m["modifiedTimeGMT"]));
    }
    if (m.find("originator") != m.end() && !m["originator"].empty()) {
      if (typeid(map<string, boost::any>) == m["originator"].type()) {
        GetFormDataByIDResponseBodyOriginator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["originator"]));
        originator = make_shared<GetFormDataByIDResponseBodyOriginator>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetFormDataByIDResponseBody() = default;
};
class GetFormDataByIDResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetFormDataByIDResponseBody> body{};

  GetFormDataByIDResponse() {}

  explicit GetFormDataByIDResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFormDataByIDResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFormDataByIDResponseBody>(model1);
      }
    }
  }


  virtual ~GetFormDataByIDResponse() = default;
};
class GetFormListInAppHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetFormListInAppHeadersAccountContext() {}

  explicit GetFormListInAppHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetFormListInAppHeadersAccountContext() = default;
};
class GetFormListInAppHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetFormListInAppHeadersAccountContext> accountContext{};

  GetFormListInAppHeaders() {}

  explicit GetFormListInAppHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetFormListInAppHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetFormListInAppHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetFormListInAppHeaders() = default;
};
class GetFormListInAppShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetFormListInAppShrinkHeaders() {}

  explicit GetFormListInAppShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetFormListInAppShrinkHeaders() = default;
};
class GetFormListInAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> formTypes{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> systemToken{};

  GetFormListInAppRequest() {}

  explicit GetFormListInAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (formTypes) {
      res["FormTypes"] = boost::any(*formTypes);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("FormTypes") != m.end() && !m["FormTypes"].empty()) {
      formTypes = make_shared<string>(boost::any_cast<string>(m["FormTypes"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~GetFormListInAppRequest() = default;
};
class GetFormListInAppResponseBodyDataTitle : public Darabonba::Model {
public:
  shared_ptr<string> enUS{};
  shared_ptr<string> zhCN{};

  GetFormListInAppResponseBodyDataTitle() {}

  explicit GetFormListInAppResponseBodyDataTitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enUS) {
      res["EnUS"] = boost::any(*enUS);
    }
    if (zhCN) {
      res["ZhCN"] = boost::any(*zhCN);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnUS") != m.end() && !m["EnUS"].empty()) {
      enUS = make_shared<string>(boost::any_cast<string>(m["EnUS"]));
    }
    if (m.find("ZhCN") != m.end() && !m["ZhCN"].empty()) {
      zhCN = make_shared<string>(boost::any_cast<string>(m["ZhCN"]));
    }
  }


  virtual ~GetFormListInAppResponseBodyDataTitle() = default;
};
class GetFormListInAppResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> creator{};
  shared_ptr<string> formType{};
  shared_ptr<string> formUuid{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<GetFormListInAppResponseBodyDataTitle> title{};

  GetFormListInAppResponseBodyData() {}

  explicit GetFormListInAppResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (formType) {
      res["FormType"] = boost::any(*formType);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (title) {
      res["Title"] = title ? boost::any(title->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("FormType") != m.end() && !m["FormType"].empty()) {
      formType = make_shared<string>(boost::any_cast<string>(m["FormType"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      if (typeid(map<string, boost::any>) == m["Title"].type()) {
        GetFormListInAppResponseBodyDataTitle model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Title"]));
        title = make_shared<GetFormListInAppResponseBodyDataTitle>(model1);
      }
    }
  }


  virtual ~GetFormListInAppResponseBodyData() = default;
};
class GetFormListInAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<GetFormListInAppResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetFormListInAppResponseBody() {}

  explicit GetFormListInAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<GetFormListInAppResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetFormListInAppResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetFormListInAppResponseBodyData>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetFormListInAppResponseBody() = default;
};
class GetFormListInAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetFormListInAppResponseBody> body{};

  GetFormListInAppResponse() {}

  explicit GetFormListInAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFormListInAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFormListInAppResponseBody>(model1);
      }
    }
  }


  virtual ~GetFormListInAppResponse() = default;
};
class GetGroupLiveListHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetGroupLiveListHeadersAccountContext() {}

  explicit GetGroupLiveListHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetGroupLiveListHeadersAccountContext() = default;
};
class GetGroupLiveListHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetGroupLiveListHeadersAccountContext> accountContext{};

  GetGroupLiveListHeaders() {}

  explicit GetGroupLiveListHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetGroupLiveListHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetGroupLiveListHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetGroupLiveListHeaders() = default;
};
class GetGroupLiveListShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetGroupLiveListShrinkHeaders() {}

  explicit GetGroupLiveListShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetGroupLiveListShrinkHeaders() = default;
};
class GetGroupLiveListRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetGroupLiveListRequestTenantContext() {}

  explicit GetGroupLiveListRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetGroupLiveListRequestTenantContext() = default;
};
class GetGroupLiveListRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> openConversationId{};
  shared_ptr<long> startTime{};
  shared_ptr<GetGroupLiveListRequestTenantContext> tenantContext{};

  GetGroupLiveListRequest() {}

  explicit GetGroupLiveListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (openConversationId) {
      res["OpenConversationId"] = boost::any(*openConversationId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("OpenConversationId") != m.end() && !m["OpenConversationId"].empty()) {
      openConversationId = make_shared<string>(boost::any_cast<string>(m["OpenConversationId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetGroupLiveListRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetGroupLiveListRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetGroupLiveListRequest() = default;
};
class GetGroupLiveListShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> openConversationId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> tenantContextShrink{};

  GetGroupLiveListShrinkRequest() {}

  explicit GetGroupLiveListShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (openConversationId) {
      res["OpenConversationId"] = boost::any(*openConversationId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("OpenConversationId") != m.end() && !m["OpenConversationId"].empty()) {
      openConversationId = make_shared<string>(boost::any_cast<string>(m["OpenConversationId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetGroupLiveListShrinkRequest() = default;
};
class GetGroupLiveListResponseBodyResultGroupLiveList : public Darabonba::Model {
public:
  shared_ptr<string> anchorNickname{};
  shared_ptr<string> anchorUnionId{};
  shared_ptr<long> liveEndTime{};
  shared_ptr<long> liveStartTime{};
  shared_ptr<string> liveUuid{};
  shared_ptr<string> title{};

  GetGroupLiveListResponseBodyResultGroupLiveList() {}

  explicit GetGroupLiveListResponseBodyResultGroupLiveList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anchorNickname) {
      res["AnchorNickname"] = boost::any(*anchorNickname);
    }
    if (anchorUnionId) {
      res["AnchorUnionId"] = boost::any(*anchorUnionId);
    }
    if (liveEndTime) {
      res["LiveEndTime"] = boost::any(*liveEndTime);
    }
    if (liveStartTime) {
      res["LiveStartTime"] = boost::any(*liveStartTime);
    }
    if (liveUuid) {
      res["LiveUuid"] = boost::any(*liveUuid);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnchorNickname") != m.end() && !m["AnchorNickname"].empty()) {
      anchorNickname = make_shared<string>(boost::any_cast<string>(m["AnchorNickname"]));
    }
    if (m.find("AnchorUnionId") != m.end() && !m["AnchorUnionId"].empty()) {
      anchorUnionId = make_shared<string>(boost::any_cast<string>(m["AnchorUnionId"]));
    }
    if (m.find("LiveEndTime") != m.end() && !m["LiveEndTime"].empty()) {
      liveEndTime = make_shared<long>(boost::any_cast<long>(m["LiveEndTime"]));
    }
    if (m.find("LiveStartTime") != m.end() && !m["LiveStartTime"].empty()) {
      liveStartTime = make_shared<long>(boost::any_cast<long>(m["LiveStartTime"]));
    }
    if (m.find("LiveUuid") != m.end() && !m["LiveUuid"].empty()) {
      liveUuid = make_shared<string>(boost::any_cast<string>(m["LiveUuid"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GetGroupLiveListResponseBodyResultGroupLiveList() = default;
};
class GetGroupLiveListResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetGroupLiveListResponseBodyResultGroupLiveList>> groupLiveList{};

  GetGroupLiveListResponseBodyResult() {}

  explicit GetGroupLiveListResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupLiveList) {
      vector<boost::any> temp1;
      for(auto item1:*groupLiveList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupLiveList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupLiveList") != m.end() && !m["GroupLiveList"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupLiveList"].type()) {
        vector<GetGroupLiveListResponseBodyResultGroupLiveList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupLiveList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetGroupLiveListResponseBodyResultGroupLiveList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupLiveList = make_shared<vector<GetGroupLiveListResponseBodyResultGroupLiveList>>(expect1);
      }
    }
  }


  virtual ~GetGroupLiveListResponseBodyResult() = default;
};
class GetGroupLiveListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetGroupLiveListResponseBodyResult> result{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetGroupLiveListResponseBody() {}

  explicit GetGroupLiveListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        GetGroupLiveListResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<GetGroupLiveListResponseBodyResult>(model1);
      }
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetGroupLiveListResponseBody() = default;
};
class GetGroupLiveListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetGroupLiveListResponseBody> body{};

  GetGroupLiveListResponse() {}

  explicit GetGroupLiveListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetGroupLiveListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetGroupLiveListResponseBody>(model1);
      }
    }
  }


  virtual ~GetGroupLiveListResponse() = default;
};
class GetInnerGroupMembersHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetInnerGroupMembersHeadersAccountContext() {}

  explicit GetInnerGroupMembersHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetInnerGroupMembersHeadersAccountContext() = default;
};
class GetInnerGroupMembersHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetInnerGroupMembersHeadersAccountContext> accountContext{};

  GetInnerGroupMembersHeaders() {}

  explicit GetInnerGroupMembersHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetInnerGroupMembersHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetInnerGroupMembersHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetInnerGroupMembersHeaders() = default;
};
class GetInnerGroupMembersShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetInnerGroupMembersShrinkHeaders() {}

  explicit GetInnerGroupMembersShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetInnerGroupMembersShrinkHeaders() = default;
};
class GetInnerGroupMembersRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> openConversationId{};

  GetInnerGroupMembersRequest() {}

  explicit GetInnerGroupMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (openConversationId) {
      res["OpenConversationId"] = boost::any(*openConversationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OpenConversationId") != m.end() && !m["OpenConversationId"].empty()) {
      openConversationId = make_shared<string>(boost::any_cast<string>(m["OpenConversationId"]));
    }
  }


  virtual ~GetInnerGroupMembersRequest() = default;
};
class GetInnerGroupMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> hasMore{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> userIds{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetInnerGroupMembersResponseBody() {}

  explicit GetInnerGroupMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasMore) {
      res["hasMore"] = boost::any(*hasMore);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (userIds) {
      res["userIds"] = boost::any(*userIds);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hasMore") != m.end() && !m["hasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["hasMore"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("userIds") != m.end() && !m["userIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["userIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["userIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetInnerGroupMembersResponseBody() = default;
};
class GetInnerGroupMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInnerGroupMembersResponseBody> body{};

  GetInnerGroupMembersResponse() {}

  explicit GetInnerGroupMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInnerGroupMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInnerGroupMembersResponseBody>(model1);
      }
    }
  }


  virtual ~GetInnerGroupMembersResponse() = default;
};
class GetInstanceByIdHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetInstanceByIdHeadersAccountContext() {}

  explicit GetInstanceByIdHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetInstanceByIdHeadersAccountContext() = default;
};
class GetInstanceByIdHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetInstanceByIdHeadersAccountContext> accountContext{};

  GetInstanceByIdHeaders() {}

  explicit GetInstanceByIdHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetInstanceByIdHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetInstanceByIdHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetInstanceByIdHeaders() = default;
};
class GetInstanceByIdShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetInstanceByIdShrinkHeaders() {}

  explicit GetInstanceByIdShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetInstanceByIdShrinkHeaders() = default;
};
class GetInstanceByIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> id{};
  shared_ptr<string> language{};
  shared_ptr<string> systemToken{};

  GetInstanceByIdRequest() {}

  explicit GetInstanceByIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~GetInstanceByIdRequest() = default;
};
class GetInstanceByIdResponseBodyActionExecutorName : public Darabonba::Model {
public:
  shared_ptr<string> nameInChinese{};
  shared_ptr<string> nameInEnglish{};
  shared_ptr<string> type{};

  GetInstanceByIdResponseBodyActionExecutorName() {}

  explicit GetInstanceByIdResponseBodyActionExecutorName(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameInChinese) {
      res["NameInChinese"] = boost::any(*nameInChinese);
    }
    if (nameInEnglish) {
      res["NameInEnglish"] = boost::any(*nameInEnglish);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameInChinese") != m.end() && !m["NameInChinese"].empty()) {
      nameInChinese = make_shared<string>(boost::any_cast<string>(m["NameInChinese"]));
    }
    if (m.find("NameInEnglish") != m.end() && !m["NameInEnglish"].empty()) {
      nameInEnglish = make_shared<string>(boost::any_cast<string>(m["NameInEnglish"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetInstanceByIdResponseBodyActionExecutorName() = default;
};
class GetInstanceByIdResponseBodyActionExecutor : public Darabonba::Model {
public:
  shared_ptr<string> deptName{};
  shared_ptr<string> email{};
  shared_ptr<GetInstanceByIdResponseBodyActionExecutorName> name{};
  shared_ptr<string> userId{};

  GetInstanceByIdResponseBodyActionExecutor() {}

  explicit GetInstanceByIdResponseBodyActionExecutor(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deptName) {
      res["DeptName"] = boost::any(*deptName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (name) {
      res["Name"] = name ? boost::any(name->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeptName") != m.end() && !m["DeptName"].empty()) {
      deptName = make_shared<string>(boost::any_cast<string>(m["DeptName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      if (typeid(map<string, boost::any>) == m["Name"].type()) {
        GetInstanceByIdResponseBodyActionExecutorName model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Name"]));
        name = make_shared<GetInstanceByIdResponseBodyActionExecutorName>(model1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetInstanceByIdResponseBodyActionExecutor() = default;
};
class GetInstanceByIdResponseBodyOriginatorName : public Darabonba::Model {
public:
  shared_ptr<string> nameInChinese{};
  shared_ptr<string> nameInEnglish{};
  shared_ptr<string> type{};

  GetInstanceByIdResponseBodyOriginatorName() {}

  explicit GetInstanceByIdResponseBodyOriginatorName(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameInChinese) {
      res["NameInChinese"] = boost::any(*nameInChinese);
    }
    if (nameInEnglish) {
      res["NameInEnglish"] = boost::any(*nameInEnglish);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameInChinese") != m.end() && !m["NameInChinese"].empty()) {
      nameInChinese = make_shared<string>(boost::any_cast<string>(m["NameInChinese"]));
    }
    if (m.find("NameInEnglish") != m.end() && !m["NameInEnglish"].empty()) {
      nameInEnglish = make_shared<string>(boost::any_cast<string>(m["NameInEnglish"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetInstanceByIdResponseBodyOriginatorName() = default;
};
class GetInstanceByIdResponseBodyOriginator : public Darabonba::Model {
public:
  shared_ptr<string> deptName{};
  shared_ptr<string> email{};
  shared_ptr<GetInstanceByIdResponseBodyOriginatorName> name{};
  shared_ptr<string> userId{};

  GetInstanceByIdResponseBodyOriginator() {}

  explicit GetInstanceByIdResponseBodyOriginator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deptName) {
      res["DeptName"] = boost::any(*deptName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (name) {
      res["Name"] = name ? boost::any(name->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeptName") != m.end() && !m["DeptName"].empty()) {
      deptName = make_shared<string>(boost::any_cast<string>(m["DeptName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      if (typeid(map<string, boost::any>) == m["Name"].type()) {
        GetInstanceByIdResponseBodyOriginatorName model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Name"]));
        name = make_shared<GetInstanceByIdResponseBodyOriginatorName>(model1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetInstanceByIdResponseBodyOriginator() = default;
};
class GetInstanceByIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetInstanceByIdResponseBodyActionExecutor>> actionExecutor{};
  shared_ptr<string> approvedResult{};
  shared_ptr<string> createTimeGMT{};
  shared_ptr<map<string, boost::any>> data{};
  shared_ptr<string> formUuid{};
  shared_ptr<string> instanceStatus{};
  shared_ptr<string> modifiedTimeGMT{};
  shared_ptr<GetInstanceByIdResponseBodyOriginator> originator{};
  shared_ptr<string> processCode{};
  shared_ptr<string> processInstanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> title{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};
  shared_ptr<long> version{};

  GetInstanceByIdResponseBody() {}

  explicit GetInstanceByIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionExecutor) {
      vector<boost::any> temp1;
      for(auto item1:*actionExecutor){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["actionExecutor"] = boost::any(temp1);
    }
    if (approvedResult) {
      res["approvedResult"] = boost::any(*approvedResult);
    }
    if (createTimeGMT) {
      res["createTimeGMT"] = boost::any(*createTimeGMT);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (formUuid) {
      res["formUuid"] = boost::any(*formUuid);
    }
    if (instanceStatus) {
      res["instanceStatus"] = boost::any(*instanceStatus);
    }
    if (modifiedTimeGMT) {
      res["modifiedTimeGMT"] = boost::any(*modifiedTimeGMT);
    }
    if (originator) {
      res["originator"] = originator ? boost::any(originator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (processCode) {
      res["processCode"] = boost::any(*processCode);
    }
    if (processInstanceId) {
      res["processInstanceId"] = boost::any(*processInstanceId);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actionExecutor") != m.end() && !m["actionExecutor"].empty()) {
      if (typeid(vector<boost::any>) == m["actionExecutor"].type()) {
        vector<GetInstanceByIdResponseBodyActionExecutor> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["actionExecutor"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceByIdResponseBodyActionExecutor model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        actionExecutor = make_shared<vector<GetInstanceByIdResponseBodyActionExecutor>>(expect1);
      }
    }
    if (m.find("approvedResult") != m.end() && !m["approvedResult"].empty()) {
      approvedResult = make_shared<string>(boost::any_cast<string>(m["approvedResult"]));
    }
    if (m.find("createTimeGMT") != m.end() && !m["createTimeGMT"].empty()) {
      createTimeGMT = make_shared<string>(boost::any_cast<string>(m["createTimeGMT"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["data"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      data = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("formUuid") != m.end() && !m["formUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["formUuid"]));
    }
    if (m.find("instanceStatus") != m.end() && !m["instanceStatus"].empty()) {
      instanceStatus = make_shared<string>(boost::any_cast<string>(m["instanceStatus"]));
    }
    if (m.find("modifiedTimeGMT") != m.end() && !m["modifiedTimeGMT"].empty()) {
      modifiedTimeGMT = make_shared<string>(boost::any_cast<string>(m["modifiedTimeGMT"]));
    }
    if (m.find("originator") != m.end() && !m["originator"].empty()) {
      if (typeid(map<string, boost::any>) == m["originator"].type()) {
        GetInstanceByIdResponseBodyOriginator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["originator"]));
        originator = make_shared<GetInstanceByIdResponseBodyOriginator>(model1);
      }
    }
    if (m.find("processCode") != m.end() && !m["processCode"].empty()) {
      processCode = make_shared<string>(boost::any_cast<string>(m["processCode"]));
    }
    if (m.find("processInstanceId") != m.end() && !m["processInstanceId"].empty()) {
      processInstanceId = make_shared<string>(boost::any_cast<string>(m["processInstanceId"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["version"]));
    }
  }


  virtual ~GetInstanceByIdResponseBody() = default;
};
class GetInstanceByIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInstanceByIdResponseBody> body{};

  GetInstanceByIdResponse() {}

  explicit GetInstanceByIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceByIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceByIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceByIdResponse() = default;
};
class GetInstanceIdListHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetInstanceIdListHeadersAccountContext() {}

  explicit GetInstanceIdListHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetInstanceIdListHeadersAccountContext() = default;
};
class GetInstanceIdListHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetInstanceIdListHeadersAccountContext> accountContext{};

  GetInstanceIdListHeaders() {}

  explicit GetInstanceIdListHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetInstanceIdListHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetInstanceIdListHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetInstanceIdListHeaders() = default;
};
class GetInstanceIdListShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetInstanceIdListShrinkHeaders() {}

  explicit GetInstanceIdListShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetInstanceIdListShrinkHeaders() = default;
};
class GetInstanceIdListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> approvedResult{};
  shared_ptr<string> createFromTimeGMT{};
  shared_ptr<string> createToTimeGMT{};
  shared_ptr<string> formUuid{};
  shared_ptr<string> instanceStatus{};
  shared_ptr<string> language{};
  shared_ptr<string> modifiedFromTimeGMT{};
  shared_ptr<string> modifiedToTimeGMT{};
  shared_ptr<string> originatorId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchFieldJson{};
  shared_ptr<string> systemToken{};
  shared_ptr<string> taskId{};

  GetInstanceIdListRequest() {}

  explicit GetInstanceIdListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (approvedResult) {
      res["ApprovedResult"] = boost::any(*approvedResult);
    }
    if (createFromTimeGMT) {
      res["CreateFromTimeGMT"] = boost::any(*createFromTimeGMT);
    }
    if (createToTimeGMT) {
      res["CreateToTimeGMT"] = boost::any(*createToTimeGMT);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (instanceStatus) {
      res["InstanceStatus"] = boost::any(*instanceStatus);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (modifiedFromTimeGMT) {
      res["ModifiedFromTimeGMT"] = boost::any(*modifiedFromTimeGMT);
    }
    if (modifiedToTimeGMT) {
      res["ModifiedToTimeGMT"] = boost::any(*modifiedToTimeGMT);
    }
    if (originatorId) {
      res["OriginatorId"] = boost::any(*originatorId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchFieldJson) {
      res["SearchFieldJson"] = boost::any(*searchFieldJson);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("ApprovedResult") != m.end() && !m["ApprovedResult"].empty()) {
      approvedResult = make_shared<string>(boost::any_cast<string>(m["ApprovedResult"]));
    }
    if (m.find("CreateFromTimeGMT") != m.end() && !m["CreateFromTimeGMT"].empty()) {
      createFromTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateFromTimeGMT"]));
    }
    if (m.find("CreateToTimeGMT") != m.end() && !m["CreateToTimeGMT"].empty()) {
      createToTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateToTimeGMT"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("InstanceStatus") != m.end() && !m["InstanceStatus"].empty()) {
      instanceStatus = make_shared<string>(boost::any_cast<string>(m["InstanceStatus"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("ModifiedFromTimeGMT") != m.end() && !m["ModifiedFromTimeGMT"].empty()) {
      modifiedFromTimeGMT = make_shared<string>(boost::any_cast<string>(m["ModifiedFromTimeGMT"]));
    }
    if (m.find("ModifiedToTimeGMT") != m.end() && !m["ModifiedToTimeGMT"].empty()) {
      modifiedToTimeGMT = make_shared<string>(boost::any_cast<string>(m["ModifiedToTimeGMT"]));
    }
    if (m.find("OriginatorId") != m.end() && !m["OriginatorId"].empty()) {
      originatorId = make_shared<string>(boost::any_cast<string>(m["OriginatorId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchFieldJson") != m.end() && !m["SearchFieldJson"].empty()) {
      searchFieldJson = make_shared<string>(boost::any_cast<string>(m["SearchFieldJson"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetInstanceIdListRequest() = default;
};
class GetInstanceIdListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetInstanceIdListResponseBody() {}

  explicit GetInstanceIdListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetInstanceIdListResponseBody() = default;
};
class GetInstanceIdListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInstanceIdListResponseBody> body{};

  GetInstanceIdListResponse() {}

  explicit GetInstanceIdListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceIdListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceIdListResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceIdListResponse() = default;
};
class GetInstancesHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetInstancesHeadersAccountContext() {}

  explicit GetInstancesHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetInstancesHeadersAccountContext() = default;
};
class GetInstancesHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetInstancesHeadersAccountContext> accountContext{};

  GetInstancesHeaders() {}

  explicit GetInstancesHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetInstancesHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetInstancesHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetInstancesHeaders() = default;
};
class GetInstancesShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetInstancesShrinkHeaders() {}

  explicit GetInstancesShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetInstancesShrinkHeaders() = default;
};
class GetInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> approvedResult{};
  shared_ptr<string> createFromTimeGMT{};
  shared_ptr<string> createToTimeGMT{};
  shared_ptr<string> formUuid{};
  shared_ptr<string> instanceStatus{};
  shared_ptr<string> language{};
  shared_ptr<string> modifiedFromTimeGMT{};
  shared_ptr<string> modifiedToTimeGMT{};
  shared_ptr<string> orderConfigJson{};
  shared_ptr<string> originatorId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchFieldJson{};
  shared_ptr<string> systemToken{};
  shared_ptr<string> taskId{};

  GetInstancesRequest() {}

  explicit GetInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (approvedResult) {
      res["ApprovedResult"] = boost::any(*approvedResult);
    }
    if (createFromTimeGMT) {
      res["CreateFromTimeGMT"] = boost::any(*createFromTimeGMT);
    }
    if (createToTimeGMT) {
      res["CreateToTimeGMT"] = boost::any(*createToTimeGMT);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (instanceStatus) {
      res["InstanceStatus"] = boost::any(*instanceStatus);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (modifiedFromTimeGMT) {
      res["ModifiedFromTimeGMT"] = boost::any(*modifiedFromTimeGMT);
    }
    if (modifiedToTimeGMT) {
      res["ModifiedToTimeGMT"] = boost::any(*modifiedToTimeGMT);
    }
    if (orderConfigJson) {
      res["OrderConfigJson"] = boost::any(*orderConfigJson);
    }
    if (originatorId) {
      res["OriginatorId"] = boost::any(*originatorId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchFieldJson) {
      res["SearchFieldJson"] = boost::any(*searchFieldJson);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("ApprovedResult") != m.end() && !m["ApprovedResult"].empty()) {
      approvedResult = make_shared<string>(boost::any_cast<string>(m["ApprovedResult"]));
    }
    if (m.find("CreateFromTimeGMT") != m.end() && !m["CreateFromTimeGMT"].empty()) {
      createFromTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateFromTimeGMT"]));
    }
    if (m.find("CreateToTimeGMT") != m.end() && !m["CreateToTimeGMT"].empty()) {
      createToTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateToTimeGMT"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("InstanceStatus") != m.end() && !m["InstanceStatus"].empty()) {
      instanceStatus = make_shared<string>(boost::any_cast<string>(m["InstanceStatus"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("ModifiedFromTimeGMT") != m.end() && !m["ModifiedFromTimeGMT"].empty()) {
      modifiedFromTimeGMT = make_shared<string>(boost::any_cast<string>(m["ModifiedFromTimeGMT"]));
    }
    if (m.find("ModifiedToTimeGMT") != m.end() && !m["ModifiedToTimeGMT"].empty()) {
      modifiedToTimeGMT = make_shared<string>(boost::any_cast<string>(m["ModifiedToTimeGMT"]));
    }
    if (m.find("OrderConfigJson") != m.end() && !m["OrderConfigJson"].empty()) {
      orderConfigJson = make_shared<string>(boost::any_cast<string>(m["OrderConfigJson"]));
    }
    if (m.find("OriginatorId") != m.end() && !m["OriginatorId"].empty()) {
      originatorId = make_shared<string>(boost::any_cast<string>(m["OriginatorId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchFieldJson") != m.end() && !m["SearchFieldJson"].empty()) {
      searchFieldJson = make_shared<string>(boost::any_cast<string>(m["SearchFieldJson"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetInstancesRequest() = default;
};
class GetInstancesResponseBodyDataActionExecutorName : public Darabonba::Model {
public:
  shared_ptr<string> nameInChinese{};
  shared_ptr<string> nameInEnglish{};
  shared_ptr<string> type{};

  GetInstancesResponseBodyDataActionExecutorName() {}

  explicit GetInstancesResponseBodyDataActionExecutorName(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameInChinese) {
      res["NameInChinese"] = boost::any(*nameInChinese);
    }
    if (nameInEnglish) {
      res["NameInEnglish"] = boost::any(*nameInEnglish);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameInChinese") != m.end() && !m["NameInChinese"].empty()) {
      nameInChinese = make_shared<string>(boost::any_cast<string>(m["NameInChinese"]));
    }
    if (m.find("NameInEnglish") != m.end() && !m["NameInEnglish"].empty()) {
      nameInEnglish = make_shared<string>(boost::any_cast<string>(m["NameInEnglish"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetInstancesResponseBodyDataActionExecutorName() = default;
};
class GetInstancesResponseBodyDataActionExecutor : public Darabonba::Model {
public:
  shared_ptr<string> deptName{};
  shared_ptr<string> email{};
  shared_ptr<GetInstancesResponseBodyDataActionExecutorName> name{};
  shared_ptr<string> userId{};

  GetInstancesResponseBodyDataActionExecutor() {}

  explicit GetInstancesResponseBodyDataActionExecutor(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deptName) {
      res["DeptName"] = boost::any(*deptName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (name) {
      res["Name"] = name ? boost::any(name->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeptName") != m.end() && !m["DeptName"].empty()) {
      deptName = make_shared<string>(boost::any_cast<string>(m["DeptName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      if (typeid(map<string, boost::any>) == m["Name"].type()) {
        GetInstancesResponseBodyDataActionExecutorName model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Name"]));
        name = make_shared<GetInstancesResponseBodyDataActionExecutorName>(model1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetInstancesResponseBodyDataActionExecutor() = default;
};
class GetInstancesResponseBodyDataOriginatorName : public Darabonba::Model {
public:
  shared_ptr<string> nameInChinese{};
  shared_ptr<string> nameInEnglish{};
  shared_ptr<string> type{};

  GetInstancesResponseBodyDataOriginatorName() {}

  explicit GetInstancesResponseBodyDataOriginatorName(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameInChinese) {
      res["NameInChinese"] = boost::any(*nameInChinese);
    }
    if (nameInEnglish) {
      res["NameInEnglish"] = boost::any(*nameInEnglish);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameInChinese") != m.end() && !m["NameInChinese"].empty()) {
      nameInChinese = make_shared<string>(boost::any_cast<string>(m["NameInChinese"]));
    }
    if (m.find("NameInEnglish") != m.end() && !m["NameInEnglish"].empty()) {
      nameInEnglish = make_shared<string>(boost::any_cast<string>(m["NameInEnglish"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetInstancesResponseBodyDataOriginatorName() = default;
};
class GetInstancesResponseBodyDataOriginator : public Darabonba::Model {
public:
  shared_ptr<string> deptName{};
  shared_ptr<string> email{};
  shared_ptr<GetInstancesResponseBodyDataOriginatorName> name{};
  shared_ptr<string> userId{};

  GetInstancesResponseBodyDataOriginator() {}

  explicit GetInstancesResponseBodyDataOriginator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deptName) {
      res["DeptName"] = boost::any(*deptName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (name) {
      res["Name"] = name ? boost::any(name->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeptName") != m.end() && !m["DeptName"].empty()) {
      deptName = make_shared<string>(boost::any_cast<string>(m["DeptName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      if (typeid(map<string, boost::any>) == m["Name"].type()) {
        GetInstancesResponseBodyDataOriginatorName model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Name"]));
        name = make_shared<GetInstancesResponseBodyDataOriginatorName>(model1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetInstancesResponseBodyDataOriginator() = default;
};
class GetInstancesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetInstancesResponseBodyDataActionExecutor>> actionExecutor{};
  shared_ptr<string> approvedResult{};
  shared_ptr<string> createTimeGMT{};
  shared_ptr<map<string, boost::any>> data{};
  shared_ptr<string> formUuid{};
  shared_ptr<string> instanceStatus{};
  shared_ptr<string> modifiedTimeGMT{};
  shared_ptr<GetInstancesResponseBodyDataOriginator> originator{};
  shared_ptr<string> processCode{};
  shared_ptr<string> processInstanceId{};
  shared_ptr<string> title{};
  shared_ptr<long> version{};

  GetInstancesResponseBodyData() {}

  explicit GetInstancesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionExecutor) {
      vector<boost::any> temp1;
      for(auto item1:*actionExecutor){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ActionExecutor"] = boost::any(temp1);
    }
    if (approvedResult) {
      res["ApprovedResult"] = boost::any(*approvedResult);
    }
    if (createTimeGMT) {
      res["CreateTimeGMT"] = boost::any(*createTimeGMT);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (instanceStatus) {
      res["InstanceStatus"] = boost::any(*instanceStatus);
    }
    if (modifiedTimeGMT) {
      res["ModifiedTimeGMT"] = boost::any(*modifiedTimeGMT);
    }
    if (originator) {
      res["Originator"] = originator ? boost::any(originator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (processCode) {
      res["ProcessCode"] = boost::any(*processCode);
    }
    if (processInstanceId) {
      res["ProcessInstanceId"] = boost::any(*processInstanceId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionExecutor") != m.end() && !m["ActionExecutor"].empty()) {
      if (typeid(vector<boost::any>) == m["ActionExecutor"].type()) {
        vector<GetInstancesResponseBodyDataActionExecutor> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ActionExecutor"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstancesResponseBodyDataActionExecutor model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        actionExecutor = make_shared<vector<GetInstancesResponseBodyDataActionExecutor>>(expect1);
      }
    }
    if (m.find("ApprovedResult") != m.end() && !m["ApprovedResult"].empty()) {
      approvedResult = make_shared<string>(boost::any_cast<string>(m["ApprovedResult"]));
    }
    if (m.find("CreateTimeGMT") != m.end() && !m["CreateTimeGMT"].empty()) {
      createTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateTimeGMT"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Data"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      data = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("InstanceStatus") != m.end() && !m["InstanceStatus"].empty()) {
      instanceStatus = make_shared<string>(boost::any_cast<string>(m["InstanceStatus"]));
    }
    if (m.find("ModifiedTimeGMT") != m.end() && !m["ModifiedTimeGMT"].empty()) {
      modifiedTimeGMT = make_shared<string>(boost::any_cast<string>(m["ModifiedTimeGMT"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      if (typeid(map<string, boost::any>) == m["Originator"].type()) {
        GetInstancesResponseBodyDataOriginator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Originator"]));
        originator = make_shared<GetInstancesResponseBodyDataOriginator>(model1);
      }
    }
    if (m.find("ProcessCode") != m.end() && !m["ProcessCode"].empty()) {
      processCode = make_shared<string>(boost::any_cast<string>(m["ProcessCode"]));
    }
    if (m.find("ProcessInstanceId") != m.end() && !m["ProcessInstanceId"].empty()) {
      processInstanceId = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~GetInstancesResponseBodyData() = default;
};
class GetInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetInstancesResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetInstancesResponseBody() {}

  explicit GetInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<GetInstancesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstancesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetInstancesResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetInstancesResponseBody() = default;
};
class GetInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInstancesResponseBody> body{};

  GetInstancesResponse() {}

  explicit GetInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstancesResponse() = default;
};
class GetInstancesByIdListHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetInstancesByIdListHeadersAccountContext() {}

  explicit GetInstancesByIdListHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetInstancesByIdListHeadersAccountContext() = default;
};
class GetInstancesByIdListHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetInstancesByIdListHeadersAccountContext> accountContext{};

  GetInstancesByIdListHeaders() {}

  explicit GetInstancesByIdListHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetInstancesByIdListHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetInstancesByIdListHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetInstancesByIdListHeaders() = default;
};
class GetInstancesByIdListShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetInstancesByIdListShrinkHeaders() {}

  explicit GetInstancesByIdListShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetInstancesByIdListShrinkHeaders() = default;
};
class GetInstancesByIdListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> language{};
  shared_ptr<string> processInstanceIds{};
  shared_ptr<string> systemToken{};

  GetInstancesByIdListRequest() {}

  explicit GetInstancesByIdListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (processInstanceIds) {
      res["ProcessInstanceIds"] = boost::any(*processInstanceIds);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("ProcessInstanceIds") != m.end() && !m["ProcessInstanceIds"].empty()) {
      processInstanceIds = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceIds"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~GetInstancesByIdListRequest() = default;
};
class GetInstancesByIdListResponseBodyResultActionExecutorName : public Darabonba::Model {
public:
  shared_ptr<string> nameInChinese{};
  shared_ptr<string> nameInEnglish{};
  shared_ptr<string> type{};

  GetInstancesByIdListResponseBodyResultActionExecutorName() {}

  explicit GetInstancesByIdListResponseBodyResultActionExecutorName(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameInChinese) {
      res["NameInChinese"] = boost::any(*nameInChinese);
    }
    if (nameInEnglish) {
      res["NameInEnglish"] = boost::any(*nameInEnglish);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameInChinese") != m.end() && !m["NameInChinese"].empty()) {
      nameInChinese = make_shared<string>(boost::any_cast<string>(m["NameInChinese"]));
    }
    if (m.find("NameInEnglish") != m.end() && !m["NameInEnglish"].empty()) {
      nameInEnglish = make_shared<string>(boost::any_cast<string>(m["NameInEnglish"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetInstancesByIdListResponseBodyResultActionExecutorName() = default;
};
class GetInstancesByIdListResponseBodyResultActionExecutor : public Darabonba::Model {
public:
  shared_ptr<string> departmentName{};
  shared_ptr<string> email{};
  shared_ptr<GetInstancesByIdListResponseBodyResultActionExecutorName> name{};
  shared_ptr<string> userId{};

  GetInstancesByIdListResponseBodyResultActionExecutor() {}

  explicit GetInstancesByIdListResponseBodyResultActionExecutor(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (departmentName) {
      res["DepartmentName"] = boost::any(*departmentName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (name) {
      res["Name"] = name ? boost::any(name->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DepartmentName") != m.end() && !m["DepartmentName"].empty()) {
      departmentName = make_shared<string>(boost::any_cast<string>(m["DepartmentName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      if (typeid(map<string, boost::any>) == m["Name"].type()) {
        GetInstancesByIdListResponseBodyResultActionExecutorName model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Name"]));
        name = make_shared<GetInstancesByIdListResponseBodyResultActionExecutorName>(model1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetInstancesByIdListResponseBodyResultActionExecutor() = default;
};
class GetInstancesByIdListResponseBodyResultOriginatorName : public Darabonba::Model {
public:
  shared_ptr<string> nameInChinese{};
  shared_ptr<string> nameInEnglish{};
  shared_ptr<string> type{};

  GetInstancesByIdListResponseBodyResultOriginatorName() {}

  explicit GetInstancesByIdListResponseBodyResultOriginatorName(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameInChinese) {
      res["NameInChinese"] = boost::any(*nameInChinese);
    }
    if (nameInEnglish) {
      res["NameInEnglish"] = boost::any(*nameInEnglish);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameInChinese") != m.end() && !m["NameInChinese"].empty()) {
      nameInChinese = make_shared<string>(boost::any_cast<string>(m["NameInChinese"]));
    }
    if (m.find("NameInEnglish") != m.end() && !m["NameInEnglish"].empty()) {
      nameInEnglish = make_shared<string>(boost::any_cast<string>(m["NameInEnglish"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetInstancesByIdListResponseBodyResultOriginatorName() = default;
};
class GetInstancesByIdListResponseBodyResultOriginator : public Darabonba::Model {
public:
  shared_ptr<string> departmentName{};
  shared_ptr<string> email{};
  shared_ptr<GetInstancesByIdListResponseBodyResultOriginatorName> name{};
  shared_ptr<string> userId{};

  GetInstancesByIdListResponseBodyResultOriginator() {}

  explicit GetInstancesByIdListResponseBodyResultOriginator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (departmentName) {
      res["DepartmentName"] = boost::any(*departmentName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (name) {
      res["Name"] = name ? boost::any(name->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DepartmentName") != m.end() && !m["DepartmentName"].empty()) {
      departmentName = make_shared<string>(boost::any_cast<string>(m["DepartmentName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      if (typeid(map<string, boost::any>) == m["Name"].type()) {
        GetInstancesByIdListResponseBodyResultOriginatorName model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Name"]));
        name = make_shared<GetInstancesByIdListResponseBodyResultOriginatorName>(model1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetInstancesByIdListResponseBodyResultOriginator() = default;
};
class GetInstancesByIdListResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetInstancesByIdListResponseBodyResultActionExecutor>> actionExecutor{};
  shared_ptr<string> approvedResult{};
  shared_ptr<map<string, boost::any>> data{};
  shared_ptr<string> formUuid{};
  shared_ptr<string> instanceStatus{};
  shared_ptr<GetInstancesByIdListResponseBodyResultOriginator> originator{};
  shared_ptr<string> processCode{};
  shared_ptr<string> processInstanceId{};
  shared_ptr<string> title{};

  GetInstancesByIdListResponseBodyResult() {}

  explicit GetInstancesByIdListResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionExecutor) {
      vector<boost::any> temp1;
      for(auto item1:*actionExecutor){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ActionExecutor"] = boost::any(temp1);
    }
    if (approvedResult) {
      res["ApprovedResult"] = boost::any(*approvedResult);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (instanceStatus) {
      res["InstanceStatus"] = boost::any(*instanceStatus);
    }
    if (originator) {
      res["Originator"] = originator ? boost::any(originator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (processCode) {
      res["ProcessCode"] = boost::any(*processCode);
    }
    if (processInstanceId) {
      res["ProcessInstanceId"] = boost::any(*processInstanceId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionExecutor") != m.end() && !m["ActionExecutor"].empty()) {
      if (typeid(vector<boost::any>) == m["ActionExecutor"].type()) {
        vector<GetInstancesByIdListResponseBodyResultActionExecutor> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ActionExecutor"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstancesByIdListResponseBodyResultActionExecutor model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        actionExecutor = make_shared<vector<GetInstancesByIdListResponseBodyResultActionExecutor>>(expect1);
      }
    }
    if (m.find("ApprovedResult") != m.end() && !m["ApprovedResult"].empty()) {
      approvedResult = make_shared<string>(boost::any_cast<string>(m["ApprovedResult"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Data"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      data = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("InstanceStatus") != m.end() && !m["InstanceStatus"].empty()) {
      instanceStatus = make_shared<string>(boost::any_cast<string>(m["InstanceStatus"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      if (typeid(map<string, boost::any>) == m["Originator"].type()) {
        GetInstancesByIdListResponseBodyResultOriginator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Originator"]));
        originator = make_shared<GetInstancesByIdListResponseBodyResultOriginator>(model1);
      }
    }
    if (m.find("ProcessCode") != m.end() && !m["ProcessCode"].empty()) {
      processCode = make_shared<string>(boost::any_cast<string>(m["ProcessCode"]));
    }
    if (m.find("ProcessInstanceId") != m.end() && !m["ProcessInstanceId"].empty()) {
      processInstanceId = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GetInstancesByIdListResponseBodyResult() = default;
};
class GetInstancesByIdListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetInstancesByIdListResponseBodyResult>> result{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetInstancesByIdListResponseBody() {}

  explicit GetInstancesByIdListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<GetInstancesByIdListResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstancesByIdListResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<GetInstancesByIdListResponseBodyResult>>(expect1);
      }
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetInstancesByIdListResponseBody() = default;
};
class GetInstancesByIdListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInstancesByIdListResponseBody> body{};

  GetInstancesByIdListResponse() {}

  explicit GetInstancesByIdListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstancesByIdListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstancesByIdListResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstancesByIdListResponse() = default;
};
class GetLiveReplayUrlHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetLiveReplayUrlHeadersAccountContext() {}

  explicit GetLiveReplayUrlHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetLiveReplayUrlHeadersAccountContext() = default;
};
class GetLiveReplayUrlHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetLiveReplayUrlHeadersAccountContext> accountContext{};

  GetLiveReplayUrlHeaders() {}

  explicit GetLiveReplayUrlHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetLiveReplayUrlHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetLiveReplayUrlHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetLiveReplayUrlHeaders() = default;
};
class GetLiveReplayUrlShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetLiveReplayUrlShrinkHeaders() {}

  explicit GetLiveReplayUrlShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetLiveReplayUrlShrinkHeaders() = default;
};
class GetLiveReplayUrlRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetLiveReplayUrlRequestTenantContext() {}

  explicit GetLiveReplayUrlRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetLiveReplayUrlRequestTenantContext() = default;
};
class GetLiveReplayUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveId{};
  shared_ptr<GetLiveReplayUrlRequestTenantContext> tenantContext{};

  GetLiveReplayUrlRequest() {}

  explicit GetLiveReplayUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveId) {
      res["LiveId"] = boost::any(*liveId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveId") != m.end() && !m["LiveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["LiveId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetLiveReplayUrlRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetLiveReplayUrlRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetLiveReplayUrlRequest() = default;
};
class GetLiveReplayUrlShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveId{};
  shared_ptr<string> tenantContextShrink{};

  GetLiveReplayUrlShrinkRequest() {}

  explicit GetLiveReplayUrlShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveId) {
      res["LiveId"] = boost::any(*liveId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveId") != m.end() && !m["LiveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["LiveId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetLiveReplayUrlShrinkRequest() = default;
};
class GetLiveReplayUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> replayUrl{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetLiveReplayUrlResponseBody() {}

  explicit GetLiveReplayUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (replayUrl) {
      res["replayUrl"] = boost::any(*replayUrl);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("replayUrl") != m.end() && !m["replayUrl"].empty()) {
      replayUrl = make_shared<string>(boost::any_cast<string>(m["replayUrl"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetLiveReplayUrlResponseBody() = default;
};
class GetLiveReplayUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLiveReplayUrlResponseBody> body{};

  GetLiveReplayUrlResponse() {}

  explicit GetLiveReplayUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLiveReplayUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLiveReplayUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetLiveReplayUrlResponse() = default;
};
class GetMeCorpSubmissionHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetMeCorpSubmissionHeadersAccountContext() {}

  explicit GetMeCorpSubmissionHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetMeCorpSubmissionHeadersAccountContext() = default;
};
class GetMeCorpSubmissionHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetMeCorpSubmissionHeadersAccountContext> accountContext{};

  GetMeCorpSubmissionHeaders() {}

  explicit GetMeCorpSubmissionHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetMeCorpSubmissionHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetMeCorpSubmissionHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetMeCorpSubmissionHeaders() = default;
};
class GetMeCorpSubmissionShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetMeCorpSubmissionShrinkHeaders() {}

  explicit GetMeCorpSubmissionShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetMeCorpSubmissionShrinkHeaders() = default;
};
class GetMeCorpSubmissionRequest : public Darabonba::Model {
public:
  shared_ptr<string> appTypes{};
  shared_ptr<string> corpId{};
  shared_ptr<long> createFromTimeGMT{};
  shared_ptr<long> createToTimeGMT{};
  shared_ptr<string> keyword{};
  shared_ptr<string> language{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> processCodes{};
  shared_ptr<string> token{};

  GetMeCorpSubmissionRequest() {}

  explicit GetMeCorpSubmissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appTypes) {
      res["AppTypes"] = boost::any(*appTypes);
    }
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (createFromTimeGMT) {
      res["CreateFromTimeGMT"] = boost::any(*createFromTimeGMT);
    }
    if (createToTimeGMT) {
      res["CreateToTimeGMT"] = boost::any(*createToTimeGMT);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (processCodes) {
      res["ProcessCodes"] = boost::any(*processCodes);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppTypes") != m.end() && !m["AppTypes"].empty()) {
      appTypes = make_shared<string>(boost::any_cast<string>(m["AppTypes"]));
    }
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("CreateFromTimeGMT") != m.end() && !m["CreateFromTimeGMT"].empty()) {
      createFromTimeGMT = make_shared<long>(boost::any_cast<long>(m["CreateFromTimeGMT"]));
    }
    if (m.find("CreateToTimeGMT") != m.end() && !m["CreateToTimeGMT"].empty()) {
      createToTimeGMT = make_shared<long>(boost::any_cast<long>(m["CreateToTimeGMT"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProcessCodes") != m.end() && !m["ProcessCodes"].empty()) {
      processCodes = make_shared<string>(boost::any_cast<string>(m["ProcessCodes"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~GetMeCorpSubmissionRequest() = default;
};
class GetMeCorpSubmissionResponseBodyDataActioner : public Darabonba::Model {
public:
  shared_ptr<string> buName{};
  shared_ptr<string> email{};
  shared_ptr<string> employeeType{};
  shared_ptr<string> employeeTypeInformation{};
  shared_ptr<string> humanResourceGroupWorkNumber{};
  shared_ptr<bool> isSystemAdmin{};
  shared_ptr<string> level{};
  shared_ptr<string> name{};
  shared_ptr<string> nickName{};
  shared_ptr<string> orderNumber{};
  shared_ptr<string> personalPhoto{};
  shared_ptr<string> personalPhotoUrl{};
  shared_ptr<string> pinyinNameAll{};
  shared_ptr<string> pinyinNickName{};
  shared_ptr<string> state{};
  shared_ptr<string> superUserId{};
  shared_ptr<string> tbWang{};
  shared_ptr<string> userId{};

  GetMeCorpSubmissionResponseBodyDataActioner() {}

  explicit GetMeCorpSubmissionResponseBodyDataActioner(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buName) {
      res["BuName"] = boost::any(*buName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (employeeType) {
      res["EmployeeType"] = boost::any(*employeeType);
    }
    if (employeeTypeInformation) {
      res["EmployeeTypeInformation"] = boost::any(*employeeTypeInformation);
    }
    if (humanResourceGroupWorkNumber) {
      res["HumanResourceGroupWorkNumber"] = boost::any(*humanResourceGroupWorkNumber);
    }
    if (isSystemAdmin) {
      res["IsSystemAdmin"] = boost::any(*isSystemAdmin);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (orderNumber) {
      res["OrderNumber"] = boost::any(*orderNumber);
    }
    if (personalPhoto) {
      res["PersonalPhoto"] = boost::any(*personalPhoto);
    }
    if (personalPhotoUrl) {
      res["PersonalPhotoUrl"] = boost::any(*personalPhotoUrl);
    }
    if (pinyinNameAll) {
      res["PinyinNameAll"] = boost::any(*pinyinNameAll);
    }
    if (pinyinNickName) {
      res["PinyinNickName"] = boost::any(*pinyinNickName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (superUserId) {
      res["SuperUserId"] = boost::any(*superUserId);
    }
    if (tbWang) {
      res["TbWang"] = boost::any(*tbWang);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BuName") != m.end() && !m["BuName"].empty()) {
      buName = make_shared<string>(boost::any_cast<string>(m["BuName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("EmployeeType") != m.end() && !m["EmployeeType"].empty()) {
      employeeType = make_shared<string>(boost::any_cast<string>(m["EmployeeType"]));
    }
    if (m.find("EmployeeTypeInformation") != m.end() && !m["EmployeeTypeInformation"].empty()) {
      employeeTypeInformation = make_shared<string>(boost::any_cast<string>(m["EmployeeTypeInformation"]));
    }
    if (m.find("HumanResourceGroupWorkNumber") != m.end() && !m["HumanResourceGroupWorkNumber"].empty()) {
      humanResourceGroupWorkNumber = make_shared<string>(boost::any_cast<string>(m["HumanResourceGroupWorkNumber"]));
    }
    if (m.find("IsSystemAdmin") != m.end() && !m["IsSystemAdmin"].empty()) {
      isSystemAdmin = make_shared<bool>(boost::any_cast<bool>(m["IsSystemAdmin"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("OrderNumber") != m.end() && !m["OrderNumber"].empty()) {
      orderNumber = make_shared<string>(boost::any_cast<string>(m["OrderNumber"]));
    }
    if (m.find("PersonalPhoto") != m.end() && !m["PersonalPhoto"].empty()) {
      personalPhoto = make_shared<string>(boost::any_cast<string>(m["PersonalPhoto"]));
    }
    if (m.find("PersonalPhotoUrl") != m.end() && !m["PersonalPhotoUrl"].empty()) {
      personalPhotoUrl = make_shared<string>(boost::any_cast<string>(m["PersonalPhotoUrl"]));
    }
    if (m.find("PinyinNameAll") != m.end() && !m["PinyinNameAll"].empty()) {
      pinyinNameAll = make_shared<string>(boost::any_cast<string>(m["PinyinNameAll"]));
    }
    if (m.find("PinyinNickName") != m.end() && !m["PinyinNickName"].empty()) {
      pinyinNickName = make_shared<string>(boost::any_cast<string>(m["PinyinNickName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("SuperUserId") != m.end() && !m["SuperUserId"].empty()) {
      superUserId = make_shared<string>(boost::any_cast<string>(m["SuperUserId"]));
    }
    if (m.find("TbWang") != m.end() && !m["TbWang"].empty()) {
      tbWang = make_shared<string>(boost::any_cast<string>(m["TbWang"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetMeCorpSubmissionResponseBodyDataActioner() = default;
};
class GetMeCorpSubmissionResponseBodyDataCurrentActivityInstances : public Darabonba::Model {
public:
  shared_ptr<string> activityId{};
  shared_ptr<string> activityInstanceStatus{};
  shared_ptr<string> activityName{};
  shared_ptr<string> activityNameEn{};
  shared_ptr<long> id{};

  GetMeCorpSubmissionResponseBodyDataCurrentActivityInstances() {}

  explicit GetMeCorpSubmissionResponseBodyDataCurrentActivityInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityId) {
      res["ActivityId"] = boost::any(*activityId);
    }
    if (activityInstanceStatus) {
      res["ActivityInstanceStatus"] = boost::any(*activityInstanceStatus);
    }
    if (activityName) {
      res["ActivityName"] = boost::any(*activityName);
    }
    if (activityNameEn) {
      res["ActivityNameEn"] = boost::any(*activityNameEn);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityId") != m.end() && !m["ActivityId"].empty()) {
      activityId = make_shared<string>(boost::any_cast<string>(m["ActivityId"]));
    }
    if (m.find("ActivityInstanceStatus") != m.end() && !m["ActivityInstanceStatus"].empty()) {
      activityInstanceStatus = make_shared<string>(boost::any_cast<string>(m["ActivityInstanceStatus"]));
    }
    if (m.find("ActivityName") != m.end() && !m["ActivityName"].empty()) {
      activityName = make_shared<string>(boost::any_cast<string>(m["ActivityName"]));
    }
    if (m.find("ActivityNameEn") != m.end() && !m["ActivityNameEn"].empty()) {
      activityNameEn = make_shared<string>(boost::any_cast<string>(m["ActivityNameEn"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetMeCorpSubmissionResponseBodyDataCurrentActivityInstances() = default;
};
class GetMeCorpSubmissionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetMeCorpSubmissionResponseBodyDataActioner>> actioner{};
  shared_ptr<vector<string>> actionerId{};
  shared_ptr<vector<string>> actionerName{};
  shared_ptr<string> appType{};
  shared_ptr<string> createTimeGMT{};
  shared_ptr<vector<GetMeCorpSubmissionResponseBodyDataCurrentActivityInstances>> currentActivityInstances{};
  shared_ptr<map<string, boost::any>> dataMap{};
  shared_ptr<string> dataType{};
  shared_ptr<string> finishTimeGMT{};
  shared_ptr<string> formInstanceId{};
  shared_ptr<string> formUuid{};
  shared_ptr<string> instanceValue{};
  shared_ptr<string> modifiedTimeGMT{};
  shared_ptr<string> originatorAvatar{};
  shared_ptr<string> originatorDisplayName{};
  shared_ptr<string> originatorId{};
  shared_ptr<string> processApprovedResult{};
  shared_ptr<string> processApprovedResultText{};
  shared_ptr<string> processCode{};
  shared_ptr<long> processId{};
  shared_ptr<string> processInstanceId{};
  shared_ptr<string> processInstanceStatus{};
  shared_ptr<string> processInstanceStatusText{};
  shared_ptr<string> processName{};
  shared_ptr<string> title{};
  shared_ptr<long> version{};

  GetMeCorpSubmissionResponseBodyData() {}

  explicit GetMeCorpSubmissionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actioner) {
      vector<boost::any> temp1;
      for(auto item1:*actioner){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Actioner"] = boost::any(temp1);
    }
    if (actionerId) {
      res["ActionerId"] = boost::any(*actionerId);
    }
    if (actionerName) {
      res["ActionerName"] = boost::any(*actionerName);
    }
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (createTimeGMT) {
      res["CreateTimeGMT"] = boost::any(*createTimeGMT);
    }
    if (currentActivityInstances) {
      vector<boost::any> temp1;
      for(auto item1:*currentActivityInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CurrentActivityInstances"] = boost::any(temp1);
    }
    if (dataMap) {
      res["DataMap"] = boost::any(*dataMap);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (finishTimeGMT) {
      res["FinishTimeGMT"] = boost::any(*finishTimeGMT);
    }
    if (formInstanceId) {
      res["FormInstanceId"] = boost::any(*formInstanceId);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (instanceValue) {
      res["InstanceValue"] = boost::any(*instanceValue);
    }
    if (modifiedTimeGMT) {
      res["ModifiedTimeGMT"] = boost::any(*modifiedTimeGMT);
    }
    if (originatorAvatar) {
      res["OriginatorAvatar"] = boost::any(*originatorAvatar);
    }
    if (originatorDisplayName) {
      res["OriginatorDisplayName"] = boost::any(*originatorDisplayName);
    }
    if (originatorId) {
      res["OriginatorId"] = boost::any(*originatorId);
    }
    if (processApprovedResult) {
      res["ProcessApprovedResult"] = boost::any(*processApprovedResult);
    }
    if (processApprovedResultText) {
      res["ProcessApprovedResultText"] = boost::any(*processApprovedResultText);
    }
    if (processCode) {
      res["ProcessCode"] = boost::any(*processCode);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    if (processInstanceId) {
      res["ProcessInstanceId"] = boost::any(*processInstanceId);
    }
    if (processInstanceStatus) {
      res["ProcessInstanceStatus"] = boost::any(*processInstanceStatus);
    }
    if (processInstanceStatusText) {
      res["ProcessInstanceStatusText"] = boost::any(*processInstanceStatusText);
    }
    if (processName) {
      res["ProcessName"] = boost::any(*processName);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Actioner") != m.end() && !m["Actioner"].empty()) {
      if (typeid(vector<boost::any>) == m["Actioner"].type()) {
        vector<GetMeCorpSubmissionResponseBodyDataActioner> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Actioner"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMeCorpSubmissionResponseBodyDataActioner model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        actioner = make_shared<vector<GetMeCorpSubmissionResponseBodyDataActioner>>(expect1);
      }
    }
    if (m.find("ActionerId") != m.end() && !m["ActionerId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ActionerId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ActionerId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      actionerId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ActionerName") != m.end() && !m["ActionerName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ActionerName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ActionerName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      actionerName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("CreateTimeGMT") != m.end() && !m["CreateTimeGMT"].empty()) {
      createTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateTimeGMT"]));
    }
    if (m.find("CurrentActivityInstances") != m.end() && !m["CurrentActivityInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["CurrentActivityInstances"].type()) {
        vector<GetMeCorpSubmissionResponseBodyDataCurrentActivityInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CurrentActivityInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMeCorpSubmissionResponseBodyDataCurrentActivityInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        currentActivityInstances = make_shared<vector<GetMeCorpSubmissionResponseBodyDataCurrentActivityInstances>>(expect1);
      }
    }
    if (m.find("DataMap") != m.end() && !m["DataMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["DataMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      dataMap = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("FinishTimeGMT") != m.end() && !m["FinishTimeGMT"].empty()) {
      finishTimeGMT = make_shared<string>(boost::any_cast<string>(m["FinishTimeGMT"]));
    }
    if (m.find("FormInstanceId") != m.end() && !m["FormInstanceId"].empty()) {
      formInstanceId = make_shared<string>(boost::any_cast<string>(m["FormInstanceId"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("InstanceValue") != m.end() && !m["InstanceValue"].empty()) {
      instanceValue = make_shared<string>(boost::any_cast<string>(m["InstanceValue"]));
    }
    if (m.find("ModifiedTimeGMT") != m.end() && !m["ModifiedTimeGMT"].empty()) {
      modifiedTimeGMT = make_shared<string>(boost::any_cast<string>(m["ModifiedTimeGMT"]));
    }
    if (m.find("OriginatorAvatar") != m.end() && !m["OriginatorAvatar"].empty()) {
      originatorAvatar = make_shared<string>(boost::any_cast<string>(m["OriginatorAvatar"]));
    }
    if (m.find("OriginatorDisplayName") != m.end() && !m["OriginatorDisplayName"].empty()) {
      originatorDisplayName = make_shared<string>(boost::any_cast<string>(m["OriginatorDisplayName"]));
    }
    if (m.find("OriginatorId") != m.end() && !m["OriginatorId"].empty()) {
      originatorId = make_shared<string>(boost::any_cast<string>(m["OriginatorId"]));
    }
    if (m.find("ProcessApprovedResult") != m.end() && !m["ProcessApprovedResult"].empty()) {
      processApprovedResult = make_shared<string>(boost::any_cast<string>(m["ProcessApprovedResult"]));
    }
    if (m.find("ProcessApprovedResultText") != m.end() && !m["ProcessApprovedResultText"].empty()) {
      processApprovedResultText = make_shared<string>(boost::any_cast<string>(m["ProcessApprovedResultText"]));
    }
    if (m.find("ProcessCode") != m.end() && !m["ProcessCode"].empty()) {
      processCode = make_shared<string>(boost::any_cast<string>(m["ProcessCode"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<long>(boost::any_cast<long>(m["ProcessId"]));
    }
    if (m.find("ProcessInstanceId") != m.end() && !m["ProcessInstanceId"].empty()) {
      processInstanceId = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceId"]));
    }
    if (m.find("ProcessInstanceStatus") != m.end() && !m["ProcessInstanceStatus"].empty()) {
      processInstanceStatus = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceStatus"]));
    }
    if (m.find("ProcessInstanceStatusText") != m.end() && !m["ProcessInstanceStatusText"].empty()) {
      processInstanceStatusText = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceStatusText"]));
    }
    if (m.find("ProcessName") != m.end() && !m["ProcessName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["ProcessName"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~GetMeCorpSubmissionResponseBodyData() = default;
};
class GetMeCorpSubmissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetMeCorpSubmissionResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetMeCorpSubmissionResponseBody() {}

  explicit GetMeCorpSubmissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<GetMeCorpSubmissionResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMeCorpSubmissionResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetMeCorpSubmissionResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetMeCorpSubmissionResponseBody() = default;
};
class GetMeCorpSubmissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMeCorpSubmissionResponseBody> body{};

  GetMeCorpSubmissionResponse() {}

  explicit GetMeCorpSubmissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMeCorpSubmissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMeCorpSubmissionResponseBody>(model1);
      }
    }
  }


  virtual ~GetMeCorpSubmissionResponse() = default;
};
class GetMeetingRoomsScheduleHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetMeetingRoomsScheduleHeadersAccountContext() {}

  explicit GetMeetingRoomsScheduleHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetMeetingRoomsScheduleHeadersAccountContext() = default;
};
class GetMeetingRoomsScheduleHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetMeetingRoomsScheduleHeadersAccountContext> accountContext{};

  GetMeetingRoomsScheduleHeaders() {}

  explicit GetMeetingRoomsScheduleHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetMeetingRoomsScheduleHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetMeetingRoomsScheduleHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetMeetingRoomsScheduleHeaders() = default;
};
class GetMeetingRoomsScheduleShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetMeetingRoomsScheduleShrinkHeaders() {}

  explicit GetMeetingRoomsScheduleShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetMeetingRoomsScheduleShrinkHeaders() = default;
};
class GetMeetingRoomsScheduleRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<vector<string>> roomIds{};
  shared_ptr<string> startTime{};

  GetMeetingRoomsScheduleRequest() {}

  explicit GetMeetingRoomsScheduleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (roomIds) {
      res["RoomIds"] = boost::any(*roomIds);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RoomIds") != m.end() && !m["RoomIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RoomIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoomIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roomIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~GetMeetingRoomsScheduleRequest() = default;
};
class GetMeetingRoomsScheduleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> roomIdsShrink{};
  shared_ptr<string> startTime{};

  GetMeetingRoomsScheduleShrinkRequest() {}

  explicit GetMeetingRoomsScheduleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (roomIdsShrink) {
      res["RoomIds"] = boost::any(*roomIdsShrink);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RoomIds") != m.end() && !m["RoomIds"].empty()) {
      roomIdsShrink = make_shared<string>(boost::any_cast<string>(m["RoomIds"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~GetMeetingRoomsScheduleShrinkRequest() = default;
};
class GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsEnd : public Darabonba::Model {
public:
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsEnd() {}

  explicit GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsEnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsEnd() = default;
};
class GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsOrganizer : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsOrganizer() {}

  explicit GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsOrganizer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsOrganizer() = default;
};
class GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsStart : public Darabonba::Model {
public:
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsStart() {}

  explicit GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsStart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsStart() = default;
};
class GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItems : public Darabonba::Model {
public:
  shared_ptr<GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsEnd> end{};
  shared_ptr<string> eventId{};
  shared_ptr<GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsOrganizer> organizer{};
  shared_ptr<GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsStart> start{};
  shared_ptr<string> status{};

  GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItems() {}

  explicit GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = end ? boost::any(end->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (organizer) {
      res["Organizer"] = organizer ? boost::any(organizer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (start) {
      res["Start"] = start ? boost::any(start->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      if (typeid(map<string, boost::any>) == m["End"].type()) {
        GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsEnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["End"]));
        end = make_shared<GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsEnd>(model1);
      }
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("Organizer") != m.end() && !m["Organizer"].empty()) {
      if (typeid(map<string, boost::any>) == m["Organizer"].type()) {
        GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsOrganizer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Organizer"]));
        organizer = make_shared<GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsOrganizer>(model1);
      }
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      if (typeid(map<string, boost::any>) == m["Start"].type()) {
        GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsStart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Start"]));
        start = make_shared<GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItemsStart>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItems() = default;
};
class GetMeetingRoomsScheduleResponseBodyScheduleInformation : public Darabonba::Model {
public:
  shared_ptr<string> error{};
  shared_ptr<string> roomId{};
  shared_ptr<vector<GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItems>> scheduleItems{};

  GetMeetingRoomsScheduleResponseBodyScheduleInformation() {}

  explicit GetMeetingRoomsScheduleResponseBodyScheduleInformation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    if (scheduleItems) {
      vector<boost::any> temp1;
      for(auto item1:*scheduleItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScheduleItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<string>(boost::any_cast<string>(m["Error"]));
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
    if (m.find("ScheduleItems") != m.end() && !m["ScheduleItems"].empty()) {
      if (typeid(vector<boost::any>) == m["ScheduleItems"].type()) {
        vector<GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScheduleItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scheduleItems = make_shared<vector<GetMeetingRoomsScheduleResponseBodyScheduleInformationScheduleItems>>(expect1);
      }
    }
  }


  virtual ~GetMeetingRoomsScheduleResponseBodyScheduleInformation() = default;
};
class GetMeetingRoomsScheduleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetMeetingRoomsScheduleResponseBodyScheduleInformation>> scheduleInformation{};

  GetMeetingRoomsScheduleResponseBody() {}

  explicit GetMeetingRoomsScheduleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (scheduleInformation) {
      vector<boost::any> temp1;
      for(auto item1:*scheduleInformation){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["scheduleInformation"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("scheduleInformation") != m.end() && !m["scheduleInformation"].empty()) {
      if (typeid(vector<boost::any>) == m["scheduleInformation"].type()) {
        vector<GetMeetingRoomsScheduleResponseBodyScheduleInformation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["scheduleInformation"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMeetingRoomsScheduleResponseBodyScheduleInformation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scheduleInformation = make_shared<vector<GetMeetingRoomsScheduleResponseBodyScheduleInformation>>(expect1);
      }
    }
  }


  virtual ~GetMeetingRoomsScheduleResponseBody() = default;
};
class GetMeetingRoomsScheduleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMeetingRoomsScheduleResponseBody> body{};

  GetMeetingRoomsScheduleResponse() {}

  explicit GetMeetingRoomsScheduleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMeetingRoomsScheduleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMeetingRoomsScheduleResponseBody>(model1);
      }
    }
  }


  virtual ~GetMeetingRoomsScheduleResponse() = default;
};
class GetMineWorkspaceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetMineWorkspaceHeadersAccountContext() {}

  explicit GetMineWorkspaceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetMineWorkspaceHeadersAccountContext() = default;
};
class GetMineWorkspaceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetMineWorkspaceHeadersAccountContext> accountContext{};

  GetMineWorkspaceHeaders() {}

  explicit GetMineWorkspaceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetMineWorkspaceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetMineWorkspaceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetMineWorkspaceHeaders() = default;
};
class GetMineWorkspaceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetMineWorkspaceShrinkHeaders() {}

  explicit GetMineWorkspaceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetMineWorkspaceShrinkHeaders() = default;
};
class GetMineWorkspaceRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetMineWorkspaceRequestTenantContext() {}

  explicit GetMineWorkspaceRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetMineWorkspaceRequestTenantContext() = default;
};
class GetMineWorkspaceRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> request{};
  shared_ptr<GetMineWorkspaceRequestTenantContext> tenantContext{};

  GetMineWorkspaceRequest() {}

  explicit GetMineWorkspaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (request) {
      res["Request"] = boost::any(*request);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Request") != m.end() && !m["Request"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Request"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      request = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetMineWorkspaceRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetMineWorkspaceRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetMineWorkspaceRequest() = default;
};
class GetMineWorkspaceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> requestShrink{};
  shared_ptr<string> tenantContextShrink{};

  GetMineWorkspaceShrinkRequest() {}

  explicit GetMineWorkspaceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestShrink) {
      res["Request"] = boost::any(*requestShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Request") != m.end() && !m["Request"].empty()) {
      requestShrink = make_shared<string>(boost::any_cast<string>(m["Request"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetMineWorkspaceShrinkRequest() = default;
};
class GetMineWorkspaceResponseBodyWorkspaceIcon : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  GetMineWorkspaceResponseBodyWorkspaceIcon() {}

  explicit GetMineWorkspaceResponseBodyWorkspaceIcon(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetMineWorkspaceResponseBodyWorkspaceIcon() = default;
};
class GetMineWorkspaceResponseBodyWorkspace : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<string> cover{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<GetMineWorkspaceResponseBodyWorkspaceIcon> icon{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> name{};
  shared_ptr<string> permissionRole{};
  shared_ptr<string> rootNodeId{};
  shared_ptr<string> teamId{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  GetMineWorkspaceResponseBodyWorkspace() {}

  explicit GetMineWorkspaceResponseBodyWorkspace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (cover) {
      res["Cover"] = boost::any(*cover);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (icon) {
      res["Icon"] = icon ? boost::any(icon->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (permissionRole) {
      res["PermissionRole"] = boost::any(*permissionRole);
    }
    if (rootNodeId) {
      res["RootNodeId"] = boost::any(*rootNodeId);
    }
    if (teamId) {
      res["TeamId"] = boost::any(*teamId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      cover = make_shared<string>(boost::any_cast<string>(m["Cover"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      if (typeid(map<string, boost::any>) == m["Icon"].type()) {
        GetMineWorkspaceResponseBodyWorkspaceIcon model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Icon"]));
        icon = make_shared<GetMineWorkspaceResponseBodyWorkspaceIcon>(model1);
      }
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["ModifierId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PermissionRole") != m.end() && !m["PermissionRole"].empty()) {
      permissionRole = make_shared<string>(boost::any_cast<string>(m["PermissionRole"]));
    }
    if (m.find("RootNodeId") != m.end() && !m["RootNodeId"].empty()) {
      rootNodeId = make_shared<string>(boost::any_cast<string>(m["RootNodeId"]));
    }
    if (m.find("TeamId") != m.end() && !m["TeamId"].empty()) {
      teamId = make_shared<string>(boost::any_cast<string>(m["TeamId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetMineWorkspaceResponseBodyWorkspace() = default;
};
class GetMineWorkspaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetMineWorkspaceResponseBodyWorkspace> workspace{};

  GetMineWorkspaceResponseBody() {}

  explicit GetMineWorkspaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (workspace) {
      res["workspace"] = workspace ? boost::any(workspace->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("workspace") != m.end() && !m["workspace"].empty()) {
      if (typeid(map<string, boost::any>) == m["workspace"].type()) {
        GetMineWorkspaceResponseBodyWorkspace model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["workspace"]));
        workspace = make_shared<GetMineWorkspaceResponseBodyWorkspace>(model1);
      }
    }
  }


  virtual ~GetMineWorkspaceResponseBody() = default;
};
class GetMineWorkspaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMineWorkspaceResponseBody> body{};

  GetMineWorkspaceResponse() {}

  explicit GetMineWorkspaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMineWorkspaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMineWorkspaceResponseBody>(model1);
      }
    }
  }


  virtual ~GetMineWorkspaceResponse() = default;
};
class GetMultiDimTableAllFieldsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetMultiDimTableAllFieldsHeadersAccountContext() {}

  explicit GetMultiDimTableAllFieldsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetMultiDimTableAllFieldsHeadersAccountContext() = default;
};
class GetMultiDimTableAllFieldsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetMultiDimTableAllFieldsHeadersAccountContext> accountContext{};

  GetMultiDimTableAllFieldsHeaders() {}

  explicit GetMultiDimTableAllFieldsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetMultiDimTableAllFieldsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetMultiDimTableAllFieldsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetMultiDimTableAllFieldsHeaders() = default;
};
class GetMultiDimTableAllFieldsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetMultiDimTableAllFieldsShrinkHeaders() {}

  explicit GetMultiDimTableAllFieldsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetMultiDimTableAllFieldsShrinkHeaders() = default;
};
class GetMultiDimTableAllFieldsRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetMultiDimTableAllFieldsRequestTenantContext() {}

  explicit GetMultiDimTableAllFieldsRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetMultiDimTableAllFieldsRequestTenantContext() = default;
};
class GetMultiDimTableAllFieldsRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<string> sheetIdOrName{};
  shared_ptr<GetMultiDimTableAllFieldsRequestTenantContext> tenantContext{};

  GetMultiDimTableAllFieldsRequest() {}

  explicit GetMultiDimTableAllFieldsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (sheetIdOrName) {
      res["SheetIdOrName"] = boost::any(*sheetIdOrName);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("SheetIdOrName") != m.end() && !m["SheetIdOrName"].empty()) {
      sheetIdOrName = make_shared<string>(boost::any_cast<string>(m["SheetIdOrName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetMultiDimTableAllFieldsRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetMultiDimTableAllFieldsRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetMultiDimTableAllFieldsRequest() = default;
};
class GetMultiDimTableAllFieldsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<string> sheetIdOrName{};
  shared_ptr<string> tenantContextShrink{};

  GetMultiDimTableAllFieldsShrinkRequest() {}

  explicit GetMultiDimTableAllFieldsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (sheetIdOrName) {
      res["SheetIdOrName"] = boost::any(*sheetIdOrName);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("SheetIdOrName") != m.end() && !m["SheetIdOrName"].empty()) {
      sheetIdOrName = make_shared<string>(boost::any_cast<string>(m["SheetIdOrName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetMultiDimTableAllFieldsShrinkRequest() = default;
};
class GetMultiDimTableAllFieldsResponseBodyValue : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<map<string, boost::any>> property{};
  shared_ptr<string> type{};

  GetMultiDimTableAllFieldsResponseBodyValue() {}

  explicit GetMultiDimTableAllFieldsResponseBodyValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (property) {
      res["Property"] = boost::any(*property);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Property"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      property = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetMultiDimTableAllFieldsResponseBodyValue() = default;
};
class GetMultiDimTableAllFieldsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetMultiDimTableAllFieldsResponseBodyValue>> value{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetMultiDimTableAllFieldsResponseBody() {}

  explicit GetMultiDimTableAllFieldsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (value) {
      vector<boost::any> temp1;
      for(auto item1:*value){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["value"] = boost::any(temp1);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      if (typeid(vector<boost::any>) == m["value"].type()) {
        vector<GetMultiDimTableAllFieldsResponseBodyValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["value"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMultiDimTableAllFieldsResponseBodyValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        value = make_shared<vector<GetMultiDimTableAllFieldsResponseBodyValue>>(expect1);
      }
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetMultiDimTableAllFieldsResponseBody() = default;
};
class GetMultiDimTableAllFieldsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMultiDimTableAllFieldsResponseBody> body{};

  GetMultiDimTableAllFieldsResponse() {}

  explicit GetMultiDimTableAllFieldsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMultiDimTableAllFieldsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMultiDimTableAllFieldsResponseBody>(model1);
      }
    }
  }


  virtual ~GetMultiDimTableAllFieldsResponse() = default;
};
class GetMultiDimTableAllSheetsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetMultiDimTableAllSheetsHeadersAccountContext() {}

  explicit GetMultiDimTableAllSheetsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetMultiDimTableAllSheetsHeadersAccountContext() = default;
};
class GetMultiDimTableAllSheetsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetMultiDimTableAllSheetsHeadersAccountContext> accountContext{};

  GetMultiDimTableAllSheetsHeaders() {}

  explicit GetMultiDimTableAllSheetsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetMultiDimTableAllSheetsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetMultiDimTableAllSheetsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetMultiDimTableAllSheetsHeaders() = default;
};
class GetMultiDimTableAllSheetsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetMultiDimTableAllSheetsShrinkHeaders() {}

  explicit GetMultiDimTableAllSheetsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetMultiDimTableAllSheetsShrinkHeaders() = default;
};
class GetMultiDimTableAllSheetsRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetMultiDimTableAllSheetsRequestTenantContext() {}

  explicit GetMultiDimTableAllSheetsRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetMultiDimTableAllSheetsRequestTenantContext() = default;
};
class GetMultiDimTableAllSheetsRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<GetMultiDimTableAllSheetsRequestTenantContext> tenantContext{};

  GetMultiDimTableAllSheetsRequest() {}

  explicit GetMultiDimTableAllSheetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetMultiDimTableAllSheetsRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetMultiDimTableAllSheetsRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetMultiDimTableAllSheetsRequest() = default;
};
class GetMultiDimTableAllSheetsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<string> tenantContextShrink{};

  GetMultiDimTableAllSheetsShrinkRequest() {}

  explicit GetMultiDimTableAllSheetsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetMultiDimTableAllSheetsShrinkRequest() = default;
};
class GetMultiDimTableAllSheetsResponseBodyValue : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  GetMultiDimTableAllSheetsResponseBodyValue() {}

  explicit GetMultiDimTableAllSheetsResponseBodyValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetMultiDimTableAllSheetsResponseBodyValue() = default;
};
class GetMultiDimTableAllSheetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetMultiDimTableAllSheetsResponseBodyValue>> value{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetMultiDimTableAllSheetsResponseBody() {}

  explicit GetMultiDimTableAllSheetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (value) {
      vector<boost::any> temp1;
      for(auto item1:*value){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["value"] = boost::any(temp1);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      if (typeid(vector<boost::any>) == m["value"].type()) {
        vector<GetMultiDimTableAllSheetsResponseBodyValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["value"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMultiDimTableAllSheetsResponseBodyValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        value = make_shared<vector<GetMultiDimTableAllSheetsResponseBodyValue>>(expect1);
      }
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetMultiDimTableAllSheetsResponseBody() = default;
};
class GetMultiDimTableAllSheetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMultiDimTableAllSheetsResponseBody> body{};

  GetMultiDimTableAllSheetsResponse() {}

  explicit GetMultiDimTableAllSheetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMultiDimTableAllSheetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMultiDimTableAllSheetsResponseBody>(model1);
      }
    }
  }


  virtual ~GetMultiDimTableAllSheetsResponse() = default;
};
class GetMultiDimTableRecordHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetMultiDimTableRecordHeadersAccountContext() {}

  explicit GetMultiDimTableRecordHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetMultiDimTableRecordHeadersAccountContext() = default;
};
class GetMultiDimTableRecordHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetMultiDimTableRecordHeadersAccountContext> accountContext{};

  GetMultiDimTableRecordHeaders() {}

  explicit GetMultiDimTableRecordHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetMultiDimTableRecordHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetMultiDimTableRecordHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetMultiDimTableRecordHeaders() = default;
};
class GetMultiDimTableRecordShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetMultiDimTableRecordShrinkHeaders() {}

  explicit GetMultiDimTableRecordShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetMultiDimTableRecordShrinkHeaders() = default;
};
class GetMultiDimTableRecordRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetMultiDimTableRecordRequestTenantContext() {}

  explicit GetMultiDimTableRecordRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetMultiDimTableRecordRequestTenantContext() = default;
};
class GetMultiDimTableRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<string> recordId{};
  shared_ptr<string> sheetIdOrName{};
  shared_ptr<GetMultiDimTableRecordRequestTenantContext> tenantContext{};

  GetMultiDimTableRecordRequest() {}

  explicit GetMultiDimTableRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (sheetIdOrName) {
      res["SheetIdOrName"] = boost::any(*sheetIdOrName);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("SheetIdOrName") != m.end() && !m["SheetIdOrName"].empty()) {
      sheetIdOrName = make_shared<string>(boost::any_cast<string>(m["SheetIdOrName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetMultiDimTableRecordRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetMultiDimTableRecordRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetMultiDimTableRecordRequest() = default;
};
class GetMultiDimTableRecordShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<string> recordId{};
  shared_ptr<string> sheetIdOrName{};
  shared_ptr<string> tenantContextShrink{};

  GetMultiDimTableRecordShrinkRequest() {}

  explicit GetMultiDimTableRecordShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (sheetIdOrName) {
      res["SheetIdOrName"] = boost::any(*sheetIdOrName);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("SheetIdOrName") != m.end() && !m["SheetIdOrName"].empty()) {
      sheetIdOrName = make_shared<string>(boost::any_cast<string>(m["SheetIdOrName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetMultiDimTableRecordShrinkRequest() = default;
};
class GetMultiDimTableRecordResponseBodyCreatedBy : public Darabonba::Model {
public:
  shared_ptr<string> userId{};

  GetMultiDimTableRecordResponseBodyCreatedBy() {}

  explicit GetMultiDimTableRecordResponseBodyCreatedBy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetMultiDimTableRecordResponseBodyCreatedBy() = default;
};
class GetMultiDimTableRecordResponseBodyLastModifiedBy : public Darabonba::Model {
public:
  shared_ptr<string> userId{};

  GetMultiDimTableRecordResponseBodyLastModifiedBy() {}

  explicit GetMultiDimTableRecordResponseBodyLastModifiedBy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetMultiDimTableRecordResponseBodyLastModifiedBy() = default;
};
class GetMultiDimTableRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMultiDimTableRecordResponseBodyCreatedBy> createdBy{};
  shared_ptr<long> createdTime{};
  shared_ptr<map<string, boost::any>> fields{};
  shared_ptr<string> id{};
  shared_ptr<GetMultiDimTableRecordResponseBodyLastModifiedBy> lastModifiedBy{};
  shared_ptr<long> lastModifiedTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetMultiDimTableRecordResponseBody() {}

  explicit GetMultiDimTableRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdBy) {
      res["CreatedBy"] = createdBy ? boost::any(createdBy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (fields) {
      res["Fields"] = boost::any(*fields);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastModifiedBy) {
      res["LastModifiedBy"] = lastModifiedBy ? boost::any(lastModifiedBy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (lastModifiedTime) {
      res["LastModifiedTime"] = boost::any(*lastModifiedTime);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedBy") != m.end() && !m["CreatedBy"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreatedBy"].type()) {
        GetMultiDimTableRecordResponseBodyCreatedBy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreatedBy"]));
        createdBy = make_shared<GetMultiDimTableRecordResponseBodyCreatedBy>(model1);
      }
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("Fields") != m.end() && !m["Fields"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Fields"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      fields = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LastModifiedBy") != m.end() && !m["LastModifiedBy"].empty()) {
      if (typeid(map<string, boost::any>) == m["LastModifiedBy"].type()) {
        GetMultiDimTableRecordResponseBodyLastModifiedBy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LastModifiedBy"]));
        lastModifiedBy = make_shared<GetMultiDimTableRecordResponseBodyLastModifiedBy>(model1);
      }
    }
    if (m.find("LastModifiedTime") != m.end() && !m["LastModifiedTime"].empty()) {
      lastModifiedTime = make_shared<long>(boost::any_cast<long>(m["LastModifiedTime"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetMultiDimTableRecordResponseBody() = default;
};
class GetMultiDimTableRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMultiDimTableRecordResponseBody> body{};

  GetMultiDimTableRecordResponse() {}

  explicit GetMultiDimTableRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMultiDimTableRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMultiDimTableRecordResponseBody>(model1);
      }
    }
  }


  virtual ~GetMultiDimTableRecordResponse() = default;
};
class GetMultiDimTableSheetHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetMultiDimTableSheetHeadersAccountContext() {}

  explicit GetMultiDimTableSheetHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetMultiDimTableSheetHeadersAccountContext() = default;
};
class GetMultiDimTableSheetHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetMultiDimTableSheetHeadersAccountContext> accountContext{};

  GetMultiDimTableSheetHeaders() {}

  explicit GetMultiDimTableSheetHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetMultiDimTableSheetHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetMultiDimTableSheetHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetMultiDimTableSheetHeaders() = default;
};
class GetMultiDimTableSheetShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetMultiDimTableSheetShrinkHeaders() {}

  explicit GetMultiDimTableSheetShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetMultiDimTableSheetShrinkHeaders() = default;
};
class GetMultiDimTableSheetRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetMultiDimTableSheetRequestTenantContext() {}

  explicit GetMultiDimTableSheetRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetMultiDimTableSheetRequestTenantContext() = default;
};
class GetMultiDimTableSheetRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<string> sheetIdOrName{};
  shared_ptr<GetMultiDimTableSheetRequestTenantContext> tenantContext{};

  GetMultiDimTableSheetRequest() {}

  explicit GetMultiDimTableSheetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (sheetIdOrName) {
      res["SheetIdOrName"] = boost::any(*sheetIdOrName);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("SheetIdOrName") != m.end() && !m["SheetIdOrName"].empty()) {
      sheetIdOrName = make_shared<string>(boost::any_cast<string>(m["SheetIdOrName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetMultiDimTableSheetRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetMultiDimTableSheetRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetMultiDimTableSheetRequest() = default;
};
class GetMultiDimTableSheetShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<string> sheetIdOrName{};
  shared_ptr<string> tenantContextShrink{};

  GetMultiDimTableSheetShrinkRequest() {}

  explicit GetMultiDimTableSheetShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (sheetIdOrName) {
      res["SheetIdOrName"] = boost::any(*sheetIdOrName);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("SheetIdOrName") != m.end() && !m["SheetIdOrName"].empty()) {
      sheetIdOrName = make_shared<string>(boost::any_cast<string>(m["SheetIdOrName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetMultiDimTableSheetShrinkRequest() = default;
};
class GetMultiDimTableSheetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetMultiDimTableSheetResponseBody() {}

  explicit GetMultiDimTableSheetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetMultiDimTableSheetResponseBody() = default;
};
class GetMultiDimTableSheetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMultiDimTableSheetResponseBody> body{};

  GetMultiDimTableSheetResponse() {}

  explicit GetMultiDimTableSheetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMultiDimTableSheetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMultiDimTableSheetResponseBody>(model1);
      }
    }
  }


  virtual ~GetMultiDimTableSheetResponse() = default;
};
class GetMultipartFileUploadInfosHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetMultipartFileUploadInfosHeadersAccountContext() {}

  explicit GetMultipartFileUploadInfosHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetMultipartFileUploadInfosHeadersAccountContext() = default;
};
class GetMultipartFileUploadInfosHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetMultipartFileUploadInfosHeadersAccountContext> accountContext{};

  GetMultipartFileUploadInfosHeaders() {}

  explicit GetMultipartFileUploadInfosHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetMultipartFileUploadInfosHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetMultipartFileUploadInfosHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetMultipartFileUploadInfosHeaders() = default;
};
class GetMultipartFileUploadInfosShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetMultipartFileUploadInfosShrinkHeaders() {}

  explicit GetMultipartFileUploadInfosShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetMultipartFileUploadInfosShrinkHeaders() = default;
};
class GetMultipartFileUploadInfosRequestOption : public Darabonba::Model {
public:
  shared_ptr<bool> preferIntranet{};

  GetMultipartFileUploadInfosRequestOption() {}

  explicit GetMultipartFileUploadInfosRequestOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preferIntranet) {
      res["PreferIntranet"] = boost::any(*preferIntranet);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreferIntranet") != m.end() && !m["PreferIntranet"].empty()) {
      preferIntranet = make_shared<bool>(boost::any_cast<bool>(m["PreferIntranet"]));
    }
  }


  virtual ~GetMultipartFileUploadInfosRequestOption() = default;
};
class GetMultipartFileUploadInfosRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetMultipartFileUploadInfosRequestTenantContext() {}

  explicit GetMultipartFileUploadInfosRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetMultipartFileUploadInfosRequestTenantContext() = default;
};
class GetMultipartFileUploadInfosRequest : public Darabonba::Model {
public:
  shared_ptr<GetMultipartFileUploadInfosRequestOption> option{};
  shared_ptr<vector<long>> partNumbers{};
  shared_ptr<GetMultipartFileUploadInfosRequestTenantContext> tenantContext{};
  shared_ptr<string> uploadKey{};

  GetMultipartFileUploadInfosRequest() {}

  explicit GetMultipartFileUploadInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (option) {
      res["Option"] = option ? boost::any(option->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (partNumbers) {
      res["PartNumbers"] = boost::any(*partNumbers);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (uploadKey) {
      res["UploadKey"] = boost::any(*uploadKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      if (typeid(map<string, boost::any>) == m["Option"].type()) {
        GetMultipartFileUploadInfosRequestOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Option"]));
        option = make_shared<GetMultipartFileUploadInfosRequestOption>(model1);
      }
    }
    if (m.find("PartNumbers") != m.end() && !m["PartNumbers"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["PartNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PartNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      partNumbers = make_shared<vector<long>>(toVec1);
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetMultipartFileUploadInfosRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetMultipartFileUploadInfosRequestTenantContext>(model1);
      }
    }
    if (m.find("UploadKey") != m.end() && !m["UploadKey"].empty()) {
      uploadKey = make_shared<string>(boost::any_cast<string>(m["UploadKey"]));
    }
  }


  virtual ~GetMultipartFileUploadInfosRequest() = default;
};
class GetMultipartFileUploadInfosShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> optionShrink{};
  shared_ptr<string> partNumbersShrink{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> uploadKey{};

  GetMultipartFileUploadInfosShrinkRequest() {}

  explicit GetMultipartFileUploadInfosShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (optionShrink) {
      res["Option"] = boost::any(*optionShrink);
    }
    if (partNumbersShrink) {
      res["PartNumbers"] = boost::any(*partNumbersShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (uploadKey) {
      res["UploadKey"] = boost::any(*uploadKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      optionShrink = make_shared<string>(boost::any_cast<string>(m["Option"]));
    }
    if (m.find("PartNumbers") != m.end() && !m["PartNumbers"].empty()) {
      partNumbersShrink = make_shared<string>(boost::any_cast<string>(m["PartNumbers"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("UploadKey") != m.end() && !m["UploadKey"].empty()) {
      uploadKey = make_shared<string>(boost::any_cast<string>(m["UploadKey"]));
    }
  }


  virtual ~GetMultipartFileUploadInfosShrinkRequest() = default;
};
class GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfosHeaderSignatureInfo : public Darabonba::Model {
public:
  shared_ptr<long> expirationSeconds{};
  shared_ptr<map<string, string>> headers{};
  shared_ptr<vector<string>> internalResourceUrls{};
  shared_ptr<string> region{};
  shared_ptr<vector<string>> resourceUrls{};

  GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfosHeaderSignatureInfo() {}

  explicit GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfosHeaderSignatureInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expirationSeconds) {
      res["ExpirationSeconds"] = boost::any(*expirationSeconds);
    }
    if (headers) {
      res["Headers"] = boost::any(*headers);
    }
    if (internalResourceUrls) {
      res["InternalResourceUrls"] = boost::any(*internalResourceUrls);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceUrls) {
      res["ResourceUrls"] = boost::any(*resourceUrls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpirationSeconds") != m.end() && !m["ExpirationSeconds"].empty()) {
      expirationSeconds = make_shared<long>(boost::any_cast<long>(m["ExpirationSeconds"]));
    }
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("InternalResourceUrls") != m.end() && !m["InternalResourceUrls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InternalResourceUrls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InternalResourceUrls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      internalResourceUrls = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceUrls") != m.end() && !m["ResourceUrls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceUrls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceUrls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceUrls = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfosHeaderSignatureInfo() = default;
};
class GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfos : public Darabonba::Model {
public:
  shared_ptr<GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfosHeaderSignatureInfo> headerSignatureInfo{};
  shared_ptr<long> partNumber{};

  GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfos() {}

  explicit GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerSignatureInfo) {
      res["HeaderSignatureInfo"] = headerSignatureInfo ? boost::any(headerSignatureInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (partNumber) {
      res["PartNumber"] = boost::any(*partNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeaderSignatureInfo") != m.end() && !m["HeaderSignatureInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["HeaderSignatureInfo"].type()) {
        GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfosHeaderSignatureInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HeaderSignatureInfo"]));
        headerSignatureInfo = make_shared<GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfosHeaderSignatureInfo>(model1);
      }
    }
    if (m.find("PartNumber") != m.end() && !m["PartNumber"].empty()) {
      partNumber = make_shared<long>(boost::any_cast<long>(m["PartNumber"]));
    }
  }


  virtual ~GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfos() = default;
};
class GetMultipartFileUploadInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfos>> multipartHeaderSignatureInfos{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetMultipartFileUploadInfosResponseBody() {}

  explicit GetMultipartFileUploadInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (multipartHeaderSignatureInfos) {
      vector<boost::any> temp1;
      for(auto item1:*multipartHeaderSignatureInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["multipartHeaderSignatureInfos"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("multipartHeaderSignatureInfos") != m.end() && !m["multipartHeaderSignatureInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["multipartHeaderSignatureInfos"].type()) {
        vector<GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["multipartHeaderSignatureInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        multipartHeaderSignatureInfos = make_shared<vector<GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfos>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetMultipartFileUploadInfosResponseBody() = default;
};
class GetMultipartFileUploadInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMultipartFileUploadInfosResponseBody> body{};

  GetMultipartFileUploadInfosResponse() {}

  explicit GetMultipartFileUploadInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMultipartFileUploadInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMultipartFileUploadInfosResponseBody>(model1);
      }
    }
  }


  virtual ~GetMultipartFileUploadInfosResponse() = default;
};
class GetNewestInnerGroupsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetNewestInnerGroupsHeadersAccountContext() {}

  explicit GetNewestInnerGroupsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetNewestInnerGroupsHeadersAccountContext() = default;
};
class GetNewestInnerGroupsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetNewestInnerGroupsHeadersAccountContext> accountContext{};

  GetNewestInnerGroupsHeaders() {}

  explicit GetNewestInnerGroupsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetNewestInnerGroupsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetNewestInnerGroupsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetNewestInnerGroupsHeaders() = default;
};
class GetNewestInnerGroupsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetNewestInnerGroupsShrinkHeaders() {}

  explicit GetNewestInnerGroupsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetNewestInnerGroupsShrinkHeaders() = default;
};
class GetNewestInnerGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> request{};

  GetNewestInnerGroupsRequest() {}

  explicit GetNewestInnerGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (request) {
      res["Request"] = boost::any(*request);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Request") != m.end() && !m["Request"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Request"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      request = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~GetNewestInnerGroupsRequest() = default;
};
class GetNewestInnerGroupsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> requestShrink{};

  GetNewestInnerGroupsShrinkRequest() {}

  explicit GetNewestInnerGroupsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestShrink) {
      res["Request"] = boost::any(*requestShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Request") != m.end() && !m["Request"].empty()) {
      requestShrink = make_shared<string>(boost::any_cast<string>(m["Request"]));
    }
  }


  virtual ~GetNewestInnerGroupsShrinkRequest() = default;
};
class GetNewestInnerGroupsResponseBodyGroupInfos : public Darabonba::Model {
public:
  shared_ptr<string> icon{};
  shared_ptr<string> memberAmount{};
  shared_ptr<string> openConversationId{};
  shared_ptr<string> title{};

  GetNewestInnerGroupsResponseBodyGroupInfos() {}

  explicit GetNewestInnerGroupsResponseBodyGroupInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (memberAmount) {
      res["MemberAmount"] = boost::any(*memberAmount);
    }
    if (openConversationId) {
      res["OpenConversationId"] = boost::any(*openConversationId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("MemberAmount") != m.end() && !m["MemberAmount"].empty()) {
      memberAmount = make_shared<string>(boost::any_cast<string>(m["MemberAmount"]));
    }
    if (m.find("OpenConversationId") != m.end() && !m["OpenConversationId"].empty()) {
      openConversationId = make_shared<string>(boost::any_cast<string>(m["OpenConversationId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GetNewestInnerGroupsResponseBodyGroupInfos() = default;
};
class GetNewestInnerGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetNewestInnerGroupsResponseBodyGroupInfos>> groupInfos{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetNewestInnerGroupsResponseBody() {}

  explicit GetNewestInnerGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupInfos) {
      vector<boost::any> temp1;
      for(auto item1:*groupInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["groupInfos"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("groupInfos") != m.end() && !m["groupInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["groupInfos"].type()) {
        vector<GetNewestInnerGroupsResponseBodyGroupInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["groupInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetNewestInnerGroupsResponseBodyGroupInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupInfos = make_shared<vector<GetNewestInnerGroupsResponseBodyGroupInfos>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetNewestInnerGroupsResponseBody() = default;
};
class GetNewestInnerGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetNewestInnerGroupsResponseBody> body{};

  GetNewestInnerGroupsResponse() {}

  explicit GetNewestInnerGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNewestInnerGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNewestInnerGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~GetNewestInnerGroupsResponse() = default;
};
class GetNodeHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetNodeHeadersAccountContext() {}

  explicit GetNodeHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetNodeHeadersAccountContext() = default;
};
class GetNodeHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetNodeHeadersAccountContext> accountContext{};

  GetNodeHeaders() {}

  explicit GetNodeHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetNodeHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetNodeHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetNodeHeaders() = default;
};
class GetNodeShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetNodeShrinkHeaders() {}

  explicit GetNodeShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetNodeShrinkHeaders() = default;
};
class GetNodeRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetNodeRequestTenantContext() {}

  explicit GetNodeRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetNodeRequestTenantContext() = default;
};
class GetNodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};
  shared_ptr<GetNodeRequestTenantContext> tenantContext{};
  shared_ptr<bool> withPermissionRole{};
  shared_ptr<bool> withStatisticalInfo{};

  GetNodeRequest() {}

  explicit GetNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (withPermissionRole) {
      res["WithPermissionRole"] = boost::any(*withPermissionRole);
    }
    if (withStatisticalInfo) {
      res["WithStatisticalInfo"] = boost::any(*withStatisticalInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetNodeRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetNodeRequestTenantContext>(model1);
      }
    }
    if (m.find("WithPermissionRole") != m.end() && !m["WithPermissionRole"].empty()) {
      withPermissionRole = make_shared<bool>(boost::any_cast<bool>(m["WithPermissionRole"]));
    }
    if (m.find("WithStatisticalInfo") != m.end() && !m["WithStatisticalInfo"].empty()) {
      withStatisticalInfo = make_shared<bool>(boost::any_cast<bool>(m["WithStatisticalInfo"]));
    }
  }


  virtual ~GetNodeRequest() = default;
};
class GetNodeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<bool> withPermissionRole{};
  shared_ptr<bool> withStatisticalInfo{};

  GetNodeShrinkRequest() {}

  explicit GetNodeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (withPermissionRole) {
      res["WithPermissionRole"] = boost::any(*withPermissionRole);
    }
    if (withStatisticalInfo) {
      res["WithStatisticalInfo"] = boost::any(*withStatisticalInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WithPermissionRole") != m.end() && !m["WithPermissionRole"].empty()) {
      withPermissionRole = make_shared<bool>(boost::any_cast<bool>(m["WithPermissionRole"]));
    }
    if (m.find("WithStatisticalInfo") != m.end() && !m["WithStatisticalInfo"].empty()) {
      withStatisticalInfo = make_shared<bool>(boost::any_cast<bool>(m["WithStatisticalInfo"]));
    }
  }


  virtual ~GetNodeShrinkRequest() = default;
};
class GetNodeResponseBodyNodeStatisticalInfo : public Darabonba::Model {
public:
  shared_ptr<long> wordCount{};

  GetNodeResponseBodyNodeStatisticalInfo() {}

  explicit GetNodeResponseBodyNodeStatisticalInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (wordCount) {
      res["WordCount"] = boost::any(*wordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WordCount") != m.end() && !m["WordCount"].empty()) {
      wordCount = make_shared<long>(boost::any_cast<long>(m["WordCount"]));
    }
  }


  virtual ~GetNodeResponseBodyNodeStatisticalInfo() = default;
};
class GetNodeResponseBodyNode : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> extension{};
  shared_ptr<bool> hasChildren{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> name{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> permissionRole{};
  shared_ptr<long> size{};
  shared_ptr<GetNodeResponseBodyNodeStatisticalInfo> statisticalInfo{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  GetNodeResponseBodyNode() {}

  explicit GetNodeResponseBodyNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (hasChildren) {
      res["HasChildren"] = boost::any(*hasChildren);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (permissionRole) {
      res["PermissionRole"] = boost::any(*permissionRole);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (statisticalInfo) {
      res["StatisticalInfo"] = statisticalInfo ? boost::any(statisticalInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("HasChildren") != m.end() && !m["HasChildren"].empty()) {
      hasChildren = make_shared<bool>(boost::any_cast<bool>(m["HasChildren"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["ModifierId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("PermissionRole") != m.end() && !m["PermissionRole"].empty()) {
      permissionRole = make_shared<string>(boost::any_cast<string>(m["PermissionRole"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StatisticalInfo") != m.end() && !m["StatisticalInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatisticalInfo"].type()) {
        GetNodeResponseBodyNodeStatisticalInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatisticalInfo"]));
        statisticalInfo = make_shared<GetNodeResponseBodyNodeStatisticalInfo>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetNodeResponseBodyNode() = default;
};
class GetNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetNodeResponseBodyNode> node{};
  shared_ptr<string> requestId{};

  GetNodeResponseBody() {}

  explicit GetNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (node) {
      res["node"] = node ? boost::any(node->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("node") != m.end() && !m["node"].empty()) {
      if (typeid(map<string, boost::any>) == m["node"].type()) {
        GetNodeResponseBodyNode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["node"]));
        node = make_shared<GetNodeResponseBodyNode>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetNodeResponseBody() = default;
};
class GetNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetNodeResponseBody> body{};

  GetNodeResponse() {}

  explicit GetNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNodeResponseBody>(model1);
      }
    }
  }


  virtual ~GetNodeResponse() = default;
};
class GetNodeByUrlHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetNodeByUrlHeadersAccountContext() {}

  explicit GetNodeByUrlHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetNodeByUrlHeadersAccountContext() = default;
};
class GetNodeByUrlHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetNodeByUrlHeadersAccountContext> accountContext{};

  GetNodeByUrlHeaders() {}

  explicit GetNodeByUrlHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetNodeByUrlHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetNodeByUrlHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetNodeByUrlHeaders() = default;
};
class GetNodeByUrlShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetNodeByUrlShrinkHeaders() {}

  explicit GetNodeByUrlShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetNodeByUrlShrinkHeaders() = default;
};
class GetNodeByUrlRequestOption : public Darabonba::Model {
public:
  shared_ptr<bool> withPermissionRole{};
  shared_ptr<bool> withStatisticalInfo{};

  GetNodeByUrlRequestOption() {}

  explicit GetNodeByUrlRequestOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (withPermissionRole) {
      res["WithPermissionRole"] = boost::any(*withPermissionRole);
    }
    if (withStatisticalInfo) {
      res["WithStatisticalInfo"] = boost::any(*withStatisticalInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WithPermissionRole") != m.end() && !m["WithPermissionRole"].empty()) {
      withPermissionRole = make_shared<bool>(boost::any_cast<bool>(m["WithPermissionRole"]));
    }
    if (m.find("WithStatisticalInfo") != m.end() && !m["WithStatisticalInfo"].empty()) {
      withStatisticalInfo = make_shared<bool>(boost::any_cast<bool>(m["WithStatisticalInfo"]));
    }
  }


  virtual ~GetNodeByUrlRequestOption() = default;
};
class GetNodeByUrlRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetNodeByUrlRequestTenantContext() {}

  explicit GetNodeByUrlRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetNodeByUrlRequestTenantContext() = default;
};
class GetNodeByUrlRequest : public Darabonba::Model {
public:
  shared_ptr<GetNodeByUrlRequestOption> option{};
  shared_ptr<GetNodeByUrlRequestTenantContext> tenantContext{};
  shared_ptr<string> url{};

  GetNodeByUrlRequest() {}

  explicit GetNodeByUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (option) {
      res["Option"] = option ? boost::any(option->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      if (typeid(map<string, boost::any>) == m["Option"].type()) {
        GetNodeByUrlRequestOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Option"]));
        option = make_shared<GetNodeByUrlRequestOption>(model1);
      }
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetNodeByUrlRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetNodeByUrlRequestTenantContext>(model1);
      }
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetNodeByUrlRequest() = default;
};
class GetNodeByUrlShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> optionShrink{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> url{};

  GetNodeByUrlShrinkRequest() {}

  explicit GetNodeByUrlShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (optionShrink) {
      res["Option"] = boost::any(*optionShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      optionShrink = make_shared<string>(boost::any_cast<string>(m["Option"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetNodeByUrlShrinkRequest() = default;
};
class GetNodeByUrlResponseBodyNodeStatisticalInfo : public Darabonba::Model {
public:
  shared_ptr<long> wordCount{};

  GetNodeByUrlResponseBodyNodeStatisticalInfo() {}

  explicit GetNodeByUrlResponseBodyNodeStatisticalInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (wordCount) {
      res["WordCount"] = boost::any(*wordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WordCount") != m.end() && !m["WordCount"].empty()) {
      wordCount = make_shared<long>(boost::any_cast<long>(m["WordCount"]));
    }
  }


  virtual ~GetNodeByUrlResponseBodyNodeStatisticalInfo() = default;
};
class GetNodeByUrlResponseBodyNode : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> extension{};
  shared_ptr<bool> hasChildren{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> name{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> permissionRole{};
  shared_ptr<long> size{};
  shared_ptr<GetNodeByUrlResponseBodyNodeStatisticalInfo> statisticalInfo{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  GetNodeByUrlResponseBodyNode() {}

  explicit GetNodeByUrlResponseBodyNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (hasChildren) {
      res["HasChildren"] = boost::any(*hasChildren);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (permissionRole) {
      res["PermissionRole"] = boost::any(*permissionRole);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (statisticalInfo) {
      res["StatisticalInfo"] = statisticalInfo ? boost::any(statisticalInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("HasChildren") != m.end() && !m["HasChildren"].empty()) {
      hasChildren = make_shared<bool>(boost::any_cast<bool>(m["HasChildren"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["ModifierId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("PermissionRole") != m.end() && !m["PermissionRole"].empty()) {
      permissionRole = make_shared<string>(boost::any_cast<string>(m["PermissionRole"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StatisticalInfo") != m.end() && !m["StatisticalInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatisticalInfo"].type()) {
        GetNodeByUrlResponseBodyNodeStatisticalInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatisticalInfo"]));
        statisticalInfo = make_shared<GetNodeByUrlResponseBodyNodeStatisticalInfo>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetNodeByUrlResponseBodyNode() = default;
};
class GetNodeByUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetNodeByUrlResponseBodyNode> node{};
  shared_ptr<string> requestId{};

  GetNodeByUrlResponseBody() {}

  explicit GetNodeByUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (node) {
      res["node"] = node ? boost::any(node->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("node") != m.end() && !m["node"].empty()) {
      if (typeid(map<string, boost::any>) == m["node"].type()) {
        GetNodeByUrlResponseBodyNode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["node"]));
        node = make_shared<GetNodeByUrlResponseBodyNode>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetNodeByUrlResponseBody() = default;
};
class GetNodeByUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetNodeByUrlResponseBody> body{};

  GetNodeByUrlResponse() {}

  explicit GetNodeByUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNodeByUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNodeByUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetNodeByUrlResponse() = default;
};
class GetNodesHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetNodesHeadersAccountContext() {}

  explicit GetNodesHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetNodesHeadersAccountContext() = default;
};
class GetNodesHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetNodesHeadersAccountContext> accountContext{};

  GetNodesHeaders() {}

  explicit GetNodesHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetNodesHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetNodesHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetNodesHeaders() = default;
};
class GetNodesShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetNodesShrinkHeaders() {}

  explicit GetNodesShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetNodesShrinkHeaders() = default;
};
class GetNodesRequestOption : public Darabonba::Model {
public:
  shared_ptr<bool> withPermissionRole{};
  shared_ptr<bool> withStatisticalInfo{};

  GetNodesRequestOption() {}

  explicit GetNodesRequestOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (withPermissionRole) {
      res["WithPermissionRole"] = boost::any(*withPermissionRole);
    }
    if (withStatisticalInfo) {
      res["WithStatisticalInfo"] = boost::any(*withStatisticalInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WithPermissionRole") != m.end() && !m["WithPermissionRole"].empty()) {
      withPermissionRole = make_shared<bool>(boost::any_cast<bool>(m["WithPermissionRole"]));
    }
    if (m.find("WithStatisticalInfo") != m.end() && !m["WithStatisticalInfo"].empty()) {
      withStatisticalInfo = make_shared<bool>(boost::any_cast<bool>(m["WithStatisticalInfo"]));
    }
  }


  virtual ~GetNodesRequestOption() = default;
};
class GetNodesRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetNodesRequestTenantContext() {}

  explicit GetNodesRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetNodesRequestTenantContext() = default;
};
class GetNodesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> nodeIds{};
  shared_ptr<GetNodesRequestOption> option{};
  shared_ptr<GetNodesRequestTenantContext> tenantContext{};

  GetNodesRequest() {}

  explicit GetNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeIds) {
      res["NodeIds"] = boost::any(*nodeIds);
    }
    if (option) {
      res["Option"] = option ? boost::any(option->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeIds") != m.end() && !m["NodeIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      if (typeid(map<string, boost::any>) == m["Option"].type()) {
        GetNodesRequestOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Option"]));
        option = make_shared<GetNodesRequestOption>(model1);
      }
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetNodesRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetNodesRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetNodesRequest() = default;
};
class GetNodesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> nodeIdsShrink{};
  shared_ptr<string> optionShrink{};
  shared_ptr<string> tenantContextShrink{};

  GetNodesShrinkRequest() {}

  explicit GetNodesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeIdsShrink) {
      res["NodeIds"] = boost::any(*nodeIdsShrink);
    }
    if (optionShrink) {
      res["Option"] = boost::any(*optionShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeIds") != m.end() && !m["NodeIds"].empty()) {
      nodeIdsShrink = make_shared<string>(boost::any_cast<string>(m["NodeIds"]));
    }
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      optionShrink = make_shared<string>(boost::any_cast<string>(m["Option"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetNodesShrinkRequest() = default;
};
class GetNodesResponseBodyNodesStatisticalInfo : public Darabonba::Model {
public:
  shared_ptr<long> wordCount{};

  GetNodesResponseBodyNodesStatisticalInfo() {}

  explicit GetNodesResponseBodyNodesStatisticalInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (wordCount) {
      res["WordCount"] = boost::any(*wordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WordCount") != m.end() && !m["WordCount"].empty()) {
      wordCount = make_shared<long>(boost::any_cast<long>(m["WordCount"]));
    }
  }


  virtual ~GetNodesResponseBodyNodesStatisticalInfo() = default;
};
class GetNodesResponseBodyNodes : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> extension{};
  shared_ptr<bool> hasChildren{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> name{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> permissionRole{};
  shared_ptr<long> size{};
  shared_ptr<GetNodesResponseBodyNodesStatisticalInfo> statisticalInfo{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  GetNodesResponseBodyNodes() {}

  explicit GetNodesResponseBodyNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (hasChildren) {
      res["HasChildren"] = boost::any(*hasChildren);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (permissionRole) {
      res["PermissionRole"] = boost::any(*permissionRole);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (statisticalInfo) {
      res["StatisticalInfo"] = statisticalInfo ? boost::any(statisticalInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("HasChildren") != m.end() && !m["HasChildren"].empty()) {
      hasChildren = make_shared<bool>(boost::any_cast<bool>(m["HasChildren"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["ModifierId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("PermissionRole") != m.end() && !m["PermissionRole"].empty()) {
      permissionRole = make_shared<string>(boost::any_cast<string>(m["PermissionRole"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StatisticalInfo") != m.end() && !m["StatisticalInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatisticalInfo"].type()) {
        GetNodesResponseBodyNodesStatisticalInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatisticalInfo"]));
        statisticalInfo = make_shared<GetNodesResponseBodyNodesStatisticalInfo>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetNodesResponseBodyNodes() = default;
};
class GetNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetNodesResponseBodyNodes>> nodes{};
  shared_ptr<string> requestId{};

  GetNodesResponseBody() {}

  explicit GetNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["nodes"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nodes") != m.end() && !m["nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["nodes"].type()) {
        vector<GetNodesResponseBodyNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetNodesResponseBodyNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<GetNodesResponseBodyNodes>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetNodesResponseBody() = default;
};
class GetNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetNodesResponseBody> body{};

  GetNodesResponse() {}

  explicit GetNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNodesResponseBody>(model1);
      }
    }
  }


  virtual ~GetNodesResponse() = default;
};
class GetNotifyMeHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetNotifyMeHeadersAccountContext() {}

  explicit GetNotifyMeHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetNotifyMeHeadersAccountContext() = default;
};
class GetNotifyMeHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetNotifyMeHeadersAccountContext> accountContext{};

  GetNotifyMeHeaders() {}

  explicit GetNotifyMeHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetNotifyMeHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetNotifyMeHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetNotifyMeHeaders() = default;
};
class GetNotifyMeShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetNotifyMeShrinkHeaders() {}

  explicit GetNotifyMeShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetNotifyMeShrinkHeaders() = default;
};
class GetNotifyMeRequest : public Darabonba::Model {
public:
  shared_ptr<string> appTypes{};
  shared_ptr<string> corpId{};
  shared_ptr<long> createFromTimeGMT{};
  shared_ptr<long> createToTimeGMT{};
  shared_ptr<long> instanceCreateFromTimeGMT{};
  shared_ptr<long> instanceCreateToTimeGMT{};
  shared_ptr<string> keyword{};
  shared_ptr<string> language{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> processCodes{};
  shared_ptr<string> token{};

  GetNotifyMeRequest() {}

  explicit GetNotifyMeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appTypes) {
      res["AppTypes"] = boost::any(*appTypes);
    }
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (createFromTimeGMT) {
      res["CreateFromTimeGMT"] = boost::any(*createFromTimeGMT);
    }
    if (createToTimeGMT) {
      res["CreateToTimeGMT"] = boost::any(*createToTimeGMT);
    }
    if (instanceCreateFromTimeGMT) {
      res["InstanceCreateFromTimeGMT"] = boost::any(*instanceCreateFromTimeGMT);
    }
    if (instanceCreateToTimeGMT) {
      res["InstanceCreateToTimeGMT"] = boost::any(*instanceCreateToTimeGMT);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (processCodes) {
      res["ProcessCodes"] = boost::any(*processCodes);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppTypes") != m.end() && !m["AppTypes"].empty()) {
      appTypes = make_shared<string>(boost::any_cast<string>(m["AppTypes"]));
    }
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("CreateFromTimeGMT") != m.end() && !m["CreateFromTimeGMT"].empty()) {
      createFromTimeGMT = make_shared<long>(boost::any_cast<long>(m["CreateFromTimeGMT"]));
    }
    if (m.find("CreateToTimeGMT") != m.end() && !m["CreateToTimeGMT"].empty()) {
      createToTimeGMT = make_shared<long>(boost::any_cast<long>(m["CreateToTimeGMT"]));
    }
    if (m.find("InstanceCreateFromTimeGMT") != m.end() && !m["InstanceCreateFromTimeGMT"].empty()) {
      instanceCreateFromTimeGMT = make_shared<long>(boost::any_cast<long>(m["InstanceCreateFromTimeGMT"]));
    }
    if (m.find("InstanceCreateToTimeGMT") != m.end() && !m["InstanceCreateToTimeGMT"].empty()) {
      instanceCreateToTimeGMT = make_shared<long>(boost::any_cast<long>(m["InstanceCreateToTimeGMT"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProcessCodes") != m.end() && !m["ProcessCodes"].empty()) {
      processCodes = make_shared<string>(boost::any_cast<string>(m["ProcessCodes"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~GetNotifyMeRequest() = default;
};
class GetNotifyMeResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> activityId{};
  shared_ptr<string> appType{};
  shared_ptr<string> corpId{};
  shared_ptr<string> createTimeGMT{};
  shared_ptr<string> creatorUserId{};
  shared_ptr<string> formInstanceId{};
  shared_ptr<string> instStatus{};
  shared_ptr<string> mobileUrl{};
  shared_ptr<string> modifiedTimeGMT{};

  GetNotifyMeResponseBodyData() {}

  explicit GetNotifyMeResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityId) {
      res["ActivityId"] = boost::any(*activityId);
    }
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (createTimeGMT) {
      res["CreateTimeGMT"] = boost::any(*createTimeGMT);
    }
    if (creatorUserId) {
      res["CreatorUserId"] = boost::any(*creatorUserId);
    }
    if (formInstanceId) {
      res["FormInstanceId"] = boost::any(*formInstanceId);
    }
    if (instStatus) {
      res["InstStatus"] = boost::any(*instStatus);
    }
    if (mobileUrl) {
      res["MobileUrl"] = boost::any(*mobileUrl);
    }
    if (modifiedTimeGMT) {
      res["ModifiedTimeGMT"] = boost::any(*modifiedTimeGMT);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityId") != m.end() && !m["ActivityId"].empty()) {
      activityId = make_shared<string>(boost::any_cast<string>(m["ActivityId"]));
    }
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("CreateTimeGMT") != m.end() && !m["CreateTimeGMT"].empty()) {
      createTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateTimeGMT"]));
    }
    if (m.find("CreatorUserId") != m.end() && !m["CreatorUserId"].empty()) {
      creatorUserId = make_shared<string>(boost::any_cast<string>(m["CreatorUserId"]));
    }
    if (m.find("FormInstanceId") != m.end() && !m["FormInstanceId"].empty()) {
      formInstanceId = make_shared<string>(boost::any_cast<string>(m["FormInstanceId"]));
    }
    if (m.find("InstStatus") != m.end() && !m["InstStatus"].empty()) {
      instStatus = make_shared<string>(boost::any_cast<string>(m["InstStatus"]));
    }
    if (m.find("MobileUrl") != m.end() && !m["MobileUrl"].empty()) {
      mobileUrl = make_shared<string>(boost::any_cast<string>(m["MobileUrl"]));
    }
    if (m.find("ModifiedTimeGMT") != m.end() && !m["ModifiedTimeGMT"].empty()) {
      modifiedTimeGMT = make_shared<string>(boost::any_cast<string>(m["ModifiedTimeGMT"]));
    }
  }


  virtual ~GetNotifyMeResponseBodyData() = default;
};
class GetNotifyMeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetNotifyMeResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetNotifyMeResponseBody() {}

  explicit GetNotifyMeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<GetNotifyMeResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetNotifyMeResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetNotifyMeResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetNotifyMeResponseBody() = default;
};
class GetNotifyMeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetNotifyMeResponseBody> body{};

  GetNotifyMeResponse() {}

  explicit GetNotifyMeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNotifyMeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNotifyMeResponseBody>(model1);
      }
    }
  }


  virtual ~GetNotifyMeResponse() = default;
};
class GetOpenUrlHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetOpenUrlHeadersAccountContext() {}

  explicit GetOpenUrlHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetOpenUrlHeadersAccountContext() = default;
};
class GetOpenUrlHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetOpenUrlHeadersAccountContext> accountContext{};

  GetOpenUrlHeaders() {}

  explicit GetOpenUrlHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetOpenUrlHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetOpenUrlHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetOpenUrlHeaders() = default;
};
class GetOpenUrlShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetOpenUrlShrinkHeaders() {}

  explicit GetOpenUrlShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetOpenUrlShrinkHeaders() = default;
};
class GetOpenUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> language{};
  shared_ptr<string> systemToken{};
  shared_ptr<long> timeout{};

  GetOpenUrlRequest() {}

  explicit GetOpenUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~GetOpenUrlRequest() = default;
};
class GetOpenUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  GetOpenUrlResponseBody() {}

  explicit GetOpenUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["result"]));
    }
  }


  virtual ~GetOpenUrlResponseBody() = default;
};
class GetOpenUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOpenUrlResponseBody> body{};

  GetOpenUrlResponse() {}

  explicit GetOpenUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOpenUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOpenUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetOpenUrlResponse() = default;
};
class GetOperationRecordsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetOperationRecordsHeadersAccountContext() {}

  explicit GetOperationRecordsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetOperationRecordsHeadersAccountContext() = default;
};
class GetOperationRecordsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetOperationRecordsHeadersAccountContext> accountContext{};

  GetOperationRecordsHeaders() {}

  explicit GetOperationRecordsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetOperationRecordsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetOperationRecordsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetOperationRecordsHeaders() = default;
};
class GetOperationRecordsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetOperationRecordsShrinkHeaders() {}

  explicit GetOperationRecordsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetOperationRecordsShrinkHeaders() = default;
};
class GetOperationRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> language{};
  shared_ptr<string> processInstanceId{};
  shared_ptr<string> systemToken{};

  GetOperationRecordsRequest() {}

  explicit GetOperationRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (processInstanceId) {
      res["ProcessInstanceId"] = boost::any(*processInstanceId);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("ProcessInstanceId") != m.end() && !m["ProcessInstanceId"].empty()) {
      processInstanceId = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceId"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~GetOperationRecordsRequest() = default;
};
class GetOperationRecordsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> actionExit{};
  shared_ptr<string> activeTimeGMT{};
  shared_ptr<string> activityId{};
  shared_ptr<long> dataId{};
  shared_ptr<string> digitalSign{};
  shared_ptr<string> files{};
  shared_ptr<string> operateTimeGMT{};
  shared_ptr<string> operateType{};
  shared_ptr<string> operatorDisplayName{};
  shared_ptr<string> operatorName{};
  shared_ptr<string> operatorNickName{};
  shared_ptr<string> operatorPhotoUrl{};
  shared_ptr<string> operatorStatus{};
  shared_ptr<string> operatorUserId{};
  shared_ptr<string> processInstanceId{};
  shared_ptr<string> remark{};
  shared_ptr<string> showName{};
  shared_ptr<long> size{};
  shared_ptr<string> taskExecuteType{};
  shared_ptr<long> taskHoldTimeGMT{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskType{};
  shared_ptr<string> type{};

  GetOperationRecordsResponseBodyResult() {}

  explicit GetOperationRecordsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (actionExit) {
      res["ActionExit"] = boost::any(*actionExit);
    }
    if (activeTimeGMT) {
      res["ActiveTimeGMT"] = boost::any(*activeTimeGMT);
    }
    if (activityId) {
      res["ActivityId"] = boost::any(*activityId);
    }
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (digitalSign) {
      res["DigitalSign"] = boost::any(*digitalSign);
    }
    if (files) {
      res["Files"] = boost::any(*files);
    }
    if (operateTimeGMT) {
      res["OperateTimeGMT"] = boost::any(*operateTimeGMT);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    if (operatorDisplayName) {
      res["OperatorDisplayName"] = boost::any(*operatorDisplayName);
    }
    if (operatorName) {
      res["OperatorName"] = boost::any(*operatorName);
    }
    if (operatorNickName) {
      res["OperatorNickName"] = boost::any(*operatorNickName);
    }
    if (operatorPhotoUrl) {
      res["OperatorPhotoUrl"] = boost::any(*operatorPhotoUrl);
    }
    if (operatorStatus) {
      res["OperatorStatus"] = boost::any(*operatorStatus);
    }
    if (operatorUserId) {
      res["OperatorUserId"] = boost::any(*operatorUserId);
    }
    if (processInstanceId) {
      res["ProcessInstanceId"] = boost::any(*processInstanceId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (showName) {
      res["ShowName"] = boost::any(*showName);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (taskExecuteType) {
      res["TaskExecuteType"] = boost::any(*taskExecuteType);
    }
    if (taskHoldTimeGMT) {
      res["TaskHoldTimeGMT"] = boost::any(*taskHoldTimeGMT);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("ActionExit") != m.end() && !m["ActionExit"].empty()) {
      actionExit = make_shared<string>(boost::any_cast<string>(m["ActionExit"]));
    }
    if (m.find("ActiveTimeGMT") != m.end() && !m["ActiveTimeGMT"].empty()) {
      activeTimeGMT = make_shared<string>(boost::any_cast<string>(m["ActiveTimeGMT"]));
    }
    if (m.find("ActivityId") != m.end() && !m["ActivityId"].empty()) {
      activityId = make_shared<string>(boost::any_cast<string>(m["ActivityId"]));
    }
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<long>(boost::any_cast<long>(m["DataId"]));
    }
    if (m.find("DigitalSign") != m.end() && !m["DigitalSign"].empty()) {
      digitalSign = make_shared<string>(boost::any_cast<string>(m["DigitalSign"]));
    }
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      files = make_shared<string>(boost::any_cast<string>(m["Files"]));
    }
    if (m.find("OperateTimeGMT") != m.end() && !m["OperateTimeGMT"].empty()) {
      operateTimeGMT = make_shared<string>(boost::any_cast<string>(m["OperateTimeGMT"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<string>(boost::any_cast<string>(m["OperateType"]));
    }
    if (m.find("OperatorDisplayName") != m.end() && !m["OperatorDisplayName"].empty()) {
      operatorDisplayName = make_shared<string>(boost::any_cast<string>(m["OperatorDisplayName"]));
    }
    if (m.find("OperatorName") != m.end() && !m["OperatorName"].empty()) {
      operatorName = make_shared<string>(boost::any_cast<string>(m["OperatorName"]));
    }
    if (m.find("OperatorNickName") != m.end() && !m["OperatorNickName"].empty()) {
      operatorNickName = make_shared<string>(boost::any_cast<string>(m["OperatorNickName"]));
    }
    if (m.find("OperatorPhotoUrl") != m.end() && !m["OperatorPhotoUrl"].empty()) {
      operatorPhotoUrl = make_shared<string>(boost::any_cast<string>(m["OperatorPhotoUrl"]));
    }
    if (m.find("OperatorStatus") != m.end() && !m["OperatorStatus"].empty()) {
      operatorStatus = make_shared<string>(boost::any_cast<string>(m["OperatorStatus"]));
    }
    if (m.find("OperatorUserId") != m.end() && !m["OperatorUserId"].empty()) {
      operatorUserId = make_shared<string>(boost::any_cast<string>(m["OperatorUserId"]));
    }
    if (m.find("ProcessInstanceId") != m.end() && !m["ProcessInstanceId"].empty()) {
      processInstanceId = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ShowName") != m.end() && !m["ShowName"].empty()) {
      showName = make_shared<string>(boost::any_cast<string>(m["ShowName"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TaskExecuteType") != m.end() && !m["TaskExecuteType"].empty()) {
      taskExecuteType = make_shared<string>(boost::any_cast<string>(m["TaskExecuteType"]));
    }
    if (m.find("TaskHoldTimeGMT") != m.end() && !m["TaskHoldTimeGMT"].empty()) {
      taskHoldTimeGMT = make_shared<long>(boost::any_cast<long>(m["TaskHoldTimeGMT"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetOperationRecordsResponseBodyResult() = default;
};
class GetOperationRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetOperationRecordsResponseBodyResult>> result{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetOperationRecordsResponseBody() {}

  explicit GetOperationRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<GetOperationRecordsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetOperationRecordsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<GetOperationRecordsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetOperationRecordsResponseBody() = default;
};
class GetOperationRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOperationRecordsResponseBody> body{};

  GetOperationRecordsResponse() {}

  explicit GetOperationRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOperationRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOperationRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~GetOperationRecordsResponse() = default;
};
class GetOrgLiveListHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetOrgLiveListHeadersAccountContext() {}

  explicit GetOrgLiveListHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetOrgLiveListHeadersAccountContext() = default;
};
class GetOrgLiveListHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetOrgLiveListHeadersAccountContext> accountContext{};

  GetOrgLiveListHeaders() {}

  explicit GetOrgLiveListHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetOrgLiveListHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetOrgLiveListHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetOrgLiveListHeaders() = default;
};
class GetOrgLiveListShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetOrgLiveListShrinkHeaders() {}

  explicit GetOrgLiveListShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetOrgLiveListShrinkHeaders() = default;
};
class GetOrgLiveListRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetOrgLiveListRequestTenantContext() {}

  explicit GetOrgLiveListRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetOrgLiveListRequestTenantContext() = default;
};
class GetOrgLiveListRequest : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<long> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};
  shared_ptr<GetOrgLiveListRequestTenantContext> tenantContext{};
  shared_ptr<string> userId{};

  GetOrgLiveListRequest() {}

  explicit GetOrgLiveListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetOrgLiveListRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetOrgLiveListRequestTenantContext>(model1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetOrgLiveListRequest() = default;
};
class GetOrgLiveListShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<long> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> userId{};

  GetOrgLiveListShrinkRequest() {}

  explicit GetOrgLiveListShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetOrgLiveListShrinkRequest() = default;
};
class GetOrgLiveListResponseBodyResultNewLiveLiveList : public Darabonba::Model {
public:
  shared_ptr<string> anchorNickname{};
  shared_ptr<string> anchorUnionId{};
  shared_ptr<string> anchorUserId{};
  shared_ptr<long> liveEndTime{};
  shared_ptr<long> liveStartTime{};
  shared_ptr<string> liveUuid{};
  shared_ptr<vector<string>> shareOpenConversationIds{};
  shared_ptr<string> title{};

  GetOrgLiveListResponseBodyResultNewLiveLiveList() {}

  explicit GetOrgLiveListResponseBodyResultNewLiveLiveList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anchorNickname) {
      res["AnchorNickname"] = boost::any(*anchorNickname);
    }
    if (anchorUnionId) {
      res["AnchorUnionId"] = boost::any(*anchorUnionId);
    }
    if (anchorUserId) {
      res["AnchorUserId"] = boost::any(*anchorUserId);
    }
    if (liveEndTime) {
      res["LiveEndTime"] = boost::any(*liveEndTime);
    }
    if (liveStartTime) {
      res["LiveStartTime"] = boost::any(*liveStartTime);
    }
    if (liveUuid) {
      res["LiveUuid"] = boost::any(*liveUuid);
    }
    if (shareOpenConversationIds) {
      res["ShareOpenConversationIds"] = boost::any(*shareOpenConversationIds);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnchorNickname") != m.end() && !m["AnchorNickname"].empty()) {
      anchorNickname = make_shared<string>(boost::any_cast<string>(m["AnchorNickname"]));
    }
    if (m.find("AnchorUnionId") != m.end() && !m["AnchorUnionId"].empty()) {
      anchorUnionId = make_shared<string>(boost::any_cast<string>(m["AnchorUnionId"]));
    }
    if (m.find("AnchorUserId") != m.end() && !m["AnchorUserId"].empty()) {
      anchorUserId = make_shared<string>(boost::any_cast<string>(m["AnchorUserId"]));
    }
    if (m.find("LiveEndTime") != m.end() && !m["LiveEndTime"].empty()) {
      liveEndTime = make_shared<long>(boost::any_cast<long>(m["LiveEndTime"]));
    }
    if (m.find("LiveStartTime") != m.end() && !m["LiveStartTime"].empty()) {
      liveStartTime = make_shared<long>(boost::any_cast<long>(m["LiveStartTime"]));
    }
    if (m.find("LiveUuid") != m.end() && !m["LiveUuid"].empty()) {
      liveUuid = make_shared<string>(boost::any_cast<string>(m["LiveUuid"]));
    }
    if (m.find("ShareOpenConversationIds") != m.end() && !m["ShareOpenConversationIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShareOpenConversationIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShareOpenConversationIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shareOpenConversationIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GetOrgLiveListResponseBodyResultNewLiveLiveList() = default;
};
class GetOrgLiveListResponseBodyResultNewLive : public Darabonba::Model {
public:
  shared_ptr<bool> hasMore{};
  shared_ptr<vector<GetOrgLiveListResponseBodyResultNewLiveLiveList>> liveList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  GetOrgLiveListResponseBodyResultNewLive() {}

  explicit GetOrgLiveListResponseBodyResultNewLive(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (liveList) {
      vector<boost::any> temp1;
      for(auto item1:*liveList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveList"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("LiveList") != m.end() && !m["LiveList"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveList"].type()) {
        vector<GetOrgLiveListResponseBodyResultNewLiveLiveList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetOrgLiveListResponseBodyResultNewLiveLiveList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveList = make_shared<vector<GetOrgLiveListResponseBodyResultNewLiveLiveList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetOrgLiveListResponseBodyResultNewLive() = default;
};
class GetOrgLiveListResponseBodyResultUpdateLiveLiveList : public Darabonba::Model {
public:
  shared_ptr<string> anchorNickname{};
  shared_ptr<string> anchorUnionId{};
  shared_ptr<string> anchorUserId{};
  shared_ptr<long> liveEndTime{};
  shared_ptr<long> liveStartTime{};
  shared_ptr<string> liveUuid{};
  shared_ptr<string> title{};

  GetOrgLiveListResponseBodyResultUpdateLiveLiveList() {}

  explicit GetOrgLiveListResponseBodyResultUpdateLiveLiveList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anchorNickname) {
      res["AnchorNickname"] = boost::any(*anchorNickname);
    }
    if (anchorUnionId) {
      res["AnchorUnionId"] = boost::any(*anchorUnionId);
    }
    if (anchorUserId) {
      res["AnchorUserId"] = boost::any(*anchorUserId);
    }
    if (liveEndTime) {
      res["LiveEndTime"] = boost::any(*liveEndTime);
    }
    if (liveStartTime) {
      res["LiveStartTime"] = boost::any(*liveStartTime);
    }
    if (liveUuid) {
      res["LiveUuid"] = boost::any(*liveUuid);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnchorNickname") != m.end() && !m["AnchorNickname"].empty()) {
      anchorNickname = make_shared<string>(boost::any_cast<string>(m["AnchorNickname"]));
    }
    if (m.find("AnchorUnionId") != m.end() && !m["AnchorUnionId"].empty()) {
      anchorUnionId = make_shared<string>(boost::any_cast<string>(m["AnchorUnionId"]));
    }
    if (m.find("AnchorUserId") != m.end() && !m["AnchorUserId"].empty()) {
      anchorUserId = make_shared<string>(boost::any_cast<string>(m["AnchorUserId"]));
    }
    if (m.find("LiveEndTime") != m.end() && !m["LiveEndTime"].empty()) {
      liveEndTime = make_shared<long>(boost::any_cast<long>(m["LiveEndTime"]));
    }
    if (m.find("LiveStartTime") != m.end() && !m["LiveStartTime"].empty()) {
      liveStartTime = make_shared<long>(boost::any_cast<long>(m["LiveStartTime"]));
    }
    if (m.find("LiveUuid") != m.end() && !m["LiveUuid"].empty()) {
      liveUuid = make_shared<string>(boost::any_cast<string>(m["LiveUuid"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GetOrgLiveListResponseBodyResultUpdateLiveLiveList() = default;
};
class GetOrgLiveListResponseBodyResultUpdateLive : public Darabonba::Model {
public:
  shared_ptr<bool> hasMore{};
  shared_ptr<vector<GetOrgLiveListResponseBodyResultUpdateLiveLiveList>> liveList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  GetOrgLiveListResponseBodyResultUpdateLive() {}

  explicit GetOrgLiveListResponseBodyResultUpdateLive(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (liveList) {
      vector<boost::any> temp1;
      for(auto item1:*liveList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveList"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("LiveList") != m.end() && !m["LiveList"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveList"].type()) {
        vector<GetOrgLiveListResponseBodyResultUpdateLiveLiveList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetOrgLiveListResponseBodyResultUpdateLiveLiveList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveList = make_shared<vector<GetOrgLiveListResponseBodyResultUpdateLiveLiveList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetOrgLiveListResponseBodyResultUpdateLive() = default;
};
class GetOrgLiveListResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<GetOrgLiveListResponseBodyResultNewLive> newLive{};
  shared_ptr<GetOrgLiveListResponseBodyResultUpdateLive> updateLive{};

  GetOrgLiveListResponseBodyResult() {}

  explicit GetOrgLiveListResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (newLive) {
      res["NewLive"] = newLive ? boost::any(newLive->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updateLive) {
      res["UpdateLive"] = updateLive ? boost::any(updateLive->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NewLive") != m.end() && !m["NewLive"].empty()) {
      if (typeid(map<string, boost::any>) == m["NewLive"].type()) {
        GetOrgLiveListResponseBodyResultNewLive model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NewLive"]));
        newLive = make_shared<GetOrgLiveListResponseBodyResultNewLive>(model1);
      }
    }
    if (m.find("UpdateLive") != m.end() && !m["UpdateLive"].empty()) {
      if (typeid(map<string, boost::any>) == m["UpdateLive"].type()) {
        GetOrgLiveListResponseBodyResultUpdateLive model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UpdateLive"]));
        updateLive = make_shared<GetOrgLiveListResponseBodyResultUpdateLive>(model1);
      }
    }
  }


  virtual ~GetOrgLiveListResponseBodyResult() = default;
};
class GetOrgLiveListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetOrgLiveListResponseBodyResult> result{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetOrgLiveListResponseBody() {}

  explicit GetOrgLiveListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        GetOrgLiveListResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<GetOrgLiveListResponseBodyResult>(model1);
      }
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetOrgLiveListResponseBody() = default;
};
class GetOrgLiveListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOrgLiveListResponseBody> body{};

  GetOrgLiveListResponse() {}

  explicit GetOrgLiveListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOrgLiveListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOrgLiveListResponseBody>(model1);
      }
    }
  }


  virtual ~GetOrgLiveListResponse() = default;
};
class GetOrgOrWebOpenDocContentTaskIdHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetOrgOrWebOpenDocContentTaskIdHeadersAccountContext() {}

  explicit GetOrgOrWebOpenDocContentTaskIdHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetOrgOrWebOpenDocContentTaskIdHeadersAccountContext() = default;
};
class GetOrgOrWebOpenDocContentTaskIdHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetOrgOrWebOpenDocContentTaskIdHeadersAccountContext> accountContext{};

  GetOrgOrWebOpenDocContentTaskIdHeaders() {}

  explicit GetOrgOrWebOpenDocContentTaskIdHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetOrgOrWebOpenDocContentTaskIdHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetOrgOrWebOpenDocContentTaskIdHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetOrgOrWebOpenDocContentTaskIdHeaders() = default;
};
class GetOrgOrWebOpenDocContentTaskIdShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetOrgOrWebOpenDocContentTaskIdShrinkHeaders() {}

  explicit GetOrgOrWebOpenDocContentTaskIdShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetOrgOrWebOpenDocContentTaskIdShrinkHeaders() = default;
};
class GetOrgOrWebOpenDocContentTaskIdRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetOrgOrWebOpenDocContentTaskIdRequestTenantContext() {}

  explicit GetOrgOrWebOpenDocContentTaskIdRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetOrgOrWebOpenDocContentTaskIdRequestTenantContext() = default;
};
class GetOrgOrWebOpenDocContentTaskIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryUuid{};
  shared_ptr<bool> generateCp{};
  shared_ptr<long> scopeType{};
  shared_ptr<string> targetFormat{};
  shared_ptr<GetOrgOrWebOpenDocContentTaskIdRequestTenantContext> tenantContext{};

  GetOrgOrWebOpenDocContentTaskIdRequest() {}

  explicit GetOrgOrWebOpenDocContentTaskIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryUuid) {
      res["DentryUuid"] = boost::any(*dentryUuid);
    }
    if (generateCp) {
      res["GenerateCp"] = boost::any(*generateCp);
    }
    if (scopeType) {
      res["ScopeType"] = boost::any(*scopeType);
    }
    if (targetFormat) {
      res["TargetFormat"] = boost::any(*targetFormat);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryUuid") != m.end() && !m["DentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["DentryUuid"]));
    }
    if (m.find("GenerateCp") != m.end() && !m["GenerateCp"].empty()) {
      generateCp = make_shared<bool>(boost::any_cast<bool>(m["GenerateCp"]));
    }
    if (m.find("ScopeType") != m.end() && !m["ScopeType"].empty()) {
      scopeType = make_shared<long>(boost::any_cast<long>(m["ScopeType"]));
    }
    if (m.find("TargetFormat") != m.end() && !m["TargetFormat"].empty()) {
      targetFormat = make_shared<string>(boost::any_cast<string>(m["TargetFormat"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetOrgOrWebOpenDocContentTaskIdRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetOrgOrWebOpenDocContentTaskIdRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetOrgOrWebOpenDocContentTaskIdRequest() = default;
};
class GetOrgOrWebOpenDocContentTaskIdShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryUuid{};
  shared_ptr<bool> generateCp{};
  shared_ptr<long> scopeType{};
  shared_ptr<string> targetFormat{};
  shared_ptr<string> tenantContextShrink{};

  GetOrgOrWebOpenDocContentTaskIdShrinkRequest() {}

  explicit GetOrgOrWebOpenDocContentTaskIdShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryUuid) {
      res["DentryUuid"] = boost::any(*dentryUuid);
    }
    if (generateCp) {
      res["GenerateCp"] = boost::any(*generateCp);
    }
    if (scopeType) {
      res["ScopeType"] = boost::any(*scopeType);
    }
    if (targetFormat) {
      res["TargetFormat"] = boost::any(*targetFormat);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryUuid") != m.end() && !m["DentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["DentryUuid"]));
    }
    if (m.find("GenerateCp") != m.end() && !m["GenerateCp"].empty()) {
      generateCp = make_shared<bool>(boost::any_cast<bool>(m["GenerateCp"]));
    }
    if (m.find("ScopeType") != m.end() && !m["ScopeType"].empty()) {
      scopeType = make_shared<long>(boost::any_cast<long>(m["ScopeType"]));
    }
    if (m.find("TargetFormat") != m.end() && !m["TargetFormat"].empty()) {
      targetFormat = make_shared<string>(boost::any_cast<string>(m["TargetFormat"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetOrgOrWebOpenDocContentTaskIdShrinkRequest() = default;
};
class GetOrgOrWebOpenDocContentTaskIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> taskId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetOrgOrWebOpenDocContentTaskIdResponseBody() {}

  explicit GetOrgOrWebOpenDocContentTaskIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["taskId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetOrgOrWebOpenDocContentTaskIdResponseBody() = default;
};
class GetOrgOrWebOpenDocContentTaskIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOrgOrWebOpenDocContentTaskIdResponseBody> body{};

  GetOrgOrWebOpenDocContentTaskIdResponse() {}

  explicit GetOrgOrWebOpenDocContentTaskIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOrgOrWebOpenDocContentTaskIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOrgOrWebOpenDocContentTaskIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetOrgOrWebOpenDocContentTaskIdResponse() = default;
};
class GetProcessDefinitionHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetProcessDefinitionHeadersAccountContext() {}

  explicit GetProcessDefinitionHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetProcessDefinitionHeadersAccountContext() = default;
};
class GetProcessDefinitionHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetProcessDefinitionHeadersAccountContext> accountContext{};

  GetProcessDefinitionHeaders() {}

  explicit GetProcessDefinitionHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetProcessDefinitionHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetProcessDefinitionHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetProcessDefinitionHeaders() = default;
};
class GetProcessDefinitionShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetProcessDefinitionShrinkHeaders() {}

  explicit GetProcessDefinitionShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetProcessDefinitionShrinkHeaders() = default;
};
class GetProcessDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> corpId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> language{};
  shared_ptr<string> nameSpace_{};
  shared_ptr<string> orderNumber{};
  shared_ptr<string> processInstanceId{};
  shared_ptr<string> systemToken{};
  shared_ptr<string> systemType{};

  GetProcessDefinitionRequest() {}

  explicit GetProcessDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (nameSpace_) {
      res["NameSpace"] = boost::any(*nameSpace_);
    }
    if (orderNumber) {
      res["OrderNumber"] = boost::any(*orderNumber);
    }
    if (processInstanceId) {
      res["ProcessInstanceId"] = boost::any(*processInstanceId);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    if (systemType) {
      res["SystemType"] = boost::any(*systemType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("NameSpace") != m.end() && !m["NameSpace"].empty()) {
      nameSpace_ = make_shared<string>(boost::any_cast<string>(m["NameSpace"]));
    }
    if (m.find("OrderNumber") != m.end() && !m["OrderNumber"].empty()) {
      orderNumber = make_shared<string>(boost::any_cast<string>(m["OrderNumber"]));
    }
    if (m.find("ProcessInstanceId") != m.end() && !m["ProcessInstanceId"].empty()) {
      processInstanceId = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceId"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
    if (m.find("SystemType") != m.end() && !m["SystemType"].empty()) {
      systemType = make_shared<string>(boost::any_cast<string>(m["SystemType"]));
    }
  }


  virtual ~GetProcessDefinitionRequest() = default;
};
class GetProcessDefinitionResponseBodyOriginatorMasterDataDepartments : public Darabonba::Model {
public:
  shared_ptr<string> deptName{};
  shared_ptr<string> deptNameInEnglish{};
  shared_ptr<string> deptNo{};
  shared_ptr<string> deptPath{};
  shared_ptr<string> humanSourceGroupOrderNumber{};
  shared_ptr<string> humanSourceGroupWorkNo{};
  shared_ptr<long> id{};
  shared_ptr<string> masterWorkNo{};

  GetProcessDefinitionResponseBodyOriginatorMasterDataDepartments() {}

  explicit GetProcessDefinitionResponseBodyOriginatorMasterDataDepartments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deptName) {
      res["DeptName"] = boost::any(*deptName);
    }
    if (deptNameInEnglish) {
      res["DeptNameInEnglish"] = boost::any(*deptNameInEnglish);
    }
    if (deptNo) {
      res["DeptNo"] = boost::any(*deptNo);
    }
    if (deptPath) {
      res["DeptPath"] = boost::any(*deptPath);
    }
    if (humanSourceGroupOrderNumber) {
      res["HumanSourceGroupOrderNumber"] = boost::any(*humanSourceGroupOrderNumber);
    }
    if (humanSourceGroupWorkNo) {
      res["HumanSourceGroupWorkNo"] = boost::any(*humanSourceGroupWorkNo);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (masterWorkNo) {
      res["MasterWorkNo"] = boost::any(*masterWorkNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeptName") != m.end() && !m["DeptName"].empty()) {
      deptName = make_shared<string>(boost::any_cast<string>(m["DeptName"]));
    }
    if (m.find("DeptNameInEnglish") != m.end() && !m["DeptNameInEnglish"].empty()) {
      deptNameInEnglish = make_shared<string>(boost::any_cast<string>(m["DeptNameInEnglish"]));
    }
    if (m.find("DeptNo") != m.end() && !m["DeptNo"].empty()) {
      deptNo = make_shared<string>(boost::any_cast<string>(m["DeptNo"]));
    }
    if (m.find("DeptPath") != m.end() && !m["DeptPath"].empty()) {
      deptPath = make_shared<string>(boost::any_cast<string>(m["DeptPath"]));
    }
    if (m.find("HumanSourceGroupOrderNumber") != m.end() && !m["HumanSourceGroupOrderNumber"].empty()) {
      humanSourceGroupOrderNumber = make_shared<string>(boost::any_cast<string>(m["HumanSourceGroupOrderNumber"]));
    }
    if (m.find("HumanSourceGroupWorkNo") != m.end() && !m["HumanSourceGroupWorkNo"].empty()) {
      humanSourceGroupWorkNo = make_shared<string>(boost::any_cast<string>(m["HumanSourceGroupWorkNo"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MasterWorkNo") != m.end() && !m["MasterWorkNo"].empty()) {
      masterWorkNo = make_shared<string>(boost::any_cast<string>(m["MasterWorkNo"]));
    }
  }


  virtual ~GetProcessDefinitionResponseBodyOriginatorMasterDataDepartments() = default;
};
class GetProcessDefinitionResponseBodyOriginator : public Darabonba::Model {
public:
  shared_ptr<string> departmentDescription{};
  shared_ptr<string> displayEnName{};
  shared_ptr<string> displayName{};
  shared_ptr<vector<GetProcessDefinitionResponseBodyOriginatorMasterDataDepartments>> masterDataDepartments{};
  shared_ptr<string> orderNumber{};
  shared_ptr<string> personalPhoto{};
  shared_ptr<string> status{};
  shared_ptr<string> tbWang{};
  shared_ptr<string> userId{};
  shared_ptr<string> userInfo{};

  GetProcessDefinitionResponseBodyOriginator() {}

  explicit GetProcessDefinitionResponseBodyOriginator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (departmentDescription) {
      res["DepartmentDescription"] = boost::any(*departmentDescription);
    }
    if (displayEnName) {
      res["DisplayEnName"] = boost::any(*displayEnName);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (masterDataDepartments) {
      vector<boost::any> temp1;
      for(auto item1:*masterDataDepartments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MasterDataDepartments"] = boost::any(temp1);
    }
    if (orderNumber) {
      res["OrderNumber"] = boost::any(*orderNumber);
    }
    if (personalPhoto) {
      res["PersonalPhoto"] = boost::any(*personalPhoto);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tbWang) {
      res["TbWang"] = boost::any(*tbWang);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userInfo) {
      res["UserInfo"] = boost::any(*userInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DepartmentDescription") != m.end() && !m["DepartmentDescription"].empty()) {
      departmentDescription = make_shared<string>(boost::any_cast<string>(m["DepartmentDescription"]));
    }
    if (m.find("DisplayEnName") != m.end() && !m["DisplayEnName"].empty()) {
      displayEnName = make_shared<string>(boost::any_cast<string>(m["DisplayEnName"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("MasterDataDepartments") != m.end() && !m["MasterDataDepartments"].empty()) {
      if (typeid(vector<boost::any>) == m["MasterDataDepartments"].type()) {
        vector<GetProcessDefinitionResponseBodyOriginatorMasterDataDepartments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MasterDataDepartments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetProcessDefinitionResponseBodyOriginatorMasterDataDepartments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        masterDataDepartments = make_shared<vector<GetProcessDefinitionResponseBodyOriginatorMasterDataDepartments>>(expect1);
      }
    }
    if (m.find("OrderNumber") != m.end() && !m["OrderNumber"].empty()) {
      orderNumber = make_shared<string>(boost::any_cast<string>(m["OrderNumber"]));
    }
    if (m.find("PersonalPhoto") != m.end() && !m["PersonalPhoto"].empty()) {
      personalPhoto = make_shared<string>(boost::any_cast<string>(m["PersonalPhoto"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TbWang") != m.end() && !m["TbWang"].empty()) {
      tbWang = make_shared<string>(boost::any_cast<string>(m["TbWang"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserInfo") != m.end() && !m["UserInfo"].empty()) {
      userInfo = make_shared<string>(boost::any_cast<string>(m["UserInfo"]));
    }
  }


  virtual ~GetProcessDefinitionResponseBodyOriginator() = default;
};
class GetProcessDefinitionResponseBodyOwnersMasterDataDepartments : public Darabonba::Model {
public:
  shared_ptr<string> deptName{};
  shared_ptr<string> deptNameInEnglish{};
  shared_ptr<string> deptNo{};
  shared_ptr<string> deptPath{};
  shared_ptr<string> humanSourceGroupOrderNumber{};
  shared_ptr<string> humanSourceGroupWorkNo{};
  shared_ptr<long> id{};
  shared_ptr<string> masterWorkNo{};

  GetProcessDefinitionResponseBodyOwnersMasterDataDepartments() {}

  explicit GetProcessDefinitionResponseBodyOwnersMasterDataDepartments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deptName) {
      res["DeptName"] = boost::any(*deptName);
    }
    if (deptNameInEnglish) {
      res["DeptNameInEnglish"] = boost::any(*deptNameInEnglish);
    }
    if (deptNo) {
      res["DeptNo"] = boost::any(*deptNo);
    }
    if (deptPath) {
      res["DeptPath"] = boost::any(*deptPath);
    }
    if (humanSourceGroupOrderNumber) {
      res["HumanSourceGroupOrderNumber"] = boost::any(*humanSourceGroupOrderNumber);
    }
    if (humanSourceGroupWorkNo) {
      res["HumanSourceGroupWorkNo"] = boost::any(*humanSourceGroupWorkNo);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (masterWorkNo) {
      res["MasterWorkNo"] = boost::any(*masterWorkNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeptName") != m.end() && !m["DeptName"].empty()) {
      deptName = make_shared<string>(boost::any_cast<string>(m["DeptName"]));
    }
    if (m.find("DeptNameInEnglish") != m.end() && !m["DeptNameInEnglish"].empty()) {
      deptNameInEnglish = make_shared<string>(boost::any_cast<string>(m["DeptNameInEnglish"]));
    }
    if (m.find("DeptNo") != m.end() && !m["DeptNo"].empty()) {
      deptNo = make_shared<string>(boost::any_cast<string>(m["DeptNo"]));
    }
    if (m.find("DeptPath") != m.end() && !m["DeptPath"].empty()) {
      deptPath = make_shared<string>(boost::any_cast<string>(m["DeptPath"]));
    }
    if (m.find("HumanSourceGroupOrderNumber") != m.end() && !m["HumanSourceGroupOrderNumber"].empty()) {
      humanSourceGroupOrderNumber = make_shared<string>(boost::any_cast<string>(m["HumanSourceGroupOrderNumber"]));
    }
    if (m.find("HumanSourceGroupWorkNo") != m.end() && !m["HumanSourceGroupWorkNo"].empty()) {
      humanSourceGroupWorkNo = make_shared<string>(boost::any_cast<string>(m["HumanSourceGroupWorkNo"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MasterWorkNo") != m.end() && !m["MasterWorkNo"].empty()) {
      masterWorkNo = make_shared<string>(boost::any_cast<string>(m["MasterWorkNo"]));
    }
  }


  virtual ~GetProcessDefinitionResponseBodyOwnersMasterDataDepartments() = default;
};
class GetProcessDefinitionResponseBodyOwners : public Darabonba::Model {
public:
  shared_ptr<string> departmentDescription{};
  shared_ptr<string> displayEnName{};
  shared_ptr<string> displayName{};
  shared_ptr<vector<GetProcessDefinitionResponseBodyOwnersMasterDataDepartments>> masterDataDepartments{};
  shared_ptr<string> orderNumber{};
  shared_ptr<string> personalPhoto{};
  shared_ptr<string> status{};
  shared_ptr<string> tbWang{};
  shared_ptr<string> userId{};
  shared_ptr<string> userInfo{};

  GetProcessDefinitionResponseBodyOwners() {}

  explicit GetProcessDefinitionResponseBodyOwners(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (departmentDescription) {
      res["DepartmentDescription"] = boost::any(*departmentDescription);
    }
    if (displayEnName) {
      res["DisplayEnName"] = boost::any(*displayEnName);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (masterDataDepartments) {
      vector<boost::any> temp1;
      for(auto item1:*masterDataDepartments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MasterDataDepartments"] = boost::any(temp1);
    }
    if (orderNumber) {
      res["OrderNumber"] = boost::any(*orderNumber);
    }
    if (personalPhoto) {
      res["PersonalPhoto"] = boost::any(*personalPhoto);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tbWang) {
      res["TbWang"] = boost::any(*tbWang);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userInfo) {
      res["UserInfo"] = boost::any(*userInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DepartmentDescription") != m.end() && !m["DepartmentDescription"].empty()) {
      departmentDescription = make_shared<string>(boost::any_cast<string>(m["DepartmentDescription"]));
    }
    if (m.find("DisplayEnName") != m.end() && !m["DisplayEnName"].empty()) {
      displayEnName = make_shared<string>(boost::any_cast<string>(m["DisplayEnName"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("MasterDataDepartments") != m.end() && !m["MasterDataDepartments"].empty()) {
      if (typeid(vector<boost::any>) == m["MasterDataDepartments"].type()) {
        vector<GetProcessDefinitionResponseBodyOwnersMasterDataDepartments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MasterDataDepartments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetProcessDefinitionResponseBodyOwnersMasterDataDepartments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        masterDataDepartments = make_shared<vector<GetProcessDefinitionResponseBodyOwnersMasterDataDepartments>>(expect1);
      }
    }
    if (m.find("OrderNumber") != m.end() && !m["OrderNumber"].empty()) {
      orderNumber = make_shared<string>(boost::any_cast<string>(m["OrderNumber"]));
    }
    if (m.find("PersonalPhoto") != m.end() && !m["PersonalPhoto"].empty()) {
      personalPhoto = make_shared<string>(boost::any_cast<string>(m["PersonalPhoto"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TbWang") != m.end() && !m["TbWang"].empty()) {
      tbWang = make_shared<string>(boost::any_cast<string>(m["TbWang"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserInfo") != m.end() && !m["UserInfo"].empty()) {
      userInfo = make_shared<string>(boost::any_cast<string>(m["UserInfo"]));
    }
  }


  virtual ~GetProcessDefinitionResponseBodyOwners() = default;
};
class GetProcessDefinitionResponseBodyTasksActivity : public Darabonba::Model {
public:
  shared_ptr<string> activityId{};
  shared_ptr<string> activityInstanceStatus{};
  shared_ptr<string> activityName{};
  shared_ptr<string> activityNameInEnglish{};
  shared_ptr<long> id{};

  GetProcessDefinitionResponseBodyTasksActivity() {}

  explicit GetProcessDefinitionResponseBodyTasksActivity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityId) {
      res["ActivityId"] = boost::any(*activityId);
    }
    if (activityInstanceStatus) {
      res["ActivityInstanceStatus"] = boost::any(*activityInstanceStatus);
    }
    if (activityName) {
      res["ActivityName"] = boost::any(*activityName);
    }
    if (activityNameInEnglish) {
      res["ActivityNameInEnglish"] = boost::any(*activityNameInEnglish);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityId") != m.end() && !m["ActivityId"].empty()) {
      activityId = make_shared<string>(boost::any_cast<string>(m["ActivityId"]));
    }
    if (m.find("ActivityInstanceStatus") != m.end() && !m["ActivityInstanceStatus"].empty()) {
      activityInstanceStatus = make_shared<string>(boost::any_cast<string>(m["ActivityInstanceStatus"]));
    }
    if (m.find("ActivityName") != m.end() && !m["ActivityName"].empty()) {
      activityName = make_shared<string>(boost::any_cast<string>(m["ActivityName"]));
    }
    if (m.find("ActivityNameInEnglish") != m.end() && !m["ActivityNameInEnglish"].empty()) {
      activityNameInEnglish = make_shared<string>(boost::any_cast<string>(m["ActivityNameInEnglish"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetProcessDefinitionResponseBodyTasksActivity() = default;
};
class GetProcessDefinitionResponseBodyTasks : public Darabonba::Model {
public:
  shared_ptr<string> actionerId{};
  shared_ptr<GetProcessDefinitionResponseBodyTasksActivity> activity{};
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};

  GetProcessDefinitionResponseBodyTasks() {}

  explicit GetProcessDefinitionResponseBodyTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionerId) {
      res["ActionerId"] = boost::any(*actionerId);
    }
    if (activity) {
      res["Activity"] = activity ? boost::any(activity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionerId") != m.end() && !m["ActionerId"].empty()) {
      actionerId = make_shared<string>(boost::any_cast<string>(m["ActionerId"]));
    }
    if (m.find("Activity") != m.end() && !m["Activity"].empty()) {
      if (typeid(map<string, boost::any>) == m["Activity"].type()) {
        GetProcessDefinitionResponseBodyTasksActivity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Activity"]));
        activity = make_shared<GetProcessDefinitionResponseBodyTasksActivity>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~GetProcessDefinitionResponseBodyTasks() = default;
};
class GetProcessDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> formUuid{};
  shared_ptr<GetProcessDefinitionResponseBodyOriginator> originator{};
  shared_ptr<string> outResult{};
  shared_ptr<vector<GetProcessDefinitionResponseBodyOwners>> owners{};
  shared_ptr<string> processId{};
  shared_ptr<string> processInstanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<vector<GetProcessDefinitionResponseBodyTasks>> tasks{};
  shared_ptr<string> title{};
  shared_ptr<map<string, boost::any>> variables{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetProcessDefinitionResponseBody() {}

  explicit GetProcessDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (formUuid) {
      res["formUuid"] = boost::any(*formUuid);
    }
    if (originator) {
      res["originator"] = originator ? boost::any(originator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outResult) {
      res["outResult"] = boost::any(*outResult);
    }
    if (owners) {
      vector<boost::any> temp1;
      for(auto item1:*owners){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["owners"] = boost::any(temp1);
    }
    if (processId) {
      res["processId"] = boost::any(*processId);
    }
    if (processInstanceId) {
      res["processInstanceId"] = boost::any(*processInstanceId);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tasks"] = boost::any(temp1);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (variables) {
      res["variables"] = boost::any(*variables);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("formUuid") != m.end() && !m["formUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["formUuid"]));
    }
    if (m.find("originator") != m.end() && !m["originator"].empty()) {
      if (typeid(map<string, boost::any>) == m["originator"].type()) {
        GetProcessDefinitionResponseBodyOriginator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["originator"]));
        originator = make_shared<GetProcessDefinitionResponseBodyOriginator>(model1);
      }
    }
    if (m.find("outResult") != m.end() && !m["outResult"].empty()) {
      outResult = make_shared<string>(boost::any_cast<string>(m["outResult"]));
    }
    if (m.find("owners") != m.end() && !m["owners"].empty()) {
      if (typeid(vector<boost::any>) == m["owners"].type()) {
        vector<GetProcessDefinitionResponseBodyOwners> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["owners"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetProcessDefinitionResponseBodyOwners model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        owners = make_shared<vector<GetProcessDefinitionResponseBodyOwners>>(expect1);
      }
    }
    if (m.find("processId") != m.end() && !m["processId"].empty()) {
      processId = make_shared<string>(boost::any_cast<string>(m["processId"]));
    }
    if (m.find("processInstanceId") != m.end() && !m["processInstanceId"].empty()) {
      processInstanceId = make_shared<string>(boost::any_cast<string>(m["processInstanceId"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("tasks") != m.end() && !m["tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["tasks"].type()) {
        vector<GetProcessDefinitionResponseBodyTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetProcessDefinitionResponseBodyTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<GetProcessDefinitionResponseBodyTasks>>(expect1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("variables") != m.end() && !m["variables"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["variables"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      variables = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetProcessDefinitionResponseBody() = default;
};
class GetProcessDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetProcessDefinitionResponseBody> body{};

  GetProcessDefinitionResponse() {}

  explicit GetProcessDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetProcessDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetProcessDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~GetProcessDefinitionResponse() = default;
};
class GetRangeHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetRangeHeadersAccountContext() {}

  explicit GetRangeHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetRangeHeadersAccountContext() = default;
};
class GetRangeHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetRangeHeadersAccountContext> accountContext{};

  GetRangeHeaders() {}

  explicit GetRangeHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetRangeHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetRangeHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetRangeHeaders() = default;
};
class GetRangeShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetRangeShrinkHeaders() {}

  explicit GetRangeShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetRangeShrinkHeaders() = default;
};
class GetRangeRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetRangeRequestTenantContext() {}

  explicit GetRangeRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetRangeRequestTenantContext() = default;
};
class GetRangeRequest : public Darabonba::Model {
public:
  shared_ptr<string> rangeAddress{};
  shared_ptr<string> select{};
  shared_ptr<string> sheetId{};
  shared_ptr<GetRangeRequestTenantContext> tenantContext{};
  shared_ptr<string> workbookId{};

  GetRangeRequest() {}

  explicit GetRangeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rangeAddress) {
      res["RangeAddress"] = boost::any(*rangeAddress);
    }
    if (select) {
      res["Select"] = boost::any(*select);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RangeAddress") != m.end() && !m["RangeAddress"].empty()) {
      rangeAddress = make_shared<string>(boost::any_cast<string>(m["RangeAddress"]));
    }
    if (m.find("Select") != m.end() && !m["Select"].empty()) {
      select = make_shared<string>(boost::any_cast<string>(m["Select"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetRangeRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetRangeRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~GetRangeRequest() = default;
};
class GetRangeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> rangeAddress{};
  shared_ptr<string> select{};
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workbookId{};

  GetRangeShrinkRequest() {}

  explicit GetRangeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rangeAddress) {
      res["RangeAddress"] = boost::any(*rangeAddress);
    }
    if (select) {
      res["Select"] = boost::any(*select);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RangeAddress") != m.end() && !m["RangeAddress"].empty()) {
      rangeAddress = make_shared<string>(boost::any_cast<string>(m["RangeAddress"]));
    }
    if (m.find("Select") != m.end() && !m["Select"].empty()) {
      select = make_shared<string>(boost::any_cast<string>(m["Select"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~GetRangeShrinkRequest() = default;
};
class GetRangeResponseBodyBackgroundColors : public Darabonba::Model {
public:
  shared_ptr<long> red{};
  shared_ptr<long> green{};
  shared_ptr<long> blue{};
  shared_ptr<string> hexString{};

  GetRangeResponseBodyBackgroundColors() {}

  explicit GetRangeResponseBodyBackgroundColors(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (red) {
      res["Red"] = boost::any(*red);
    }
    if (green) {
      res["Green"] = boost::any(*green);
    }
    if (blue) {
      res["Blue"] = boost::any(*blue);
    }
    if (hexString) {
      res["HexString"] = boost::any(*hexString);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Red") != m.end() && !m["Red"].empty()) {
      red = make_shared<long>(boost::any_cast<long>(m["Red"]));
    }
    if (m.find("Green") != m.end() && !m["Green"].empty()) {
      green = make_shared<long>(boost::any_cast<long>(m["Green"]));
    }
    if (m.find("Blue") != m.end() && !m["Blue"].empty()) {
      blue = make_shared<long>(boost::any_cast<long>(m["Blue"]));
    }
    if (m.find("HexString") != m.end() && !m["HexString"].empty()) {
      hexString = make_shared<string>(boost::any_cast<string>(m["HexString"]));
    }
  }


  virtual ~GetRangeResponseBodyBackgroundColors() = default;
};
class GetRangeResponseBodyHyperlinks : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> link{};
  shared_ptr<string> text{};

  GetRangeResponseBodyHyperlinks() {}

  explicit GetRangeResponseBodyHyperlinks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (link) {
      res["link"] = boost::any(*link);
    }
    if (text) {
      res["text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("link") != m.end() && !m["link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["link"]));
    }
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
  }


  virtual ~GetRangeResponseBodyHyperlinks() = default;
};
class GetRangeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<vector<undefined>>> backgroundColors{};
  shared_ptr<vector<vector<string>>> displayValues{};
  shared_ptr<vector<vector<string>>> formulas{};
  shared_ptr<vector<vector<undefined>>> hyperlinks{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<vector<boost::any>>> values{};

  GetRangeResponseBody() {}

  explicit GetRangeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backgroundColors) {
      vector<boost::any> temp1;
      for(auto item1:*backgroundColors){
        vector<boost::any> temp2;
        for(auto item2:item1){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1 = boost::any(temp2);
      }
      res["backgroundColors"] = boost::any(temp1);
    }
    if (displayValues) {
      res["displayValues"] = boost::any(*displayValues);
    }
    if (formulas) {
      res["formulas"] = boost::any(*formulas);
    }
    if (hyperlinks) {
      vector<boost::any> temp1;
      for(auto item1:*hyperlinks){
        vector<boost::any> temp2;
        for(auto item2:item1){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1 = boost::any(temp2);
      }
      res["hyperlinks"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (values) {
      res["values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("backgroundColors") != m.end() && !m["backgroundColors"].empty()) {
      if (typeid(vector<boost::any>) == m["backgroundColors"].type()) {
        vector<vector<undefined>> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["backgroundColors"])){
          if (typeid(vector<boost::any>) == item1.type()) {
            vector<undefined> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                undefined model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1.push_back(expect2);
          }
        }
        backgroundColors = make_shared<vector<vector<undefined>>>(expect1);
      }
    }
    if (m.find("displayValues") != m.end() && !m["displayValues"].empty()) {
      vector<vector<string>> toVec1;
      if (typeid(vector<boost::any>) == m["displayValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["displayValues"]);
        for (auto item:vec1) {
          vector<string> toVec2;
          if (typeid(vector<boost::any>) == item.type()) {
            vector<boost::any> vec2 = boost::any_cast<vector<boost::any>>(item);
            for (auto item:vec2) {
               toVec2.push_back(boost::any_cast<string>(item));
            }
          }
           toVec1 = toVec2;
        }
      }
      displayValues = make_shared<vector<vector<string>>>(toVec1);
    }
    if (m.find("formulas") != m.end() && !m["formulas"].empty()) {
      vector<vector<string>> toVec1;
      if (typeid(vector<boost::any>) == m["formulas"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["formulas"]);
        for (auto item:vec1) {
          vector<string> toVec2;
          if (typeid(vector<boost::any>) == item.type()) {
            vector<boost::any> vec2 = boost::any_cast<vector<boost::any>>(item);
            for (auto item:vec2) {
               toVec2.push_back(boost::any_cast<string>(item));
            }
          }
           toVec1 = toVec2;
        }
      }
      formulas = make_shared<vector<vector<string>>>(toVec1);
    }
    if (m.find("hyperlinks") != m.end() && !m["hyperlinks"].empty()) {
      if (typeid(vector<boost::any>) == m["hyperlinks"].type()) {
        vector<vector<undefined>> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["hyperlinks"])){
          if (typeid(vector<boost::any>) == item1.type()) {
            vector<undefined> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                undefined model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1.push_back(expect2);
          }
        }
        hyperlinks = make_shared<vector<vector<undefined>>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("values") != m.end() && !m["values"].empty()) {
      vector<vector<boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["values"]);
        for (auto item:vec1) {
          vector<boost::any> toVec2;
          if (typeid(vector<boost::any>) == item.type()) {
            vector<boost::any> vec2 = boost::any_cast<vector<boost::any>>(item);
            for (auto item:vec2) {
               toVec2.push_back(boost::any_cast<boost::any>(item));
            }
          }
           toVec1 = toVec2;
        }
      }
      values = make_shared<vector<vector<boost::any>>>(toVec1);
    }
  }


  virtual ~GetRangeResponseBody() = default;
};
class GetRangeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRangeResponseBody> body{};

  GetRangeResponse() {}

  explicit GetRangeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRangeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRangeResponseBody>(model1);
      }
    }
  }


  virtual ~GetRangeResponse() = default;
};
class GetRelatedWorkspacesHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetRelatedWorkspacesHeadersAccountContext() {}

  explicit GetRelatedWorkspacesHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetRelatedWorkspacesHeadersAccountContext() = default;
};
class GetRelatedWorkspacesHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetRelatedWorkspacesHeadersAccountContext> accountContext{};

  GetRelatedWorkspacesHeaders() {}

  explicit GetRelatedWorkspacesHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetRelatedWorkspacesHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetRelatedWorkspacesHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetRelatedWorkspacesHeaders() = default;
};
class GetRelatedWorkspacesShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetRelatedWorkspacesShrinkHeaders() {}

  explicit GetRelatedWorkspacesShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetRelatedWorkspacesShrinkHeaders() = default;
};
class GetRelatedWorkspacesRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetRelatedWorkspacesRequestTenantContext() {}

  explicit GetRelatedWorkspacesRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetRelatedWorkspacesRequestTenantContext() = default;
};
class GetRelatedWorkspacesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> includeRecent{};
  shared_ptr<GetRelatedWorkspacesRequestTenantContext> tenantContext{};

  GetRelatedWorkspacesRequest() {}

  explicit GetRelatedWorkspacesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (includeRecent) {
      res["IncludeRecent"] = boost::any(*includeRecent);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IncludeRecent") != m.end() && !m["IncludeRecent"].empty()) {
      includeRecent = make_shared<bool>(boost::any_cast<bool>(m["IncludeRecent"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetRelatedWorkspacesRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetRelatedWorkspacesRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetRelatedWorkspacesRequest() = default;
};
class GetRelatedWorkspacesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> includeRecent{};
  shared_ptr<string> tenantContextShrink{};

  GetRelatedWorkspacesShrinkRequest() {}

  explicit GetRelatedWorkspacesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (includeRecent) {
      res["IncludeRecent"] = boost::any(*includeRecent);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IncludeRecent") != m.end() && !m["IncludeRecent"].empty()) {
      includeRecent = make_shared<bool>(boost::any_cast<bool>(m["IncludeRecent"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetRelatedWorkspacesShrinkRequest() = default;
};
class GetRelatedWorkspacesResponseBodyWorkspacesRecentList : public Darabonba::Model {
public:
  shared_ptr<long> lastEditTime{};
  shared_ptr<string> name{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> url{};

  GetRelatedWorkspacesResponseBodyWorkspacesRecentList() {}

  explicit GetRelatedWorkspacesResponseBodyWorkspacesRecentList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lastEditTime) {
      res["LastEditTime"] = boost::any(*lastEditTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LastEditTime") != m.end() && !m["LastEditTime"].empty()) {
      lastEditTime = make_shared<long>(boost::any_cast<long>(m["LastEditTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetRelatedWorkspacesResponseBodyWorkspacesRecentList() = default;
};
class GetRelatedWorkspacesResponseBodyWorkspaces : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<bool> deleted{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<vector<GetRelatedWorkspacesResponseBodyWorkspacesRecentList>> recentList{};
  shared_ptr<string> role{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  GetRelatedWorkspacesResponseBodyWorkspaces() {}

  explicit GetRelatedWorkspacesResponseBodyWorkspaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deleted) {
      res["Deleted"] = boost::any(*deleted);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (recentList) {
      vector<boost::any> temp1;
      for(auto item1:*recentList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecentList"] = boost::any(temp1);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Deleted") != m.end() && !m["Deleted"].empty()) {
      deleted = make_shared<bool>(boost::any_cast<bool>(m["Deleted"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("RecentList") != m.end() && !m["RecentList"].empty()) {
      if (typeid(vector<boost::any>) == m["RecentList"].type()) {
        vector<GetRelatedWorkspacesResponseBodyWorkspacesRecentList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecentList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRelatedWorkspacesResponseBodyWorkspacesRecentList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recentList = make_shared<vector<GetRelatedWorkspacesResponseBodyWorkspacesRecentList>>(expect1);
      }
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetRelatedWorkspacesResponseBodyWorkspaces() = default;
};
class GetRelatedWorkspacesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};
  shared_ptr<vector<GetRelatedWorkspacesResponseBodyWorkspaces>> workspaces{};

  GetRelatedWorkspacesResponseBody() {}

  explicit GetRelatedWorkspacesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    if (workspaces) {
      vector<boost::any> temp1;
      for(auto item1:*workspaces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["workspaces"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
    if (m.find("workspaces") != m.end() && !m["workspaces"].empty()) {
      if (typeid(vector<boost::any>) == m["workspaces"].type()) {
        vector<GetRelatedWorkspacesResponseBodyWorkspaces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["workspaces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRelatedWorkspacesResponseBodyWorkspaces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workspaces = make_shared<vector<GetRelatedWorkspacesResponseBodyWorkspaces>>(expect1);
      }
    }
  }


  virtual ~GetRelatedWorkspacesResponseBody() = default;
};
class GetRelatedWorkspacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRelatedWorkspacesResponseBody> body{};

  GetRelatedWorkspacesResponse() {}

  explicit GetRelatedWorkspacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRelatedWorkspacesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRelatedWorkspacesResponseBody>(model1);
      }
    }
  }


  virtual ~GetRelatedWorkspacesResponse() = default;
};
class GetReportTemplateByNameHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetReportTemplateByNameHeadersAccountContext() {}

  explicit GetReportTemplateByNameHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetReportTemplateByNameHeadersAccountContext() = default;
};
class GetReportTemplateByNameHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetReportTemplateByNameHeadersAccountContext> accountContext{};

  GetReportTemplateByNameHeaders() {}

  explicit GetReportTemplateByNameHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetReportTemplateByNameHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetReportTemplateByNameHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetReportTemplateByNameHeaders() = default;
};
class GetReportTemplateByNameShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetReportTemplateByNameShrinkHeaders() {}

  explicit GetReportTemplateByNameShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetReportTemplateByNameShrinkHeaders() = default;
};
class GetReportTemplateByNameRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetReportTemplateByNameRequestTenantContext() {}

  explicit GetReportTemplateByNameRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetReportTemplateByNameRequestTenantContext() = default;
};
class GetReportTemplateByNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateName{};
  shared_ptr<GetReportTemplateByNameRequestTenantContext> tenantContext{};

  GetReportTemplateByNameRequest() {}

  explicit GetReportTemplateByNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetReportTemplateByNameRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetReportTemplateByNameRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetReportTemplateByNameRequest() = default;
};
class GetReportTemplateByNameShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateName{};
  shared_ptr<string> tenantContextShrink{};

  GetReportTemplateByNameShrinkRequest() {}

  explicit GetReportTemplateByNameShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetReportTemplateByNameShrinkRequest() = default;
};
class GetReportTemplateByNameResponseBodyDefaultReceivedConvs : public Darabonba::Model {
public:
  shared_ptr<string> conversationId{};
  shared_ptr<string> title{};

  GetReportTemplateByNameResponseBodyDefaultReceivedConvs() {}

  explicit GetReportTemplateByNameResponseBodyDefaultReceivedConvs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conversationId) {
      res["ConversationId"] = boost::any(*conversationId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConversationId") != m.end() && !m["ConversationId"].empty()) {
      conversationId = make_shared<string>(boost::any_cast<string>(m["ConversationId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GetReportTemplateByNameResponseBodyDefaultReceivedConvs() = default;
};
class GetReportTemplateByNameResponseBodyDefaultReceivers : public Darabonba::Model {
public:
  shared_ptr<string> userName{};
  shared_ptr<string> userid{};

  GetReportTemplateByNameResponseBodyDefaultReceivers() {}

  explicit GetReportTemplateByNameResponseBodyDefaultReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (userid) {
      res["Userid"] = boost::any(*userid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("Userid") != m.end() && !m["Userid"].empty()) {
      userid = make_shared<string>(boost::any_cast<string>(m["Userid"]));
    }
  }


  virtual ~GetReportTemplateByNameResponseBodyDefaultReceivers() = default;
};
class GetReportTemplateByNameResponseBodyFields : public Darabonba::Model {
public:
  shared_ptr<string> fieldName{};
  shared_ptr<long> sort{};
  shared_ptr<long> type{};

  GetReportTemplateByNameResponseBodyFields() {}

  explicit GetReportTemplateByNameResponseBodyFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<long>(boost::any_cast<long>(m["Sort"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~GetReportTemplateByNameResponseBodyFields() = default;
};
class GetReportTemplateByNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetReportTemplateByNameResponseBodyDefaultReceivedConvs>> defaultReceivedConvs{};
  shared_ptr<vector<GetReportTemplateByNameResponseBodyDefaultReceivers>> defaultReceivers{};
  shared_ptr<vector<GetReportTemplateByNameResponseBodyFields>> fields{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> userName{};
  shared_ptr<string> userid{};

  GetReportTemplateByNameResponseBody() {}

  explicit GetReportTemplateByNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultReceivedConvs) {
      vector<boost::any> temp1;
      for(auto item1:*defaultReceivedConvs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["defaultReceivedConvs"] = boost::any(temp1);
    }
    if (defaultReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*defaultReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["defaultReceivers"] = boost::any(temp1);
    }
    if (fields) {
      vector<boost::any> temp1;
      for(auto item1:*fields){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["fields"] = boost::any(temp1);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (userName) {
      res["userName"] = boost::any(*userName);
    }
    if (userid) {
      res["userid"] = boost::any(*userid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("defaultReceivedConvs") != m.end() && !m["defaultReceivedConvs"].empty()) {
      if (typeid(vector<boost::any>) == m["defaultReceivedConvs"].type()) {
        vector<GetReportTemplateByNameResponseBodyDefaultReceivedConvs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["defaultReceivedConvs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetReportTemplateByNameResponseBodyDefaultReceivedConvs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        defaultReceivedConvs = make_shared<vector<GetReportTemplateByNameResponseBodyDefaultReceivedConvs>>(expect1);
      }
    }
    if (m.find("defaultReceivers") != m.end() && !m["defaultReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["defaultReceivers"].type()) {
        vector<GetReportTemplateByNameResponseBodyDefaultReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["defaultReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetReportTemplateByNameResponseBodyDefaultReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        defaultReceivers = make_shared<vector<GetReportTemplateByNameResponseBodyDefaultReceivers>>(expect1);
      }
    }
    if (m.find("fields") != m.end() && !m["fields"].empty()) {
      if (typeid(vector<boost::any>) == m["fields"].type()) {
        vector<GetReportTemplateByNameResponseBodyFields> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["fields"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetReportTemplateByNameResponseBodyFields model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fields = make_shared<vector<GetReportTemplateByNameResponseBodyFields>>(expect1);
      }
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("userName") != m.end() && !m["userName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["userName"]));
    }
    if (m.find("userid") != m.end() && !m["userid"].empty()) {
      userid = make_shared<string>(boost::any_cast<string>(m["userid"]));
    }
  }


  virtual ~GetReportTemplateByNameResponseBody() = default;
};
class GetReportTemplateByNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetReportTemplateByNameResponseBody> body{};

  GetReportTemplateByNameResponse() {}

  explicit GetReportTemplateByNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetReportTemplateByNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetReportTemplateByNameResponseBody>(model1);
      }
    }
  }


  virtual ~GetReportTemplateByNameResponse() = default;
};
class GetReportUnReadCountHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetReportUnReadCountHeadersAccountContext() {}

  explicit GetReportUnReadCountHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetReportUnReadCountHeadersAccountContext() = default;
};
class GetReportUnReadCountHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetReportUnReadCountHeadersAccountContext> accountContext{};

  GetReportUnReadCountHeaders() {}

  explicit GetReportUnReadCountHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetReportUnReadCountHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetReportUnReadCountHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetReportUnReadCountHeaders() = default;
};
class GetReportUnReadCountShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetReportUnReadCountShrinkHeaders() {}

  explicit GetReportUnReadCountShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetReportUnReadCountShrinkHeaders() = default;
};
class GetReportUnReadCountRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetReportUnReadCountRequestTenantContext() {}

  explicit GetReportUnReadCountRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetReportUnReadCountRequestTenantContext() = default;
};
class GetReportUnReadCountRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> request{};
  shared_ptr<GetReportUnReadCountRequestTenantContext> tenantContext{};

  GetReportUnReadCountRequest() {}

  explicit GetReportUnReadCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (request) {
      res["Request"] = boost::any(*request);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Request") != m.end() && !m["Request"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Request"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      request = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetReportUnReadCountRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetReportUnReadCountRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetReportUnReadCountRequest() = default;
};
class GetReportUnReadCountShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> requestShrink{};
  shared_ptr<string> tenantContextShrink{};

  GetReportUnReadCountShrinkRequest() {}

  explicit GetReportUnReadCountShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestShrink) {
      res["Request"] = boost::any(*requestShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Request") != m.end() && !m["Request"].empty()) {
      requestShrink = make_shared<string>(boost::any_cast<string>(m["Request"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetReportUnReadCountShrinkRequest() = default;
};
class GetReportUnReadCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> requestId{};

  GetReportUnReadCountResponseBody() {}

  explicit GetReportUnReadCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["count"] = boost::any(*count);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetReportUnReadCountResponseBody() = default;
};
class GetReportUnReadCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetReportUnReadCountResponseBody> body{};

  GetReportUnReadCountResponse() {}

  explicit GetReportUnReadCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetReportUnReadCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetReportUnReadCountResponseBody>(model1);
      }
    }
  }


  virtual ~GetReportUnReadCountResponse() = default;
};
class GetRunningTasksHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetRunningTasksHeadersAccountContext() {}

  explicit GetRunningTasksHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetRunningTasksHeadersAccountContext() = default;
};
class GetRunningTasksHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetRunningTasksHeadersAccountContext> accountContext{};

  GetRunningTasksHeaders() {}

  explicit GetRunningTasksHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetRunningTasksHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetRunningTasksHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetRunningTasksHeaders() = default;
};
class GetRunningTasksShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetRunningTasksShrinkHeaders() {}

  explicit GetRunningTasksShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetRunningTasksShrinkHeaders() = default;
};
class GetRunningTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> language{};
  shared_ptr<string> processCodes{};
  shared_ptr<string> processInstanceId{};
  shared_ptr<string> systemToken{};

  GetRunningTasksRequest() {}

  explicit GetRunningTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (processCodes) {
      res["ProcessCodes"] = boost::any(*processCodes);
    }
    if (processInstanceId) {
      res["ProcessInstanceId"] = boost::any(*processInstanceId);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("ProcessCodes") != m.end() && !m["ProcessCodes"].empty()) {
      processCodes = make_shared<string>(boost::any_cast<string>(m["ProcessCodes"]));
    }
    if (m.find("ProcessInstanceId") != m.end() && !m["ProcessInstanceId"].empty()) {
      processInstanceId = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceId"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~GetRunningTasksRequest() = default;
};
class GetRunningTasksResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> activeTimeGMT{};
  shared_ptr<string> activityId{};
  shared_ptr<string> actualActionerId{};
  shared_ptr<string> createTimeGMT{};
  shared_ptr<string> finishTimeGMT{};
  shared_ptr<string> originatorId{};
  shared_ptr<string> processInstanceId{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskType{};
  shared_ptr<string> title{};
  shared_ptr<string> titleInEnglish{};

  GetRunningTasksResponseBodyResult() {}

  explicit GetRunningTasksResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeTimeGMT) {
      res["ActiveTimeGMT"] = boost::any(*activeTimeGMT);
    }
    if (activityId) {
      res["ActivityId"] = boost::any(*activityId);
    }
    if (actualActionerId) {
      res["ActualActionerId"] = boost::any(*actualActionerId);
    }
    if (createTimeGMT) {
      res["CreateTimeGMT"] = boost::any(*createTimeGMT);
    }
    if (finishTimeGMT) {
      res["FinishTimeGMT"] = boost::any(*finishTimeGMT);
    }
    if (originatorId) {
      res["OriginatorId"] = boost::any(*originatorId);
    }
    if (processInstanceId) {
      res["ProcessInstanceId"] = boost::any(*processInstanceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (titleInEnglish) {
      res["TitleInEnglish"] = boost::any(*titleInEnglish);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveTimeGMT") != m.end() && !m["ActiveTimeGMT"].empty()) {
      activeTimeGMT = make_shared<string>(boost::any_cast<string>(m["ActiveTimeGMT"]));
    }
    if (m.find("ActivityId") != m.end() && !m["ActivityId"].empty()) {
      activityId = make_shared<string>(boost::any_cast<string>(m["ActivityId"]));
    }
    if (m.find("ActualActionerId") != m.end() && !m["ActualActionerId"].empty()) {
      actualActionerId = make_shared<string>(boost::any_cast<string>(m["ActualActionerId"]));
    }
    if (m.find("CreateTimeGMT") != m.end() && !m["CreateTimeGMT"].empty()) {
      createTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateTimeGMT"]));
    }
    if (m.find("FinishTimeGMT") != m.end() && !m["FinishTimeGMT"].empty()) {
      finishTimeGMT = make_shared<string>(boost::any_cast<string>(m["FinishTimeGMT"]));
    }
    if (m.find("OriginatorId") != m.end() && !m["OriginatorId"].empty()) {
      originatorId = make_shared<string>(boost::any_cast<string>(m["OriginatorId"]));
    }
    if (m.find("ProcessInstanceId") != m.end() && !m["ProcessInstanceId"].empty()) {
      processInstanceId = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("TitleInEnglish") != m.end() && !m["TitleInEnglish"].empty()) {
      titleInEnglish = make_shared<string>(boost::any_cast<string>(m["TitleInEnglish"]));
    }
  }


  virtual ~GetRunningTasksResponseBodyResult() = default;
};
class GetRunningTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetRunningTasksResponseBodyResult>> result{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetRunningTasksResponseBody() {}

  explicit GetRunningTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<GetRunningTasksResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRunningTasksResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<GetRunningTasksResponseBodyResult>>(expect1);
      }
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetRunningTasksResponseBody() = default;
};
class GetRunningTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRunningTasksResponseBody> body{};

  GetRunningTasksResponse() {}

  explicit GetRunningTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRunningTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRunningTasksResponseBody>(model1);
      }
    }
  }


  virtual ~GetRunningTasksResponse() = default;
};
class GetScheduleHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetScheduleHeadersAccountContext() {}

  explicit GetScheduleHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetScheduleHeadersAccountContext() = default;
};
class GetScheduleHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetScheduleHeadersAccountContext> accountContext{};

  GetScheduleHeaders() {}

  explicit GetScheduleHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetScheduleHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetScheduleHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetScheduleHeaders() = default;
};
class GetScheduleShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetScheduleShrinkHeaders() {}

  explicit GetScheduleShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetScheduleShrinkHeaders() = default;
};
class GetScheduleRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetScheduleRequestTenantContext() {}

  explicit GetScheduleRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetScheduleRequestTenantContext() = default;
};
class GetScheduleRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<GetScheduleRequestTenantContext> tenantContext{};
  shared_ptr<vector<string>> userIds{};

  GetScheduleRequest() {}

  explicit GetScheduleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetScheduleRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetScheduleRequestTenantContext>(model1);
      }
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetScheduleRequest() = default;
};
class GetScheduleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> userIdsShrink{};

  GetScheduleShrinkRequest() {}

  explicit GetScheduleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (userIdsShrink) {
      res["UserIds"] = boost::any(*userIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      userIdsShrink = make_shared<string>(boost::any_cast<string>(m["UserIds"]));
    }
  }


  virtual ~GetScheduleShrinkRequest() = default;
};
class GetScheduleResponseBodyScheduleInformationScheduleItemsEnd : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  GetScheduleResponseBodyScheduleInformationScheduleItemsEnd() {}

  explicit GetScheduleResponseBodyScheduleInformationScheduleItemsEnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~GetScheduleResponseBodyScheduleInformationScheduleItemsEnd() = default;
};
class GetScheduleResponseBodyScheduleInformationScheduleItemsStart : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  GetScheduleResponseBodyScheduleInformationScheduleItemsStart() {}

  explicit GetScheduleResponseBodyScheduleInformationScheduleItemsStart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~GetScheduleResponseBodyScheduleInformationScheduleItemsStart() = default;
};
class GetScheduleResponseBodyScheduleInformationScheduleItems : public Darabonba::Model {
public:
  shared_ptr<GetScheduleResponseBodyScheduleInformationScheduleItemsEnd> end{};
  shared_ptr<GetScheduleResponseBodyScheduleInformationScheduleItemsStart> start{};
  shared_ptr<string> status{};

  GetScheduleResponseBodyScheduleInformationScheduleItems() {}

  explicit GetScheduleResponseBodyScheduleInformationScheduleItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = end ? boost::any(end->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (start) {
      res["Start"] = start ? boost::any(start->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      if (typeid(map<string, boost::any>) == m["End"].type()) {
        GetScheduleResponseBodyScheduleInformationScheduleItemsEnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["End"]));
        end = make_shared<GetScheduleResponseBodyScheduleInformationScheduleItemsEnd>(model1);
      }
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      if (typeid(map<string, boost::any>) == m["Start"].type()) {
        GetScheduleResponseBodyScheduleInformationScheduleItemsStart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Start"]));
        start = make_shared<GetScheduleResponseBodyScheduleInformationScheduleItemsStart>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetScheduleResponseBodyScheduleInformationScheduleItems() = default;
};
class GetScheduleResponseBodyScheduleInformation : public Darabonba::Model {
public:
  shared_ptr<string> error{};
  shared_ptr<vector<GetScheduleResponseBodyScheduleInformationScheduleItems>> scheduleItems{};
  shared_ptr<string> userId{};

  GetScheduleResponseBodyScheduleInformation() {}

  explicit GetScheduleResponseBodyScheduleInformation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (scheduleItems) {
      vector<boost::any> temp1;
      for(auto item1:*scheduleItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScheduleItems"] = boost::any(temp1);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<string>(boost::any_cast<string>(m["Error"]));
    }
    if (m.find("ScheduleItems") != m.end() && !m["ScheduleItems"].empty()) {
      if (typeid(vector<boost::any>) == m["ScheduleItems"].type()) {
        vector<GetScheduleResponseBodyScheduleInformationScheduleItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScheduleItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetScheduleResponseBodyScheduleInformationScheduleItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scheduleItems = make_shared<vector<GetScheduleResponseBodyScheduleInformationScheduleItems>>(expect1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetScheduleResponseBodyScheduleInformation() = default;
};
class GetScheduleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetScheduleResponseBodyScheduleInformation>> scheduleInformation{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetScheduleResponseBody() {}

  explicit GetScheduleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (scheduleInformation) {
      vector<boost::any> temp1;
      for(auto item1:*scheduleInformation){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["scheduleInformation"] = boost::any(temp1);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("scheduleInformation") != m.end() && !m["scheduleInformation"].empty()) {
      if (typeid(vector<boost::any>) == m["scheduleInformation"].type()) {
        vector<GetScheduleResponseBodyScheduleInformation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["scheduleInformation"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetScheduleResponseBodyScheduleInformation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scheduleInformation = make_shared<vector<GetScheduleResponseBodyScheduleInformation>>(expect1);
      }
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetScheduleResponseBody() = default;
};
class GetScheduleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetScheduleResponseBody> body{};

  GetScheduleResponse() {}

  explicit GetScheduleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetScheduleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetScheduleResponseBody>(model1);
      }
    }
  }


  virtual ~GetScheduleResponse() = default;
};
class GetSheetHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetSheetHeadersAccountContext() {}

  explicit GetSheetHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetSheetHeadersAccountContext() = default;
};
class GetSheetHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetSheetHeadersAccountContext> accountContext{};

  GetSheetHeaders() {}

  explicit GetSheetHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetSheetHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetSheetHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetSheetHeaders() = default;
};
class GetSheetShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetSheetShrinkHeaders() {}

  explicit GetSheetShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetSheetShrinkHeaders() = default;
};
class GetSheetRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetSheetRequestTenantContext() {}

  explicit GetSheetRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetSheetRequestTenantContext() = default;
};
class GetSheetRequest : public Darabonba::Model {
public:
  shared_ptr<string> sheetId{};
  shared_ptr<GetSheetRequestTenantContext> tenantContext{};
  shared_ptr<string> workbookId{};

  GetSheetRequest() {}

  explicit GetSheetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetSheetRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetSheetRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~GetSheetRequest() = default;
};
class GetSheetShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workbookId{};

  GetSheetShrinkRequest() {}

  explicit GetSheetShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~GetSheetShrinkRequest() = default;
};
class GetSheetResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> columnCount{};
  shared_ptr<string> id{};
  shared_ptr<long> lastNonEmptyColumn{};
  shared_ptr<long> lastNonEmptyRow{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<long> rowCount{};
  shared_ptr<string> visibility{};

  GetSheetResponseBody() {}

  explicit GetSheetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnCount) {
      res["columnCount"] = boost::any(*columnCount);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (lastNonEmptyColumn) {
      res["lastNonEmptyColumn"] = boost::any(*lastNonEmptyColumn);
    }
    if (lastNonEmptyRow) {
      res["lastNonEmptyRow"] = boost::any(*lastNonEmptyRow);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (rowCount) {
      res["rowCount"] = boost::any(*rowCount);
    }
    if (visibility) {
      res["visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("columnCount") != m.end() && !m["columnCount"].empty()) {
      columnCount = make_shared<long>(boost::any_cast<long>(m["columnCount"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("lastNonEmptyColumn") != m.end() && !m["lastNonEmptyColumn"].empty()) {
      lastNonEmptyColumn = make_shared<long>(boost::any_cast<long>(m["lastNonEmptyColumn"]));
    }
    if (m.find("lastNonEmptyRow") != m.end() && !m["lastNonEmptyRow"].empty()) {
      lastNonEmptyRow = make_shared<long>(boost::any_cast<long>(m["lastNonEmptyRow"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("rowCount") != m.end() && !m["rowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["rowCount"]));
    }
    if (m.find("visibility") != m.end() && !m["visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["visibility"]));
    }
  }


  virtual ~GetSheetResponseBody() = default;
};
class GetSheetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSheetResponseBody> body{};

  GetSheetResponse() {}

  explicit GetSheetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSheetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSheetResponseBody>(model1);
      }
    }
  }


  virtual ~GetSheetResponse() = default;
};
class GetSheetContentJobIdHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetSheetContentJobIdHeadersAccountContext() {}

  explicit GetSheetContentJobIdHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetSheetContentJobIdHeadersAccountContext() = default;
};
class GetSheetContentJobIdHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetSheetContentJobIdHeadersAccountContext> accountContext{};

  GetSheetContentJobIdHeaders() {}

  explicit GetSheetContentJobIdHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetSheetContentJobIdHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetSheetContentJobIdHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetSheetContentJobIdHeaders() = default;
};
class GetSheetContentJobIdShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetSheetContentJobIdShrinkHeaders() {}

  explicit GetSheetContentJobIdShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetSheetContentJobIdShrinkHeaders() = default;
};
class GetSheetContentJobIdRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetSheetContentJobIdRequestTenantContext() {}

  explicit GetSheetContentJobIdRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetSheetContentJobIdRequestTenantContext() = default;
};
class GetSheetContentJobIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryUuid{};
  shared_ptr<string> exportType{};
  shared_ptr<GetSheetContentJobIdRequestTenantContext> tenantContext{};

  GetSheetContentJobIdRequest() {}

  explicit GetSheetContentJobIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryUuid) {
      res["DentryUuid"] = boost::any(*dentryUuid);
    }
    if (exportType) {
      res["ExportType"] = boost::any(*exportType);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryUuid") != m.end() && !m["DentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["DentryUuid"]));
    }
    if (m.find("ExportType") != m.end() && !m["ExportType"].empty()) {
      exportType = make_shared<string>(boost::any_cast<string>(m["ExportType"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetSheetContentJobIdRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetSheetContentJobIdRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetSheetContentJobIdRequest() = default;
};
class GetSheetContentJobIdShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryUuid{};
  shared_ptr<string> exportType{};
  shared_ptr<string> tenantContextShrink{};

  GetSheetContentJobIdShrinkRequest() {}

  explicit GetSheetContentJobIdShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryUuid) {
      res["DentryUuid"] = boost::any(*dentryUuid);
    }
    if (exportType) {
      res["ExportType"] = boost::any(*exportType);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryUuid") != m.end() && !m["DentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["DentryUuid"]));
    }
    if (m.find("ExportType") != m.end() && !m["ExportType"].empty()) {
      exportType = make_shared<string>(boost::any_cast<string>(m["ExportType"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetSheetContentJobIdShrinkRequest() = default;
};
class GetSheetContentJobIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetSheetContentJobIdResponseBody() {}

  explicit GetSheetContentJobIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["jobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("jobId") != m.end() && !m["jobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["jobId"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetSheetContentJobIdResponseBody() = default;
};
class GetSheetContentJobIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSheetContentJobIdResponseBody> body{};

  GetSheetContentJobIdResponse() {}

  explicit GetSheetContentJobIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSheetContentJobIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSheetContentJobIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetSheetContentJobIdResponse() = default;
};
class GetSpaceDirectoriesHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetSpaceDirectoriesHeadersAccountContext() {}

  explicit GetSpaceDirectoriesHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetSpaceDirectoriesHeadersAccountContext() = default;
};
class GetSpaceDirectoriesHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetSpaceDirectoriesHeadersAccountContext> accountContext{};

  GetSpaceDirectoriesHeaders() {}

  explicit GetSpaceDirectoriesHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetSpaceDirectoriesHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetSpaceDirectoriesHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetSpaceDirectoriesHeaders() = default;
};
class GetSpaceDirectoriesShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetSpaceDirectoriesShrinkHeaders() {}

  explicit GetSpaceDirectoriesShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetSpaceDirectoriesShrinkHeaders() = default;
};
class GetSpaceDirectoriesRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetSpaceDirectoriesRequestTenantContext() {}

  explicit GetSpaceDirectoriesRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetSpaceDirectoriesRequestTenantContext() = default;
};
class GetSpaceDirectoriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> spaceId{};
  shared_ptr<GetSpaceDirectoriesRequestTenantContext> tenantContext{};

  GetSpaceDirectoriesRequest() {}

  explicit GetSpaceDirectoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryId) {
      res["DentryId"] = boost::any(*dentryId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryId") != m.end() && !m["DentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["DentryId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetSpaceDirectoriesRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetSpaceDirectoriesRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetSpaceDirectoriesRequest() = default;
};
class GetSpaceDirectoriesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> spaceId{};
  shared_ptr<string> tenantContextShrink{};

  GetSpaceDirectoriesShrinkRequest() {}

  explicit GetSpaceDirectoriesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryId) {
      res["DentryId"] = boost::any(*dentryId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryId") != m.end() && !m["DentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["DentryId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetSpaceDirectoriesShrinkRequest() = default;
};
class GetSpaceDirectoriesResponseBodyChildrenCreator : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> userId{};

  GetSpaceDirectoriesResponseBodyChildrenCreator() {}

  explicit GetSpaceDirectoriesResponseBodyChildrenCreator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildrenCreator() = default;
};
class GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfoIconUrl : public Darabonba::Model {
public:
  shared_ptr<string> line{};
  shared_ptr<string> small{};

  GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfoIconUrl() {}

  explicit GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfoIconUrl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (small) {
      res["Small"] = boost::any(*small);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("Small") != m.end() && !m["Small"].empty()) {
      small = make_shared<string>(boost::any_cast<string>(m["Small"]));
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfoIconUrl() = default;
};
class GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfo : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfoIconUrl> iconUrl{};
  shared_ptr<string> id{};
  shared_ptr<long> linkType{};
  shared_ptr<string> spaceId{};

  GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfo() {}

  explicit GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (iconUrl) {
      res["IconUrl"] = iconUrl ? boost::any(iconUrl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (linkType) {
      res["LinkType"] = boost::any(*linkType);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("IconUrl") != m.end() && !m["IconUrl"].empty()) {
      if (typeid(map<string, boost::any>) == m["IconUrl"].type()) {
        GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfoIconUrl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IconUrl"]));
        iconUrl = make_shared<GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfoIconUrl>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LinkType") != m.end() && !m["LinkType"].empty()) {
      linkType = make_shared<long>(boost::any_cast<long>(m["LinkType"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfo() = default;
};
class GetSpaceDirectoriesResponseBodyChildrenSpaceHdIconVO : public Darabonba::Model {
public:
  shared_ptr<string> icon{};
  shared_ptr<string> type{};

  GetSpaceDirectoriesResponseBodyChildrenSpaceHdIconVO() {}

  explicit GetSpaceDirectoriesResponseBodyChildrenSpaceHdIconVO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildrenSpaceHdIconVO() = default;
};
class GetSpaceDirectoriesResponseBodyChildrenSpaceIconVO : public Darabonba::Model {
public:
  shared_ptr<string> icon{};
  shared_ptr<string> type{};

  GetSpaceDirectoriesResponseBodyChildrenSpaceIconVO() {}

  explicit GetSpaceDirectoriesResponseBodyChildrenSpaceIconVO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildrenSpaceIconVO() = default;
};
class GetSpaceDirectoriesResponseBodyChildrenSpaceOwner : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> userId{};

  GetSpaceDirectoriesResponseBodyChildrenSpaceOwner() {}

  explicit GetSpaceDirectoriesResponseBodyChildrenSpaceOwner(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildrenSpaceOwner() = default;
};
class GetSpaceDirectoriesResponseBodyChildrenSpaceVisitorInfo : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dentryActions{};
  shared_ptr<string> roleCode{};
  shared_ptr<vector<string>> spaceActions{};

  GetSpaceDirectoriesResponseBodyChildrenSpaceVisitorInfo() {}

  explicit GetSpaceDirectoriesResponseBodyChildrenSpaceVisitorInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryActions) {
      res["DentryActions"] = boost::any(*dentryActions);
    }
    if (roleCode) {
      res["RoleCode"] = boost::any(*roleCode);
    }
    if (spaceActions) {
      res["SpaceActions"] = boost::any(*spaceActions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryActions") != m.end() && !m["DentryActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DentryActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DentryActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dentryActions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoleCode") != m.end() && !m["RoleCode"].empty()) {
      roleCode = make_shared<string>(boost::any_cast<string>(m["RoleCode"]));
    }
    if (m.find("SpaceActions") != m.end() && !m["SpaceActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SpaceActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SpaceActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      spaceActions = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildrenSpaceVisitorInfo() = default;
};
class GetSpaceDirectoriesResponseBodyChildrenSpace : public Darabonba::Model {
public:
  shared_ptr<string> cover{};
  shared_ptr<string> description{};
  shared_ptr<GetSpaceDirectoriesResponseBodyChildrenSpaceHdIconVO> hdIconVO{};
  shared_ptr<GetSpaceDirectoriesResponseBodyChildrenSpaceIconVO> iconVO{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<GetSpaceDirectoriesResponseBodyChildrenSpaceOwner> owner{};
  shared_ptr<vector<boost::any>> recentList{};
  shared_ptr<long> type{};
  shared_ptr<string> url{};
  shared_ptr<GetSpaceDirectoriesResponseBodyChildrenSpaceVisitorInfo> visitorInfo{};

  GetSpaceDirectoriesResponseBodyChildrenSpace() {}

  explicit GetSpaceDirectoriesResponseBodyChildrenSpace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cover) {
      res["Cover"] = boost::any(*cover);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hdIconVO) {
      res["HdIconVO"] = hdIconVO ? boost::any(hdIconVO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (iconVO) {
      res["IconVO"] = iconVO ? boost::any(iconVO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = owner ? boost::any(owner->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recentList) {
      res["RecentList"] = boost::any(*recentList);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (visitorInfo) {
      res["VisitorInfo"] = visitorInfo ? boost::any(visitorInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      cover = make_shared<string>(boost::any_cast<string>(m["Cover"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HdIconVO") != m.end() && !m["HdIconVO"].empty()) {
      if (typeid(map<string, boost::any>) == m["HdIconVO"].type()) {
        GetSpaceDirectoriesResponseBodyChildrenSpaceHdIconVO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HdIconVO"]));
        hdIconVO = make_shared<GetSpaceDirectoriesResponseBodyChildrenSpaceHdIconVO>(model1);
      }
    }
    if (m.find("IconVO") != m.end() && !m["IconVO"].empty()) {
      if (typeid(map<string, boost::any>) == m["IconVO"].type()) {
        GetSpaceDirectoriesResponseBodyChildrenSpaceIconVO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IconVO"]));
        iconVO = make_shared<GetSpaceDirectoriesResponseBodyChildrenSpaceIconVO>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      if (typeid(map<string, boost::any>) == m["Owner"].type()) {
        GetSpaceDirectoriesResponseBodyChildrenSpaceOwner model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Owner"]));
        owner = make_shared<GetSpaceDirectoriesResponseBodyChildrenSpaceOwner>(model1);
      }
    }
    if (m.find("RecentList") != m.end() && !m["RecentList"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["RecentList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecentList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      recentList = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("VisitorInfo") != m.end() && !m["VisitorInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["VisitorInfo"].type()) {
        GetSpaceDirectoriesResponseBodyChildrenSpaceVisitorInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VisitorInfo"]));
        visitorInfo = make_shared<GetSpaceDirectoriesResponseBodyChildrenSpaceVisitorInfo>(model1);
      }
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildrenSpace() = default;
};
class GetSpaceDirectoriesResponseBodyChildrenStatisticalInfo : public Darabonba::Model {
public:
  shared_ptr<long> wordCount{};

  GetSpaceDirectoriesResponseBodyChildrenStatisticalInfo() {}

  explicit GetSpaceDirectoriesResponseBodyChildrenStatisticalInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (wordCount) {
      res["WordCount"] = boost::any(*wordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WordCount") != m.end() && !m["WordCount"].empty()) {
      wordCount = make_shared<long>(boost::any_cast<long>(m["WordCount"]));
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildrenStatisticalInfo() = default;
};
class GetSpaceDirectoriesResponseBodyChildrenUpdater : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> userId{};

  GetSpaceDirectoriesResponseBodyChildrenUpdater() {}

  explicit GetSpaceDirectoriesResponseBodyChildrenUpdater(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildrenUpdater() = default;
};
class GetSpaceDirectoriesResponseBodyChildrenVisitorInfo : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dentryActions{};
  shared_ptr<string> roleCode{};
  shared_ptr<vector<string>> spaceActions{};

  GetSpaceDirectoriesResponseBodyChildrenVisitorInfo() {}

  explicit GetSpaceDirectoriesResponseBodyChildrenVisitorInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryActions) {
      res["DentryActions"] = boost::any(*dentryActions);
    }
    if (roleCode) {
      res["RoleCode"] = boost::any(*roleCode);
    }
    if (spaceActions) {
      res["SpaceActions"] = boost::any(*spaceActions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryActions") != m.end() && !m["DentryActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DentryActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DentryActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dentryActions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoleCode") != m.end() && !m["RoleCode"].empty()) {
      roleCode = make_shared<string>(boost::any_cast<string>(m["RoleCode"]));
    }
    if (m.find("SpaceActions") != m.end() && !m["SpaceActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SpaceActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SpaceActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      spaceActions = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildrenVisitorInfo() = default;
};
class GetSpaceDirectoriesResponseBodyChildren : public Darabonba::Model {
public:
  shared_ptr<string> contentType{};
  shared_ptr<long> createdTime{};
  shared_ptr<GetSpaceDirectoriesResponseBodyChildrenCreator> creator{};
  shared_ptr<string> dentryId{};
  shared_ptr<string> dentryType{};
  shared_ptr<string> dentryUuid{};
  shared_ptr<string> docKey{};
  shared_ptr<string> extension{};
  shared_ptr<bool> hasChildren{};
  shared_ptr<GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfo> linkSourceInfo{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<GetSpaceDirectoriesResponseBodyChildrenSpace> space{};
  shared_ptr<string> spaceId{};
  shared_ptr<GetSpaceDirectoriesResponseBodyChildrenStatisticalInfo> statisticalInfo{};
  shared_ptr<long> updatedTime{};
  shared_ptr<GetSpaceDirectoriesResponseBodyChildrenUpdater> updater{};
  shared_ptr<string> url{};
  shared_ptr<GetSpaceDirectoriesResponseBodyChildrenVisitorInfo> visitorInfo{};

  GetSpaceDirectoriesResponseBodyChildren() {}

  explicit GetSpaceDirectoriesResponseBodyChildren(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (creator) {
      res["Creator"] = creator ? boost::any(creator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dentryId) {
      res["DentryId"] = boost::any(*dentryId);
    }
    if (dentryType) {
      res["DentryType"] = boost::any(*dentryType);
    }
    if (dentryUuid) {
      res["DentryUuid"] = boost::any(*dentryUuid);
    }
    if (docKey) {
      res["DocKey"] = boost::any(*docKey);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (hasChildren) {
      res["HasChildren"] = boost::any(*hasChildren);
    }
    if (linkSourceInfo) {
      res["LinkSourceInfo"] = linkSourceInfo ? boost::any(linkSourceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (space) {
      res["Space"] = space ? boost::any(space->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (statisticalInfo) {
      res["StatisticalInfo"] = statisticalInfo ? boost::any(statisticalInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    if (updater) {
      res["Updater"] = updater ? boost::any(updater->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (visitorInfo) {
      res["VisitorInfo"] = visitorInfo ? boost::any(visitorInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      if (typeid(map<string, boost::any>) == m["Creator"].type()) {
        GetSpaceDirectoriesResponseBodyChildrenCreator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Creator"]));
        creator = make_shared<GetSpaceDirectoriesResponseBodyChildrenCreator>(model1);
      }
    }
    if (m.find("DentryId") != m.end() && !m["DentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["DentryId"]));
    }
    if (m.find("DentryType") != m.end() && !m["DentryType"].empty()) {
      dentryType = make_shared<string>(boost::any_cast<string>(m["DentryType"]));
    }
    if (m.find("DentryUuid") != m.end() && !m["DentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["DentryUuid"]));
    }
    if (m.find("DocKey") != m.end() && !m["DocKey"].empty()) {
      docKey = make_shared<string>(boost::any_cast<string>(m["DocKey"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("HasChildren") != m.end() && !m["HasChildren"].empty()) {
      hasChildren = make_shared<bool>(boost::any_cast<bool>(m["HasChildren"]));
    }
    if (m.find("LinkSourceInfo") != m.end() && !m["LinkSourceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["LinkSourceInfo"].type()) {
        GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LinkSourceInfo"]));
        linkSourceInfo = make_shared<GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfo>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Space") != m.end() && !m["Space"].empty()) {
      if (typeid(map<string, boost::any>) == m["Space"].type()) {
        GetSpaceDirectoriesResponseBodyChildrenSpace model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Space"]));
        space = make_shared<GetSpaceDirectoriesResponseBodyChildrenSpace>(model1);
      }
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("StatisticalInfo") != m.end() && !m["StatisticalInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatisticalInfo"].type()) {
        GetSpaceDirectoriesResponseBodyChildrenStatisticalInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatisticalInfo"]));
        statisticalInfo = make_shared<GetSpaceDirectoriesResponseBodyChildrenStatisticalInfo>(model1);
      }
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["UpdatedTime"]));
    }
    if (m.find("Updater") != m.end() && !m["Updater"].empty()) {
      if (typeid(map<string, boost::any>) == m["Updater"].type()) {
        GetSpaceDirectoriesResponseBodyChildrenUpdater model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Updater"]));
        updater = make_shared<GetSpaceDirectoriesResponseBodyChildrenUpdater>(model1);
      }
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("VisitorInfo") != m.end() && !m["VisitorInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["VisitorInfo"].type()) {
        GetSpaceDirectoriesResponseBodyChildrenVisitorInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VisitorInfo"]));
        visitorInfo = make_shared<GetSpaceDirectoriesResponseBodyChildrenVisitorInfo>(model1);
      }
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildren() = default;
};
class GetSpaceDirectoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetSpaceDirectoriesResponseBodyChildren>> children{};
  shared_ptr<bool> hasMore{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  GetSpaceDirectoriesResponseBody() {}

  explicit GetSpaceDirectoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (children) {
      vector<boost::any> temp1;
      for(auto item1:*children){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["children"] = boost::any(temp1);
    }
    if (hasMore) {
      res["hasMore"] = boost::any(*hasMore);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("children") != m.end() && !m["children"].empty()) {
      if (typeid(vector<boost::any>) == m["children"].type()) {
        vector<GetSpaceDirectoriesResponseBodyChildren> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["children"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSpaceDirectoriesResponseBodyChildren model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        children = make_shared<vector<GetSpaceDirectoriesResponseBodyChildren>>(expect1);
      }
    }
    if (m.find("hasMore") != m.end() && !m["hasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["hasMore"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetSpaceDirectoriesResponseBody() = default;
};
class GetSpaceDirectoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSpaceDirectoriesResponseBody> body{};

  GetSpaceDirectoriesResponse() {}

  explicit GetSpaceDirectoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSpaceDirectoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSpaceDirectoriesResponseBody>(model1);
      }
    }
  }


  virtual ~GetSpaceDirectoriesResponse() = default;
};
class GetSubscribedCalendarHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetSubscribedCalendarHeadersAccountContext() {}

  explicit GetSubscribedCalendarHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetSubscribedCalendarHeadersAccountContext() = default;
};
class GetSubscribedCalendarHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetSubscribedCalendarHeadersAccountContext> accountContext{};

  GetSubscribedCalendarHeaders() {}

  explicit GetSubscribedCalendarHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetSubscribedCalendarHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetSubscribedCalendarHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetSubscribedCalendarHeaders() = default;
};
class GetSubscribedCalendarShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetSubscribedCalendarShrinkHeaders() {}

  explicit GetSubscribedCalendarShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetSubscribedCalendarShrinkHeaders() = default;
};
class GetSubscribedCalendarRequest : public Darabonba::Model {
public:
  shared_ptr<string> calendarId{};

  GetSubscribedCalendarRequest() {}

  explicit GetSubscribedCalendarRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
  }


  virtual ~GetSubscribedCalendarRequest() = default;
};
class GetSubscribedCalendarResponseBodySubscribeScope : public Darabonba::Model {
public:
  shared_ptr<vector<string>> corpIds{};
  shared_ptr<vector<string>> openConversationIds{};
  shared_ptr<vector<string>> userIds{};

  GetSubscribedCalendarResponseBodySubscribeScope() {}

  explicit GetSubscribedCalendarResponseBodySubscribeScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpIds) {
      res["CorpIds"] = boost::any(*corpIds);
    }
    if (openConversationIds) {
      res["OpenConversationIds"] = boost::any(*openConversationIds);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpIds") != m.end() && !m["CorpIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CorpIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CorpIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      corpIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OpenConversationIds") != m.end() && !m["OpenConversationIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OpenConversationIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OpenConversationIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      openConversationIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetSubscribedCalendarResponseBodySubscribeScope() = default;
};
class GetSubscribedCalendarResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> author{};
  shared_ptr<string> calendarId{};
  shared_ptr<string> description{};
  shared_ptr<vector<string>> managers{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<GetSubscribedCalendarResponseBodySubscribeScope> subscribeScope{};

  GetSubscribedCalendarResponseBody() {}

  explicit GetSubscribedCalendarResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["author"] = boost::any(*author);
    }
    if (calendarId) {
      res["calendarId"] = boost::any(*calendarId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (managers) {
      res["managers"] = boost::any(*managers);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (subscribeScope) {
      res["subscribeScope"] = subscribeScope ? boost::any(subscribeScope->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("author") != m.end() && !m["author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["author"]));
    }
    if (m.find("calendarId") != m.end() && !m["calendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["calendarId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("managers") != m.end() && !m["managers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["managers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["managers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      managers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("subscribeScope") != m.end() && !m["subscribeScope"].empty()) {
      if (typeid(map<string, boost::any>) == m["subscribeScope"].type()) {
        GetSubscribedCalendarResponseBodySubscribeScope model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["subscribeScope"]));
        subscribeScope = make_shared<GetSubscribedCalendarResponseBodySubscribeScope>(model1);
      }
    }
  }


  virtual ~GetSubscribedCalendarResponseBody() = default;
};
class GetSubscribedCalendarResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSubscribedCalendarResponseBody> body{};

  GetSubscribedCalendarResponse() {}

  explicit GetSubscribedCalendarResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSubscribedCalendarResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSubscribedCalendarResponseBody>(model1);
      }
    }
  }


  virtual ~GetSubscribedCalendarResponse() = default;
};
class GetTaskCopiesHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetTaskCopiesHeadersAccountContext() {}

  explicit GetTaskCopiesHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetTaskCopiesHeadersAccountContext() = default;
};
class GetTaskCopiesHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetTaskCopiesHeadersAccountContext> accountContext{};

  GetTaskCopiesHeaders() {}

  explicit GetTaskCopiesHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetTaskCopiesHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetTaskCopiesHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetTaskCopiesHeaders() = default;
};
class GetTaskCopiesShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetTaskCopiesShrinkHeaders() {}

  explicit GetTaskCopiesShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetTaskCopiesShrinkHeaders() = default;
};
class GetTaskCopiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<long> createFromTimeGMT{};
  shared_ptr<long> createToTimeGMT{};
  shared_ptr<string> keyword{};
  shared_ptr<string> language{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> processCodes{};
  shared_ptr<string> systemToken{};

  GetTaskCopiesRequest() {}

  explicit GetTaskCopiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (createFromTimeGMT) {
      res["CreateFromTimeGMT"] = boost::any(*createFromTimeGMT);
    }
    if (createToTimeGMT) {
      res["CreateToTimeGMT"] = boost::any(*createToTimeGMT);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (processCodes) {
      res["ProcessCodes"] = boost::any(*processCodes);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("CreateFromTimeGMT") != m.end() && !m["CreateFromTimeGMT"].empty()) {
      createFromTimeGMT = make_shared<long>(boost::any_cast<long>(m["CreateFromTimeGMT"]));
    }
    if (m.find("CreateToTimeGMT") != m.end() && !m["CreateToTimeGMT"].empty()) {
      createToTimeGMT = make_shared<long>(boost::any_cast<long>(m["CreateToTimeGMT"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProcessCodes") != m.end() && !m["ProcessCodes"].empty()) {
      processCodes = make_shared<string>(boost::any_cast<string>(m["ProcessCodes"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~GetTaskCopiesRequest() = default;
};
class GetTaskCopiesResponseBodyDataCurrentActivityInstances : public Darabonba::Model {
public:
  shared_ptr<string> activityId{};
  shared_ptr<string> activityInstanceStatus{};
  shared_ptr<string> activityName{};
  shared_ptr<string> activityNameInEnglish{};
  shared_ptr<long> id{};

  GetTaskCopiesResponseBodyDataCurrentActivityInstances() {}

  explicit GetTaskCopiesResponseBodyDataCurrentActivityInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityId) {
      res["ActivityId"] = boost::any(*activityId);
    }
    if (activityInstanceStatus) {
      res["ActivityInstanceStatus"] = boost::any(*activityInstanceStatus);
    }
    if (activityName) {
      res["ActivityName"] = boost::any(*activityName);
    }
    if (activityNameInEnglish) {
      res["ActivityNameInEnglish"] = boost::any(*activityNameInEnglish);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityId") != m.end() && !m["ActivityId"].empty()) {
      activityId = make_shared<string>(boost::any_cast<string>(m["ActivityId"]));
    }
    if (m.find("ActivityInstanceStatus") != m.end() && !m["ActivityInstanceStatus"].empty()) {
      activityInstanceStatus = make_shared<string>(boost::any_cast<string>(m["ActivityInstanceStatus"]));
    }
    if (m.find("ActivityName") != m.end() && !m["ActivityName"].empty()) {
      activityName = make_shared<string>(boost::any_cast<string>(m["ActivityName"]));
    }
    if (m.find("ActivityNameInEnglish") != m.end() && !m["ActivityNameInEnglish"].empty()) {
      activityNameInEnglish = make_shared<string>(boost::any_cast<string>(m["ActivityNameInEnglish"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetTaskCopiesResponseBodyDataCurrentActivityInstances() = default;
};
class GetTaskCopiesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> actionExecutorId{};
  shared_ptr<vector<string>> actionExecutorName{};
  shared_ptr<string> appType{};
  shared_ptr<string> carbonActivityId{};
  shared_ptr<string> createTimeGMT{};
  shared_ptr<vector<GetTaskCopiesResponseBodyDataCurrentActivityInstances>> currentActivityInstances{};
  shared_ptr<map<string, boost::any>> dataMap{};
  shared_ptr<string> dataType{};
  shared_ptr<string> finishTimeGMT{};
  shared_ptr<string> formInstanceId{};
  shared_ptr<string> formUuid{};
  shared_ptr<string> instanceValue{};
  shared_ptr<string> modifiedTimeGMT{};
  shared_ptr<string> originatorAvatar{};
  shared_ptr<string> originatorDisplayName{};
  shared_ptr<string> originatorId{};
  shared_ptr<string> processApprovedResult{};
  shared_ptr<string> processApprovedResultText{};
  shared_ptr<string> processCode{};
  shared_ptr<long> processId{};
  shared_ptr<string> processInstanceId{};
  shared_ptr<string> processInstanceStatus{};
  shared_ptr<string> processInstanceStatusText{};
  shared_ptr<string> processName{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> title{};
  shared_ptr<long> version{};

  GetTaskCopiesResponseBodyData() {}

  explicit GetTaskCopiesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionExecutorId) {
      res["ActionExecutorId"] = boost::any(*actionExecutorId);
    }
    if (actionExecutorName) {
      res["ActionExecutorName"] = boost::any(*actionExecutorName);
    }
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (carbonActivityId) {
      res["CarbonActivityId"] = boost::any(*carbonActivityId);
    }
    if (createTimeGMT) {
      res["CreateTimeGMT"] = boost::any(*createTimeGMT);
    }
    if (currentActivityInstances) {
      vector<boost::any> temp1;
      for(auto item1:*currentActivityInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CurrentActivityInstances"] = boost::any(temp1);
    }
    if (dataMap) {
      res["DataMap"] = boost::any(*dataMap);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (finishTimeGMT) {
      res["FinishTimeGMT"] = boost::any(*finishTimeGMT);
    }
    if (formInstanceId) {
      res["FormInstanceId"] = boost::any(*formInstanceId);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (instanceValue) {
      res["InstanceValue"] = boost::any(*instanceValue);
    }
    if (modifiedTimeGMT) {
      res["ModifiedTimeGMT"] = boost::any(*modifiedTimeGMT);
    }
    if (originatorAvatar) {
      res["OriginatorAvatar"] = boost::any(*originatorAvatar);
    }
    if (originatorDisplayName) {
      res["OriginatorDisplayName"] = boost::any(*originatorDisplayName);
    }
    if (originatorId) {
      res["OriginatorId"] = boost::any(*originatorId);
    }
    if (processApprovedResult) {
      res["ProcessApprovedResult"] = boost::any(*processApprovedResult);
    }
    if (processApprovedResultText) {
      res["ProcessApprovedResultText"] = boost::any(*processApprovedResultText);
    }
    if (processCode) {
      res["ProcessCode"] = boost::any(*processCode);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    if (processInstanceId) {
      res["ProcessInstanceId"] = boost::any(*processInstanceId);
    }
    if (processInstanceStatus) {
      res["ProcessInstanceStatus"] = boost::any(*processInstanceStatus);
    }
    if (processInstanceStatusText) {
      res["ProcessInstanceStatusText"] = boost::any(*processInstanceStatusText);
    }
    if (processName) {
      res["ProcessName"] = boost::any(*processName);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionExecutorId") != m.end() && !m["ActionExecutorId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ActionExecutorId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ActionExecutorId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      actionExecutorId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ActionExecutorName") != m.end() && !m["ActionExecutorName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ActionExecutorName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ActionExecutorName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      actionExecutorName = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("CarbonActivityId") != m.end() && !m["CarbonActivityId"].empty()) {
      carbonActivityId = make_shared<string>(boost::any_cast<string>(m["CarbonActivityId"]));
    }
    if (m.find("CreateTimeGMT") != m.end() && !m["CreateTimeGMT"].empty()) {
      createTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateTimeGMT"]));
    }
    if (m.find("CurrentActivityInstances") != m.end() && !m["CurrentActivityInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["CurrentActivityInstances"].type()) {
        vector<GetTaskCopiesResponseBodyDataCurrentActivityInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CurrentActivityInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskCopiesResponseBodyDataCurrentActivityInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        currentActivityInstances = make_shared<vector<GetTaskCopiesResponseBodyDataCurrentActivityInstances>>(expect1);
      }
    }
    if (m.find("DataMap") != m.end() && !m["DataMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["DataMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      dataMap = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("FinishTimeGMT") != m.end() && !m["FinishTimeGMT"].empty()) {
      finishTimeGMT = make_shared<string>(boost::any_cast<string>(m["FinishTimeGMT"]));
    }
    if (m.find("FormInstanceId") != m.end() && !m["FormInstanceId"].empty()) {
      formInstanceId = make_shared<string>(boost::any_cast<string>(m["FormInstanceId"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("InstanceValue") != m.end() && !m["InstanceValue"].empty()) {
      instanceValue = make_shared<string>(boost::any_cast<string>(m["InstanceValue"]));
    }
    if (m.find("ModifiedTimeGMT") != m.end() && !m["ModifiedTimeGMT"].empty()) {
      modifiedTimeGMT = make_shared<string>(boost::any_cast<string>(m["ModifiedTimeGMT"]));
    }
    if (m.find("OriginatorAvatar") != m.end() && !m["OriginatorAvatar"].empty()) {
      originatorAvatar = make_shared<string>(boost::any_cast<string>(m["OriginatorAvatar"]));
    }
    if (m.find("OriginatorDisplayName") != m.end() && !m["OriginatorDisplayName"].empty()) {
      originatorDisplayName = make_shared<string>(boost::any_cast<string>(m["OriginatorDisplayName"]));
    }
    if (m.find("OriginatorId") != m.end() && !m["OriginatorId"].empty()) {
      originatorId = make_shared<string>(boost::any_cast<string>(m["OriginatorId"]));
    }
    if (m.find("ProcessApprovedResult") != m.end() && !m["ProcessApprovedResult"].empty()) {
      processApprovedResult = make_shared<string>(boost::any_cast<string>(m["ProcessApprovedResult"]));
    }
    if (m.find("ProcessApprovedResultText") != m.end() && !m["ProcessApprovedResultText"].empty()) {
      processApprovedResultText = make_shared<string>(boost::any_cast<string>(m["ProcessApprovedResultText"]));
    }
    if (m.find("ProcessCode") != m.end() && !m["ProcessCode"].empty()) {
      processCode = make_shared<string>(boost::any_cast<string>(m["ProcessCode"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<long>(boost::any_cast<long>(m["ProcessId"]));
    }
    if (m.find("ProcessInstanceId") != m.end() && !m["ProcessInstanceId"].empty()) {
      processInstanceId = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceId"]));
    }
    if (m.find("ProcessInstanceStatus") != m.end() && !m["ProcessInstanceStatus"].empty()) {
      processInstanceStatus = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceStatus"]));
    }
    if (m.find("ProcessInstanceStatusText") != m.end() && !m["ProcessInstanceStatusText"].empty()) {
      processInstanceStatusText = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceStatusText"]));
    }
    if (m.find("ProcessName") != m.end() && !m["ProcessName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["ProcessName"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~GetTaskCopiesResponseBodyData() = default;
};
class GetTaskCopiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetTaskCopiesResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetTaskCopiesResponseBody() {}

  explicit GetTaskCopiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<GetTaskCopiesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskCopiesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetTaskCopiesResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetTaskCopiesResponseBody() = default;
};
class GetTaskCopiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTaskCopiesResponseBody> body{};

  GetTaskCopiesResponse() {}

  explicit GetTaskCopiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTaskCopiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTaskCopiesResponseBody>(model1);
      }
    }
  }


  virtual ~GetTaskCopiesResponse() = default;
};
class GetTemplateListByUserIdHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetTemplateListByUserIdHeadersAccountContext() {}

  explicit GetTemplateListByUserIdHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetTemplateListByUserIdHeadersAccountContext() = default;
};
class GetTemplateListByUserIdHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetTemplateListByUserIdHeadersAccountContext> accountContext{};

  GetTemplateListByUserIdHeaders() {}

  explicit GetTemplateListByUserIdHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetTemplateListByUserIdHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetTemplateListByUserIdHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetTemplateListByUserIdHeaders() = default;
};
class GetTemplateListByUserIdShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetTemplateListByUserIdShrinkHeaders() {}

  explicit GetTemplateListByUserIdShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetTemplateListByUserIdShrinkHeaders() = default;
};
class GetTemplateListByUserIdRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetTemplateListByUserIdRequestTenantContext() {}

  explicit GetTemplateListByUserIdRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetTemplateListByUserIdRequestTenantContext() = default;
};
class GetTemplateListByUserIdRequest : public Darabonba::Model {
public:
  shared_ptr<long> offset{};
  shared_ptr<long> size{};
  shared_ptr<GetTemplateListByUserIdRequestTenantContext> tenantContext{};

  GetTemplateListByUserIdRequest() {}

  explicit GetTemplateListByUserIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetTemplateListByUserIdRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetTemplateListByUserIdRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetTemplateListByUserIdRequest() = default;
};
class GetTemplateListByUserIdShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> offset{};
  shared_ptr<long> size{};
  shared_ptr<string> tenantContextShrink{};

  GetTemplateListByUserIdShrinkRequest() {}

  explicit GetTemplateListByUserIdShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetTemplateListByUserIdShrinkRequest() = default;
};
class GetTemplateListByUserIdResponseBodyTemplateList : public Darabonba::Model {
public:
  shared_ptr<string> iconUrl{};
  shared_ptr<string> name{};
  shared_ptr<string> reportCode{};
  shared_ptr<string> url{};

  GetTemplateListByUserIdResponseBodyTemplateList() {}

  explicit GetTemplateListByUserIdResponseBodyTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iconUrl) {
      res["IconUrl"] = boost::any(*iconUrl);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (reportCode) {
      res["ReportCode"] = boost::any(*reportCode);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IconUrl") != m.end() && !m["IconUrl"].empty()) {
      iconUrl = make_shared<string>(boost::any_cast<string>(m["IconUrl"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ReportCode") != m.end() && !m["ReportCode"].empty()) {
      reportCode = make_shared<string>(boost::any_cast<string>(m["ReportCode"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetTemplateListByUserIdResponseBodyTemplateList() = default;
};
class GetTemplateListByUserIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> nextCursor{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetTemplateListByUserIdResponseBodyTemplateList>> templateList{};

  GetTemplateListByUserIdResponseBody() {}

  explicit GetTemplateListByUserIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextCursor) {
      res["nextCursor"] = boost::any(*nextCursor);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (templateList) {
      vector<boost::any> temp1;
      for(auto item1:*templateList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["templateList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nextCursor") != m.end() && !m["nextCursor"].empty()) {
      nextCursor = make_shared<long>(boost::any_cast<long>(m["nextCursor"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("templateList") != m.end() && !m["templateList"].empty()) {
      if (typeid(vector<boost::any>) == m["templateList"].type()) {
        vector<GetTemplateListByUserIdResponseBodyTemplateList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["templateList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTemplateListByUserIdResponseBodyTemplateList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templateList = make_shared<vector<GetTemplateListByUserIdResponseBodyTemplateList>>(expect1);
      }
    }
  }


  virtual ~GetTemplateListByUserIdResponseBody() = default;
};
class GetTemplateListByUserIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTemplateListByUserIdResponseBody> body{};

  GetTemplateListByUserIdResponse() {}

  explicit GetTemplateListByUserIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTemplateListByUserIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTemplateListByUserIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetTemplateListByUserIdResponse() = default;
};
class GetTicketHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetTicketHeadersAccountContext() {}

  explicit GetTicketHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetTicketHeadersAccountContext() = default;
};
class GetTicketHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetTicketHeadersAccountContext> accountContext{};

  GetTicketHeaders() {}

  explicit GetTicketHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetTicketHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetTicketHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetTicketHeaders() = default;
};
class GetTicketShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetTicketShrinkHeaders() {}

  explicit GetTicketShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetTicketShrinkHeaders() = default;
};
class GetTicketRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetTicketRequestTenantContext() {}

  explicit GetTicketRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetTicketRequestTenantContext() = default;
};
class GetTicketRequest : public Darabonba::Model {
public:
  shared_ptr<string> openTeamId{};
  shared_ptr<string> openTicketId{};
  shared_ptr<GetTicketRequestTenantContext> tenantContext{};

  GetTicketRequest() {}

  explicit GetTicketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openTeamId) {
      res["OpenTeamId"] = boost::any(*openTeamId);
    }
    if (openTicketId) {
      res["OpenTicketId"] = boost::any(*openTicketId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpenTeamId") != m.end() && !m["OpenTeamId"].empty()) {
      openTeamId = make_shared<string>(boost::any_cast<string>(m["OpenTeamId"]));
    }
    if (m.find("OpenTicketId") != m.end() && !m["OpenTicketId"].empty()) {
      openTicketId = make_shared<string>(boost::any_cast<string>(m["OpenTicketId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetTicketRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetTicketRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetTicketRequest() = default;
};
class GetTicketShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> openTeamId{};
  shared_ptr<string> openTicketId{};
  shared_ptr<string> tenantContextShrink{};

  GetTicketShrinkRequest() {}

  explicit GetTicketShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openTeamId) {
      res["OpenTeamId"] = boost::any(*openTeamId);
    }
    if (openTicketId) {
      res["OpenTicketId"] = boost::any(*openTicketId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpenTeamId") != m.end() && !m["OpenTeamId"].empty()) {
      openTeamId = make_shared<string>(boost::any_cast<string>(m["OpenTeamId"]));
    }
    if (m.find("OpenTicketId") != m.end() && !m["OpenTicketId"].empty()) {
      openTicketId = make_shared<string>(boost::any_cast<string>(m["OpenTicketId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetTicketShrinkRequest() = default;
};
class GetTicketResponseBodyCreator : public Darabonba::Model {
public:
  shared_ptr<string> nickName{};
  shared_ptr<string> unionId{};

  GetTicketResponseBodyCreator() {}

  explicit GetTicketResponseBodyCreator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (unionId) {
      res["UnionId"] = boost::any(*unionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("UnionId") != m.end() && !m["UnionId"].empty()) {
      unionId = make_shared<string>(boost::any_cast<string>(m["UnionId"]));
    }
  }


  virtual ~GetTicketResponseBodyCreator() = default;
};
class GetTicketResponseBodyProcessor : public Darabonba::Model {
public:
  shared_ptr<string> nickName{};
  shared_ptr<string> unionId{};

  GetTicketResponseBodyProcessor() {}

  explicit GetTicketResponseBodyProcessor(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (unionId) {
      res["UnionId"] = boost::any(*unionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("UnionId") != m.end() && !m["UnionId"].empty()) {
      unionId = make_shared<string>(boost::any_cast<string>(m["UnionId"]));
    }
  }


  virtual ~GetTicketResponseBodyProcessor() = default;
};
class GetTicketResponseBodyTakers : public Darabonba::Model {
public:
  shared_ptr<string> nickName{};
  shared_ptr<string> unionId{};

  GetTicketResponseBodyTakers() {}

  explicit GetTicketResponseBodyTakers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (unionId) {
      res["UnionId"] = boost::any(*unionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("UnionId") != m.end() && !m["UnionId"].empty()) {
      unionId = make_shared<string>(boost::any_cast<string>(m["UnionId"]));
    }
  }


  virtual ~GetTicketResponseBodyTakers() = default;
};
class GetTicketResponseBodyTemplate : public Darabonba::Model {
public:
  shared_ptr<string> openTemplateBizId{};
  shared_ptr<string> openTemplateId{};
  shared_ptr<string> templateName{};

  GetTicketResponseBodyTemplate() {}

  explicit GetTicketResponseBodyTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openTemplateBizId) {
      res["OpenTemplateBizId"] = boost::any(*openTemplateBizId);
    }
    if (openTemplateId) {
      res["OpenTemplateId"] = boost::any(*openTemplateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpenTemplateBizId") != m.end() && !m["OpenTemplateBizId"].empty()) {
      openTemplateBizId = make_shared<string>(boost::any_cast<string>(m["OpenTemplateBizId"]));
    }
    if (m.find("OpenTemplateId") != m.end() && !m["OpenTemplateId"].empty()) {
      openTemplateId = make_shared<string>(boost::any_cast<string>(m["OpenTemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~GetTicketResponseBodyTemplate() = default;
};
class GetTicketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<GetTicketResponseBodyCreator> creator{};
  shared_ptr<string> customFields{};
  shared_ptr<string> openConversationId{};
  shared_ptr<string> openTicketId{};
  shared_ptr<GetTicketResponseBodyProcessor> processor{};
  shared_ptr<string> requestId{};
  shared_ptr<string> scene{};
  shared_ptr<string> sceneContext{};
  shared_ptr<string> stage{};
  shared_ptr<vector<GetTicketResponseBodyTakers>> takers{};
  shared_ptr<GetTicketResponseBodyTemplate> template_{};
  shared_ptr<string> title{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetTicketResponseBody() {}

  explicit GetTicketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["creator"] = creator ? boost::any(creator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customFields) {
      res["customFields"] = boost::any(*customFields);
    }
    if (openConversationId) {
      res["openConversationId"] = boost::any(*openConversationId);
    }
    if (openTicketId) {
      res["openTicketId"] = boost::any(*openTicketId);
    }
    if (processor) {
      res["processor"] = processor ? boost::any(processor->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (scene) {
      res["scene"] = boost::any(*scene);
    }
    if (sceneContext) {
      res["sceneContext"] = boost::any(*sceneContext);
    }
    if (stage) {
      res["stage"] = boost::any(*stage);
    }
    if (takers) {
      vector<boost::any> temp1;
      for(auto item1:*takers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["takers"] = boost::any(temp1);
    }
    if (template_) {
      res["template"] = template_ ? boost::any(template_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      if (typeid(map<string, boost::any>) == m["creator"].type()) {
        GetTicketResponseBodyCreator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["creator"]));
        creator = make_shared<GetTicketResponseBodyCreator>(model1);
      }
    }
    if (m.find("customFields") != m.end() && !m["customFields"].empty()) {
      customFields = make_shared<string>(boost::any_cast<string>(m["customFields"]));
    }
    if (m.find("openConversationId") != m.end() && !m["openConversationId"].empty()) {
      openConversationId = make_shared<string>(boost::any_cast<string>(m["openConversationId"]));
    }
    if (m.find("openTicketId") != m.end() && !m["openTicketId"].empty()) {
      openTicketId = make_shared<string>(boost::any_cast<string>(m["openTicketId"]));
    }
    if (m.find("processor") != m.end() && !m["processor"].empty()) {
      if (typeid(map<string, boost::any>) == m["processor"].type()) {
        GetTicketResponseBodyProcessor model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["processor"]));
        processor = make_shared<GetTicketResponseBodyProcessor>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("scene") != m.end() && !m["scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["scene"]));
    }
    if (m.find("sceneContext") != m.end() && !m["sceneContext"].empty()) {
      sceneContext = make_shared<string>(boost::any_cast<string>(m["sceneContext"]));
    }
    if (m.find("stage") != m.end() && !m["stage"].empty()) {
      stage = make_shared<string>(boost::any_cast<string>(m["stage"]));
    }
    if (m.find("takers") != m.end() && !m["takers"].empty()) {
      if (typeid(vector<boost::any>) == m["takers"].type()) {
        vector<GetTicketResponseBodyTakers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["takers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTicketResponseBodyTakers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        takers = make_shared<vector<GetTicketResponseBodyTakers>>(expect1);
      }
    }
    if (m.find("template") != m.end() && !m["template"].empty()) {
      if (typeid(map<string, boost::any>) == m["template"].type()) {
        GetTicketResponseBodyTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["template"]));
        template_ = make_shared<GetTicketResponseBodyTemplate>(model1);
      }
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["updateTime"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetTicketResponseBody() = default;
};
class GetTicketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTicketResponseBody> body{};

  GetTicketResponse() {}

  explicit GetTicketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTicketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTicketResponseBody>(model1);
      }
    }
  }


  virtual ~GetTicketResponse() = default;
};
class GetTodoTaskHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetTodoTaskHeadersAccountContext() {}

  explicit GetTodoTaskHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetTodoTaskHeadersAccountContext() = default;
};
class GetTodoTaskHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetTodoTaskHeadersAccountContext> accountContext{};

  GetTodoTaskHeaders() {}

  explicit GetTodoTaskHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetTodoTaskHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetTodoTaskHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetTodoTaskHeaders() = default;
};
class GetTodoTaskShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetTodoTaskShrinkHeaders() {}

  explicit GetTodoTaskShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetTodoTaskShrinkHeaders() = default;
};
class GetTodoTaskRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetTodoTaskRequestTenantContext() {}

  explicit GetTodoTaskRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetTodoTaskRequestTenantContext() = default;
};
class GetTodoTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<GetTodoTaskRequestTenantContext> tenantContext{};

  GetTodoTaskRequest() {}

  explicit GetTodoTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetTodoTaskRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetTodoTaskRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetTodoTaskRequest() = default;
};
class GetTodoTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> tenantContextShrink{};

  GetTodoTaskShrinkRequest() {}

  explicit GetTodoTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetTodoTaskShrinkRequest() = default;
};
class GetTodoTaskResponseBodyDetailUrl : public Darabonba::Model {
public:
  shared_ptr<string> appUrl{};
  shared_ptr<string> pcUrl{};

  GetTodoTaskResponseBodyDetailUrl() {}

  explicit GetTodoTaskResponseBodyDetailUrl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appUrl) {
      res["AppUrl"] = boost::any(*appUrl);
    }
    if (pcUrl) {
      res["PcUrl"] = boost::any(*pcUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppUrl") != m.end() && !m["AppUrl"].empty()) {
      appUrl = make_shared<string>(boost::any_cast<string>(m["AppUrl"]));
    }
    if (m.find("PcUrl") != m.end() && !m["PcUrl"].empty()) {
      pcUrl = make_shared<string>(boost::any_cast<string>(m["PcUrl"]));
    }
  }


  virtual ~GetTodoTaskResponseBodyDetailUrl() = default;
};
class GetTodoTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bizTag{};
  shared_ptr<string> cardTypeId{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<GetTodoTaskResponseBodyDetailUrl> detailUrl{};
  shared_ptr<bool> done{};
  shared_ptr<long> dueTime{};
  shared_ptr<vector<string>> executorIds{};
  shared_ptr<long> finishTime{};
  shared_ptr<string> id{};
  shared_ptr<bool> isOnlyShowExecutor{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<vector<string>> participantIds{};
  shared_ptr<long> priority{};
  shared_ptr<string> requestId{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> subject{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> tenantType{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetTodoTaskResponseBody() {}

  explicit GetTodoTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizTag) {
      res["bizTag"] = boost::any(*bizTag);
    }
    if (cardTypeId) {
      res["cardTypeId"] = boost::any(*cardTypeId);
    }
    if (createdTime) {
      res["createdTime"] = boost::any(*createdTime);
    }
    if (creatorId) {
      res["creatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (detailUrl) {
      res["detailUrl"] = detailUrl ? boost::any(detailUrl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (done) {
      res["done"] = boost::any(*done);
    }
    if (dueTime) {
      res["dueTime"] = boost::any(*dueTime);
    }
    if (executorIds) {
      res["executorIds"] = boost::any(*executorIds);
    }
    if (finishTime) {
      res["finishTime"] = boost::any(*finishTime);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isOnlyShowExecutor) {
      res["isOnlyShowExecutor"] = boost::any(*isOnlyShowExecutor);
    }
    if (modifiedTime) {
      res["modifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["modifierId"] = boost::any(*modifierId);
    }
    if (participantIds) {
      res["participantIds"] = boost::any(*participantIds);
    }
    if (priority) {
      res["priority"] = boost::any(*priority);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (sourceId) {
      res["sourceId"] = boost::any(*sourceId);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    if (tenantType) {
      res["tenantType"] = boost::any(*tenantType);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bizTag") != m.end() && !m["bizTag"].empty()) {
      bizTag = make_shared<string>(boost::any_cast<string>(m["bizTag"]));
    }
    if (m.find("cardTypeId") != m.end() && !m["cardTypeId"].empty()) {
      cardTypeId = make_shared<string>(boost::any_cast<string>(m["cardTypeId"]));
    }
    if (m.find("createdTime") != m.end() && !m["createdTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["createdTime"]));
    }
    if (m.find("creatorId") != m.end() && !m["creatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["creatorId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("detailUrl") != m.end() && !m["detailUrl"].empty()) {
      if (typeid(map<string, boost::any>) == m["detailUrl"].type()) {
        GetTodoTaskResponseBodyDetailUrl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["detailUrl"]));
        detailUrl = make_shared<GetTodoTaskResponseBodyDetailUrl>(model1);
      }
    }
    if (m.find("done") != m.end() && !m["done"].empty()) {
      done = make_shared<bool>(boost::any_cast<bool>(m["done"]));
    }
    if (m.find("dueTime") != m.end() && !m["dueTime"].empty()) {
      dueTime = make_shared<long>(boost::any_cast<long>(m["dueTime"]));
    }
    if (m.find("executorIds") != m.end() && !m["executorIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["executorIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["executorIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      executorIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("finishTime") != m.end() && !m["finishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["finishTime"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("isOnlyShowExecutor") != m.end() && !m["isOnlyShowExecutor"].empty()) {
      isOnlyShowExecutor = make_shared<bool>(boost::any_cast<bool>(m["isOnlyShowExecutor"]));
    }
    if (m.find("modifiedTime") != m.end() && !m["modifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["modifiedTime"]));
    }
    if (m.find("modifierId") != m.end() && !m["modifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["modifierId"]));
    }
    if (m.find("participantIds") != m.end() && !m["participantIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["participantIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["participantIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      participantIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("priority") != m.end() && !m["priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["priority"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("sourceId") != m.end() && !m["sourceId"].empty()) {
      sourceId = make_shared<string>(boost::any_cast<string>(m["sourceId"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
    if (m.find("tenantType") != m.end() && !m["tenantType"].empty()) {
      tenantType = make_shared<string>(boost::any_cast<string>(m["tenantType"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetTodoTaskResponseBody() = default;
};
class GetTodoTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTodoTaskResponseBody> body{};

  GetTodoTaskResponse() {}

  explicit GetTodoTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTodoTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTodoTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetTodoTaskResponse() = default;
};
class GetUserHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetUserHeadersAccountContext() {}

  explicit GetUserHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetUserHeadersAccountContext() = default;
};
class GetUserHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetUserHeadersAccountContext> accountContext{};

  GetUserHeaders() {}

  explicit GetUserHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetUserHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetUserHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetUserHeaders() = default;
};
class GetUserShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetUserShrinkHeaders() {}

  explicit GetUserShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetUserShrinkHeaders() = default;
};
class GetUserRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetUserRequestTenantContext() {}

  explicit GetUserRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetUserRequestTenantContext() = default;
};
class GetUserRequest : public Darabonba::Model {
public:
  shared_ptr<GetUserRequestTenantContext> tenantContext{};
  shared_ptr<string> language{};

  GetUserRequest() {}

  explicit GetUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (language) {
      res["language"] = boost::any(*language);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetUserRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetUserRequestTenantContext>(model1);
      }
    }
    if (m.find("language") != m.end() && !m["language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["language"]));
    }
  }


  virtual ~GetUserRequest() = default;
};
class GetUserShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> language{};

  GetUserShrinkRequest() {}

  explicit GetUserShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (language) {
      res["language"] = boost::any(*language);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("language") != m.end() && !m["language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["language"]));
    }
  }


  virtual ~GetUserShrinkRequest() = default;
};
class GetUserResponseBodyDeptOrderList : public Darabonba::Model {
public:
  shared_ptr<long> deptId{};
  shared_ptr<long> order{};

  GetUserResponseBodyDeptOrderList() {}

  explicit GetUserResponseBodyDeptOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deptId) {
      res["deptId"] = boost::any(*deptId);
    }
    if (order) {
      res["order"] = boost::any(*order);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("deptId") != m.end() && !m["deptId"].empty()) {
      deptId = make_shared<long>(boost::any_cast<long>(m["deptId"]));
    }
    if (m.find("order") != m.end() && !m["order"].empty()) {
      order = make_shared<long>(boost::any_cast<long>(m["order"]));
    }
  }


  virtual ~GetUserResponseBodyDeptOrderList() = default;
};
class GetUserResponseBodyLeaderInDept : public Darabonba::Model {
public:
  shared_ptr<long> deptId{};
  shared_ptr<bool> leader{};

  GetUserResponseBodyLeaderInDept() {}

  explicit GetUserResponseBodyLeaderInDept(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deptId) {
      res["deptId"] = boost::any(*deptId);
    }
    if (leader) {
      res["leader"] = boost::any(*leader);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("deptId") != m.end() && !m["deptId"].empty()) {
      deptId = make_shared<long>(boost::any_cast<long>(m["deptId"]));
    }
    if (m.find("leader") != m.end() && !m["leader"].empty()) {
      leader = make_shared<bool>(boost::any_cast<bool>(m["leader"]));
    }
  }


  virtual ~GetUserResponseBodyLeaderInDept() = default;
};
class GetUserResponseBodyRoleList : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  GetUserResponseBodyRoleList() {}

  explicit GetUserResponseBodyRoleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["groupName"] = boost::any(*groupName);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("groupName") != m.end() && !m["groupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["groupName"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~GetUserResponseBodyRoleList() = default;
};
class GetUserResponseBodyUnionEmpExtUnionEmpMapList : public Darabonba::Model {
public:
  shared_ptr<string> cropId{};
  shared_ptr<string> userid{};

  GetUserResponseBodyUnionEmpExtUnionEmpMapList() {}

  explicit GetUserResponseBodyUnionEmpExtUnionEmpMapList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cropId) {
      res["cropId"] = boost::any(*cropId);
    }
    if (userid) {
      res["userid"] = boost::any(*userid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cropId") != m.end() && !m["cropId"].empty()) {
      cropId = make_shared<string>(boost::any_cast<string>(m["cropId"]));
    }
    if (m.find("userid") != m.end() && !m["userid"].empty()) {
      userid = make_shared<string>(boost::any_cast<string>(m["userid"]));
    }
  }


  virtual ~GetUserResponseBodyUnionEmpExtUnionEmpMapList() = default;
};
class GetUserResponseBodyUnionEmpExt : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<vector<GetUserResponseBodyUnionEmpExtUnionEmpMapList>> unionEmpMapList{};
  shared_ptr<string> userid{};

  GetUserResponseBodyUnionEmpExt() {}

  explicit GetUserResponseBodyUnionEmpExt(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["corpId"] = boost::any(*corpId);
    }
    if (unionEmpMapList) {
      vector<boost::any> temp1;
      for(auto item1:*unionEmpMapList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["unionEmpMapList"] = boost::any(temp1);
    }
    if (userid) {
      res["userid"] = boost::any(*userid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corpId") != m.end() && !m["corpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corpId"]));
    }
    if (m.find("unionEmpMapList") != m.end() && !m["unionEmpMapList"].empty()) {
      if (typeid(vector<boost::any>) == m["unionEmpMapList"].type()) {
        vector<GetUserResponseBodyUnionEmpExtUnionEmpMapList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["unionEmpMapList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetUserResponseBodyUnionEmpExtUnionEmpMapList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        unionEmpMapList = make_shared<vector<GetUserResponseBodyUnionEmpExtUnionEmpMapList>>(expect1);
      }
    }
    if (m.find("userid") != m.end() && !m["userid"].empty()) {
      userid = make_shared<string>(boost::any_cast<string>(m["userid"]));
    }
  }


  virtual ~GetUserResponseBodyUnionEmpExt() = default;
};
class GetUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<bool> admin{};
  shared_ptr<string> avatar{};
  shared_ptr<bool> boss{};
  shared_ptr<vector<long>> deptIdList{};
  shared_ptr<vector<GetUserResponseBodyDeptOrderList>> deptOrderList{};
  shared_ptr<string> email{};
  shared_ptr<bool> exclusiveAccount{};
  shared_ptr<string> exclusiveAccountCorpId{};
  shared_ptr<string> exclusiveAccountCorpName{};
  shared_ptr<string> exclusiveAccountType{};
  shared_ptr<string> extension{};
  shared_ptr<bool> hideMobile{};
  shared_ptr<long> hiredDate{};
  shared_ptr<string> jobNumber{};
  shared_ptr<vector<GetUserResponseBodyLeaderInDept>> leaderInDept{};
  shared_ptr<string> loginId{};
  shared_ptr<string> managerUserid{};
  shared_ptr<string> mobile{};
  shared_ptr<string> name{};
  shared_ptr<string> nickname{};
  shared_ptr<string> orgEmail{};
  shared_ptr<bool> realAuthed{};
  shared_ptr<string> remark{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetUserResponseBodyRoleList>> roleList{};
  shared_ptr<bool> senior{};
  shared_ptr<string> stateCode{};
  shared_ptr<string> telephone{};
  shared_ptr<string> title{};
  shared_ptr<GetUserResponseBodyUnionEmpExt> unionEmpExt{};
  shared_ptr<string> unionid{};
  shared_ptr<string> userid{};
  shared_ptr<string> workPlace{};

  GetUserResponseBody() {}

  explicit GetUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["active"] = boost::any(*active);
    }
    if (admin) {
      res["admin"] = boost::any(*admin);
    }
    if (avatar) {
      res["avatar"] = boost::any(*avatar);
    }
    if (boss) {
      res["boss"] = boost::any(*boss);
    }
    if (deptIdList) {
      res["deptIdList"] = boost::any(*deptIdList);
    }
    if (deptOrderList) {
      vector<boost::any> temp1;
      for(auto item1:*deptOrderList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["deptOrderList"] = boost::any(temp1);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (exclusiveAccount) {
      res["exclusiveAccount"] = boost::any(*exclusiveAccount);
    }
    if (exclusiveAccountCorpId) {
      res["exclusiveAccountCorpId"] = boost::any(*exclusiveAccountCorpId);
    }
    if (exclusiveAccountCorpName) {
      res["exclusiveAccountCorpName"] = boost::any(*exclusiveAccountCorpName);
    }
    if (exclusiveAccountType) {
      res["exclusiveAccountType"] = boost::any(*exclusiveAccountType);
    }
    if (extension) {
      res["extension"] = boost::any(*extension);
    }
    if (hideMobile) {
      res["hideMobile"] = boost::any(*hideMobile);
    }
    if (hiredDate) {
      res["hiredDate"] = boost::any(*hiredDate);
    }
    if (jobNumber) {
      res["jobNumber"] = boost::any(*jobNumber);
    }
    if (leaderInDept) {
      vector<boost::any> temp1;
      for(auto item1:*leaderInDept){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["leaderInDept"] = boost::any(temp1);
    }
    if (loginId) {
      res["loginId"] = boost::any(*loginId);
    }
    if (managerUserid) {
      res["managerUserid"] = boost::any(*managerUserid);
    }
    if (mobile) {
      res["mobile"] = boost::any(*mobile);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nickname) {
      res["nickname"] = boost::any(*nickname);
    }
    if (orgEmail) {
      res["orgEmail"] = boost::any(*orgEmail);
    }
    if (realAuthed) {
      res["realAuthed"] = boost::any(*realAuthed);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (roleList) {
      vector<boost::any> temp1;
      for(auto item1:*roleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["roleList"] = boost::any(temp1);
    }
    if (senior) {
      res["senior"] = boost::any(*senior);
    }
    if (stateCode) {
      res["stateCode"] = boost::any(*stateCode);
    }
    if (telephone) {
      res["telephone"] = boost::any(*telephone);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (unionEmpExt) {
      res["unionEmpExt"] = unionEmpExt ? boost::any(unionEmpExt->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (unionid) {
      res["unionid"] = boost::any(*unionid);
    }
    if (userid) {
      res["userid"] = boost::any(*userid);
    }
    if (workPlace) {
      res["workPlace"] = boost::any(*workPlace);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("active") != m.end() && !m["active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["active"]));
    }
    if (m.find("admin") != m.end() && !m["admin"].empty()) {
      admin = make_shared<bool>(boost::any_cast<bool>(m["admin"]));
    }
    if (m.find("avatar") != m.end() && !m["avatar"].empty()) {
      avatar = make_shared<string>(boost::any_cast<string>(m["avatar"]));
    }
    if (m.find("boss") != m.end() && !m["boss"].empty()) {
      boss = make_shared<bool>(boost::any_cast<bool>(m["boss"]));
    }
    if (m.find("deptIdList") != m.end() && !m["deptIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["deptIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["deptIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      deptIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("deptOrderList") != m.end() && !m["deptOrderList"].empty()) {
      if (typeid(vector<boost::any>) == m["deptOrderList"].type()) {
        vector<GetUserResponseBodyDeptOrderList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["deptOrderList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetUserResponseBodyDeptOrderList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deptOrderList = make_shared<vector<GetUserResponseBodyDeptOrderList>>(expect1);
      }
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("exclusiveAccount") != m.end() && !m["exclusiveAccount"].empty()) {
      exclusiveAccount = make_shared<bool>(boost::any_cast<bool>(m["exclusiveAccount"]));
    }
    if (m.find("exclusiveAccountCorpId") != m.end() && !m["exclusiveAccountCorpId"].empty()) {
      exclusiveAccountCorpId = make_shared<string>(boost::any_cast<string>(m["exclusiveAccountCorpId"]));
    }
    if (m.find("exclusiveAccountCorpName") != m.end() && !m["exclusiveAccountCorpName"].empty()) {
      exclusiveAccountCorpName = make_shared<string>(boost::any_cast<string>(m["exclusiveAccountCorpName"]));
    }
    if (m.find("exclusiveAccountType") != m.end() && !m["exclusiveAccountType"].empty()) {
      exclusiveAccountType = make_shared<string>(boost::any_cast<string>(m["exclusiveAccountType"]));
    }
    if (m.find("extension") != m.end() && !m["extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["extension"]));
    }
    if (m.find("hideMobile") != m.end() && !m["hideMobile"].empty()) {
      hideMobile = make_shared<bool>(boost::any_cast<bool>(m["hideMobile"]));
    }
    if (m.find("hiredDate") != m.end() && !m["hiredDate"].empty()) {
      hiredDate = make_shared<long>(boost::any_cast<long>(m["hiredDate"]));
    }
    if (m.find("jobNumber") != m.end() && !m["jobNumber"].empty()) {
      jobNumber = make_shared<string>(boost::any_cast<string>(m["jobNumber"]));
    }
    if (m.find("leaderInDept") != m.end() && !m["leaderInDept"].empty()) {
      if (typeid(vector<boost::any>) == m["leaderInDept"].type()) {
        vector<GetUserResponseBodyLeaderInDept> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["leaderInDept"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetUserResponseBodyLeaderInDept model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        leaderInDept = make_shared<vector<GetUserResponseBodyLeaderInDept>>(expect1);
      }
    }
    if (m.find("loginId") != m.end() && !m["loginId"].empty()) {
      loginId = make_shared<string>(boost::any_cast<string>(m["loginId"]));
    }
    if (m.find("managerUserid") != m.end() && !m["managerUserid"].empty()) {
      managerUserid = make_shared<string>(boost::any_cast<string>(m["managerUserid"]));
    }
    if (m.find("mobile") != m.end() && !m["mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["mobile"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nickname") != m.end() && !m["nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["nickname"]));
    }
    if (m.find("orgEmail") != m.end() && !m["orgEmail"].empty()) {
      orgEmail = make_shared<string>(boost::any_cast<string>(m["orgEmail"]));
    }
    if (m.find("realAuthed") != m.end() && !m["realAuthed"].empty()) {
      realAuthed = make_shared<bool>(boost::any_cast<bool>(m["realAuthed"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("roleList") != m.end() && !m["roleList"].empty()) {
      if (typeid(vector<boost::any>) == m["roleList"].type()) {
        vector<GetUserResponseBodyRoleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["roleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetUserResponseBodyRoleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roleList = make_shared<vector<GetUserResponseBodyRoleList>>(expect1);
      }
    }
    if (m.find("senior") != m.end() && !m["senior"].empty()) {
      senior = make_shared<bool>(boost::any_cast<bool>(m["senior"]));
    }
    if (m.find("stateCode") != m.end() && !m["stateCode"].empty()) {
      stateCode = make_shared<string>(boost::any_cast<string>(m["stateCode"]));
    }
    if (m.find("telephone") != m.end() && !m["telephone"].empty()) {
      telephone = make_shared<string>(boost::any_cast<string>(m["telephone"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("unionEmpExt") != m.end() && !m["unionEmpExt"].empty()) {
      if (typeid(map<string, boost::any>) == m["unionEmpExt"].type()) {
        GetUserResponseBodyUnionEmpExt model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["unionEmpExt"]));
        unionEmpExt = make_shared<GetUserResponseBodyUnionEmpExt>(model1);
      }
    }
    if (m.find("unionid") != m.end() && !m["unionid"].empty()) {
      unionid = make_shared<string>(boost::any_cast<string>(m["unionid"]));
    }
    if (m.find("userid") != m.end() && !m["userid"].empty()) {
      userid = make_shared<string>(boost::any_cast<string>(m["userid"]));
    }
    if (m.find("workPlace") != m.end() && !m["workPlace"].empty()) {
      workPlace = make_shared<string>(boost::any_cast<string>(m["workPlace"]));
    }
  }


  virtual ~GetUserResponseBody() = default;
};
class GetUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserResponseBody> body{};

  GetUserResponse() {}

  explicit GetUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserResponse() = default;
};
class GetUserIdHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetUserIdHeadersAccountContext() {}

  explicit GetUserIdHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetUserIdHeadersAccountContext() = default;
};
class GetUserIdHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetUserIdHeadersAccountContext> accountContext{};

  GetUserIdHeaders() {}

  explicit GetUserIdHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetUserIdHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetUserIdHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetUserIdHeaders() = default;
};
class GetUserIdShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetUserIdShrinkHeaders() {}

  explicit GetUserIdShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetUserIdShrinkHeaders() = default;
};
class GetUserIdRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetUserIdRequestTenantContext() {}

  explicit GetUserIdRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetUserIdRequestTenantContext() = default;
};
class GetUserIdRequest : public Darabonba::Model {
public:
  shared_ptr<GetUserIdRequestTenantContext> tenantContext{};
  shared_ptr<string> unionId{};

  GetUserIdRequest() {}

  explicit GetUserIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (unionId) {
      res["UnionId"] = boost::any(*unionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetUserIdRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetUserIdRequestTenantContext>(model1);
      }
    }
    if (m.find("UnionId") != m.end() && !m["UnionId"].empty()) {
      unionId = make_shared<string>(boost::any_cast<string>(m["UnionId"]));
    }
  }


  virtual ~GetUserIdRequest() = default;
};
class GetUserIdShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> unionId{};

  GetUserIdShrinkRequest() {}

  explicit GetUserIdShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (unionId) {
      res["UnionId"] = boost::any(*unionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("UnionId") != m.end() && !m["UnionId"].empty()) {
      unionId = make_shared<string>(boost::any_cast<string>(m["UnionId"]));
    }
  }


  virtual ~GetUserIdShrinkRequest() = default;
};
class GetUserIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> userId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetUserIdResponseBody() {}

  explicit GetUserIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetUserIdResponseBody() = default;
};
class GetUserIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserIdResponseBody> body{};

  GetUserIdResponse() {}

  explicit GetUserIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserIdResponse() = default;
};
class GetUserIdByOrgIdAndStaffIdHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetUserIdByOrgIdAndStaffIdHeadersAccountContext() {}

  explicit GetUserIdByOrgIdAndStaffIdHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetUserIdByOrgIdAndStaffIdHeadersAccountContext() = default;
};
class GetUserIdByOrgIdAndStaffIdHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetUserIdByOrgIdAndStaffIdHeadersAccountContext> accountContext{};

  GetUserIdByOrgIdAndStaffIdHeaders() {}

  explicit GetUserIdByOrgIdAndStaffIdHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetUserIdByOrgIdAndStaffIdHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetUserIdByOrgIdAndStaffIdHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetUserIdByOrgIdAndStaffIdHeaders() = default;
};
class GetUserIdByOrgIdAndStaffIdShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetUserIdByOrgIdAndStaffIdShrinkHeaders() {}

  explicit GetUserIdByOrgIdAndStaffIdShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetUserIdByOrgIdAndStaffIdShrinkHeaders() = default;
};
class GetUserIdByOrgIdAndStaffIdRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetUserIdByOrgIdAndStaffIdRequestTenantContext() {}

  explicit GetUserIdByOrgIdAndStaffIdRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetUserIdByOrgIdAndStaffIdRequestTenantContext() = default;
};
class GetUserIdByOrgIdAndStaffIdRequest : public Darabonba::Model {
public:
  shared_ptr<long> orgId{};
  shared_ptr<GetUserIdByOrgIdAndStaffIdRequestTenantContext> tenantContext{};

  GetUserIdByOrgIdAndStaffIdRequest() {}

  explicit GetUserIdByOrgIdAndStaffIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orgId) {
      res["OrgId"] = boost::any(*orgId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrgId") != m.end() && !m["OrgId"].empty()) {
      orgId = make_shared<long>(boost::any_cast<long>(m["OrgId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetUserIdByOrgIdAndStaffIdRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetUserIdByOrgIdAndStaffIdRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetUserIdByOrgIdAndStaffIdRequest() = default;
};
class GetUserIdByOrgIdAndStaffIdShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> orgId{};
  shared_ptr<string> tenantContextShrink{};

  GetUserIdByOrgIdAndStaffIdShrinkRequest() {}

  explicit GetUserIdByOrgIdAndStaffIdShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orgId) {
      res["OrgId"] = boost::any(*orgId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrgId") != m.end() && !m["OrgId"].empty()) {
      orgId = make_shared<long>(boost::any_cast<long>(m["OrgId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetUserIdByOrgIdAndStaffIdShrinkRequest() = default;
};
class GetUserIdByOrgIdAndStaffIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> userId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetUserIdByOrgIdAndStaffIdResponseBody() {}

  explicit GetUserIdByOrgIdAndStaffIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetUserIdByOrgIdAndStaffIdResponseBody() = default;
};
class GetUserIdByOrgIdAndStaffIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserIdByOrgIdAndStaffIdResponseBody> body{};

  GetUserIdByOrgIdAndStaffIdResponse() {}

  explicit GetUserIdByOrgIdAndStaffIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserIdByOrgIdAndStaffIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserIdByOrgIdAndStaffIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserIdByOrgIdAndStaffIdResponse() = default;
};
class GetUserLatestPlanHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetUserLatestPlanHeadersAccountContext() {}

  explicit GetUserLatestPlanHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetUserLatestPlanHeadersAccountContext() = default;
};
class GetUserLatestPlanHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetUserLatestPlanHeadersAccountContext> accountContext{};

  GetUserLatestPlanHeaders() {}

  explicit GetUserLatestPlanHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetUserLatestPlanHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetUserLatestPlanHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetUserLatestPlanHeaders() = default;
};
class GetUserLatestPlanShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetUserLatestPlanShrinkHeaders() {}

  explicit GetUserLatestPlanShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetUserLatestPlanShrinkHeaders() = default;
};
class GetUserLatestPlanRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetUserLatestPlanRequestTenantContext() {}

  explicit GetUserLatestPlanRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetUserLatestPlanRequestTenantContext() = default;
};
class GetUserLatestPlanRequest : public Darabonba::Model {
public:
  shared_ptr<GetUserLatestPlanRequestTenantContext> tenantContext{};

  GetUserLatestPlanRequest() {}

  explicit GetUserLatestPlanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetUserLatestPlanRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetUserLatestPlanRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetUserLatestPlanRequest() = default;
};
class GetUserLatestPlanShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};

  GetUserLatestPlanShrinkRequest() {}

  explicit GetUserLatestPlanShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetUserLatestPlanShrinkRequest() = default;
};
class GetUserLatestPlanResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> accountHandleStatus{};
  shared_ptr<string> accountHandleTime{};
  shared_ptr<long> accountType{};
  shared_ptr<string> agreementFirstSignTime{};
  shared_ptr<string> agreementLastSignTime{};
  shared_ptr<long> agreementStatus{};
  shared_ptr<string> dataHandleEndTime{};
  shared_ptr<string> dataHandleStartTime{};
  shared_ptr<long> dataHandleStatus{};
  shared_ptr<long> exclusivePlan{};
  shared_ptr<long> newAccountUid{};
  shared_ptr<string> requestId{};
  shared_ptr<long> status{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  GetUserLatestPlanResponseBody() {}

  explicit GetUserLatestPlanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountHandleStatus) {
      res["accountHandleStatus"] = boost::any(*accountHandleStatus);
    }
    if (accountHandleTime) {
      res["accountHandleTime"] = boost::any(*accountHandleTime);
    }
    if (accountType) {
      res["accountType"] = boost::any(*accountType);
    }
    if (agreementFirstSignTime) {
      res["agreementFirstSignTime"] = boost::any(*agreementFirstSignTime);
    }
    if (agreementLastSignTime) {
      res["agreementLastSignTime"] = boost::any(*agreementLastSignTime);
    }
    if (agreementStatus) {
      res["agreementStatus"] = boost::any(*agreementStatus);
    }
    if (dataHandleEndTime) {
      res["dataHandleEndTime"] = boost::any(*dataHandleEndTime);
    }
    if (dataHandleStartTime) {
      res["dataHandleStartTime"] = boost::any(*dataHandleStartTime);
    }
    if (dataHandleStatus) {
      res["dataHandleStatus"] = boost::any(*dataHandleStatus);
    }
    if (exclusivePlan) {
      res["exclusivePlan"] = boost::any(*exclusivePlan);
    }
    if (newAccountUid) {
      res["newAccountUid"] = boost::any(*newAccountUid);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountHandleStatus") != m.end() && !m["accountHandleStatus"].empty()) {
      accountHandleStatus = make_shared<long>(boost::any_cast<long>(m["accountHandleStatus"]));
    }
    if (m.find("accountHandleTime") != m.end() && !m["accountHandleTime"].empty()) {
      accountHandleTime = make_shared<string>(boost::any_cast<string>(m["accountHandleTime"]));
    }
    if (m.find("accountType") != m.end() && !m["accountType"].empty()) {
      accountType = make_shared<long>(boost::any_cast<long>(m["accountType"]));
    }
    if (m.find("agreementFirstSignTime") != m.end() && !m["agreementFirstSignTime"].empty()) {
      agreementFirstSignTime = make_shared<string>(boost::any_cast<string>(m["agreementFirstSignTime"]));
    }
    if (m.find("agreementLastSignTime") != m.end() && !m["agreementLastSignTime"].empty()) {
      agreementLastSignTime = make_shared<string>(boost::any_cast<string>(m["agreementLastSignTime"]));
    }
    if (m.find("agreementStatus") != m.end() && !m["agreementStatus"].empty()) {
      agreementStatus = make_shared<long>(boost::any_cast<long>(m["agreementStatus"]));
    }
    if (m.find("dataHandleEndTime") != m.end() && !m["dataHandleEndTime"].empty()) {
      dataHandleEndTime = make_shared<string>(boost::any_cast<string>(m["dataHandleEndTime"]));
    }
    if (m.find("dataHandleStartTime") != m.end() && !m["dataHandleStartTime"].empty()) {
      dataHandleStartTime = make_shared<string>(boost::any_cast<string>(m["dataHandleStartTime"]));
    }
    if (m.find("dataHandleStatus") != m.end() && !m["dataHandleStatus"].empty()) {
      dataHandleStatus = make_shared<long>(boost::any_cast<long>(m["dataHandleStatus"]));
    }
    if (m.find("exclusivePlan") != m.end() && !m["exclusivePlan"].empty()) {
      exclusivePlan = make_shared<long>(boost::any_cast<long>(m["exclusivePlan"]));
    }
    if (m.find("newAccountUid") != m.end() && !m["newAccountUid"].empty()) {
      newAccountUid = make_shared<long>(boost::any_cast<long>(m["newAccountUid"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~GetUserLatestPlanResponseBody() = default;
};
class GetUserLatestPlanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserLatestPlanResponseBody> body{};

  GetUserLatestPlanResponse() {}

  explicit GetUserLatestPlanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserLatestPlanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserLatestPlanResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserLatestPlanResponse() = default;
};
class GetWorkspaceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetWorkspaceHeadersAccountContext() {}

  explicit GetWorkspaceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetWorkspaceHeadersAccountContext() = default;
};
class GetWorkspaceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetWorkspaceHeadersAccountContext> accountContext{};

  GetWorkspaceHeaders() {}

  explicit GetWorkspaceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetWorkspaceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetWorkspaceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetWorkspaceHeaders() = default;
};
class GetWorkspaceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetWorkspaceShrinkHeaders() {}

  explicit GetWorkspaceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetWorkspaceShrinkHeaders() = default;
};
class GetWorkspaceRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetWorkspaceRequestTenantContext() {}

  explicit GetWorkspaceRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetWorkspaceRequestTenantContext() = default;
};
class GetWorkspaceRequest : public Darabonba::Model {
public:
  shared_ptr<GetWorkspaceRequestTenantContext> tenantContext{};
  shared_ptr<bool> withPermissionRole{};
  shared_ptr<string> workspaceId{};

  GetWorkspaceRequest() {}

  explicit GetWorkspaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (withPermissionRole) {
      res["WithPermissionRole"] = boost::any(*withPermissionRole);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetWorkspaceRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetWorkspaceRequestTenantContext>(model1);
      }
    }
    if (m.find("WithPermissionRole") != m.end() && !m["WithPermissionRole"].empty()) {
      withPermissionRole = make_shared<bool>(boost::any_cast<bool>(m["WithPermissionRole"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetWorkspaceRequest() = default;
};
class GetWorkspaceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<bool> withPermissionRole{};
  shared_ptr<string> workspaceId{};

  GetWorkspaceShrinkRequest() {}

  explicit GetWorkspaceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (withPermissionRole) {
      res["WithPermissionRole"] = boost::any(*withPermissionRole);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WithPermissionRole") != m.end() && !m["WithPermissionRole"].empty()) {
      withPermissionRole = make_shared<bool>(boost::any_cast<bool>(m["WithPermissionRole"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetWorkspaceShrinkRequest() = default;
};
class GetWorkspaceResponseBodyWorkspaceIcon : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  GetWorkspaceResponseBodyWorkspaceIcon() {}

  explicit GetWorkspaceResponseBodyWorkspaceIcon(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetWorkspaceResponseBodyWorkspaceIcon() = default;
};
class GetWorkspaceResponseBodyWorkspace : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<string> cover{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<GetWorkspaceResponseBodyWorkspaceIcon> icon{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> name{};
  shared_ptr<string> permissionRole{};
  shared_ptr<string> rootNodeId{};
  shared_ptr<string> teamId{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  GetWorkspaceResponseBodyWorkspace() {}

  explicit GetWorkspaceResponseBodyWorkspace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (cover) {
      res["Cover"] = boost::any(*cover);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (icon) {
      res["Icon"] = icon ? boost::any(icon->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (permissionRole) {
      res["PermissionRole"] = boost::any(*permissionRole);
    }
    if (rootNodeId) {
      res["RootNodeId"] = boost::any(*rootNodeId);
    }
    if (teamId) {
      res["TeamId"] = boost::any(*teamId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      cover = make_shared<string>(boost::any_cast<string>(m["Cover"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      if (typeid(map<string, boost::any>) == m["Icon"].type()) {
        GetWorkspaceResponseBodyWorkspaceIcon model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Icon"]));
        icon = make_shared<GetWorkspaceResponseBodyWorkspaceIcon>(model1);
      }
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["ModifierId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PermissionRole") != m.end() && !m["PermissionRole"].empty()) {
      permissionRole = make_shared<string>(boost::any_cast<string>(m["PermissionRole"]));
    }
    if (m.find("RootNodeId") != m.end() && !m["RootNodeId"].empty()) {
      rootNodeId = make_shared<string>(boost::any_cast<string>(m["RootNodeId"]));
    }
    if (m.find("TeamId") != m.end() && !m["TeamId"].empty()) {
      teamId = make_shared<string>(boost::any_cast<string>(m["TeamId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetWorkspaceResponseBodyWorkspace() = default;
};
class GetWorkspaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetWorkspaceResponseBodyWorkspace> workspace{};

  GetWorkspaceResponseBody() {}

  explicit GetWorkspaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (workspace) {
      res["workspace"] = workspace ? boost::any(workspace->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("workspace") != m.end() && !m["workspace"].empty()) {
      if (typeid(map<string, boost::any>) == m["workspace"].type()) {
        GetWorkspaceResponseBodyWorkspace model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["workspace"]));
        workspace = make_shared<GetWorkspaceResponseBodyWorkspace>(model1);
      }
    }
  }


  virtual ~GetWorkspaceResponseBody() = default;
};
class GetWorkspaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWorkspaceResponseBody> body{};

  GetWorkspaceResponse() {}

  explicit GetWorkspaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWorkspaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWorkspaceResponseBody>(model1);
      }
    }
  }


  virtual ~GetWorkspaceResponse() = default;
};
class GetWorkspacesHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetWorkspacesHeadersAccountContext() {}

  explicit GetWorkspacesHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetWorkspacesHeadersAccountContext() = default;
};
class GetWorkspacesHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetWorkspacesHeadersAccountContext> accountContext{};

  GetWorkspacesHeaders() {}

  explicit GetWorkspacesHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetWorkspacesHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetWorkspacesHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetWorkspacesHeaders() = default;
};
class GetWorkspacesShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetWorkspacesShrinkHeaders() {}

  explicit GetWorkspacesShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetWorkspacesShrinkHeaders() = default;
};
class GetWorkspacesRequestOption : public Darabonba::Model {
public:
  shared_ptr<bool> withPermissionRole{};

  GetWorkspacesRequestOption() {}

  explicit GetWorkspacesRequestOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (withPermissionRole) {
      res["WithPermissionRole"] = boost::any(*withPermissionRole);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WithPermissionRole") != m.end() && !m["WithPermissionRole"].empty()) {
      withPermissionRole = make_shared<bool>(boost::any_cast<bool>(m["WithPermissionRole"]));
    }
  }


  virtual ~GetWorkspacesRequestOption() = default;
};
class GetWorkspacesRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetWorkspacesRequestTenantContext() {}

  explicit GetWorkspacesRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetWorkspacesRequestTenantContext() = default;
};
class GetWorkspacesRequest : public Darabonba::Model {
public:
  shared_ptr<GetWorkspacesRequestOption> option{};
  shared_ptr<GetWorkspacesRequestTenantContext> tenantContext{};
  shared_ptr<vector<string>> workspaceIds{};

  GetWorkspacesRequest() {}

  explicit GetWorkspacesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (option) {
      res["Option"] = option ? boost::any(option->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workspaceIds) {
      res["WorkspaceIds"] = boost::any(*workspaceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      if (typeid(map<string, boost::any>) == m["Option"].type()) {
        GetWorkspacesRequestOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Option"]));
        option = make_shared<GetWorkspacesRequestOption>(model1);
      }
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetWorkspacesRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetWorkspacesRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkspaceIds") != m.end() && !m["WorkspaceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WorkspaceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WorkspaceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      workspaceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetWorkspacesRequest() = default;
};
class GetWorkspacesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> optionShrink{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workspaceIdsShrink{};

  GetWorkspacesShrinkRequest() {}

  explicit GetWorkspacesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (optionShrink) {
      res["Option"] = boost::any(*optionShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workspaceIdsShrink) {
      res["WorkspaceIds"] = boost::any(*workspaceIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      optionShrink = make_shared<string>(boost::any_cast<string>(m["Option"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkspaceIds") != m.end() && !m["WorkspaceIds"].empty()) {
      workspaceIdsShrink = make_shared<string>(boost::any_cast<string>(m["WorkspaceIds"]));
    }
  }


  virtual ~GetWorkspacesShrinkRequest() = default;
};
class GetWorkspacesResponseBodyWorkspaceIcon : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  GetWorkspacesResponseBodyWorkspaceIcon() {}

  explicit GetWorkspacesResponseBodyWorkspaceIcon(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetWorkspacesResponseBodyWorkspaceIcon() = default;
};
class GetWorkspacesResponseBodyWorkspace : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<string> cover{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<GetWorkspacesResponseBodyWorkspaceIcon> icon{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> name{};
  shared_ptr<string> permissionRole{};
  shared_ptr<string> rootNodeId{};
  shared_ptr<string> teamId{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  GetWorkspacesResponseBodyWorkspace() {}

  explicit GetWorkspacesResponseBodyWorkspace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (cover) {
      res["Cover"] = boost::any(*cover);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (icon) {
      res["Icon"] = icon ? boost::any(icon->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (permissionRole) {
      res["PermissionRole"] = boost::any(*permissionRole);
    }
    if (rootNodeId) {
      res["RootNodeId"] = boost::any(*rootNodeId);
    }
    if (teamId) {
      res["TeamId"] = boost::any(*teamId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      cover = make_shared<string>(boost::any_cast<string>(m["Cover"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      if (typeid(map<string, boost::any>) == m["Icon"].type()) {
        GetWorkspacesResponseBodyWorkspaceIcon model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Icon"]));
        icon = make_shared<GetWorkspacesResponseBodyWorkspaceIcon>(model1);
      }
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["ModifierId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PermissionRole") != m.end() && !m["PermissionRole"].empty()) {
      permissionRole = make_shared<string>(boost::any_cast<string>(m["PermissionRole"]));
    }
    if (m.find("RootNodeId") != m.end() && !m["RootNodeId"].empty()) {
      rootNodeId = make_shared<string>(boost::any_cast<string>(m["RootNodeId"]));
    }
    if (m.find("TeamId") != m.end() && !m["TeamId"].empty()) {
      teamId = make_shared<string>(boost::any_cast<string>(m["TeamId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetWorkspacesResponseBodyWorkspace() = default;
};
class GetWorkspacesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetWorkspacesResponseBodyWorkspace>> workspace{};

  GetWorkspacesResponseBody() {}

  explicit GetWorkspacesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (workspace) {
      vector<boost::any> temp1;
      for(auto item1:*workspace){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["workspace"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("workspace") != m.end() && !m["workspace"].empty()) {
      if (typeid(vector<boost::any>) == m["workspace"].type()) {
        vector<GetWorkspacesResponseBodyWorkspace> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["workspace"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWorkspacesResponseBodyWorkspace model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workspace = make_shared<vector<GetWorkspacesResponseBodyWorkspace>>(expect1);
      }
    }
  }


  virtual ~GetWorkspacesResponseBody() = default;
};
class GetWorkspacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWorkspacesResponseBody> body{};

  GetWorkspacesResponse() {}

  explicit GetWorkspacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWorkspacesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWorkspacesResponseBody>(model1);
      }
    }
  }


  virtual ~GetWorkspacesResponse() = default;
};
class GrantHonorHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GrantHonorHeadersAccountContext() {}

  explicit GrantHonorHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GrantHonorHeadersAccountContext() = default;
};
class GrantHonorHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GrantHonorHeadersAccountContext> accountContext{};

  GrantHonorHeaders() {}

  explicit GrantHonorHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GrantHonorHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GrantHonorHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GrantHonorHeaders() = default;
};
class GrantHonorShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GrantHonorShrinkHeaders() {}

  explicit GrantHonorShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GrantHonorShrinkHeaders() = default;
};
class GrantHonorRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GrantHonorRequestTenantContext() {}

  explicit GrantHonorRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GrantHonorRequestTenantContext() = default;
};
class GrantHonorRequest : public Darabonba::Model {
public:
  shared_ptr<GrantHonorRequestTenantContext> tenantContext{};
  shared_ptr<long> expirationTime{};
  shared_ptr<string> grantReason{};
  shared_ptr<string> granterName{};
  shared_ptr<string> honorId{};
  shared_ptr<bool> noticeAnnouncer{};
  shared_ptr<bool> noticeSingle{};
  shared_ptr<vector<string>> openConversationIds{};
  shared_ptr<long> orgId{};
  shared_ptr<vector<string>> receiverUserIds{};
  shared_ptr<string> senderUserId{};

  GrantHonorRequest() {}

  explicit GrantHonorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expirationTime) {
      res["expirationTime"] = boost::any(*expirationTime);
    }
    if (grantReason) {
      res["grantReason"] = boost::any(*grantReason);
    }
    if (granterName) {
      res["granterName"] = boost::any(*granterName);
    }
    if (honorId) {
      res["honorId"] = boost::any(*honorId);
    }
    if (noticeAnnouncer) {
      res["noticeAnnouncer"] = boost::any(*noticeAnnouncer);
    }
    if (noticeSingle) {
      res["noticeSingle"] = boost::any(*noticeSingle);
    }
    if (openConversationIds) {
      res["openConversationIds"] = boost::any(*openConversationIds);
    }
    if (orgId) {
      res["orgId"] = boost::any(*orgId);
    }
    if (receiverUserIds) {
      res["receiverUserIds"] = boost::any(*receiverUserIds);
    }
    if (senderUserId) {
      res["senderUserId"] = boost::any(*senderUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GrantHonorRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GrantHonorRequestTenantContext>(model1);
      }
    }
    if (m.find("expirationTime") != m.end() && !m["expirationTime"].empty()) {
      expirationTime = make_shared<long>(boost::any_cast<long>(m["expirationTime"]));
    }
    if (m.find("grantReason") != m.end() && !m["grantReason"].empty()) {
      grantReason = make_shared<string>(boost::any_cast<string>(m["grantReason"]));
    }
    if (m.find("granterName") != m.end() && !m["granterName"].empty()) {
      granterName = make_shared<string>(boost::any_cast<string>(m["granterName"]));
    }
    if (m.find("honorId") != m.end() && !m["honorId"].empty()) {
      honorId = make_shared<string>(boost::any_cast<string>(m["honorId"]));
    }
    if (m.find("noticeAnnouncer") != m.end() && !m["noticeAnnouncer"].empty()) {
      noticeAnnouncer = make_shared<bool>(boost::any_cast<bool>(m["noticeAnnouncer"]));
    }
    if (m.find("noticeSingle") != m.end() && !m["noticeSingle"].empty()) {
      noticeSingle = make_shared<bool>(boost::any_cast<bool>(m["noticeSingle"]));
    }
    if (m.find("openConversationIds") != m.end() && !m["openConversationIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["openConversationIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["openConversationIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      openConversationIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("orgId") != m.end() && !m["orgId"].empty()) {
      orgId = make_shared<long>(boost::any_cast<long>(m["orgId"]));
    }
    if (m.find("receiverUserIds") != m.end() && !m["receiverUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["receiverUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["receiverUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      receiverUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("senderUserId") != m.end() && !m["senderUserId"].empty()) {
      senderUserId = make_shared<string>(boost::any_cast<string>(m["senderUserId"]));
    }
  }


  virtual ~GrantHonorRequest() = default;
};
class GrantHonorShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<long> expirationTime{};
  shared_ptr<string> grantReason{};
  shared_ptr<string> granterName{};
  shared_ptr<string> honorId{};
  shared_ptr<bool> noticeAnnouncer{};
  shared_ptr<bool> noticeSingle{};
  shared_ptr<string> openConversationIdsShrink{};
  shared_ptr<long> orgId{};
  shared_ptr<string> receiverUserIdsShrink{};
  shared_ptr<string> senderUserId{};

  GrantHonorShrinkRequest() {}

  explicit GrantHonorShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (expirationTime) {
      res["expirationTime"] = boost::any(*expirationTime);
    }
    if (grantReason) {
      res["grantReason"] = boost::any(*grantReason);
    }
    if (granterName) {
      res["granterName"] = boost::any(*granterName);
    }
    if (honorId) {
      res["honorId"] = boost::any(*honorId);
    }
    if (noticeAnnouncer) {
      res["noticeAnnouncer"] = boost::any(*noticeAnnouncer);
    }
    if (noticeSingle) {
      res["noticeSingle"] = boost::any(*noticeSingle);
    }
    if (openConversationIdsShrink) {
      res["openConversationIds"] = boost::any(*openConversationIdsShrink);
    }
    if (orgId) {
      res["orgId"] = boost::any(*orgId);
    }
    if (receiverUserIdsShrink) {
      res["receiverUserIds"] = boost::any(*receiverUserIdsShrink);
    }
    if (senderUserId) {
      res["senderUserId"] = boost::any(*senderUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("expirationTime") != m.end() && !m["expirationTime"].empty()) {
      expirationTime = make_shared<long>(boost::any_cast<long>(m["expirationTime"]));
    }
    if (m.find("grantReason") != m.end() && !m["grantReason"].empty()) {
      grantReason = make_shared<string>(boost::any_cast<string>(m["grantReason"]));
    }
    if (m.find("granterName") != m.end() && !m["granterName"].empty()) {
      granterName = make_shared<string>(boost::any_cast<string>(m["granterName"]));
    }
    if (m.find("honorId") != m.end() && !m["honorId"].empty()) {
      honorId = make_shared<string>(boost::any_cast<string>(m["honorId"]));
    }
    if (m.find("noticeAnnouncer") != m.end() && !m["noticeAnnouncer"].empty()) {
      noticeAnnouncer = make_shared<bool>(boost::any_cast<bool>(m["noticeAnnouncer"]));
    }
    if (m.find("noticeSingle") != m.end() && !m["noticeSingle"].empty()) {
      noticeSingle = make_shared<bool>(boost::any_cast<bool>(m["noticeSingle"]));
    }
    if (m.find("openConversationIds") != m.end() && !m["openConversationIds"].empty()) {
      openConversationIdsShrink = make_shared<string>(boost::any_cast<string>(m["openConversationIds"]));
    }
    if (m.find("orgId") != m.end() && !m["orgId"].empty()) {
      orgId = make_shared<long>(boost::any_cast<long>(m["orgId"]));
    }
    if (m.find("receiverUserIds") != m.end() && !m["receiverUserIds"].empty()) {
      receiverUserIdsShrink = make_shared<string>(boost::any_cast<string>(m["receiverUserIds"]));
    }
    if (m.find("senderUserId") != m.end() && !m["senderUserId"].empty()) {
      senderUserId = make_shared<string>(boost::any_cast<string>(m["senderUserId"]));
    }
  }


  virtual ~GrantHonorShrinkRequest() = default;
};
class GrantHonorResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> failedUserIds{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> successUserIds{};

  GrantHonorResponseBody() {}

  explicit GrantHonorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedUserIds) {
      res["failedUserIds"] = boost::any(*failedUserIds);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (successUserIds) {
      res["successUserIds"] = boost::any(*successUserIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("failedUserIds") != m.end() && !m["failedUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["failedUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["failedUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failedUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("successUserIds") != m.end() && !m["successUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["successUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["successUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      successUserIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GrantHonorResponseBody() = default;
};
class GrantHonorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GrantHonorResponseBody> body{};

  GrantHonorResponse() {}

  explicit GrantHonorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GrantHonorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GrantHonorResponseBody>(model1);
      }
    }
  }


  virtual ~GrantHonorResponse() = default;
};
class InitMultipartFileUploadHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  InitMultipartFileUploadHeadersAccountContext() {}

  explicit InitMultipartFileUploadHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~InitMultipartFileUploadHeadersAccountContext() = default;
};
class InitMultipartFileUploadHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<InitMultipartFileUploadHeadersAccountContext> accountContext{};

  InitMultipartFileUploadHeaders() {}

  explicit InitMultipartFileUploadHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        InitMultipartFileUploadHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<InitMultipartFileUploadHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~InitMultipartFileUploadHeaders() = default;
};
class InitMultipartFileUploadShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  InitMultipartFileUploadShrinkHeaders() {}

  explicit InitMultipartFileUploadShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~InitMultipartFileUploadShrinkHeaders() = default;
};
class InitMultipartFileUploadRequestOptionPreCheckParam : public Darabonba::Model {
public:
  shared_ptr<string> md5{};
  shared_ptr<string> name{};
  shared_ptr<string> parentId{};
  shared_ptr<long> size{};

  InitMultipartFileUploadRequestOptionPreCheckParam() {}

  explicit InitMultipartFileUploadRequestOptionPreCheckParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~InitMultipartFileUploadRequestOptionPreCheckParam() = default;
};
class InitMultipartFileUploadRequestOption : public Darabonba::Model {
public:
  shared_ptr<InitMultipartFileUploadRequestOptionPreCheckParam> preCheckParam{};
  shared_ptr<string> preferRegion{};
  shared_ptr<string> storageDriver{};

  InitMultipartFileUploadRequestOption() {}

  explicit InitMultipartFileUploadRequestOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preCheckParam) {
      res["PreCheckParam"] = preCheckParam ? boost::any(preCheckParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (preferRegion) {
      res["PreferRegion"] = boost::any(*preferRegion);
    }
    if (storageDriver) {
      res["StorageDriver"] = boost::any(*storageDriver);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreCheckParam") != m.end() && !m["PreCheckParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["PreCheckParam"].type()) {
        InitMultipartFileUploadRequestOptionPreCheckParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PreCheckParam"]));
        preCheckParam = make_shared<InitMultipartFileUploadRequestOptionPreCheckParam>(model1);
      }
    }
    if (m.find("PreferRegion") != m.end() && !m["PreferRegion"].empty()) {
      preferRegion = make_shared<string>(boost::any_cast<string>(m["PreferRegion"]));
    }
    if (m.find("StorageDriver") != m.end() && !m["StorageDriver"].empty()) {
      storageDriver = make_shared<string>(boost::any_cast<string>(m["StorageDriver"]));
    }
  }


  virtual ~InitMultipartFileUploadRequestOption() = default;
};
class InitMultipartFileUploadRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  InitMultipartFileUploadRequestTenantContext() {}

  explicit InitMultipartFileUploadRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~InitMultipartFileUploadRequestTenantContext() = default;
};
class InitMultipartFileUploadRequest : public Darabonba::Model {
public:
  shared_ptr<InitMultipartFileUploadRequestOption> option{};
  shared_ptr<string> parentDentryUuid{};
  shared_ptr<InitMultipartFileUploadRequestTenantContext> tenantContext{};

  InitMultipartFileUploadRequest() {}

  explicit InitMultipartFileUploadRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (option) {
      res["Option"] = option ? boost::any(option->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parentDentryUuid) {
      res["ParentDentryUuid"] = boost::any(*parentDentryUuid);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      if (typeid(map<string, boost::any>) == m["Option"].type()) {
        InitMultipartFileUploadRequestOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Option"]));
        option = make_shared<InitMultipartFileUploadRequestOption>(model1);
      }
    }
    if (m.find("ParentDentryUuid") != m.end() && !m["ParentDentryUuid"].empty()) {
      parentDentryUuid = make_shared<string>(boost::any_cast<string>(m["ParentDentryUuid"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        InitMultipartFileUploadRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<InitMultipartFileUploadRequestTenantContext>(model1);
      }
    }
  }


  virtual ~InitMultipartFileUploadRequest() = default;
};
class InitMultipartFileUploadShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> optionShrink{};
  shared_ptr<string> parentDentryUuid{};
  shared_ptr<string> tenantContextShrink{};

  InitMultipartFileUploadShrinkRequest() {}

  explicit InitMultipartFileUploadShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (optionShrink) {
      res["Option"] = boost::any(*optionShrink);
    }
    if (parentDentryUuid) {
      res["ParentDentryUuid"] = boost::any(*parentDentryUuid);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      optionShrink = make_shared<string>(boost::any_cast<string>(m["Option"]));
    }
    if (m.find("ParentDentryUuid") != m.end() && !m["ParentDentryUuid"].empty()) {
      parentDentryUuid = make_shared<string>(boost::any_cast<string>(m["ParentDentryUuid"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~InitMultipartFileUploadShrinkRequest() = default;
};
class InitMultipartFileUploadResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> storageDriver{};
  shared_ptr<string> uploadKey{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  InitMultipartFileUploadResponseBody() {}

  explicit InitMultipartFileUploadResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (storageDriver) {
      res["storageDriver"] = boost::any(*storageDriver);
    }
    if (uploadKey) {
      res["uploadKey"] = boost::any(*uploadKey);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("storageDriver") != m.end() && !m["storageDriver"].empty()) {
      storageDriver = make_shared<string>(boost::any_cast<string>(m["storageDriver"]));
    }
    if (m.find("uploadKey") != m.end() && !m["uploadKey"].empty()) {
      uploadKey = make_shared<string>(boost::any_cast<string>(m["uploadKey"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~InitMultipartFileUploadResponseBody() = default;
};
class InitMultipartFileUploadResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InitMultipartFileUploadResponseBody> body{};

  InitMultipartFileUploadResponse() {}

  explicit InitMultipartFileUploadResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InitMultipartFileUploadResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InitMultipartFileUploadResponseBody>(model1);
      }
    }
  }


  virtual ~InitMultipartFileUploadResponse() = default;
};
class InsertColumnsBeforeHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  InsertColumnsBeforeHeadersAccountContext() {}

  explicit InsertColumnsBeforeHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~InsertColumnsBeforeHeadersAccountContext() = default;
};
class InsertColumnsBeforeHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<InsertColumnsBeforeHeadersAccountContext> accountContext{};

  InsertColumnsBeforeHeaders() {}

  explicit InsertColumnsBeforeHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        InsertColumnsBeforeHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<InsertColumnsBeforeHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~InsertColumnsBeforeHeaders() = default;
};
class InsertColumnsBeforeShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  InsertColumnsBeforeShrinkHeaders() {}

  explicit InsertColumnsBeforeShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~InsertColumnsBeforeShrinkHeaders() = default;
};
class InsertColumnsBeforeRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  InsertColumnsBeforeRequestTenantContext() {}

  explicit InsertColumnsBeforeRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~InsertColumnsBeforeRequestTenantContext() = default;
};
class InsertColumnsBeforeRequest : public Darabonba::Model {
public:
  shared_ptr<long> column{};
  shared_ptr<long> columnCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<InsertColumnsBeforeRequestTenantContext> tenantContext{};
  shared_ptr<string> workbookId{};

  InsertColumnsBeforeRequest() {}

  explicit InsertColumnsBeforeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (column) {
      res["Column"] = boost::any(*column);
    }
    if (columnCount) {
      res["ColumnCount"] = boost::any(*columnCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Column") != m.end() && !m["Column"].empty()) {
      column = make_shared<long>(boost::any_cast<long>(m["Column"]));
    }
    if (m.find("ColumnCount") != m.end() && !m["ColumnCount"].empty()) {
      columnCount = make_shared<long>(boost::any_cast<long>(m["ColumnCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        InsertColumnsBeforeRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<InsertColumnsBeforeRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~InsertColumnsBeforeRequest() = default;
};
class InsertColumnsBeforeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> column{};
  shared_ptr<long> columnCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workbookId{};

  InsertColumnsBeforeShrinkRequest() {}

  explicit InsertColumnsBeforeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (column) {
      res["Column"] = boost::any(*column);
    }
    if (columnCount) {
      res["ColumnCount"] = boost::any(*columnCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Column") != m.end() && !m["Column"].empty()) {
      column = make_shared<long>(boost::any_cast<long>(m["Column"]));
    }
    if (m.find("ColumnCount") != m.end() && !m["ColumnCount"].empty()) {
      columnCount = make_shared<long>(boost::any_cast<long>(m["ColumnCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~InsertColumnsBeforeShrinkRequest() = default;
};
class InsertColumnsBeforeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  InsertColumnsBeforeResponseBody() {}

  explicit InsertColumnsBeforeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~InsertColumnsBeforeResponseBody() = default;
};
class InsertColumnsBeforeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsertColumnsBeforeResponseBody> body{};

  InsertColumnsBeforeResponse() {}

  explicit InsertColumnsBeforeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertColumnsBeforeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertColumnsBeforeResponseBody>(model1);
      }
    }
  }


  virtual ~InsertColumnsBeforeResponse() = default;
};
class InsertContentWithOptionsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  InsertContentWithOptionsHeadersAccountContext() {}

  explicit InsertContentWithOptionsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~InsertContentWithOptionsHeadersAccountContext() = default;
};
class InsertContentWithOptionsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<InsertContentWithOptionsHeadersAccountContext> accountContext{};

  InsertContentWithOptionsHeaders() {}

  explicit InsertContentWithOptionsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        InsertContentWithOptionsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<InsertContentWithOptionsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~InsertContentWithOptionsHeaders() = default;
};
class InsertContentWithOptionsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  InsertContentWithOptionsShrinkHeaders() {}

  explicit InsertContentWithOptionsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~InsertContentWithOptionsShrinkHeaders() = default;
};
class InsertContentWithOptionsRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  InsertContentWithOptionsRequestTenantContext() {}

  explicit InsertContentWithOptionsRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~InsertContentWithOptionsRequestTenantContext() = default;
};
class InsertContentWithOptionsRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> documentId{};
  shared_ptr<long> index{};
  shared_ptr<string> operatorId{};
  shared_ptr<vector<long>> path{};
  shared_ptr<InsertContentWithOptionsRequestTenantContext> tenantContext{};

  InsertContentWithOptionsRequest() {}

  explicit InsertContentWithOptionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (documentId) {
      res["DocumentId"] = boost::any(*documentId);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (operatorId) {
      res["OperatorId"] = boost::any(*operatorId);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("DocumentId") != m.end() && !m["DocumentId"].empty()) {
      documentId = make_shared<string>(boost::any_cast<string>(m["DocumentId"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("OperatorId") != m.end() && !m["OperatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["OperatorId"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Path"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Path"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      path = make_shared<vector<long>>(toVec1);
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        InsertContentWithOptionsRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<InsertContentWithOptionsRequestTenantContext>(model1);
      }
    }
  }


  virtual ~InsertContentWithOptionsRequest() = default;
};
class InsertContentWithOptionsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> contentShrink{};
  shared_ptr<string> documentId{};
  shared_ptr<long> index{};
  shared_ptr<string> operatorId{};
  shared_ptr<string> pathShrink{};
  shared_ptr<string> tenantContextShrink{};

  InsertContentWithOptionsShrinkRequest() {}

  explicit InsertContentWithOptionsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentShrink) {
      res["Content"] = boost::any(*contentShrink);
    }
    if (documentId) {
      res["DocumentId"] = boost::any(*documentId);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (operatorId) {
      res["OperatorId"] = boost::any(*operatorId);
    }
    if (pathShrink) {
      res["Path"] = boost::any(*pathShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      contentShrink = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DocumentId") != m.end() && !m["DocumentId"].empty()) {
      documentId = make_shared<string>(boost::any_cast<string>(m["DocumentId"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("OperatorId") != m.end() && !m["OperatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["OperatorId"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      pathShrink = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~InsertContentWithOptionsShrinkRequest() = default;
};
class InsertContentWithOptionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  InsertContentWithOptionsResponseBody() {}

  explicit InsertContentWithOptionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~InsertContentWithOptionsResponseBody() = default;
};
class InsertContentWithOptionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsertContentWithOptionsResponseBody> body{};

  InsertContentWithOptionsResponse() {}

  explicit InsertContentWithOptionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertContentWithOptionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertContentWithOptionsResponseBody>(model1);
      }
    }
  }


  virtual ~InsertContentWithOptionsResponse() = default;
};
class InsertMultiDimTableRecordHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  InsertMultiDimTableRecordHeadersAccountContext() {}

  explicit InsertMultiDimTableRecordHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~InsertMultiDimTableRecordHeadersAccountContext() = default;
};
class InsertMultiDimTableRecordHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<InsertMultiDimTableRecordHeadersAccountContext> accountContext{};

  InsertMultiDimTableRecordHeaders() {}

  explicit InsertMultiDimTableRecordHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        InsertMultiDimTableRecordHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<InsertMultiDimTableRecordHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~InsertMultiDimTableRecordHeaders() = default;
};
class InsertMultiDimTableRecordShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  InsertMultiDimTableRecordShrinkHeaders() {}

  explicit InsertMultiDimTableRecordShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~InsertMultiDimTableRecordShrinkHeaders() = default;
};
class InsertMultiDimTableRecordRequestRecords : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> fields{};

  InsertMultiDimTableRecordRequestRecords() {}

  explicit InsertMultiDimTableRecordRequestRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fields) {
      res["Fields"] = boost::any(*fields);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Fields") != m.end() && !m["Fields"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Fields"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      fields = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~InsertMultiDimTableRecordRequestRecords() = default;
};
class InsertMultiDimTableRecordRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  InsertMultiDimTableRecordRequestTenantContext() {}

  explicit InsertMultiDimTableRecordRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~InsertMultiDimTableRecordRequestTenantContext() = default;
};
class InsertMultiDimTableRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<vector<InsertMultiDimTableRecordRequestRecords>> records{};
  shared_ptr<string> sheetIdOrName{};
  shared_ptr<InsertMultiDimTableRecordRequestTenantContext> tenantContext{};

  InsertMultiDimTableRecordRequest() {}

  explicit InsertMultiDimTableRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (records) {
      vector<boost::any> temp1;
      for(auto item1:*records){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Records"] = boost::any(temp1);
    }
    if (sheetIdOrName) {
      res["SheetIdOrName"] = boost::any(*sheetIdOrName);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("Records") != m.end() && !m["Records"].empty()) {
      if (typeid(vector<boost::any>) == m["Records"].type()) {
        vector<InsertMultiDimTableRecordRequestRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InsertMultiDimTableRecordRequestRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        records = make_shared<vector<InsertMultiDimTableRecordRequestRecords>>(expect1);
      }
    }
    if (m.find("SheetIdOrName") != m.end() && !m["SheetIdOrName"].empty()) {
      sheetIdOrName = make_shared<string>(boost::any_cast<string>(m["SheetIdOrName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        InsertMultiDimTableRecordRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<InsertMultiDimTableRecordRequestTenantContext>(model1);
      }
    }
  }


  virtual ~InsertMultiDimTableRecordRequest() = default;
};
class InsertMultiDimTableRecordShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<string> recordsShrink{};
  shared_ptr<string> sheetIdOrName{};
  shared_ptr<string> tenantContextShrink{};

  InsertMultiDimTableRecordShrinkRequest() {}

  explicit InsertMultiDimTableRecordShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (recordsShrink) {
      res["Records"] = boost::any(*recordsShrink);
    }
    if (sheetIdOrName) {
      res["SheetIdOrName"] = boost::any(*sheetIdOrName);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("Records") != m.end() && !m["Records"].empty()) {
      recordsShrink = make_shared<string>(boost::any_cast<string>(m["Records"]));
    }
    if (m.find("SheetIdOrName") != m.end() && !m["SheetIdOrName"].empty()) {
      sheetIdOrName = make_shared<string>(boost::any_cast<string>(m["SheetIdOrName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~InsertMultiDimTableRecordShrinkRequest() = default;
};
class InsertMultiDimTableRecordResponseBodyValue : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  InsertMultiDimTableRecordResponseBodyValue() {}

  explicit InsertMultiDimTableRecordResponseBodyValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~InsertMultiDimTableRecordResponseBodyValue() = default;
};
class InsertMultiDimTableRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<InsertMultiDimTableRecordResponseBodyValue>> value{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  InsertMultiDimTableRecordResponseBody() {}

  explicit InsertMultiDimTableRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      vector<boost::any> temp1;
      for(auto item1:*value){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Value"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<InsertMultiDimTableRecordResponseBodyValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Value"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InsertMultiDimTableRecordResponseBodyValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        value = make_shared<vector<InsertMultiDimTableRecordResponseBodyValue>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~InsertMultiDimTableRecordResponseBody() = default;
};
class InsertMultiDimTableRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsertMultiDimTableRecordResponseBody> body{};

  InsertMultiDimTableRecordResponse() {}

  explicit InsertMultiDimTableRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertMultiDimTableRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertMultiDimTableRecordResponseBody>(model1);
      }
    }
  }


  virtual ~InsertMultiDimTableRecordResponse() = default;
};
class InsertRowsBeforeHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  InsertRowsBeforeHeadersAccountContext() {}

  explicit InsertRowsBeforeHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~InsertRowsBeforeHeadersAccountContext() = default;
};
class InsertRowsBeforeHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<InsertRowsBeforeHeadersAccountContext> accountContext{};

  InsertRowsBeforeHeaders() {}

  explicit InsertRowsBeforeHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        InsertRowsBeforeHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<InsertRowsBeforeHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~InsertRowsBeforeHeaders() = default;
};
class InsertRowsBeforeShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  InsertRowsBeforeShrinkHeaders() {}

  explicit InsertRowsBeforeShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~InsertRowsBeforeShrinkHeaders() = default;
};
class InsertRowsBeforeRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  InsertRowsBeforeRequestTenantContext() {}

  explicit InsertRowsBeforeRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~InsertRowsBeforeRequestTenantContext() = default;
};
class InsertRowsBeforeRequest : public Darabonba::Model {
public:
  shared_ptr<long> row{};
  shared_ptr<long> rowCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<InsertRowsBeforeRequestTenantContext> tenantContext{};
  shared_ptr<string> workbookId{};

  InsertRowsBeforeRequest() {}

  explicit InsertRowsBeforeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (row) {
      res["Row"] = boost::any(*row);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Row") != m.end() && !m["Row"].empty()) {
      row = make_shared<long>(boost::any_cast<long>(m["Row"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["RowCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        InsertRowsBeforeRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<InsertRowsBeforeRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~InsertRowsBeforeRequest() = default;
};
class InsertRowsBeforeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> row{};
  shared_ptr<long> rowCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workbookId{};

  InsertRowsBeforeShrinkRequest() {}

  explicit InsertRowsBeforeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (row) {
      res["Row"] = boost::any(*row);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Row") != m.end() && !m["Row"].empty()) {
      row = make_shared<long>(boost::any_cast<long>(m["Row"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["RowCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~InsertRowsBeforeShrinkRequest() = default;
};
class InsertRowsBeforeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  InsertRowsBeforeResponseBody() {}

  explicit InsertRowsBeforeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~InsertRowsBeforeResponseBody() = default;
};
class InsertRowsBeforeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsertRowsBeforeResponseBody> body{};

  InsertRowsBeforeResponse() {}

  explicit InsertRowsBeforeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertRowsBeforeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertRowsBeforeResponseBody>(model1);
      }
    }
  }


  virtual ~InsertRowsBeforeResponse() = default;
};
class InviteUsersHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  InviteUsersHeadersAccountContext() {}

  explicit InviteUsersHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~InviteUsersHeadersAccountContext() = default;
};
class InviteUsersHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<InviteUsersHeadersAccountContext> accountContext{};

  InviteUsersHeaders() {}

  explicit InviteUsersHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        InviteUsersHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<InviteUsersHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~InviteUsersHeaders() = default;
};
class InviteUsersShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  InviteUsersShrinkHeaders() {}

  explicit InviteUsersShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~InviteUsersShrinkHeaders() = default;
};
class InviteUsersRequestInviteeList : public Darabonba::Model {
public:
  shared_ptr<string> nick{};
  shared_ptr<string> userId{};

  InviteUsersRequestInviteeList() {}

  explicit InviteUsersRequestInviteeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nick) {
      res["Nick"] = boost::any(*nick);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Nick") != m.end() && !m["Nick"].empty()) {
      nick = make_shared<string>(boost::any_cast<string>(m["Nick"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~InviteUsersRequestInviteeList() = default;
};
class InviteUsersRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  InviteUsersRequestTenantContext() {}

  explicit InviteUsersRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~InviteUsersRequestTenantContext() = default;
};
class InviteUsersRequestPhoneInviteeList : public Darabonba::Model {
public:
  shared_ptr<bool> inviteClient{};
  shared_ptr<string> nick{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> statusCode{};

  InviteUsersRequestPhoneInviteeList() {}

  explicit InviteUsersRequestPhoneInviteeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inviteClient) {
      res["InviteClient"] = boost::any(*inviteClient);
    }
    if (nick) {
      res["Nick"] = boost::any(*nick);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InviteClient") != m.end() && !m["InviteClient"].empty()) {
      inviteClient = make_shared<bool>(boost::any_cast<bool>(m["InviteClient"]));
    }
    if (m.find("Nick") != m.end() && !m["Nick"].empty()) {
      nick = make_shared<string>(boost::any_cast<string>(m["Nick"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<string>(boost::any_cast<string>(m["StatusCode"]));
    }
  }


  virtual ~InviteUsersRequestPhoneInviteeList() = default;
};
class InviteUsersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<InviteUsersRequestInviteeList>> inviteeList{};
  shared_ptr<InviteUsersRequestTenantContext> tenantContext{};
  shared_ptr<string> conferenceId{};
  shared_ptr<vector<InviteUsersRequestPhoneInviteeList>> phoneInviteeList{};

  InviteUsersRequest() {}

  explicit InviteUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inviteeList) {
      vector<boost::any> temp1;
      for(auto item1:*inviteeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InviteeList"] = boost::any(temp1);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    if (phoneInviteeList) {
      vector<boost::any> temp1;
      for(auto item1:*phoneInviteeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["phoneInviteeList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InviteeList") != m.end() && !m["InviteeList"].empty()) {
      if (typeid(vector<boost::any>) == m["InviteeList"].type()) {
        vector<InviteUsersRequestInviteeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InviteeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InviteUsersRequestInviteeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inviteeList = make_shared<vector<InviteUsersRequestInviteeList>>(expect1);
      }
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        InviteUsersRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<InviteUsersRequestTenantContext>(model1);
      }
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
    if (m.find("phoneInviteeList") != m.end() && !m["phoneInviteeList"].empty()) {
      if (typeid(vector<boost::any>) == m["phoneInviteeList"].type()) {
        vector<InviteUsersRequestPhoneInviteeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["phoneInviteeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InviteUsersRequestPhoneInviteeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        phoneInviteeList = make_shared<vector<InviteUsersRequestPhoneInviteeList>>(expect1);
      }
    }
  }


  virtual ~InviteUsersRequest() = default;
};
class InviteUsersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> inviteeListShrink{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> conferenceId{};
  shared_ptr<string> phoneInviteeListShrink{};

  InviteUsersShrinkRequest() {}

  explicit InviteUsersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inviteeListShrink) {
      res["InviteeList"] = boost::any(*inviteeListShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    if (phoneInviteeListShrink) {
      res["phoneInviteeList"] = boost::any(*phoneInviteeListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InviteeList") != m.end() && !m["InviteeList"].empty()) {
      inviteeListShrink = make_shared<string>(boost::any_cast<string>(m["InviteeList"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
    if (m.find("phoneInviteeList") != m.end() && !m["phoneInviteeList"].empty()) {
      phoneInviteeListShrink = make_shared<string>(boost::any_cast<string>(m["phoneInviteeList"]));
    }
  }


  virtual ~InviteUsersShrinkRequest() = default;
};
class InviteUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  InviteUsersResponseBody() {}

  explicit InviteUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~InviteUsersResponseBody() = default;
};
class InviteUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InviteUsersResponseBody> body{};

  InviteUsersResponse() {}

  explicit InviteUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InviteUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InviteUsersResponseBody>(model1);
      }
    }
  }


  virtual ~InviteUsersResponse() = default;
};
class InvokeAssistantHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountId{};

  InvokeAssistantHeaders() {}

  explicit InvokeAssistantHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~InvokeAssistantHeaders() = default;
};
class InvokeAssistantRequestMessagesContentCardCallback : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> relatedMessageId{};

  InvokeAssistantRequestMessagesContentCardCallback() {}

  explicit InvokeAssistantRequestMessagesContentCardCallback(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (relatedMessageId) {
      res["relatedMessageId"] = boost::any(*relatedMessageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("relatedMessageId") != m.end() && !m["relatedMessageId"].empty()) {
      relatedMessageId = make_shared<string>(boost::any_cast<string>(m["relatedMessageId"]));
    }
  }


  virtual ~InvokeAssistantRequestMessagesContentCardCallback() = default;
};
class InvokeAssistantRequestMessagesContentDingCard : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentType{};
  shared_ptr<bool> finished{};
  shared_ptr<string> templateId{};

  InvokeAssistantRequestMessagesContentDingCard() {}

  explicit InvokeAssistantRequestMessagesContentDingCard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (contentType) {
      res["contentType"] = boost::any(*contentType);
    }
    if (finished) {
      res["finished"] = boost::any(*finished);
    }
    if (templateId) {
      res["templateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("contentType") != m.end() && !m["contentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["contentType"]));
    }
    if (m.find("finished") != m.end() && !m["finished"].empty()) {
      finished = make_shared<bool>(boost::any_cast<bool>(m["finished"]));
    }
    if (m.find("templateId") != m.end() && !m["templateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["templateId"]));
    }
  }


  virtual ~InvokeAssistantRequestMessagesContentDingCard() = default;
};
class InvokeAssistantRequestMessagesContentDingNormalCardCardData : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> cardParamMap{};

  InvokeAssistantRequestMessagesContentDingNormalCardCardData() {}

  explicit InvokeAssistantRequestMessagesContentDingNormalCardCardData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardParamMap) {
      res["cardParamMap"] = boost::any(*cardParamMap);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cardParamMap") != m.end() && !m["cardParamMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["cardParamMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      cardParamMap = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~InvokeAssistantRequestMessagesContentDingNormalCardCardData() = default;
};
class InvokeAssistantRequestMessagesContentDingNormalCardCardUpdateOptions : public Darabonba::Model {
public:
  shared_ptr<bool> updateCardDataByKey{};
  shared_ptr<bool> updatePrivateDataByKey{};

  InvokeAssistantRequestMessagesContentDingNormalCardCardUpdateOptions() {}

  explicit InvokeAssistantRequestMessagesContentDingNormalCardCardUpdateOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateCardDataByKey) {
      res["updateCardDataByKey"] = boost::any(*updateCardDataByKey);
    }
    if (updatePrivateDataByKey) {
      res["updatePrivateDataByKey"] = boost::any(*updatePrivateDataByKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("updateCardDataByKey") != m.end() && !m["updateCardDataByKey"].empty()) {
      updateCardDataByKey = make_shared<bool>(boost::any_cast<bool>(m["updateCardDataByKey"]));
    }
    if (m.find("updatePrivateDataByKey") != m.end() && !m["updatePrivateDataByKey"].empty()) {
      updatePrivateDataByKey = make_shared<bool>(boost::any_cast<bool>(m["updatePrivateDataByKey"]));
    }
  }


  virtual ~InvokeAssistantRequestMessagesContentDingNormalCardCardUpdateOptions() = default;
};
class InvokeAssistantRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig : public Darabonba::Model {
public:
  shared_ptr<long> interval{};
  shared_ptr<string> pullStrategy{};
  shared_ptr<string> timeUnit{};

  InvokeAssistantRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig() {}

  explicit InvokeAssistantRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interval) {
      res["interval"] = boost::any(*interval);
    }
    if (pullStrategy) {
      res["pullStrategy"] = boost::any(*pullStrategy);
    }
    if (timeUnit) {
      res["timeUnit"] = boost::any(*timeUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("interval") != m.end() && !m["interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["interval"]));
    }
    if (m.find("pullStrategy") != m.end() && !m["pullStrategy"].empty()) {
      pullStrategy = make_shared<string>(boost::any_cast<string>(m["pullStrategy"]));
    }
    if (m.find("timeUnit") != m.end() && !m["timeUnit"].empty()) {
      timeUnit = make_shared<string>(boost::any_cast<string>(m["timeUnit"]));
    }
  }


  virtual ~InvokeAssistantRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig() = default;
};
class InvokeAssistantRequestMessagesContentDingNormalCardDynamicDataSourceConfigs : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> constParams{};
  shared_ptr<string> dynamicDataSourceId{};
  shared_ptr<InvokeAssistantRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig> pullConfig{};

  InvokeAssistantRequestMessagesContentDingNormalCardDynamicDataSourceConfigs() {}

  explicit InvokeAssistantRequestMessagesContentDingNormalCardDynamicDataSourceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constParams) {
      res["constParams"] = boost::any(*constParams);
    }
    if (dynamicDataSourceId) {
      res["dynamicDataSourceId"] = boost::any(*dynamicDataSourceId);
    }
    if (pullConfig) {
      res["pullConfig"] = pullConfig ? boost::any(pullConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("constParams") != m.end() && !m["constParams"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["constParams"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      constParams = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("dynamicDataSourceId") != m.end() && !m["dynamicDataSourceId"].empty()) {
      dynamicDataSourceId = make_shared<string>(boost::any_cast<string>(m["dynamicDataSourceId"]));
    }
    if (m.find("pullConfig") != m.end() && !m["pullConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["pullConfig"].type()) {
        InvokeAssistantRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["pullConfig"]));
        pullConfig = make_shared<InvokeAssistantRequestMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig>(model1);
      }
    }
  }


  virtual ~InvokeAssistantRequestMessagesContentDingNormalCardDynamicDataSourceConfigs() = default;
};
class InvokeAssistantRequestMessagesContentDingNormalCard : public Darabonba::Model {
public:
  shared_ptr<InvokeAssistantRequestMessagesContentDingNormalCardCardData> cardData{};
  shared_ptr<string> cardTemplateId{};
  shared_ptr<InvokeAssistantRequestMessagesContentDingNormalCardCardUpdateOptions> cardUpdateOptions{};
  shared_ptr<vector<InvokeAssistantRequestMessagesContentDingNormalCardDynamicDataSourceConfigs>> dynamicDataSourceConfigs{};
  shared_ptr<map<string, map<string, boost::any>>> privateData{};

  InvokeAssistantRequestMessagesContentDingNormalCard() {}

  explicit InvokeAssistantRequestMessagesContentDingNormalCard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardData) {
      res["cardData"] = cardData ? boost::any(cardData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cardTemplateId) {
      res["cardTemplateId"] = boost::any(*cardTemplateId);
    }
    if (cardUpdateOptions) {
      res["cardUpdateOptions"] = cardUpdateOptions ? boost::any(cardUpdateOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dynamicDataSourceConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*dynamicDataSourceConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dynamicDataSourceConfigs"] = boost::any(temp1);
    }
    if (privateData) {
      res["privateData"] = boost::any(*privateData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cardData") != m.end() && !m["cardData"].empty()) {
      if (typeid(map<string, boost::any>) == m["cardData"].type()) {
        InvokeAssistantRequestMessagesContentDingNormalCardCardData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cardData"]));
        cardData = make_shared<InvokeAssistantRequestMessagesContentDingNormalCardCardData>(model1);
      }
    }
    if (m.find("cardTemplateId") != m.end() && !m["cardTemplateId"].empty()) {
      cardTemplateId = make_shared<string>(boost::any_cast<string>(m["cardTemplateId"]));
    }
    if (m.find("cardUpdateOptions") != m.end() && !m["cardUpdateOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["cardUpdateOptions"].type()) {
        InvokeAssistantRequestMessagesContentDingNormalCardCardUpdateOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cardUpdateOptions"]));
        cardUpdateOptions = make_shared<InvokeAssistantRequestMessagesContentDingNormalCardCardUpdateOptions>(model1);
      }
    }
    if (m.find("dynamicDataSourceConfigs") != m.end() && !m["dynamicDataSourceConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["dynamicDataSourceConfigs"].type()) {
        vector<InvokeAssistantRequestMessagesContentDingNormalCardDynamicDataSourceConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dynamicDataSourceConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InvokeAssistantRequestMessagesContentDingNormalCardDynamicDataSourceConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dynamicDataSourceConfigs = make_shared<vector<InvokeAssistantRequestMessagesContentDingNormalCardDynamicDataSourceConfigs>>(expect1);
      }
    }
    if (m.find("privateData") != m.end() && !m["privateData"].empty()) {
      map<string, map<string, boost::any>> map1 = boost::any_cast<map<string, map<string, boost::any>>>(m["privateData"]);
      map<string, map<string, boost::any>> toMap1;
      for (auto item:map1) {
        map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item.second);
        map<string, boost::any> toMap2;
        for (auto item:map2) {
           toMap2[item.first] = item.second;
        }
         toMap1[item.first] = toMap2;
      }
      privateData = make_shared<map<string, map<string, boost::any>>>(toMap1);
    }
  }


  virtual ~InvokeAssistantRequestMessagesContentDingNormalCard() = default;
};
class InvokeAssistantRequestMessagesContentMarkdown : public Darabonba::Model {
public:
  shared_ptr<string> value{};

  InvokeAssistantRequestMessagesContentMarkdown() {}

  explicit InvokeAssistantRequestMessagesContentMarkdown(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~InvokeAssistantRequestMessagesContentMarkdown() = default;
};
class InvokeAssistantRequestMessagesContentStructViewPartsDataPart : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};

  InvokeAssistantRequestMessagesContentStructViewPartsDataPart() {}

  explicit InvokeAssistantRequestMessagesContentStructViewPartsDataPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["data"]));
    }
  }


  virtual ~InvokeAssistantRequestMessagesContentStructViewPartsDataPart() = default;
};
class InvokeAssistantRequestMessagesContentStructViewPartsReasonPart : public Darabonba::Model {
public:
  shared_ptr<string> reason{};

  InvokeAssistantRequestMessagesContentStructViewPartsReasonPart() {}

  explicit InvokeAssistantRequestMessagesContentStructViewPartsReasonPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
  }


  virtual ~InvokeAssistantRequestMessagesContentStructViewPartsReasonPart() = default;
};
class InvokeAssistantRequestMessagesContentStructViewPartsRecommendPartRecommends : public Darabonba::Model {
public:
  shared_ptr<string> mobileUrl{};
  shared_ptr<string> text{};
  shared_ptr<string> url{};

  InvokeAssistantRequestMessagesContentStructViewPartsRecommendPartRecommends() {}

  explicit InvokeAssistantRequestMessagesContentStructViewPartsRecommendPartRecommends(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mobileUrl) {
      res["mobileUrl"] = boost::any(*mobileUrl);
    }
    if (text) {
      res["text"] = boost::any(*text);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("mobileUrl") != m.end() && !m["mobileUrl"].empty()) {
      mobileUrl = make_shared<string>(boost::any_cast<string>(m["mobileUrl"]));
    }
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~InvokeAssistantRequestMessagesContentStructViewPartsRecommendPartRecommends() = default;
};
class InvokeAssistantRequestMessagesContentStructViewPartsRecommendPart : public Darabonba::Model {
public:
  shared_ptr<vector<InvokeAssistantRequestMessagesContentStructViewPartsRecommendPartRecommends>> recommends{};

  InvokeAssistantRequestMessagesContentStructViewPartsRecommendPart() {}

  explicit InvokeAssistantRequestMessagesContentStructViewPartsRecommendPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommends) {
      vector<boost::any> temp1;
      for(auto item1:*recommends){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["recommends"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("recommends") != m.end() && !m["recommends"].empty()) {
      if (typeid(vector<boost::any>) == m["recommends"].type()) {
        vector<InvokeAssistantRequestMessagesContentStructViewPartsRecommendPartRecommends> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["recommends"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InvokeAssistantRequestMessagesContentStructViewPartsRecommendPartRecommends model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recommends = make_shared<vector<InvokeAssistantRequestMessagesContentStructViewPartsRecommendPartRecommends>>(expect1);
      }
    }
  }


  virtual ~InvokeAssistantRequestMessagesContentStructViewPartsRecommendPart() = default;
};
class InvokeAssistantRequestMessagesContentStructViewPartsReferencePartReferences : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceCode{};
  shared_ptr<string> sourceIcon{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  InvokeAssistantRequestMessagesContentStructViewPartsReferencePartReferences() {}

  explicit InvokeAssistantRequestMessagesContentStructViewPartsReferencePartReferences(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceCode) {
      res["sourceCode"] = boost::any(*sourceCode);
    }
    if (sourceIcon) {
      res["sourceIcon"] = boost::any(*sourceIcon);
    }
    if (summary) {
      res["summary"] = boost::any(*summary);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceCode") != m.end() && !m["sourceCode"].empty()) {
      sourceCode = make_shared<string>(boost::any_cast<string>(m["sourceCode"]));
    }
    if (m.find("sourceIcon") != m.end() && !m["sourceIcon"].empty()) {
      sourceIcon = make_shared<string>(boost::any_cast<string>(m["sourceIcon"]));
    }
    if (m.find("summary") != m.end() && !m["summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["summary"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~InvokeAssistantRequestMessagesContentStructViewPartsReferencePartReferences() = default;
};
class InvokeAssistantRequestMessagesContentStructViewPartsReferencePart : public Darabonba::Model {
public:
  shared_ptr<vector<InvokeAssistantRequestMessagesContentStructViewPartsReferencePartReferences>> references{};

  InvokeAssistantRequestMessagesContentStructViewPartsReferencePart() {}

  explicit InvokeAssistantRequestMessagesContentStructViewPartsReferencePart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (references) {
      vector<boost::any> temp1;
      for(auto item1:*references){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["references"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("references") != m.end() && !m["references"].empty()) {
      if (typeid(vector<boost::any>) == m["references"].type()) {
        vector<InvokeAssistantRequestMessagesContentStructViewPartsReferencePartReferences> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["references"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InvokeAssistantRequestMessagesContentStructViewPartsReferencePartReferences model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        references = make_shared<vector<InvokeAssistantRequestMessagesContentStructViewPartsReferencePartReferences>>(expect1);
      }
    }
  }


  virtual ~InvokeAssistantRequestMessagesContentStructViewPartsReferencePart() = default;
};
class InvokeAssistantRequestMessagesContentStructViewPartsTextPart : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  InvokeAssistantRequestMessagesContentStructViewPartsTextPart() {}

  explicit InvokeAssistantRequestMessagesContentStructViewPartsTextPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
  }


  virtual ~InvokeAssistantRequestMessagesContentStructViewPartsTextPart() = default;
};
class InvokeAssistantRequestMessagesContentStructViewParts : public Darabonba::Model {
public:
  shared_ptr<bool> append{};
  shared_ptr<InvokeAssistantRequestMessagesContentStructViewPartsDataPart> dataPart{};
  shared_ptr<bool> finish{};
  shared_ptr<string> partDesc{};
  shared_ptr<string> partId{};
  shared_ptr<InvokeAssistantRequestMessagesContentStructViewPartsReasonPart> reasonPart{};
  shared_ptr<InvokeAssistantRequestMessagesContentStructViewPartsRecommendPart> recommendPart{};
  shared_ptr<InvokeAssistantRequestMessagesContentStructViewPartsReferencePart> referencePart{};
  shared_ptr<InvokeAssistantRequestMessagesContentStructViewPartsTextPart> textPart{};
  shared_ptr<string> type{};

  InvokeAssistantRequestMessagesContentStructViewParts() {}

  explicit InvokeAssistantRequestMessagesContentStructViewParts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (append) {
      res["append"] = boost::any(*append);
    }
    if (dataPart) {
      res["dataPart"] = dataPart ? boost::any(dataPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (finish) {
      res["finish"] = boost::any(*finish);
    }
    if (partDesc) {
      res["partDesc"] = boost::any(*partDesc);
    }
    if (partId) {
      res["partId"] = boost::any(*partId);
    }
    if (reasonPart) {
      res["reasonPart"] = reasonPart ? boost::any(reasonPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recommendPart) {
      res["recommendPart"] = recommendPart ? boost::any(recommendPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referencePart) {
      res["referencePart"] = referencePart ? boost::any(referencePart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (textPart) {
      res["textPart"] = textPart ? boost::any(textPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("append") != m.end() && !m["append"].empty()) {
      append = make_shared<bool>(boost::any_cast<bool>(m["append"]));
    }
    if (m.find("dataPart") != m.end() && !m["dataPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["dataPart"].type()) {
        InvokeAssistantRequestMessagesContentStructViewPartsDataPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dataPart"]));
        dataPart = make_shared<InvokeAssistantRequestMessagesContentStructViewPartsDataPart>(model1);
      }
    }
    if (m.find("finish") != m.end() && !m["finish"].empty()) {
      finish = make_shared<bool>(boost::any_cast<bool>(m["finish"]));
    }
    if (m.find("partDesc") != m.end() && !m["partDesc"].empty()) {
      partDesc = make_shared<string>(boost::any_cast<string>(m["partDesc"]));
    }
    if (m.find("partId") != m.end() && !m["partId"].empty()) {
      partId = make_shared<string>(boost::any_cast<string>(m["partId"]));
    }
    if (m.find("reasonPart") != m.end() && !m["reasonPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["reasonPart"].type()) {
        InvokeAssistantRequestMessagesContentStructViewPartsReasonPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["reasonPart"]));
        reasonPart = make_shared<InvokeAssistantRequestMessagesContentStructViewPartsReasonPart>(model1);
      }
    }
    if (m.find("recommendPart") != m.end() && !m["recommendPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["recommendPart"].type()) {
        InvokeAssistantRequestMessagesContentStructViewPartsRecommendPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["recommendPart"]));
        recommendPart = make_shared<InvokeAssistantRequestMessagesContentStructViewPartsRecommendPart>(model1);
      }
    }
    if (m.find("referencePart") != m.end() && !m["referencePart"].empty()) {
      if (typeid(map<string, boost::any>) == m["referencePart"].type()) {
        InvokeAssistantRequestMessagesContentStructViewPartsReferencePart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["referencePart"]));
        referencePart = make_shared<InvokeAssistantRequestMessagesContentStructViewPartsReferencePart>(model1);
      }
    }
    if (m.find("textPart") != m.end() && !m["textPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["textPart"].type()) {
        InvokeAssistantRequestMessagesContentStructViewPartsTextPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["textPart"]));
        textPart = make_shared<InvokeAssistantRequestMessagesContentStructViewPartsTextPart>(model1);
      }
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~InvokeAssistantRequestMessagesContentStructViewParts() = default;
};
class InvokeAssistantRequestMessagesContentStructView : public Darabonba::Model {
public:
  shared_ptr<vector<InvokeAssistantRequestMessagesContentStructViewParts>> parts{};

  InvokeAssistantRequestMessagesContentStructView() {}

  explicit InvokeAssistantRequestMessagesContentStructView(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parts) {
      vector<boost::any> temp1;
      for(auto item1:*parts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["parts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("parts") != m.end() && !m["parts"].empty()) {
      if (typeid(vector<boost::any>) == m["parts"].type()) {
        vector<InvokeAssistantRequestMessagesContentStructViewParts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["parts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InvokeAssistantRequestMessagesContentStructViewParts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parts = make_shared<vector<InvokeAssistantRequestMessagesContentStructViewParts>>(expect1);
      }
    }
  }


  virtual ~InvokeAssistantRequestMessagesContentStructView() = default;
};
class InvokeAssistantRequestMessagesContentText : public Darabonba::Model {
public:
  shared_ptr<string> value{};

  InvokeAssistantRequestMessagesContentText() {}

  explicit InvokeAssistantRequestMessagesContentText(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~InvokeAssistantRequestMessagesContentText() = default;
};
class InvokeAssistantRequestMessagesContent : public Darabonba::Model {
public:
  shared_ptr<InvokeAssistantRequestMessagesContentCardCallback> cardCallback{};
  shared_ptr<InvokeAssistantRequestMessagesContentDingCard> dingCard{};
  shared_ptr<InvokeAssistantRequestMessagesContentDingNormalCard> dingNormalCard{};
  shared_ptr<InvokeAssistantRequestMessagesContentMarkdown> markdown{};
  shared_ptr<InvokeAssistantRequestMessagesContentStructView> structView{};
  shared_ptr<InvokeAssistantRequestMessagesContentText> text{};
  shared_ptr<string> type{};

  InvokeAssistantRequestMessagesContent() {}

  explicit InvokeAssistantRequestMessagesContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardCallback) {
      res["cardCallback"] = cardCallback ? boost::any(cardCallback->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dingCard) {
      res["dingCard"] = dingCard ? boost::any(dingCard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dingNormalCard) {
      res["dingNormalCard"] = dingNormalCard ? boost::any(dingNormalCard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (markdown) {
      res["markdown"] = markdown ? boost::any(markdown->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (structView) {
      res["structView"] = structView ? boost::any(structView->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (text) {
      res["text"] = text ? boost::any(text->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cardCallback") != m.end() && !m["cardCallback"].empty()) {
      if (typeid(map<string, boost::any>) == m["cardCallback"].type()) {
        InvokeAssistantRequestMessagesContentCardCallback model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cardCallback"]));
        cardCallback = make_shared<InvokeAssistantRequestMessagesContentCardCallback>(model1);
      }
    }
    if (m.find("dingCard") != m.end() && !m["dingCard"].empty()) {
      if (typeid(map<string, boost::any>) == m["dingCard"].type()) {
        InvokeAssistantRequestMessagesContentDingCard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dingCard"]));
        dingCard = make_shared<InvokeAssistantRequestMessagesContentDingCard>(model1);
      }
    }
    if (m.find("dingNormalCard") != m.end() && !m["dingNormalCard"].empty()) {
      if (typeid(map<string, boost::any>) == m["dingNormalCard"].type()) {
        InvokeAssistantRequestMessagesContentDingNormalCard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dingNormalCard"]));
        dingNormalCard = make_shared<InvokeAssistantRequestMessagesContentDingNormalCard>(model1);
      }
    }
    if (m.find("markdown") != m.end() && !m["markdown"].empty()) {
      if (typeid(map<string, boost::any>) == m["markdown"].type()) {
        InvokeAssistantRequestMessagesContentMarkdown model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["markdown"]));
        markdown = make_shared<InvokeAssistantRequestMessagesContentMarkdown>(model1);
      }
    }
    if (m.find("structView") != m.end() && !m["structView"].empty()) {
      if (typeid(map<string, boost::any>) == m["structView"].type()) {
        InvokeAssistantRequestMessagesContentStructView model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["structView"]));
        structView = make_shared<InvokeAssistantRequestMessagesContentStructView>(model1);
      }
    }
    if (m.find("text") != m.end() && !m["text"].empty()) {
      if (typeid(map<string, boost::any>) == m["text"].type()) {
        InvokeAssistantRequestMessagesContentText model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["text"]));
        text = make_shared<InvokeAssistantRequestMessagesContentText>(model1);
      }
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~InvokeAssistantRequestMessagesContent() = default;
};
class InvokeAssistantRequestMessages : public Darabonba::Model {
public:
  shared_ptr<InvokeAssistantRequestMessagesContent> content{};
  shared_ptr<string> contentDesc{};
  shared_ptr<long> createAt{};
  shared_ptr<string> role{};

  InvokeAssistantRequestMessages() {}

  explicit InvokeAssistantRequestMessages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contentDesc) {
      res["contentDesc"] = boost::any(*contentDesc);
    }
    if (createAt) {
      res["createAt"] = boost::any(*createAt);
    }
    if (role) {
      res["role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      if (typeid(map<string, boost::any>) == m["content"].type()) {
        InvokeAssistantRequestMessagesContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["content"]));
        content = make_shared<InvokeAssistantRequestMessagesContent>(model1);
      }
    }
    if (m.find("contentDesc") != m.end() && !m["contentDesc"].empty()) {
      contentDesc = make_shared<string>(boost::any_cast<string>(m["contentDesc"]));
    }
    if (m.find("createAt") != m.end() && !m["createAt"].empty()) {
      createAt = make_shared<long>(boost::any_cast<long>(m["createAt"]));
    }
    if (m.find("role") != m.end() && !m["role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["role"]));
    }
  }


  virtual ~InvokeAssistantRequestMessages() = default;
};
class InvokeAssistantRequest : public Darabonba::Model {
public:
  shared_ptr<string> assistantId{};
  shared_ptr<vector<InvokeAssistantRequestMessages>> messages{};
  shared_ptr<string> originalAssistantId{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> sourceIdOfOriginalAssistantId{};
  shared_ptr<string> sourceTypeOfOriginalAssistantId{};
  shared_ptr<bool> stream{};

  InvokeAssistantRequest() {}

  explicit InvokeAssistantRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assistantId) {
      res["assistantId"] = boost::any(*assistantId);
    }
    if (messages) {
      vector<boost::any> temp1;
      for(auto item1:*messages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["messages"] = boost::any(temp1);
    }
    if (originalAssistantId) {
      res["originalAssistantId"] = boost::any(*originalAssistantId);
    }
    if (sessionId) {
      res["sessionId"] = boost::any(*sessionId);
    }
    if (sourceIdOfOriginalAssistantId) {
      res["sourceIdOfOriginalAssistantId"] = boost::any(*sourceIdOfOriginalAssistantId);
    }
    if (sourceTypeOfOriginalAssistantId) {
      res["sourceTypeOfOriginalAssistantId"] = boost::any(*sourceTypeOfOriginalAssistantId);
    }
    if (stream) {
      res["stream"] = boost::any(*stream);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assistantId") != m.end() && !m["assistantId"].empty()) {
      assistantId = make_shared<string>(boost::any_cast<string>(m["assistantId"]));
    }
    if (m.find("messages") != m.end() && !m["messages"].empty()) {
      if (typeid(vector<boost::any>) == m["messages"].type()) {
        vector<InvokeAssistantRequestMessages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["messages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InvokeAssistantRequestMessages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        messages = make_shared<vector<InvokeAssistantRequestMessages>>(expect1);
      }
    }
    if (m.find("originalAssistantId") != m.end() && !m["originalAssistantId"].empty()) {
      originalAssistantId = make_shared<string>(boost::any_cast<string>(m["originalAssistantId"]));
    }
    if (m.find("sessionId") != m.end() && !m["sessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["sessionId"]));
    }
    if (m.find("sourceIdOfOriginalAssistantId") != m.end() && !m["sourceIdOfOriginalAssistantId"].empty()) {
      sourceIdOfOriginalAssistantId = make_shared<string>(boost::any_cast<string>(m["sourceIdOfOriginalAssistantId"]));
    }
    if (m.find("sourceTypeOfOriginalAssistantId") != m.end() && !m["sourceTypeOfOriginalAssistantId"].empty()) {
      sourceTypeOfOriginalAssistantId = make_shared<string>(boost::any_cast<string>(m["sourceTypeOfOriginalAssistantId"]));
    }
    if (m.find("stream") != m.end() && !m["stream"].empty()) {
      stream = make_shared<bool>(boost::any_cast<bool>(m["stream"]));
    }
  }


  virtual ~InvokeAssistantRequest() = default;
};
class InvokeAssistantResponseBodyMessagesContentCardCallback : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> relatedMessageId{};

  InvokeAssistantResponseBodyMessagesContentCardCallback() {}

  explicit InvokeAssistantResponseBodyMessagesContentCardCallback(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (relatedMessageId) {
      res["relatedMessageId"] = boost::any(*relatedMessageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("relatedMessageId") != m.end() && !m["relatedMessageId"].empty()) {
      relatedMessageId = make_shared<string>(boost::any_cast<string>(m["relatedMessageId"]));
    }
  }


  virtual ~InvokeAssistantResponseBodyMessagesContentCardCallback() = default;
};
class InvokeAssistantResponseBodyMessagesContentDingCard : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentType{};
  shared_ptr<bool> finished{};
  shared_ptr<string> templateId{};

  InvokeAssistantResponseBodyMessagesContentDingCard() {}

  explicit InvokeAssistantResponseBodyMessagesContentDingCard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (contentType) {
      res["contentType"] = boost::any(*contentType);
    }
    if (finished) {
      res["finished"] = boost::any(*finished);
    }
    if (templateId) {
      res["templateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("contentType") != m.end() && !m["contentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["contentType"]));
    }
    if (m.find("finished") != m.end() && !m["finished"].empty()) {
      finished = make_shared<bool>(boost::any_cast<bool>(m["finished"]));
    }
    if (m.find("templateId") != m.end() && !m["templateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["templateId"]));
    }
  }


  virtual ~InvokeAssistantResponseBodyMessagesContentDingCard() = default;
};
class InvokeAssistantResponseBodyMessagesContentDingNormalCardCardData : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> cardParamMap{};

  InvokeAssistantResponseBodyMessagesContentDingNormalCardCardData() {}

  explicit InvokeAssistantResponseBodyMessagesContentDingNormalCardCardData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardParamMap) {
      res["cardParamMap"] = boost::any(*cardParamMap);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cardParamMap") != m.end() && !m["cardParamMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["cardParamMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      cardParamMap = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~InvokeAssistantResponseBodyMessagesContentDingNormalCardCardData() = default;
};
class InvokeAssistantResponseBodyMessagesContentDingNormalCardCardUpdateOptions : public Darabonba::Model {
public:
  shared_ptr<bool> updateCardDataByKey{};
  shared_ptr<bool> updatePrivateDataByKey{};

  InvokeAssistantResponseBodyMessagesContentDingNormalCardCardUpdateOptions() {}

  explicit InvokeAssistantResponseBodyMessagesContentDingNormalCardCardUpdateOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateCardDataByKey) {
      res["updateCardDataByKey"] = boost::any(*updateCardDataByKey);
    }
    if (updatePrivateDataByKey) {
      res["updatePrivateDataByKey"] = boost::any(*updatePrivateDataByKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("updateCardDataByKey") != m.end() && !m["updateCardDataByKey"].empty()) {
      updateCardDataByKey = make_shared<bool>(boost::any_cast<bool>(m["updateCardDataByKey"]));
    }
    if (m.find("updatePrivateDataByKey") != m.end() && !m["updatePrivateDataByKey"].empty()) {
      updatePrivateDataByKey = make_shared<bool>(boost::any_cast<bool>(m["updatePrivateDataByKey"]));
    }
  }


  virtual ~InvokeAssistantResponseBodyMessagesContentDingNormalCardCardUpdateOptions() = default;
};
class InvokeAssistantResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig : public Darabonba::Model {
public:
  shared_ptr<long> interval{};
  shared_ptr<string> pullStrategy{};
  shared_ptr<string> timeUnit{};

  InvokeAssistantResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig() {}

  explicit InvokeAssistantResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interval) {
      res["interval"] = boost::any(*interval);
    }
    if (pullStrategy) {
      res["pullStrategy"] = boost::any(*pullStrategy);
    }
    if (timeUnit) {
      res["timeUnit"] = boost::any(*timeUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("interval") != m.end() && !m["interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["interval"]));
    }
    if (m.find("pullStrategy") != m.end() && !m["pullStrategy"].empty()) {
      pullStrategy = make_shared<string>(boost::any_cast<string>(m["pullStrategy"]));
    }
    if (m.find("timeUnit") != m.end() && !m["timeUnit"].empty()) {
      timeUnit = make_shared<string>(boost::any_cast<string>(m["timeUnit"]));
    }
  }


  virtual ~InvokeAssistantResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig() = default;
};
class InvokeAssistantResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> constParams{};
  shared_ptr<string> dynamicDataSourceId{};
  shared_ptr<InvokeAssistantResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig> pullConfig{};

  InvokeAssistantResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs() {}

  explicit InvokeAssistantResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constParams) {
      res["constParams"] = boost::any(*constParams);
    }
    if (dynamicDataSourceId) {
      res["dynamicDataSourceId"] = boost::any(*dynamicDataSourceId);
    }
    if (pullConfig) {
      res["pullConfig"] = pullConfig ? boost::any(pullConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("constParams") != m.end() && !m["constParams"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["constParams"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      constParams = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("dynamicDataSourceId") != m.end() && !m["dynamicDataSourceId"].empty()) {
      dynamicDataSourceId = make_shared<string>(boost::any_cast<string>(m["dynamicDataSourceId"]));
    }
    if (m.find("pullConfig") != m.end() && !m["pullConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["pullConfig"].type()) {
        InvokeAssistantResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["pullConfig"]));
        pullConfig = make_shared<InvokeAssistantResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig>(model1);
      }
    }
  }


  virtual ~InvokeAssistantResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs() = default;
};
class InvokeAssistantResponseBodyMessagesContentDingNormalCard : public Darabonba::Model {
public:
  shared_ptr<InvokeAssistantResponseBodyMessagesContentDingNormalCardCardData> cardData{};
  shared_ptr<string> cardTemplateId{};
  shared_ptr<InvokeAssistantResponseBodyMessagesContentDingNormalCardCardUpdateOptions> cardUpdateOptions{};
  shared_ptr<vector<InvokeAssistantResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs>> dynamicDataSourceConfigs{};
  shared_ptr<map<string, map<string, boost::any>>> privateData{};

  InvokeAssistantResponseBodyMessagesContentDingNormalCard() {}

  explicit InvokeAssistantResponseBodyMessagesContentDingNormalCard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardData) {
      res["cardData"] = cardData ? boost::any(cardData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cardTemplateId) {
      res["cardTemplateId"] = boost::any(*cardTemplateId);
    }
    if (cardUpdateOptions) {
      res["cardUpdateOptions"] = cardUpdateOptions ? boost::any(cardUpdateOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dynamicDataSourceConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*dynamicDataSourceConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dynamicDataSourceConfigs"] = boost::any(temp1);
    }
    if (privateData) {
      res["privateData"] = boost::any(*privateData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cardData") != m.end() && !m["cardData"].empty()) {
      if (typeid(map<string, boost::any>) == m["cardData"].type()) {
        InvokeAssistantResponseBodyMessagesContentDingNormalCardCardData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cardData"]));
        cardData = make_shared<InvokeAssistantResponseBodyMessagesContentDingNormalCardCardData>(model1);
      }
    }
    if (m.find("cardTemplateId") != m.end() && !m["cardTemplateId"].empty()) {
      cardTemplateId = make_shared<string>(boost::any_cast<string>(m["cardTemplateId"]));
    }
    if (m.find("cardUpdateOptions") != m.end() && !m["cardUpdateOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["cardUpdateOptions"].type()) {
        InvokeAssistantResponseBodyMessagesContentDingNormalCardCardUpdateOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cardUpdateOptions"]));
        cardUpdateOptions = make_shared<InvokeAssistantResponseBodyMessagesContentDingNormalCardCardUpdateOptions>(model1);
      }
    }
    if (m.find("dynamicDataSourceConfigs") != m.end() && !m["dynamicDataSourceConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["dynamicDataSourceConfigs"].type()) {
        vector<InvokeAssistantResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dynamicDataSourceConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InvokeAssistantResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dynamicDataSourceConfigs = make_shared<vector<InvokeAssistantResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs>>(expect1);
      }
    }
    if (m.find("privateData") != m.end() && !m["privateData"].empty()) {
      map<string, map<string, boost::any>> map1 = boost::any_cast<map<string, map<string, boost::any>>>(m["privateData"]);
      map<string, map<string, boost::any>> toMap1;
      for (auto item:map1) {
        map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item.second);
        map<string, boost::any> toMap2;
        for (auto item:map2) {
           toMap2[item.first] = item.second;
        }
         toMap1[item.first] = toMap2;
      }
      privateData = make_shared<map<string, map<string, boost::any>>>(toMap1);
    }
  }


  virtual ~InvokeAssistantResponseBodyMessagesContentDingNormalCard() = default;
};
class InvokeAssistantResponseBodyMessagesContentMarkdown : public Darabonba::Model {
public:
  shared_ptr<string> value{};

  InvokeAssistantResponseBodyMessagesContentMarkdown() {}

  explicit InvokeAssistantResponseBodyMessagesContentMarkdown(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~InvokeAssistantResponseBodyMessagesContentMarkdown() = default;
};
class InvokeAssistantResponseBodyMessagesContentStructViewPartsDataPart : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};

  InvokeAssistantResponseBodyMessagesContentStructViewPartsDataPart() {}

  explicit InvokeAssistantResponseBodyMessagesContentStructViewPartsDataPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["data"]));
    }
  }


  virtual ~InvokeAssistantResponseBodyMessagesContentStructViewPartsDataPart() = default;
};
class InvokeAssistantResponseBodyMessagesContentStructViewPartsReasonPart : public Darabonba::Model {
public:
  shared_ptr<string> reason{};

  InvokeAssistantResponseBodyMessagesContentStructViewPartsReasonPart() {}

  explicit InvokeAssistantResponseBodyMessagesContentStructViewPartsReasonPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
  }


  virtual ~InvokeAssistantResponseBodyMessagesContentStructViewPartsReasonPart() = default;
};
class InvokeAssistantResponseBodyMessagesContentStructViewPartsRecommendPartRecommends : public Darabonba::Model {
public:
  shared_ptr<string> mobileUrl{};
  shared_ptr<string> text{};
  shared_ptr<string> url{};

  InvokeAssistantResponseBodyMessagesContentStructViewPartsRecommendPartRecommends() {}

  explicit InvokeAssistantResponseBodyMessagesContentStructViewPartsRecommendPartRecommends(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mobileUrl) {
      res["mobileUrl"] = boost::any(*mobileUrl);
    }
    if (text) {
      res["text"] = boost::any(*text);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("mobileUrl") != m.end() && !m["mobileUrl"].empty()) {
      mobileUrl = make_shared<string>(boost::any_cast<string>(m["mobileUrl"]));
    }
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~InvokeAssistantResponseBodyMessagesContentStructViewPartsRecommendPartRecommends() = default;
};
class InvokeAssistantResponseBodyMessagesContentStructViewPartsRecommendPart : public Darabonba::Model {
public:
  shared_ptr<vector<InvokeAssistantResponseBodyMessagesContentStructViewPartsRecommendPartRecommends>> recommends{};

  InvokeAssistantResponseBodyMessagesContentStructViewPartsRecommendPart() {}

  explicit InvokeAssistantResponseBodyMessagesContentStructViewPartsRecommendPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommends) {
      vector<boost::any> temp1;
      for(auto item1:*recommends){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["recommends"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("recommends") != m.end() && !m["recommends"].empty()) {
      if (typeid(vector<boost::any>) == m["recommends"].type()) {
        vector<InvokeAssistantResponseBodyMessagesContentStructViewPartsRecommendPartRecommends> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["recommends"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InvokeAssistantResponseBodyMessagesContentStructViewPartsRecommendPartRecommends model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recommends = make_shared<vector<InvokeAssistantResponseBodyMessagesContentStructViewPartsRecommendPartRecommends>>(expect1);
      }
    }
  }


  virtual ~InvokeAssistantResponseBodyMessagesContentStructViewPartsRecommendPart() = default;
};
class InvokeAssistantResponseBodyMessagesContentStructViewPartsReferencePartReferences : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceCode{};
  shared_ptr<string> sourceIcon{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  InvokeAssistantResponseBodyMessagesContentStructViewPartsReferencePartReferences() {}

  explicit InvokeAssistantResponseBodyMessagesContentStructViewPartsReferencePartReferences(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceCode) {
      res["sourceCode"] = boost::any(*sourceCode);
    }
    if (sourceIcon) {
      res["sourceIcon"] = boost::any(*sourceIcon);
    }
    if (summary) {
      res["summary"] = boost::any(*summary);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceCode") != m.end() && !m["sourceCode"].empty()) {
      sourceCode = make_shared<string>(boost::any_cast<string>(m["sourceCode"]));
    }
    if (m.find("sourceIcon") != m.end() && !m["sourceIcon"].empty()) {
      sourceIcon = make_shared<string>(boost::any_cast<string>(m["sourceIcon"]));
    }
    if (m.find("summary") != m.end() && !m["summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["summary"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~InvokeAssistantResponseBodyMessagesContentStructViewPartsReferencePartReferences() = default;
};
class InvokeAssistantResponseBodyMessagesContentStructViewPartsReferencePart : public Darabonba::Model {
public:
  shared_ptr<vector<InvokeAssistantResponseBodyMessagesContentStructViewPartsReferencePartReferences>> references{};

  InvokeAssistantResponseBodyMessagesContentStructViewPartsReferencePart() {}

  explicit InvokeAssistantResponseBodyMessagesContentStructViewPartsReferencePart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (references) {
      vector<boost::any> temp1;
      for(auto item1:*references){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["references"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("references") != m.end() && !m["references"].empty()) {
      if (typeid(vector<boost::any>) == m["references"].type()) {
        vector<InvokeAssistantResponseBodyMessagesContentStructViewPartsReferencePartReferences> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["references"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InvokeAssistantResponseBodyMessagesContentStructViewPartsReferencePartReferences model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        references = make_shared<vector<InvokeAssistantResponseBodyMessagesContentStructViewPartsReferencePartReferences>>(expect1);
      }
    }
  }


  virtual ~InvokeAssistantResponseBodyMessagesContentStructViewPartsReferencePart() = default;
};
class InvokeAssistantResponseBodyMessagesContentStructViewPartsTextPart : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  InvokeAssistantResponseBodyMessagesContentStructViewPartsTextPart() {}

  explicit InvokeAssistantResponseBodyMessagesContentStructViewPartsTextPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
  }


  virtual ~InvokeAssistantResponseBodyMessagesContentStructViewPartsTextPart() = default;
};
class InvokeAssistantResponseBodyMessagesContentStructViewParts : public Darabonba::Model {
public:
  shared_ptr<bool> append{};
  shared_ptr<InvokeAssistantResponseBodyMessagesContentStructViewPartsDataPart> dataPart{};
  shared_ptr<bool> finish{};
  shared_ptr<string> partDesc{};
  shared_ptr<string> partId{};
  shared_ptr<InvokeAssistantResponseBodyMessagesContentStructViewPartsReasonPart> reasonPart{};
  shared_ptr<InvokeAssistantResponseBodyMessagesContentStructViewPartsRecommendPart> recommendPart{};
  shared_ptr<InvokeAssistantResponseBodyMessagesContentStructViewPartsReferencePart> referencePart{};
  shared_ptr<InvokeAssistantResponseBodyMessagesContentStructViewPartsTextPart> textPart{};
  shared_ptr<string> type{};

  InvokeAssistantResponseBodyMessagesContentStructViewParts() {}

  explicit InvokeAssistantResponseBodyMessagesContentStructViewParts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (append) {
      res["append"] = boost::any(*append);
    }
    if (dataPart) {
      res["dataPart"] = dataPart ? boost::any(dataPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (finish) {
      res["finish"] = boost::any(*finish);
    }
    if (partDesc) {
      res["partDesc"] = boost::any(*partDesc);
    }
    if (partId) {
      res["partId"] = boost::any(*partId);
    }
    if (reasonPart) {
      res["reasonPart"] = reasonPart ? boost::any(reasonPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recommendPart) {
      res["recommendPart"] = recommendPart ? boost::any(recommendPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referencePart) {
      res["referencePart"] = referencePart ? boost::any(referencePart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (textPart) {
      res["textPart"] = textPart ? boost::any(textPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("append") != m.end() && !m["append"].empty()) {
      append = make_shared<bool>(boost::any_cast<bool>(m["append"]));
    }
    if (m.find("dataPart") != m.end() && !m["dataPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["dataPart"].type()) {
        InvokeAssistantResponseBodyMessagesContentStructViewPartsDataPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dataPart"]));
        dataPart = make_shared<InvokeAssistantResponseBodyMessagesContentStructViewPartsDataPart>(model1);
      }
    }
    if (m.find("finish") != m.end() && !m["finish"].empty()) {
      finish = make_shared<bool>(boost::any_cast<bool>(m["finish"]));
    }
    if (m.find("partDesc") != m.end() && !m["partDesc"].empty()) {
      partDesc = make_shared<string>(boost::any_cast<string>(m["partDesc"]));
    }
    if (m.find("partId") != m.end() && !m["partId"].empty()) {
      partId = make_shared<string>(boost::any_cast<string>(m["partId"]));
    }
    if (m.find("reasonPart") != m.end() && !m["reasonPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["reasonPart"].type()) {
        InvokeAssistantResponseBodyMessagesContentStructViewPartsReasonPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["reasonPart"]));
        reasonPart = make_shared<InvokeAssistantResponseBodyMessagesContentStructViewPartsReasonPart>(model1);
      }
    }
    if (m.find("recommendPart") != m.end() && !m["recommendPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["recommendPart"].type()) {
        InvokeAssistantResponseBodyMessagesContentStructViewPartsRecommendPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["recommendPart"]));
        recommendPart = make_shared<InvokeAssistantResponseBodyMessagesContentStructViewPartsRecommendPart>(model1);
      }
    }
    if (m.find("referencePart") != m.end() && !m["referencePart"].empty()) {
      if (typeid(map<string, boost::any>) == m["referencePart"].type()) {
        InvokeAssistantResponseBodyMessagesContentStructViewPartsReferencePart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["referencePart"]));
        referencePart = make_shared<InvokeAssistantResponseBodyMessagesContentStructViewPartsReferencePart>(model1);
      }
    }
    if (m.find("textPart") != m.end() && !m["textPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["textPart"].type()) {
        InvokeAssistantResponseBodyMessagesContentStructViewPartsTextPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["textPart"]));
        textPart = make_shared<InvokeAssistantResponseBodyMessagesContentStructViewPartsTextPart>(model1);
      }
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~InvokeAssistantResponseBodyMessagesContentStructViewParts() = default;
};
class InvokeAssistantResponseBodyMessagesContentStructView : public Darabonba::Model {
public:
  shared_ptr<vector<InvokeAssistantResponseBodyMessagesContentStructViewParts>> parts{};

  InvokeAssistantResponseBodyMessagesContentStructView() {}

  explicit InvokeAssistantResponseBodyMessagesContentStructView(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parts) {
      vector<boost::any> temp1;
      for(auto item1:*parts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["parts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("parts") != m.end() && !m["parts"].empty()) {
      if (typeid(vector<boost::any>) == m["parts"].type()) {
        vector<InvokeAssistantResponseBodyMessagesContentStructViewParts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["parts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InvokeAssistantResponseBodyMessagesContentStructViewParts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parts = make_shared<vector<InvokeAssistantResponseBodyMessagesContentStructViewParts>>(expect1);
      }
    }
  }


  virtual ~InvokeAssistantResponseBodyMessagesContentStructView() = default;
};
class InvokeAssistantResponseBodyMessagesContentText : public Darabonba::Model {
public:
  shared_ptr<string> value{};

  InvokeAssistantResponseBodyMessagesContentText() {}

  explicit InvokeAssistantResponseBodyMessagesContentText(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~InvokeAssistantResponseBodyMessagesContentText() = default;
};
class InvokeAssistantResponseBodyMessagesContent : public Darabonba::Model {
public:
  shared_ptr<InvokeAssistantResponseBodyMessagesContentCardCallback> cardCallback{};
  shared_ptr<InvokeAssistantResponseBodyMessagesContentDingCard> dingCard{};
  shared_ptr<InvokeAssistantResponseBodyMessagesContentDingNormalCard> dingNormalCard{};
  shared_ptr<InvokeAssistantResponseBodyMessagesContentMarkdown> markdown{};
  shared_ptr<InvokeAssistantResponseBodyMessagesContentStructView> structView{};
  shared_ptr<InvokeAssistantResponseBodyMessagesContentText> text{};
  shared_ptr<string> type{};

  InvokeAssistantResponseBodyMessagesContent() {}

  explicit InvokeAssistantResponseBodyMessagesContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardCallback) {
      res["cardCallback"] = cardCallback ? boost::any(cardCallback->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dingCard) {
      res["dingCard"] = dingCard ? boost::any(dingCard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dingNormalCard) {
      res["dingNormalCard"] = dingNormalCard ? boost::any(dingNormalCard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (markdown) {
      res["markdown"] = markdown ? boost::any(markdown->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (structView) {
      res["structView"] = structView ? boost::any(structView->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (text) {
      res["text"] = text ? boost::any(text->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cardCallback") != m.end() && !m["cardCallback"].empty()) {
      if (typeid(map<string, boost::any>) == m["cardCallback"].type()) {
        InvokeAssistantResponseBodyMessagesContentCardCallback model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cardCallback"]));
        cardCallback = make_shared<InvokeAssistantResponseBodyMessagesContentCardCallback>(model1);
      }
    }
    if (m.find("dingCard") != m.end() && !m["dingCard"].empty()) {
      if (typeid(map<string, boost::any>) == m["dingCard"].type()) {
        InvokeAssistantResponseBodyMessagesContentDingCard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dingCard"]));
        dingCard = make_shared<InvokeAssistantResponseBodyMessagesContentDingCard>(model1);
      }
    }
    if (m.find("dingNormalCard") != m.end() && !m["dingNormalCard"].empty()) {
      if (typeid(map<string, boost::any>) == m["dingNormalCard"].type()) {
        InvokeAssistantResponseBodyMessagesContentDingNormalCard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dingNormalCard"]));
        dingNormalCard = make_shared<InvokeAssistantResponseBodyMessagesContentDingNormalCard>(model1);
      }
    }
    if (m.find("markdown") != m.end() && !m["markdown"].empty()) {
      if (typeid(map<string, boost::any>) == m["markdown"].type()) {
        InvokeAssistantResponseBodyMessagesContentMarkdown model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["markdown"]));
        markdown = make_shared<InvokeAssistantResponseBodyMessagesContentMarkdown>(model1);
      }
    }
    if (m.find("structView") != m.end() && !m["structView"].empty()) {
      if (typeid(map<string, boost::any>) == m["structView"].type()) {
        InvokeAssistantResponseBodyMessagesContentStructView model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["structView"]));
        structView = make_shared<InvokeAssistantResponseBodyMessagesContentStructView>(model1);
      }
    }
    if (m.find("text") != m.end() && !m["text"].empty()) {
      if (typeid(map<string, boost::any>) == m["text"].type()) {
        InvokeAssistantResponseBodyMessagesContentText model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["text"]));
        text = make_shared<InvokeAssistantResponseBodyMessagesContentText>(model1);
      }
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~InvokeAssistantResponseBodyMessagesContent() = default;
};
class InvokeAssistantResponseBodyMessages : public Darabonba::Model {
public:
  shared_ptr<InvokeAssistantResponseBodyMessagesContent> content{};
  shared_ptr<string> contentDesc{};
  shared_ptr<long> createAt{};
  shared_ptr<string> role{};

  InvokeAssistantResponseBodyMessages() {}

  explicit InvokeAssistantResponseBodyMessages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contentDesc) {
      res["contentDesc"] = boost::any(*contentDesc);
    }
    if (createAt) {
      res["createAt"] = boost::any(*createAt);
    }
    if (role) {
      res["role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      if (typeid(map<string, boost::any>) == m["content"].type()) {
        InvokeAssistantResponseBodyMessagesContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["content"]));
        content = make_shared<InvokeAssistantResponseBodyMessagesContent>(model1);
      }
    }
    if (m.find("contentDesc") != m.end() && !m["contentDesc"].empty()) {
      contentDesc = make_shared<string>(boost::any_cast<string>(m["contentDesc"]));
    }
    if (m.find("createAt") != m.end() && !m["createAt"].empty()) {
      createAt = make_shared<long>(boost::any_cast<long>(m["createAt"]));
    }
    if (m.find("role") != m.end() && !m["role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["role"]));
    }
  }


  virtual ~InvokeAssistantResponseBodyMessages() = default;
};
class InvokeAssistantResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<InvokeAssistantResponseBodyMessages>> messages{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sessionId{};
  shared_ptr<bool> streamEnd{};

  InvokeAssistantResponseBody() {}

  explicit InvokeAssistantResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messages) {
      vector<boost::any> temp1;
      for(auto item1:*messages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["messages"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (sessionId) {
      res["sessionId"] = boost::any(*sessionId);
    }
    if (streamEnd) {
      res["streamEnd"] = boost::any(*streamEnd);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("messages") != m.end() && !m["messages"].empty()) {
      if (typeid(vector<boost::any>) == m["messages"].type()) {
        vector<InvokeAssistantResponseBodyMessages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["messages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InvokeAssistantResponseBodyMessages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        messages = make_shared<vector<InvokeAssistantResponseBodyMessages>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("sessionId") != m.end() && !m["sessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["sessionId"]));
    }
    if (m.find("streamEnd") != m.end() && !m["streamEnd"].empty()) {
      streamEnd = make_shared<bool>(boost::any_cast<bool>(m["streamEnd"]));
    }
  }


  virtual ~InvokeAssistantResponseBody() = default;
};
class InvokeAssistantResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InvokeAssistantResponseBody> body{};

  InvokeAssistantResponse() {}

  explicit InvokeAssistantResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InvokeAssistantResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InvokeAssistantResponseBody>(model1);
      }
    }
  }


  virtual ~InvokeAssistantResponse() = default;
};
class InvokeSkillHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  InvokeSkillHeadersAccountContext() {}

  explicit InvokeSkillHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~InvokeSkillHeadersAccountContext() = default;
};
class InvokeSkillHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<InvokeSkillHeadersAccountContext> accountContext{};

  InvokeSkillHeaders() {}

  explicit InvokeSkillHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        InvokeSkillHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<InvokeSkillHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~InvokeSkillHeaders() = default;
};
class InvokeSkillShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  InvokeSkillShrinkHeaders() {}

  explicit InvokeSkillShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~InvokeSkillShrinkHeaders() = default;
};
class InvokeSkillRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> params{};
  shared_ptr<string> skillId{};
  shared_ptr<bool> stream{};

  InvokeSkillRequest() {}

  explicit InvokeSkillRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (skillId) {
      res["SkillId"] = boost::any(*skillId);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Params"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      params = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SkillId") != m.end() && !m["SkillId"].empty()) {
      skillId = make_shared<string>(boost::any_cast<string>(m["SkillId"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<bool>(boost::any_cast<bool>(m["Stream"]));
    }
  }


  virtual ~InvokeSkillRequest() = default;
};
class InvokeSkillShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> paramsShrink{};
  shared_ptr<string> skillId{};
  shared_ptr<bool> stream{};

  InvokeSkillShrinkRequest() {}

  explicit InvokeSkillShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (paramsShrink) {
      res["Params"] = boost::any(*paramsShrink);
    }
    if (skillId) {
      res["SkillId"] = boost::any(*skillId);
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      paramsShrink = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("SkillId") != m.end() && !m["SkillId"].empty()) {
      skillId = make_shared<string>(boost::any_cast<string>(m["SkillId"]));
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      stream = make_shared<bool>(boost::any_cast<bool>(m["Stream"]));
    }
  }


  virtual ~InvokeSkillShrinkRequest() = default;
};
class InvokeSkillResponseBody : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<bool> finished{};
  shared_ptr<boost::any> metadata{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  InvokeSkillResponseBody() {}

  explicit InvokeSkillResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (finished) {
      res["Finished"] = boost::any(*finished);
    }
    if (metadata) {
      res["Metadata"] = boost::any(*metadata);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("Finished") != m.end() && !m["Finished"].empty()) {
      finished = make_shared<bool>(boost::any_cast<bool>(m["Finished"]));
    }
    if (m.find("Metadata") != m.end() && !m["Metadata"].empty()) {
      metadata = make_shared<boost::any>(boost::any_cast<boost::any>(m["Metadata"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InvokeSkillResponseBody() = default;
};
class InvokeSkillResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InvokeSkillResponseBody> body{};

  InvokeSkillResponse() {}

  explicit InvokeSkillResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InvokeSkillResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InvokeSkillResponseBody>(model1);
      }
    }
  }


  virtual ~InvokeSkillResponse() = default;
};
class ListApplicationHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListApplicationHeadersAccountContext() {}

  explicit ListApplicationHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListApplicationHeadersAccountContext() = default;
};
class ListApplicationHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ListApplicationHeadersAccountContext> accountContext{};

  ListApplicationHeaders() {}

  explicit ListApplicationHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ListApplicationHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ListApplicationHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ListApplicationHeaders() = default;
};
class ListApplicationShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ListApplicationShrinkHeaders() {}

  explicit ListApplicationShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ListApplicationShrinkHeaders() = default;
};
class ListApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appFilter{};
  shared_ptr<string> appNameSearchKeyword{};
  shared_ptr<string> corpId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> token{};

  ListApplicationRequest() {}

  explicit ListApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appFilter) {
      res["AppFilter"] = boost::any(*appFilter);
    }
    if (appNameSearchKeyword) {
      res["AppNameSearchKeyword"] = boost::any(*appNameSearchKeyword);
    }
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppFilter") != m.end() && !m["AppFilter"].empty()) {
      appFilter = make_shared<string>(boost::any_cast<string>(m["AppFilter"]));
    }
    if (m.find("AppNameSearchKeyword") != m.end() && !m["AppNameSearchKeyword"].empty()) {
      appNameSearchKeyword = make_shared<string>(boost::any_cast<string>(m["AppNameSearchKeyword"]));
    }
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~ListApplicationRequest() = default;
};
class ListApplicationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appConfig{};
  shared_ptr<string> appType{};
  shared_ptr<string> applicationStatus{};
  shared_ptr<string> corpId{};
  shared_ptr<string> creatorUserId{};
  shared_ptr<string> description{};
  shared_ptr<string> icon{};
  shared_ptr<string> inexistence{};
  shared_ptr<string> name{};
  shared_ptr<string> subCorpId{};

  ListApplicationResponseBodyData() {}

  explicit ListApplicationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appConfig) {
      res["AppConfig"] = boost::any(*appConfig);
    }
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (applicationStatus) {
      res["ApplicationStatus"] = boost::any(*applicationStatus);
    }
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (creatorUserId) {
      res["CreatorUserId"] = boost::any(*creatorUserId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (inexistence) {
      res["Inexistence"] = boost::any(*inexistence);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (subCorpId) {
      res["SubCorpId"] = boost::any(*subCorpId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppConfig") != m.end() && !m["AppConfig"].empty()) {
      appConfig = make_shared<string>(boost::any_cast<string>(m["AppConfig"]));
    }
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("ApplicationStatus") != m.end() && !m["ApplicationStatus"].empty()) {
      applicationStatus = make_shared<string>(boost::any_cast<string>(m["ApplicationStatus"]));
    }
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("CreatorUserId") != m.end() && !m["CreatorUserId"].empty()) {
      creatorUserId = make_shared<string>(boost::any_cast<string>(m["CreatorUserId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("Inexistence") != m.end() && !m["Inexistence"].empty()) {
      inexistence = make_shared<string>(boost::any_cast<string>(m["Inexistence"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SubCorpId") != m.end() && !m["SubCorpId"].empty()) {
      subCorpId = make_shared<string>(boost::any_cast<string>(m["SubCorpId"]));
    }
  }


  virtual ~ListApplicationResponseBodyData() = default;
};
class ListApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListApplicationResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  ListApplicationResponseBody() {}

  explicit ListApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListApplicationResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListApplicationResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~ListApplicationResponseBody() = default;
};
class ListApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListApplicationResponseBody> body{};

  ListApplicationResponse() {}

  explicit ListApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~ListApplicationResponse() = default;
};
class ListCalendarsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListCalendarsHeadersAccountContext() {}

  explicit ListCalendarsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListCalendarsHeadersAccountContext() = default;
};
class ListCalendarsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ListCalendarsHeadersAccountContext> accountContext{};

  ListCalendarsHeaders() {}

  explicit ListCalendarsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ListCalendarsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ListCalendarsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ListCalendarsHeaders() = default;
};
class ListCalendarsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ListCalendarsShrinkHeaders() {}

  explicit ListCalendarsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ListCalendarsShrinkHeaders() = default;
};
class ListCalendarsRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> request{};

  ListCalendarsRequest() {}

  explicit ListCalendarsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (request) {
      res["Request"] = boost::any(*request);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Request") != m.end() && !m["Request"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Request"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      request = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~ListCalendarsRequest() = default;
};
class ListCalendarsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> requestShrink{};

  ListCalendarsShrinkRequest() {}

  explicit ListCalendarsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestShrink) {
      res["Request"] = boost::any(*requestShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Request") != m.end() && !m["Request"].empty()) {
      requestShrink = make_shared<string>(boost::any_cast<string>(m["Request"]));
    }
  }


  virtual ~ListCalendarsShrinkRequest() = default;
};
class ListCalendarsResponseBodyResponseCalendars : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> ETag{};
  shared_ptr<string> id{};
  shared_ptr<string> privilege{};
  shared_ptr<string> summary{};
  shared_ptr<string> timeZone{};
  shared_ptr<string> type{};

  ListCalendarsResponseBodyResponseCalendars() {}

  explicit ListCalendarsResponseBodyResponseCalendars(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ETag) {
      res["ETag"] = boost::any(*ETag);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (privilege) {
      res["Privilege"] = boost::any(*privilege);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ETag") != m.end() && !m["ETag"].empty()) {
      ETag = make_shared<string>(boost::any_cast<string>(m["ETag"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Privilege") != m.end() && !m["Privilege"].empty()) {
      privilege = make_shared<string>(boost::any_cast<string>(m["Privilege"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListCalendarsResponseBodyResponseCalendars() = default;
};
class ListCalendarsResponseBodyResponse : public Darabonba::Model {
public:
  shared_ptr<vector<ListCalendarsResponseBodyResponseCalendars>> calendars{};

  ListCalendarsResponseBodyResponse() {}

  explicit ListCalendarsResponseBodyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calendars) {
      vector<boost::any> temp1;
      for(auto item1:*calendars){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Calendars"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Calendars") != m.end() && !m["Calendars"].empty()) {
      if (typeid(vector<boost::any>) == m["Calendars"].type()) {
        vector<ListCalendarsResponseBodyResponseCalendars> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Calendars"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCalendarsResponseBodyResponseCalendars model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        calendars = make_shared<vector<ListCalendarsResponseBodyResponseCalendars>>(expect1);
      }
    }
  }


  virtual ~ListCalendarsResponseBodyResponse() = default;
};
class ListCalendarsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListCalendarsResponseBodyResponse> response{};

  ListCalendarsResponseBody() {}

  explicit ListCalendarsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (response) {
      res["response"] = response ? boost::any(response->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("response") != m.end() && !m["response"].empty()) {
      if (typeid(map<string, boost::any>) == m["response"].type()) {
        ListCalendarsResponseBodyResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["response"]));
        response = make_shared<ListCalendarsResponseBodyResponse>(model1);
      }
    }
  }


  virtual ~ListCalendarsResponseBody() = default;
};
class ListCalendarsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCalendarsResponseBody> body{};

  ListCalendarsResponse() {}

  explicit ListCalendarsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCalendarsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCalendarsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCalendarsResponse() = default;
};
class ListDentriesHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListDentriesHeadersAccountContext() {}

  explicit ListDentriesHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListDentriesHeadersAccountContext() = default;
};
class ListDentriesHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ListDentriesHeadersAccountContext> accountContext{};

  ListDentriesHeaders() {}

  explicit ListDentriesHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ListDentriesHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ListDentriesHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ListDentriesHeaders() = default;
};
class ListDentriesShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ListDentriesShrinkHeaders() {}

  explicit ListDentriesShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ListDentriesShrinkHeaders() = default;
};
class ListDentriesRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  ListDentriesRequestTenantContext() {}

  explicit ListDentriesRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~ListDentriesRequestTenantContext() = default;
};
class ListDentriesRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> order{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> parentId{};
  shared_ptr<string> spaceId{};
  shared_ptr<ListDentriesRequestTenantContext> tenantContext{};
  shared_ptr<bool> withThumbnail{};

  ListDentriesRequest() {}

  explicit ListDentriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (withThumbnail) {
      res["WithThumbnail"] = boost::any(*withThumbnail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        ListDentriesRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<ListDentriesRequestTenantContext>(model1);
      }
    }
    if (m.find("WithThumbnail") != m.end() && !m["WithThumbnail"].empty()) {
      withThumbnail = make_shared<bool>(boost::any_cast<bool>(m["WithThumbnail"]));
    }
  }


  virtual ~ListDentriesRequest() = default;
};
class ListDentriesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> order{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> parentId{};
  shared_ptr<string> spaceId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<bool> withThumbnail{};

  ListDentriesShrinkRequest() {}

  explicit ListDentriesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (withThumbnail) {
      res["WithThumbnail"] = boost::any(*withThumbnail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WithThumbnail") != m.end() && !m["WithThumbnail"].empty()) {
      withThumbnail = make_shared<bool>(boost::any_cast<bool>(m["WithThumbnail"]));
    }
  }


  virtual ~ListDentriesShrinkRequest() = default;
};
class ListDentriesResponseBodyDentriesProperties : public Darabonba::Model {
public:
  shared_ptr<bool> readOnly{};

  ListDentriesResponseBodyDentriesProperties() {}

  explicit ListDentriesResponseBodyDentriesProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
  }


  virtual ~ListDentriesResponseBodyDentriesProperties() = default;
};
class ListDentriesResponseBodyDentriesThumbnail : public Darabonba::Model {
public:
  shared_ptr<long> height{};
  shared_ptr<string> url{};
  shared_ptr<long> width{};

  ListDentriesResponseBodyDentriesThumbnail() {}

  explicit ListDentriesResponseBodyDentriesThumbnail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~ListDentriesResponseBodyDentriesThumbnail() = default;
};
class ListDentriesResponseBodyDentries : public Darabonba::Model {
public:
  shared_ptr<map<string, vector<DentriesAppPropertiesValue>>> appProperties{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> extension{};
  shared_ptr<string> id{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> name{};
  shared_ptr<string> parentId{};
  shared_ptr<string> partitionType{};
  shared_ptr<string> path{};
  shared_ptr<ListDentriesResponseBodyDentriesProperties> properties{};
  shared_ptr<long> size{};
  shared_ptr<string> spaceId{};
  shared_ptr<string> status{};
  shared_ptr<string> storageDriver{};
  shared_ptr<ListDentriesResponseBodyDentriesThumbnail> thumbnail{};
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};
  shared_ptr<long> version{};

  ListDentriesResponseBodyDentries() {}

  explicit ListDentriesResponseBodyDentries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appProperties) {
      map<string, boost::any> temp1;
      for(auto item1:*appProperties){
        vector<boost::any> temp2;
        for(auto item2:item1.second){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1[item1.first] = boost::any(temp2);
      }
      res["AppProperties"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (partitionType) {
      res["PartitionType"] = boost::any(*partitionType);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageDriver) {
      res["StorageDriver"] = boost::any(*storageDriver);
    }
    if (thumbnail) {
      res["Thumbnail"] = thumbnail ? boost::any(thumbnail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppProperties") != m.end() && !m["AppProperties"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppProperties"].type()) {
        map<string, vector<DentriesAppPropertiesValue>> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["AppProperties"])){
          if (typeid(vector<boost::any>) == item1.second.type()) {
            vector<DentriesAppPropertiesValue> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1.second)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                DentriesAppPropertiesValue model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1[item1.first] = expect2;
          }
        }
        appProperties = make_shared<map<string, vector<DentriesAppPropertiesValue>>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["ModifierId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("PartitionType") != m.end() && !m["PartitionType"].empty()) {
      partitionType = make_shared<string>(boost::any_cast<string>(m["PartitionType"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        ListDentriesResponseBodyDentriesProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<ListDentriesResponseBodyDentriesProperties>(model1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageDriver") != m.end() && !m["StorageDriver"].empty()) {
      storageDriver = make_shared<string>(boost::any_cast<string>(m["StorageDriver"]));
    }
    if (m.find("Thumbnail") != m.end() && !m["Thumbnail"].empty()) {
      if (typeid(map<string, boost::any>) == m["Thumbnail"].type()) {
        ListDentriesResponseBodyDentriesThumbnail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Thumbnail"]));
        thumbnail = make_shared<ListDentriesResponseBodyDentriesThumbnail>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~ListDentriesResponseBodyDentries() = default;
};
class ListDentriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDentriesResponseBodyDentries>> dentries{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  ListDentriesResponseBody() {}

  explicit ListDentriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentries) {
      vector<boost::any> temp1;
      for(auto item1:*dentries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dentries"] = boost::any(temp1);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dentries") != m.end() && !m["dentries"].empty()) {
      if (typeid(vector<boost::any>) == m["dentries"].type()) {
        vector<ListDentriesResponseBodyDentries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dentries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDentriesResponseBodyDentries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dentries = make_shared<vector<ListDentriesResponseBodyDentries>>(expect1);
      }
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~ListDentriesResponseBody() = default;
};
class ListDentriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDentriesResponseBody> body{};

  ListDentriesResponse() {}

  explicit ListDentriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDentriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDentriesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDentriesResponse() = default;
};
class ListDriveSpacesHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListDriveSpacesHeadersAccountContext() {}

  explicit ListDriveSpacesHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListDriveSpacesHeadersAccountContext() = default;
};
class ListDriveSpacesHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ListDriveSpacesHeadersAccountContext> accountContext{};

  ListDriveSpacesHeaders() {}

  explicit ListDriveSpacesHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ListDriveSpacesHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ListDriveSpacesHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ListDriveSpacesHeaders() = default;
};
class ListDriveSpacesShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ListDriveSpacesShrinkHeaders() {}

  explicit ListDriveSpacesShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ListDriveSpacesShrinkHeaders() = default;
};
class ListDriveSpacesRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  ListDriveSpacesRequestTenantContext() {}

  explicit ListDriveSpacesRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~ListDriveSpacesRequestTenantContext() = default;
};
class ListDriveSpacesRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> spaceType{};
  shared_ptr<ListDriveSpacesRequestTenantContext> tenantContext{};

  ListDriveSpacesRequest() {}

  explicit ListDriveSpacesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        ListDriveSpacesRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<ListDriveSpacesRequestTenantContext>(model1);
      }
    }
  }


  virtual ~ListDriveSpacesRequest() = default;
};
class ListDriveSpacesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> spaceType{};
  shared_ptr<string> tenantContextShrink{};

  ListDriveSpacesShrinkRequest() {}

  explicit ListDriveSpacesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~ListDriveSpacesShrinkRequest() = default;
};
class ListDriveSpacesResponseBodySpaces : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> permissionMode{};
  shared_ptr<long> quota{};
  shared_ptr<string> spaceId{};
  shared_ptr<string> spaceName{};
  shared_ptr<string> spaceType{};
  shared_ptr<long> usedQuota{};

  ListDriveSpacesResponseBodySpaces() {}

  explicit ListDriveSpacesResponseBodySpaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (permissionMode) {
      res["PermissionMode"] = boost::any(*permissionMode);
    }
    if (quota) {
      res["Quota"] = boost::any(*quota);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (spaceName) {
      res["SpaceName"] = boost::any(*spaceName);
    }
    if (spaceType) {
      res["SpaceType"] = boost::any(*spaceType);
    }
    if (usedQuota) {
      res["UsedQuota"] = boost::any(*usedQuota);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("PermissionMode") != m.end() && !m["PermissionMode"].empty()) {
      permissionMode = make_shared<string>(boost::any_cast<string>(m["PermissionMode"]));
    }
    if (m.find("Quota") != m.end() && !m["Quota"].empty()) {
      quota = make_shared<long>(boost::any_cast<long>(m["Quota"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("SpaceName") != m.end() && !m["SpaceName"].empty()) {
      spaceName = make_shared<string>(boost::any_cast<string>(m["SpaceName"]));
    }
    if (m.find("SpaceType") != m.end() && !m["SpaceType"].empty()) {
      spaceType = make_shared<string>(boost::any_cast<string>(m["SpaceType"]));
    }
    if (m.find("UsedQuota") != m.end() && !m["UsedQuota"].empty()) {
      usedQuota = make_shared<long>(boost::any_cast<long>(m["UsedQuota"]));
    }
  }


  virtual ~ListDriveSpacesResponseBodySpaces() = default;
};
class ListDriveSpacesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListDriveSpacesResponseBodySpaces>> spaces{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  ListDriveSpacesResponseBody() {}

  explicit ListDriveSpacesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (spaces) {
      vector<boost::any> temp1;
      for(auto item1:*spaces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["spaces"] = boost::any(temp1);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("spaces") != m.end() && !m["spaces"].empty()) {
      if (typeid(vector<boost::any>) == m["spaces"].type()) {
        vector<ListDriveSpacesResponseBodySpaces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["spaces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDriveSpacesResponseBodySpaces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spaces = make_shared<vector<ListDriveSpacesResponseBodySpaces>>(expect1);
      }
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~ListDriveSpacesResponseBody() = default;
};
class ListDriveSpacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDriveSpacesResponseBody> body{};

  ListDriveSpacesResponse() {}

  explicit ListDriveSpacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDriveSpacesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDriveSpacesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDriveSpacesResponse() = default;
};
class ListEventsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListEventsHeadersAccountContext() {}

  explicit ListEventsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListEventsHeadersAccountContext() = default;
};
class ListEventsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ListEventsHeadersAccountContext> accountContext{};

  ListEventsHeaders() {}

  explicit ListEventsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ListEventsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ListEventsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ListEventsHeaders() = default;
};
class ListEventsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ListEventsShrinkHeaders() {}

  explicit ListEventsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ListEventsShrinkHeaders() = default;
};
class ListEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> calendarId{};
  shared_ptr<long> maxAttendees{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> seriesMasterId{};
  shared_ptr<bool> showDeleted{};
  shared_ptr<string> syncToken{};
  shared_ptr<string> timeMax{};
  shared_ptr<string> timeMin{};

  ListEventsRequest() {}

  explicit ListEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (maxAttendees) {
      res["MaxAttendees"] = boost::any(*maxAttendees);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (seriesMasterId) {
      res["SeriesMasterId"] = boost::any(*seriesMasterId);
    }
    if (showDeleted) {
      res["ShowDeleted"] = boost::any(*showDeleted);
    }
    if (syncToken) {
      res["SyncToken"] = boost::any(*syncToken);
    }
    if (timeMax) {
      res["TimeMax"] = boost::any(*timeMax);
    }
    if (timeMin) {
      res["TimeMin"] = boost::any(*timeMin);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("MaxAttendees") != m.end() && !m["MaxAttendees"].empty()) {
      maxAttendees = make_shared<long>(boost::any_cast<long>(m["MaxAttendees"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("SeriesMasterId") != m.end() && !m["SeriesMasterId"].empty()) {
      seriesMasterId = make_shared<string>(boost::any_cast<string>(m["SeriesMasterId"]));
    }
    if (m.find("ShowDeleted") != m.end() && !m["ShowDeleted"].empty()) {
      showDeleted = make_shared<bool>(boost::any_cast<bool>(m["ShowDeleted"]));
    }
    if (m.find("SyncToken") != m.end() && !m["SyncToken"].empty()) {
      syncToken = make_shared<string>(boost::any_cast<string>(m["SyncToken"]));
    }
    if (m.find("TimeMax") != m.end() && !m["TimeMax"].empty()) {
      timeMax = make_shared<string>(boost::any_cast<string>(m["TimeMax"]));
    }
    if (m.find("TimeMin") != m.end() && !m["TimeMin"].empty()) {
      timeMin = make_shared<string>(boost::any_cast<string>(m["TimeMin"]));
    }
  }


  virtual ~ListEventsRequest() = default;
};
class ListEventsResponseBodyEventsAttendees : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<bool> isOptional{};
  shared_ptr<string> responseStatus{};
  shared_ptr<bool> self{};

  ListEventsResponseBodyEventsAttendees() {}

  explicit ListEventsResponseBodyEventsAttendees(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (isOptional) {
      res["IsOptional"] = boost::any(*isOptional);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (self) {
      res["Self"] = boost::any(*self);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("IsOptional") != m.end() && !m["IsOptional"].empty()) {
      isOptional = make_shared<bool>(boost::any_cast<bool>(m["IsOptional"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("Self") != m.end() && !m["Self"].empty()) {
      self = make_shared<bool>(boost::any_cast<bool>(m["Self"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsAttendees() = default;
};
class ListEventsResponseBodyEventsCategories : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};

  ListEventsResponseBodyEventsCategories() {}

  explicit ListEventsResponseBodyEventsCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsCategories() = default;
};
class ListEventsResponseBodyEventsEnd : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  ListEventsResponseBodyEventsEnd() {}

  explicit ListEventsResponseBodyEventsEnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsEnd() = default;
};
class ListEventsResponseBodyEventsExtendedPropertiesSharedProperties : public Darabonba::Model {
public:
  shared_ptr<string> belongCorpId{};
  shared_ptr<string> sourceOpenCid{};

  ListEventsResponseBodyEventsExtendedPropertiesSharedProperties() {}

  explicit ListEventsResponseBodyEventsExtendedPropertiesSharedProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (belongCorpId) {
      res["BelongCorpId"] = boost::any(*belongCorpId);
    }
    if (sourceOpenCid) {
      res["SourceOpenCid"] = boost::any(*sourceOpenCid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BelongCorpId") != m.end() && !m["BelongCorpId"].empty()) {
      belongCorpId = make_shared<string>(boost::any_cast<string>(m["BelongCorpId"]));
    }
    if (m.find("SourceOpenCid") != m.end() && !m["SourceOpenCid"].empty()) {
      sourceOpenCid = make_shared<string>(boost::any_cast<string>(m["SourceOpenCid"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsExtendedPropertiesSharedProperties() = default;
};
class ListEventsResponseBodyEventsExtendedProperties : public Darabonba::Model {
public:
  shared_ptr<ListEventsResponseBodyEventsExtendedPropertiesSharedProperties> sharedProperties{};

  ListEventsResponseBodyEventsExtendedProperties() {}

  explicit ListEventsResponseBodyEventsExtendedProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sharedProperties) {
      res["SharedProperties"] = sharedProperties ? boost::any(sharedProperties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SharedProperties") != m.end() && !m["SharedProperties"].empty()) {
      if (typeid(map<string, boost::any>) == m["SharedProperties"].type()) {
        ListEventsResponseBodyEventsExtendedPropertiesSharedProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SharedProperties"]));
        sharedProperties = make_shared<ListEventsResponseBodyEventsExtendedPropertiesSharedProperties>(model1);
      }
    }
  }


  virtual ~ListEventsResponseBodyEventsExtendedProperties() = default;
};
class ListEventsResponseBodyEventsLocation : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<vector<string>> meetingRooms{};

  ListEventsResponseBodyEventsLocation() {}

  explicit ListEventsResponseBodyEventsLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (meetingRooms) {
      res["MeetingRooms"] = boost::any(*meetingRooms);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("MeetingRooms") != m.end() && !m["MeetingRooms"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MeetingRooms"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MeetingRooms"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      meetingRooms = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListEventsResponseBodyEventsLocation() = default;
};
class ListEventsResponseBodyEventsMeetingRooms : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> responseStatus{};
  shared_ptr<string> roomId{};

  ListEventsResponseBodyEventsMeetingRooms() {}

  explicit ListEventsResponseBodyEventsMeetingRooms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsMeetingRooms() = default;
};
class ListEventsResponseBodyEventsOnlineMeetingInfo : public Darabonba::Model {
public:
  shared_ptr<string> conferenceId{};
  shared_ptr<map<string, boost::any>> extraInfo{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  ListEventsResponseBodyEventsOnlineMeetingInfo() {}

  explicit ListEventsResponseBodyEventsOnlineMeetingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conferenceId) {
      res["ConferenceId"] = boost::any(*conferenceId);
    }
    if (extraInfo) {
      res["ExtraInfo"] = boost::any(*extraInfo);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConferenceId") != m.end() && !m["ConferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["ConferenceId"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsOnlineMeetingInfo() = default;
};
class ListEventsResponseBodyEventsOrganizer : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> responseStatus{};
  shared_ptr<bool> self{};

  ListEventsResponseBodyEventsOrganizer() {}

  explicit ListEventsResponseBodyEventsOrganizer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (self) {
      res["Self"] = boost::any(*self);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("Self") != m.end() && !m["Self"].empty()) {
      self = make_shared<bool>(boost::any_cast<bool>(m["Self"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsOrganizer() = default;
};
class ListEventsResponseBodyEventsOriginStart : public Darabonba::Model {
public:
  shared_ptr<string> dateTime{};

  ListEventsResponseBodyEventsOriginStart() {}

  explicit ListEventsResponseBodyEventsOriginStart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsOriginStart() = default;
};
class ListEventsResponseBodyEventsRecurrencePattern : public Darabonba::Model {
public:
  shared_ptr<long> dayOfMonth{};
  shared_ptr<string> daysOfWeek{};
  shared_ptr<string> index{};
  shared_ptr<long> interval{};
  shared_ptr<string> type{};

  ListEventsResponseBodyEventsRecurrencePattern() {}

  explicit ListEventsResponseBodyEventsRecurrencePattern(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dayOfMonth) {
      res["DayOfMonth"] = boost::any(*dayOfMonth);
    }
    if (daysOfWeek) {
      res["DaysOfWeek"] = boost::any(*daysOfWeek);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DayOfMonth") != m.end() && !m["DayOfMonth"].empty()) {
      dayOfMonth = make_shared<long>(boost::any_cast<long>(m["DayOfMonth"]));
    }
    if (m.find("DaysOfWeek") != m.end() && !m["DaysOfWeek"].empty()) {
      daysOfWeek = make_shared<string>(boost::any_cast<string>(m["DaysOfWeek"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsRecurrencePattern() = default;
};
class ListEventsResponseBodyEventsRecurrenceRange : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<long> numberOfOccurrences{};
  shared_ptr<string> type{};

  ListEventsResponseBodyEventsRecurrenceRange() {}

  explicit ListEventsResponseBodyEventsRecurrenceRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (numberOfOccurrences) {
      res["NumberOfOccurrences"] = boost::any(*numberOfOccurrences);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("NumberOfOccurrences") != m.end() && !m["NumberOfOccurrences"].empty()) {
      numberOfOccurrences = make_shared<long>(boost::any_cast<long>(m["NumberOfOccurrences"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsRecurrenceRange() = default;
};
class ListEventsResponseBodyEventsRecurrence : public Darabonba::Model {
public:
  shared_ptr<ListEventsResponseBodyEventsRecurrencePattern> pattern{};
  shared_ptr<ListEventsResponseBodyEventsRecurrenceRange> range{};

  ListEventsResponseBodyEventsRecurrence() {}

  explicit ListEventsResponseBodyEventsRecurrence(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pattern) {
      res["Pattern"] = pattern ? boost::any(pattern->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (range) {
      res["Range"] = range ? boost::any(range->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pattern"].type()) {
        ListEventsResponseBodyEventsRecurrencePattern model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pattern"]));
        pattern = make_shared<ListEventsResponseBodyEventsRecurrencePattern>(model1);
      }
    }
    if (m.find("Range") != m.end() && !m["Range"].empty()) {
      if (typeid(map<string, boost::any>) == m["Range"].type()) {
        ListEventsResponseBodyEventsRecurrenceRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Range"]));
        range = make_shared<ListEventsResponseBodyEventsRecurrenceRange>(model1);
      }
    }
  }


  virtual ~ListEventsResponseBodyEventsRecurrence() = default;
};
class ListEventsResponseBodyEventsReminders : public Darabonba::Model {
public:
  shared_ptr<string> method{};
  shared_ptr<string> minutes{};

  ListEventsResponseBodyEventsReminders() {}

  explicit ListEventsResponseBodyEventsReminders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (minutes) {
      res["Minutes"] = boost::any(*minutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Minutes") != m.end() && !m["Minutes"].empty()) {
      minutes = make_shared<string>(boost::any_cast<string>(m["Minutes"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsReminders() = default;
};
class ListEventsResponseBodyEventsRichTextDescription : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  ListEventsResponseBodyEventsRichTextDescription() {}

  explicit ListEventsResponseBodyEventsRichTextDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsRichTextDescription() = default;
};
class ListEventsResponseBodyEventsStart : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  ListEventsResponseBodyEventsStart() {}

  explicit ListEventsResponseBodyEventsStart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsStart() = default;
};
class ListEventsResponseBodyEvents : public Darabonba::Model {
public:
  shared_ptr<vector<ListEventsResponseBodyEventsAttendees>> attendees{};
  shared_ptr<vector<ListEventsResponseBodyEventsCategories>> categories{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<ListEventsResponseBodyEventsEnd> end{};
  shared_ptr<ListEventsResponseBodyEventsExtendedProperties> extendedProperties{};
  shared_ptr<string> id{};
  shared_ptr<bool> isAllDay{};
  shared_ptr<ListEventsResponseBodyEventsLocation> location{};
  shared_ptr<vector<ListEventsResponseBodyEventsMeetingRooms>> meetingRooms{};
  shared_ptr<ListEventsResponseBodyEventsOnlineMeetingInfo> onlineMeetingInfo{};
  shared_ptr<ListEventsResponseBodyEventsOrganizer> organizer{};
  shared_ptr<ListEventsResponseBodyEventsOriginStart> originStart{};
  shared_ptr<ListEventsResponseBodyEventsRecurrence> recurrence{};
  shared_ptr<vector<ListEventsResponseBodyEventsReminders>> reminders{};
  shared_ptr<ListEventsResponseBodyEventsRichTextDescription> richTextDescription{};
  shared_ptr<string> seriesMasterId{};
  shared_ptr<ListEventsResponseBodyEventsStart> start{};
  shared_ptr<string> status{};
  shared_ptr<string> summary{};
  shared_ptr<string> updateTime{};

  ListEventsResponseBodyEvents() {}

  explicit ListEventsResponseBodyEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendees) {
      vector<boost::any> temp1;
      for(auto item1:*attendees){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attendees"] = boost::any(temp1);
    }
    if (categories) {
      vector<boost::any> temp1;
      for(auto item1:*categories){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Categories"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (end) {
      res["End"] = end ? boost::any(end->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extendedProperties) {
      res["ExtendedProperties"] = extendedProperties ? boost::any(extendedProperties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isAllDay) {
      res["IsAllDay"] = boost::any(*isAllDay);
    }
    if (location) {
      res["Location"] = location ? boost::any(location->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (meetingRooms) {
      vector<boost::any> temp1;
      for(auto item1:*meetingRooms){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MeetingRooms"] = boost::any(temp1);
    }
    if (onlineMeetingInfo) {
      res["OnlineMeetingInfo"] = onlineMeetingInfo ? boost::any(onlineMeetingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (organizer) {
      res["Organizer"] = organizer ? boost::any(organizer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (originStart) {
      res["OriginStart"] = originStart ? boost::any(originStart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recurrence) {
      res["Recurrence"] = recurrence ? boost::any(recurrence->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reminders) {
      vector<boost::any> temp1;
      for(auto item1:*reminders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Reminders"] = boost::any(temp1);
    }
    if (richTextDescription) {
      res["RichTextDescription"] = richTextDescription ? boost::any(richTextDescription->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (seriesMasterId) {
      res["SeriesMasterId"] = boost::any(*seriesMasterId);
    }
    if (start) {
      res["Start"] = start ? boost::any(start->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attendees") != m.end() && !m["Attendees"].empty()) {
      if (typeid(vector<boost::any>) == m["Attendees"].type()) {
        vector<ListEventsResponseBodyEventsAttendees> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attendees"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEventsResponseBodyEventsAttendees model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attendees = make_shared<vector<ListEventsResponseBodyEventsAttendees>>(expect1);
      }
    }
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<ListEventsResponseBodyEventsCategories> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Categories"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEventsResponseBodyEventsCategories model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        categories = make_shared<vector<ListEventsResponseBodyEventsCategories>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      if (typeid(map<string, boost::any>) == m["End"].type()) {
        ListEventsResponseBodyEventsEnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["End"]));
        end = make_shared<ListEventsResponseBodyEventsEnd>(model1);
      }
    }
    if (m.find("ExtendedProperties") != m.end() && !m["ExtendedProperties"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtendedProperties"].type()) {
        ListEventsResponseBodyEventsExtendedProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtendedProperties"]));
        extendedProperties = make_shared<ListEventsResponseBodyEventsExtendedProperties>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IsAllDay") != m.end() && !m["IsAllDay"].empty()) {
      isAllDay = make_shared<bool>(boost::any_cast<bool>(m["IsAllDay"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      if (typeid(map<string, boost::any>) == m["Location"].type()) {
        ListEventsResponseBodyEventsLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Location"]));
        location = make_shared<ListEventsResponseBodyEventsLocation>(model1);
      }
    }
    if (m.find("MeetingRooms") != m.end() && !m["MeetingRooms"].empty()) {
      if (typeid(vector<boost::any>) == m["MeetingRooms"].type()) {
        vector<ListEventsResponseBodyEventsMeetingRooms> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MeetingRooms"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEventsResponseBodyEventsMeetingRooms model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        meetingRooms = make_shared<vector<ListEventsResponseBodyEventsMeetingRooms>>(expect1);
      }
    }
    if (m.find("OnlineMeetingInfo") != m.end() && !m["OnlineMeetingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["OnlineMeetingInfo"].type()) {
        ListEventsResponseBodyEventsOnlineMeetingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OnlineMeetingInfo"]));
        onlineMeetingInfo = make_shared<ListEventsResponseBodyEventsOnlineMeetingInfo>(model1);
      }
    }
    if (m.find("Organizer") != m.end() && !m["Organizer"].empty()) {
      if (typeid(map<string, boost::any>) == m["Organizer"].type()) {
        ListEventsResponseBodyEventsOrganizer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Organizer"]));
        organizer = make_shared<ListEventsResponseBodyEventsOrganizer>(model1);
      }
    }
    if (m.find("OriginStart") != m.end() && !m["OriginStart"].empty()) {
      if (typeid(map<string, boost::any>) == m["OriginStart"].type()) {
        ListEventsResponseBodyEventsOriginStart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OriginStart"]));
        originStart = make_shared<ListEventsResponseBodyEventsOriginStart>(model1);
      }
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      if (typeid(map<string, boost::any>) == m["Recurrence"].type()) {
        ListEventsResponseBodyEventsRecurrence model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Recurrence"]));
        recurrence = make_shared<ListEventsResponseBodyEventsRecurrence>(model1);
      }
    }
    if (m.find("Reminders") != m.end() && !m["Reminders"].empty()) {
      if (typeid(vector<boost::any>) == m["Reminders"].type()) {
        vector<ListEventsResponseBodyEventsReminders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Reminders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEventsResponseBodyEventsReminders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reminders = make_shared<vector<ListEventsResponseBodyEventsReminders>>(expect1);
      }
    }
    if (m.find("RichTextDescription") != m.end() && !m["RichTextDescription"].empty()) {
      if (typeid(map<string, boost::any>) == m["RichTextDescription"].type()) {
        ListEventsResponseBodyEventsRichTextDescription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RichTextDescription"]));
        richTextDescription = make_shared<ListEventsResponseBodyEventsRichTextDescription>(model1);
      }
    }
    if (m.find("SeriesMasterId") != m.end() && !m["SeriesMasterId"].empty()) {
      seriesMasterId = make_shared<string>(boost::any_cast<string>(m["SeriesMasterId"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      if (typeid(map<string, boost::any>) == m["Start"].type()) {
        ListEventsResponseBodyEventsStart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Start"]));
        start = make_shared<ListEventsResponseBodyEventsStart>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~ListEventsResponseBodyEvents() = default;
};
class ListEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListEventsResponseBodyEvents>> events{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<string> syncToken{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  ListEventsResponseBody() {}

  explicit ListEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (events) {
      vector<boost::any> temp1;
      for(auto item1:*events){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["events"] = boost::any(temp1);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (syncToken) {
      res["syncToken"] = boost::any(*syncToken);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("events") != m.end() && !m["events"].empty()) {
      if (typeid(vector<boost::any>) == m["events"].type()) {
        vector<ListEventsResponseBodyEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["events"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEventsResponseBodyEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        events = make_shared<vector<ListEventsResponseBodyEvents>>(expect1);
      }
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("syncToken") != m.end() && !m["syncToken"].empty()) {
      syncToken = make_shared<string>(boost::any_cast<string>(m["syncToken"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~ListEventsResponseBody() = default;
};
class ListEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEventsResponseBody> body{};

  ListEventsResponse() {}

  explicit ListEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEventsResponseBody>(model1);
      }
    }
  }


  virtual ~ListEventsResponse() = default;
};
class ListEventsViewHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListEventsViewHeadersAccountContext() {}

  explicit ListEventsViewHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListEventsViewHeadersAccountContext() = default;
};
class ListEventsViewHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ListEventsViewHeadersAccountContext> accountContext{};

  ListEventsViewHeaders() {}

  explicit ListEventsViewHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ListEventsViewHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ListEventsViewHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ListEventsViewHeaders() = default;
};
class ListEventsViewShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ListEventsViewShrinkHeaders() {}

  explicit ListEventsViewShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ListEventsViewShrinkHeaders() = default;
};
class ListEventsViewRequest : public Darabonba::Model {
public:
  shared_ptr<string> calendarId{};
  shared_ptr<long> maxAttendees{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> timeMax{};
  shared_ptr<string> timeMin{};

  ListEventsViewRequest() {}

  explicit ListEventsViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (maxAttendees) {
      res["MaxAttendees"] = boost::any(*maxAttendees);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (timeMax) {
      res["TimeMax"] = boost::any(*timeMax);
    }
    if (timeMin) {
      res["TimeMin"] = boost::any(*timeMin);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("MaxAttendees") != m.end() && !m["MaxAttendees"].empty()) {
      maxAttendees = make_shared<long>(boost::any_cast<long>(m["MaxAttendees"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("TimeMax") != m.end() && !m["TimeMax"].empty()) {
      timeMax = make_shared<string>(boost::any_cast<string>(m["TimeMax"]));
    }
    if (m.find("TimeMin") != m.end() && !m["TimeMin"].empty()) {
      timeMin = make_shared<string>(boost::any_cast<string>(m["TimeMin"]));
    }
  }


  virtual ~ListEventsViewRequest() = default;
};
class ListEventsViewResponseBodyEventsAttendees : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> id{};
  shared_ptr<bool> isOptional{};
  shared_ptr<string> responseStatus{};
  shared_ptr<bool> self{};

  ListEventsViewResponseBodyEventsAttendees() {}

  explicit ListEventsViewResponseBodyEventsAttendees(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isOptional) {
      res["IsOptional"] = boost::any(*isOptional);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (self) {
      res["Self"] = boost::any(*self);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IsOptional") != m.end() && !m["IsOptional"].empty()) {
      isOptional = make_shared<bool>(boost::any_cast<bool>(m["IsOptional"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("Self") != m.end() && !m["Self"].empty()) {
      self = make_shared<bool>(boost::any_cast<bool>(m["Self"]));
    }
  }


  virtual ~ListEventsViewResponseBodyEventsAttendees() = default;
};
class ListEventsViewResponseBodyEventsCategories : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};

  ListEventsViewResponseBodyEventsCategories() {}

  explicit ListEventsViewResponseBodyEventsCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
  }


  virtual ~ListEventsViewResponseBodyEventsCategories() = default;
};
class ListEventsViewResponseBodyEventsEnd : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  ListEventsViewResponseBodyEventsEnd() {}

  explicit ListEventsViewResponseBodyEventsEnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~ListEventsViewResponseBodyEventsEnd() = default;
};
class ListEventsViewResponseBodyEventsExtendedPropertiesSharedProperties : public Darabonba::Model {
public:
  shared_ptr<string> belongCorpId{};
  shared_ptr<string> sourceOpenCid{};

  ListEventsViewResponseBodyEventsExtendedPropertiesSharedProperties() {}

  explicit ListEventsViewResponseBodyEventsExtendedPropertiesSharedProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (belongCorpId) {
      res["BelongCorpId"] = boost::any(*belongCorpId);
    }
    if (sourceOpenCid) {
      res["SourceOpenCid"] = boost::any(*sourceOpenCid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BelongCorpId") != m.end() && !m["BelongCorpId"].empty()) {
      belongCorpId = make_shared<string>(boost::any_cast<string>(m["BelongCorpId"]));
    }
    if (m.find("SourceOpenCid") != m.end() && !m["SourceOpenCid"].empty()) {
      sourceOpenCid = make_shared<string>(boost::any_cast<string>(m["SourceOpenCid"]));
    }
  }


  virtual ~ListEventsViewResponseBodyEventsExtendedPropertiesSharedProperties() = default;
};
class ListEventsViewResponseBodyEventsExtendedProperties : public Darabonba::Model {
public:
  shared_ptr<ListEventsViewResponseBodyEventsExtendedPropertiesSharedProperties> sharedProperties{};

  ListEventsViewResponseBodyEventsExtendedProperties() {}

  explicit ListEventsViewResponseBodyEventsExtendedProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sharedProperties) {
      res["SharedProperties"] = sharedProperties ? boost::any(sharedProperties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SharedProperties") != m.end() && !m["SharedProperties"].empty()) {
      if (typeid(map<string, boost::any>) == m["SharedProperties"].type()) {
        ListEventsViewResponseBodyEventsExtendedPropertiesSharedProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SharedProperties"]));
        sharedProperties = make_shared<ListEventsViewResponseBodyEventsExtendedPropertiesSharedProperties>(model1);
      }
    }
  }


  virtual ~ListEventsViewResponseBodyEventsExtendedProperties() = default;
};
class ListEventsViewResponseBodyEventsLocation : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<vector<string>> meetingRooms{};

  ListEventsViewResponseBodyEventsLocation() {}

  explicit ListEventsViewResponseBodyEventsLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (meetingRooms) {
      res["MeetingRooms"] = boost::any(*meetingRooms);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("MeetingRooms") != m.end() && !m["MeetingRooms"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MeetingRooms"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MeetingRooms"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      meetingRooms = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListEventsViewResponseBodyEventsLocation() = default;
};
class ListEventsViewResponseBodyEventsMeetingRooms : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> responseStatus{};
  shared_ptr<string> roomId{};

  ListEventsViewResponseBodyEventsMeetingRooms() {}

  explicit ListEventsViewResponseBodyEventsMeetingRooms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
  }


  virtual ~ListEventsViewResponseBodyEventsMeetingRooms() = default;
};
class ListEventsViewResponseBodyEventsOnlineMeetingInfo : public Darabonba::Model {
public:
  shared_ptr<string> conferenceId{};
  shared_ptr<map<string, boost::any>> extraInfo{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  ListEventsViewResponseBodyEventsOnlineMeetingInfo() {}

  explicit ListEventsViewResponseBodyEventsOnlineMeetingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conferenceId) {
      res["ConferenceId"] = boost::any(*conferenceId);
    }
    if (extraInfo) {
      res["ExtraInfo"] = boost::any(*extraInfo);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConferenceId") != m.end() && !m["ConferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["ConferenceId"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ListEventsViewResponseBodyEventsOnlineMeetingInfo() = default;
};
class ListEventsViewResponseBodyEventsOrganizer : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> id{};
  shared_ptr<string> responseStatus{};
  shared_ptr<bool> self{};

  ListEventsViewResponseBodyEventsOrganizer() {}

  explicit ListEventsViewResponseBodyEventsOrganizer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (self) {
      res["Self"] = boost::any(*self);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("Self") != m.end() && !m["Self"].empty()) {
      self = make_shared<bool>(boost::any_cast<bool>(m["Self"]));
    }
  }


  virtual ~ListEventsViewResponseBodyEventsOrganizer() = default;
};
class ListEventsViewResponseBodyEventsOriginStart : public Darabonba::Model {
public:
  shared_ptr<string> dateTime{};

  ListEventsViewResponseBodyEventsOriginStart() {}

  explicit ListEventsViewResponseBodyEventsOriginStart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
  }


  virtual ~ListEventsViewResponseBodyEventsOriginStart() = default;
};
class ListEventsViewResponseBodyEventsRecurrencePattern : public Darabonba::Model {
public:
  shared_ptr<long> dayOfMonth{};
  shared_ptr<string> daysOfWeek{};
  shared_ptr<string> index{};
  shared_ptr<long> interval{};
  shared_ptr<string> type{};

  ListEventsViewResponseBodyEventsRecurrencePattern() {}

  explicit ListEventsViewResponseBodyEventsRecurrencePattern(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dayOfMonth) {
      res["DayOfMonth"] = boost::any(*dayOfMonth);
    }
    if (daysOfWeek) {
      res["DaysOfWeek"] = boost::any(*daysOfWeek);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DayOfMonth") != m.end() && !m["DayOfMonth"].empty()) {
      dayOfMonth = make_shared<long>(boost::any_cast<long>(m["DayOfMonth"]));
    }
    if (m.find("DaysOfWeek") != m.end() && !m["DaysOfWeek"].empty()) {
      daysOfWeek = make_shared<string>(boost::any_cast<string>(m["DaysOfWeek"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListEventsViewResponseBodyEventsRecurrencePattern() = default;
};
class ListEventsViewResponseBodyEventsRecurrenceRange : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<long> numberOfOccurrences{};
  shared_ptr<string> type{};

  ListEventsViewResponseBodyEventsRecurrenceRange() {}

  explicit ListEventsViewResponseBodyEventsRecurrenceRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (numberOfOccurrences) {
      res["NumberOfOccurrences"] = boost::any(*numberOfOccurrences);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("NumberOfOccurrences") != m.end() && !m["NumberOfOccurrences"].empty()) {
      numberOfOccurrences = make_shared<long>(boost::any_cast<long>(m["NumberOfOccurrences"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListEventsViewResponseBodyEventsRecurrenceRange() = default;
};
class ListEventsViewResponseBodyEventsRecurrence : public Darabonba::Model {
public:
  shared_ptr<ListEventsViewResponseBodyEventsRecurrencePattern> pattern{};
  shared_ptr<ListEventsViewResponseBodyEventsRecurrenceRange> range{};

  ListEventsViewResponseBodyEventsRecurrence() {}

  explicit ListEventsViewResponseBodyEventsRecurrence(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pattern) {
      res["Pattern"] = pattern ? boost::any(pattern->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (range) {
      res["Range"] = range ? boost::any(range->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pattern"].type()) {
        ListEventsViewResponseBodyEventsRecurrencePattern model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pattern"]));
        pattern = make_shared<ListEventsViewResponseBodyEventsRecurrencePattern>(model1);
      }
    }
    if (m.find("Range") != m.end() && !m["Range"].empty()) {
      if (typeid(map<string, boost::any>) == m["Range"].type()) {
        ListEventsViewResponseBodyEventsRecurrenceRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Range"]));
        range = make_shared<ListEventsViewResponseBodyEventsRecurrenceRange>(model1);
      }
    }
  }


  virtual ~ListEventsViewResponseBodyEventsRecurrence() = default;
};
class ListEventsViewResponseBodyEventsRichTextDescription : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  ListEventsViewResponseBodyEventsRichTextDescription() {}

  explicit ListEventsViewResponseBodyEventsRichTextDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~ListEventsViewResponseBodyEventsRichTextDescription() = default;
};
class ListEventsViewResponseBodyEventsStart : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  ListEventsViewResponseBodyEventsStart() {}

  explicit ListEventsViewResponseBodyEventsStart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~ListEventsViewResponseBodyEventsStart() = default;
};
class ListEventsViewResponseBodyEvents : public Darabonba::Model {
public:
  shared_ptr<vector<ListEventsViewResponseBodyEventsAttendees>> attendees{};
  shared_ptr<vector<ListEventsViewResponseBodyEventsCategories>> categories{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<ListEventsViewResponseBodyEventsEnd> end{};
  shared_ptr<ListEventsViewResponseBodyEventsExtendedProperties> extendedProperties{};
  shared_ptr<string> id{};
  shared_ptr<bool> isAllDay{};
  shared_ptr<ListEventsViewResponseBodyEventsLocation> location{};
  shared_ptr<vector<ListEventsViewResponseBodyEventsMeetingRooms>> meetingRooms{};
  shared_ptr<ListEventsViewResponseBodyEventsOnlineMeetingInfo> onlineMeetingInfo{};
  shared_ptr<ListEventsViewResponseBodyEventsOrganizer> organizer{};
  shared_ptr<ListEventsViewResponseBodyEventsOriginStart> originStart{};
  shared_ptr<ListEventsViewResponseBodyEventsRecurrence> recurrence{};
  shared_ptr<ListEventsViewResponseBodyEventsRichTextDescription> richTextDescription{};
  shared_ptr<string> seriesMasterId{};
  shared_ptr<ListEventsViewResponseBodyEventsStart> start{};
  shared_ptr<string> status{};
  shared_ptr<string> summary{};
  shared_ptr<string> updateTime{};

  ListEventsViewResponseBodyEvents() {}

  explicit ListEventsViewResponseBodyEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendees) {
      vector<boost::any> temp1;
      for(auto item1:*attendees){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attendees"] = boost::any(temp1);
    }
    if (categories) {
      vector<boost::any> temp1;
      for(auto item1:*categories){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Categories"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (end) {
      res["End"] = end ? boost::any(end->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extendedProperties) {
      res["ExtendedProperties"] = extendedProperties ? boost::any(extendedProperties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isAllDay) {
      res["IsAllDay"] = boost::any(*isAllDay);
    }
    if (location) {
      res["Location"] = location ? boost::any(location->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (meetingRooms) {
      vector<boost::any> temp1;
      for(auto item1:*meetingRooms){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MeetingRooms"] = boost::any(temp1);
    }
    if (onlineMeetingInfo) {
      res["OnlineMeetingInfo"] = onlineMeetingInfo ? boost::any(onlineMeetingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (organizer) {
      res["Organizer"] = organizer ? boost::any(organizer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (originStart) {
      res["OriginStart"] = originStart ? boost::any(originStart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recurrence) {
      res["Recurrence"] = recurrence ? boost::any(recurrence->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (richTextDescription) {
      res["RichTextDescription"] = richTextDescription ? boost::any(richTextDescription->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (seriesMasterId) {
      res["SeriesMasterId"] = boost::any(*seriesMasterId);
    }
    if (start) {
      res["Start"] = start ? boost::any(start->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attendees") != m.end() && !m["Attendees"].empty()) {
      if (typeid(vector<boost::any>) == m["Attendees"].type()) {
        vector<ListEventsViewResponseBodyEventsAttendees> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attendees"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEventsViewResponseBodyEventsAttendees model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attendees = make_shared<vector<ListEventsViewResponseBodyEventsAttendees>>(expect1);
      }
    }
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<ListEventsViewResponseBodyEventsCategories> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Categories"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEventsViewResponseBodyEventsCategories model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        categories = make_shared<vector<ListEventsViewResponseBodyEventsCategories>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      if (typeid(map<string, boost::any>) == m["End"].type()) {
        ListEventsViewResponseBodyEventsEnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["End"]));
        end = make_shared<ListEventsViewResponseBodyEventsEnd>(model1);
      }
    }
    if (m.find("ExtendedProperties") != m.end() && !m["ExtendedProperties"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtendedProperties"].type()) {
        ListEventsViewResponseBodyEventsExtendedProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtendedProperties"]));
        extendedProperties = make_shared<ListEventsViewResponseBodyEventsExtendedProperties>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IsAllDay") != m.end() && !m["IsAllDay"].empty()) {
      isAllDay = make_shared<bool>(boost::any_cast<bool>(m["IsAllDay"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      if (typeid(map<string, boost::any>) == m["Location"].type()) {
        ListEventsViewResponseBodyEventsLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Location"]));
        location = make_shared<ListEventsViewResponseBodyEventsLocation>(model1);
      }
    }
    if (m.find("MeetingRooms") != m.end() && !m["MeetingRooms"].empty()) {
      if (typeid(vector<boost::any>) == m["MeetingRooms"].type()) {
        vector<ListEventsViewResponseBodyEventsMeetingRooms> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MeetingRooms"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEventsViewResponseBodyEventsMeetingRooms model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        meetingRooms = make_shared<vector<ListEventsViewResponseBodyEventsMeetingRooms>>(expect1);
      }
    }
    if (m.find("OnlineMeetingInfo") != m.end() && !m["OnlineMeetingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["OnlineMeetingInfo"].type()) {
        ListEventsViewResponseBodyEventsOnlineMeetingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OnlineMeetingInfo"]));
        onlineMeetingInfo = make_shared<ListEventsViewResponseBodyEventsOnlineMeetingInfo>(model1);
      }
    }
    if (m.find("Organizer") != m.end() && !m["Organizer"].empty()) {
      if (typeid(map<string, boost::any>) == m["Organizer"].type()) {
        ListEventsViewResponseBodyEventsOrganizer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Organizer"]));
        organizer = make_shared<ListEventsViewResponseBodyEventsOrganizer>(model1);
      }
    }
    if (m.find("OriginStart") != m.end() && !m["OriginStart"].empty()) {
      if (typeid(map<string, boost::any>) == m["OriginStart"].type()) {
        ListEventsViewResponseBodyEventsOriginStart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OriginStart"]));
        originStart = make_shared<ListEventsViewResponseBodyEventsOriginStart>(model1);
      }
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      if (typeid(map<string, boost::any>) == m["Recurrence"].type()) {
        ListEventsViewResponseBodyEventsRecurrence model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Recurrence"]));
        recurrence = make_shared<ListEventsViewResponseBodyEventsRecurrence>(model1);
      }
    }
    if (m.find("RichTextDescription") != m.end() && !m["RichTextDescription"].empty()) {
      if (typeid(map<string, boost::any>) == m["RichTextDescription"].type()) {
        ListEventsViewResponseBodyEventsRichTextDescription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RichTextDescription"]));
        richTextDescription = make_shared<ListEventsViewResponseBodyEventsRichTextDescription>(model1);
      }
    }
    if (m.find("SeriesMasterId") != m.end() && !m["SeriesMasterId"].empty()) {
      seriesMasterId = make_shared<string>(boost::any_cast<string>(m["SeriesMasterId"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      if (typeid(map<string, boost::any>) == m["Start"].type()) {
        ListEventsViewResponseBodyEventsStart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Start"]));
        start = make_shared<ListEventsViewResponseBodyEventsStart>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~ListEventsViewResponseBodyEvents() = default;
};
class ListEventsViewResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListEventsViewResponseBodyEvents>> events{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  ListEventsViewResponseBody() {}

  explicit ListEventsViewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (events) {
      vector<boost::any> temp1;
      for(auto item1:*events){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["events"] = boost::any(temp1);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("events") != m.end() && !m["events"].empty()) {
      if (typeid(vector<boost::any>) == m["events"].type()) {
        vector<ListEventsViewResponseBodyEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["events"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEventsViewResponseBodyEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        events = make_shared<vector<ListEventsViewResponseBodyEvents>>(expect1);
      }
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListEventsViewResponseBody() = default;
};
class ListEventsViewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEventsViewResponseBody> body{};

  ListEventsViewResponse() {}

  explicit ListEventsViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEventsViewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEventsViewResponseBody>(model1);
      }
    }
  }


  virtual ~ListEventsViewResponse() = default;
};
class ListFormRemarksHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListFormRemarksHeadersAccountContext() {}

  explicit ListFormRemarksHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListFormRemarksHeadersAccountContext() = default;
};
class ListFormRemarksHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ListFormRemarksHeadersAccountContext> accountContext{};

  ListFormRemarksHeaders() {}

  explicit ListFormRemarksHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ListFormRemarksHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ListFormRemarksHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ListFormRemarksHeaders() = default;
};
class ListFormRemarksShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ListFormRemarksShrinkHeaders() {}

  explicit ListFormRemarksShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ListFormRemarksShrinkHeaders() = default;
};
class ListFormRemarksRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<vector<string>> formInstanceIdList{};
  shared_ptr<string> formUuid{};
  shared_ptr<string> systemToken{};

  ListFormRemarksRequest() {}

  explicit ListFormRemarksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (formInstanceIdList) {
      res["FormInstanceIdList"] = boost::any(*formInstanceIdList);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("FormInstanceIdList") != m.end() && !m["FormInstanceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FormInstanceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FormInstanceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      formInstanceIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~ListFormRemarksRequest() = default;
};
class ListFormRemarksShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> formInstanceIdListShrink{};
  shared_ptr<string> formUuid{};
  shared_ptr<string> systemToken{};

  ListFormRemarksShrinkRequest() {}

  explicit ListFormRemarksShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (formInstanceIdListShrink) {
      res["FormInstanceIdList"] = boost::any(*formInstanceIdListShrink);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("FormInstanceIdList") != m.end() && !m["FormInstanceIdList"].empty()) {
      formInstanceIdListShrink = make_shared<string>(boost::any_cast<string>(m["FormInstanceIdList"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~ListFormRemarksShrinkRequest() = default;
};
class ListFormRemarksResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> formRemarkVoMap{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  ListFormRemarksResponseBody() {}

  explicit ListFormRemarksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (formRemarkVoMap) {
      res["formRemarkVoMap"] = boost::any(*formRemarkVoMap);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("formRemarkVoMap") != m.end() && !m["formRemarkVoMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["formRemarkVoMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      formRemarkVoMap = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~ListFormRemarksResponseBody() = default;
};
class ListFormRemarksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFormRemarksResponseBody> body{};

  ListFormRemarksResponse() {}

  explicit ListFormRemarksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFormRemarksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFormRemarksResponseBody>(model1);
      }
    }
  }


  virtual ~ListFormRemarksResponse() = default;
};
class ListMessageHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountId{};

  ListMessageHeaders() {}

  explicit ListMessageHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListMessageHeaders() = default;
};
class ListMessageRequest : public Darabonba::Model {
public:
  shared_ptr<string> assistantId{};
  shared_ptr<long> limit{};
  shared_ptr<string> order{};
  shared_ptr<string> originalAssistantId{};
  shared_ptr<string> runId{};
  shared_ptr<string> sourceIdOfOriginalAssistantId{};
  shared_ptr<string> sourceTypeOfOriginalAssistantId{};
  shared_ptr<string> threadId{};

  ListMessageRequest() {}

  explicit ListMessageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assistantId) {
      res["assistantId"] = boost::any(*assistantId);
    }
    if (limit) {
      res["limit"] = boost::any(*limit);
    }
    if (order) {
      res["order"] = boost::any(*order);
    }
    if (originalAssistantId) {
      res["originalAssistantId"] = boost::any(*originalAssistantId);
    }
    if (runId) {
      res["runId"] = boost::any(*runId);
    }
    if (sourceIdOfOriginalAssistantId) {
      res["sourceIdOfOriginalAssistantId"] = boost::any(*sourceIdOfOriginalAssistantId);
    }
    if (sourceTypeOfOriginalAssistantId) {
      res["sourceTypeOfOriginalAssistantId"] = boost::any(*sourceTypeOfOriginalAssistantId);
    }
    if (threadId) {
      res["threadId"] = boost::any(*threadId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assistantId") != m.end() && !m["assistantId"].empty()) {
      assistantId = make_shared<string>(boost::any_cast<string>(m["assistantId"]));
    }
    if (m.find("limit") != m.end() && !m["limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["limit"]));
    }
    if (m.find("order") != m.end() && !m["order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["order"]));
    }
    if (m.find("originalAssistantId") != m.end() && !m["originalAssistantId"].empty()) {
      originalAssistantId = make_shared<string>(boost::any_cast<string>(m["originalAssistantId"]));
    }
    if (m.find("runId") != m.end() && !m["runId"].empty()) {
      runId = make_shared<string>(boost::any_cast<string>(m["runId"]));
    }
    if (m.find("sourceIdOfOriginalAssistantId") != m.end() && !m["sourceIdOfOriginalAssistantId"].empty()) {
      sourceIdOfOriginalAssistantId = make_shared<string>(boost::any_cast<string>(m["sourceIdOfOriginalAssistantId"]));
    }
    if (m.find("sourceTypeOfOriginalAssistantId") != m.end() && !m["sourceTypeOfOriginalAssistantId"].empty()) {
      sourceTypeOfOriginalAssistantId = make_shared<string>(boost::any_cast<string>(m["sourceTypeOfOriginalAssistantId"]));
    }
    if (m.find("threadId") != m.end() && !m["threadId"].empty()) {
      threadId = make_shared<string>(boost::any_cast<string>(m["threadId"]));
    }
  }


  virtual ~ListMessageRequest() = default;
};
class ListMessageResponseBodyMessagesContentCardCallback : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> relatedMessageId{};

  ListMessageResponseBodyMessagesContentCardCallback() {}

  explicit ListMessageResponseBodyMessagesContentCardCallback(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (relatedMessageId) {
      res["relatedMessageId"] = boost::any(*relatedMessageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("relatedMessageId") != m.end() && !m["relatedMessageId"].empty()) {
      relatedMessageId = make_shared<string>(boost::any_cast<string>(m["relatedMessageId"]));
    }
  }


  virtual ~ListMessageResponseBodyMessagesContentCardCallback() = default;
};
class ListMessageResponseBodyMessagesContentDingCard : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentType{};
  shared_ptr<bool> finished{};
  shared_ptr<string> templateId{};

  ListMessageResponseBodyMessagesContentDingCard() {}

  explicit ListMessageResponseBodyMessagesContentDingCard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (contentType) {
      res["contentType"] = boost::any(*contentType);
    }
    if (finished) {
      res["finished"] = boost::any(*finished);
    }
    if (templateId) {
      res["templateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("contentType") != m.end() && !m["contentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["contentType"]));
    }
    if (m.find("finished") != m.end() && !m["finished"].empty()) {
      finished = make_shared<bool>(boost::any_cast<bool>(m["finished"]));
    }
    if (m.find("templateId") != m.end() && !m["templateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["templateId"]));
    }
  }


  virtual ~ListMessageResponseBodyMessagesContentDingCard() = default;
};
class ListMessageResponseBodyMessagesContentDingNormalCardCardData : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> cardParamMap{};

  ListMessageResponseBodyMessagesContentDingNormalCardCardData() {}

  explicit ListMessageResponseBodyMessagesContentDingNormalCardCardData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardParamMap) {
      res["cardParamMap"] = boost::any(*cardParamMap);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cardParamMap") != m.end() && !m["cardParamMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["cardParamMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      cardParamMap = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~ListMessageResponseBodyMessagesContentDingNormalCardCardData() = default;
};
class ListMessageResponseBodyMessagesContentDingNormalCardCardUpdateOptions : public Darabonba::Model {
public:
  shared_ptr<bool> updateCardDataByKey{};
  shared_ptr<bool> updatePrivateDataByKey{};

  ListMessageResponseBodyMessagesContentDingNormalCardCardUpdateOptions() {}

  explicit ListMessageResponseBodyMessagesContentDingNormalCardCardUpdateOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateCardDataByKey) {
      res["updateCardDataByKey"] = boost::any(*updateCardDataByKey);
    }
    if (updatePrivateDataByKey) {
      res["updatePrivateDataByKey"] = boost::any(*updatePrivateDataByKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("updateCardDataByKey") != m.end() && !m["updateCardDataByKey"].empty()) {
      updateCardDataByKey = make_shared<bool>(boost::any_cast<bool>(m["updateCardDataByKey"]));
    }
    if (m.find("updatePrivateDataByKey") != m.end() && !m["updatePrivateDataByKey"].empty()) {
      updatePrivateDataByKey = make_shared<bool>(boost::any_cast<bool>(m["updatePrivateDataByKey"]));
    }
  }


  virtual ~ListMessageResponseBodyMessagesContentDingNormalCardCardUpdateOptions() = default;
};
class ListMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig : public Darabonba::Model {
public:
  shared_ptr<long> interval{};
  shared_ptr<string> pullStrategy{};
  shared_ptr<string> timeUnit{};

  ListMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig() {}

  explicit ListMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interval) {
      res["interval"] = boost::any(*interval);
    }
    if (pullStrategy) {
      res["pullStrategy"] = boost::any(*pullStrategy);
    }
    if (timeUnit) {
      res["timeUnit"] = boost::any(*timeUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("interval") != m.end() && !m["interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["interval"]));
    }
    if (m.find("pullStrategy") != m.end() && !m["pullStrategy"].empty()) {
      pullStrategy = make_shared<string>(boost::any_cast<string>(m["pullStrategy"]));
    }
    if (m.find("timeUnit") != m.end() && !m["timeUnit"].empty()) {
      timeUnit = make_shared<string>(boost::any_cast<string>(m["timeUnit"]));
    }
  }


  virtual ~ListMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig() = default;
};
class ListMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> constParams{};
  shared_ptr<string> dynamicDataSourceId{};
  shared_ptr<ListMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig> pullConfig{};

  ListMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs() {}

  explicit ListMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constParams) {
      res["constParams"] = boost::any(*constParams);
    }
    if (dynamicDataSourceId) {
      res["dynamicDataSourceId"] = boost::any(*dynamicDataSourceId);
    }
    if (pullConfig) {
      res["pullConfig"] = pullConfig ? boost::any(pullConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("constParams") != m.end() && !m["constParams"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["constParams"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      constParams = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("dynamicDataSourceId") != m.end() && !m["dynamicDataSourceId"].empty()) {
      dynamicDataSourceId = make_shared<string>(boost::any_cast<string>(m["dynamicDataSourceId"]));
    }
    if (m.find("pullConfig") != m.end() && !m["pullConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["pullConfig"].type()) {
        ListMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["pullConfig"]));
        pullConfig = make_shared<ListMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigsPullConfig>(model1);
      }
    }
  }


  virtual ~ListMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs() = default;
};
class ListMessageResponseBodyMessagesContentDingNormalCard : public Darabonba::Model {
public:
  shared_ptr<ListMessageResponseBodyMessagesContentDingNormalCardCardData> cardData{};
  shared_ptr<string> cardTemplateId{};
  shared_ptr<ListMessageResponseBodyMessagesContentDingNormalCardCardUpdateOptions> cardUpdateOptions{};
  shared_ptr<vector<ListMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs>> dynamicDataSourceConfigs{};
  shared_ptr<map<string, map<string, boost::any>>> privateData{};

  ListMessageResponseBodyMessagesContentDingNormalCard() {}

  explicit ListMessageResponseBodyMessagesContentDingNormalCard(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardData) {
      res["cardData"] = cardData ? boost::any(cardData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cardTemplateId) {
      res["cardTemplateId"] = boost::any(*cardTemplateId);
    }
    if (cardUpdateOptions) {
      res["cardUpdateOptions"] = cardUpdateOptions ? boost::any(cardUpdateOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dynamicDataSourceConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*dynamicDataSourceConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dynamicDataSourceConfigs"] = boost::any(temp1);
    }
    if (privateData) {
      res["privateData"] = boost::any(*privateData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cardData") != m.end() && !m["cardData"].empty()) {
      if (typeid(map<string, boost::any>) == m["cardData"].type()) {
        ListMessageResponseBodyMessagesContentDingNormalCardCardData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cardData"]));
        cardData = make_shared<ListMessageResponseBodyMessagesContentDingNormalCardCardData>(model1);
      }
    }
    if (m.find("cardTemplateId") != m.end() && !m["cardTemplateId"].empty()) {
      cardTemplateId = make_shared<string>(boost::any_cast<string>(m["cardTemplateId"]));
    }
    if (m.find("cardUpdateOptions") != m.end() && !m["cardUpdateOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["cardUpdateOptions"].type()) {
        ListMessageResponseBodyMessagesContentDingNormalCardCardUpdateOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cardUpdateOptions"]));
        cardUpdateOptions = make_shared<ListMessageResponseBodyMessagesContentDingNormalCardCardUpdateOptions>(model1);
      }
    }
    if (m.find("dynamicDataSourceConfigs") != m.end() && !m["dynamicDataSourceConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["dynamicDataSourceConfigs"].type()) {
        vector<ListMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dynamicDataSourceConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dynamicDataSourceConfigs = make_shared<vector<ListMessageResponseBodyMessagesContentDingNormalCardDynamicDataSourceConfigs>>(expect1);
      }
    }
    if (m.find("privateData") != m.end() && !m["privateData"].empty()) {
      map<string, map<string, boost::any>> map1 = boost::any_cast<map<string, map<string, boost::any>>>(m["privateData"]);
      map<string, map<string, boost::any>> toMap1;
      for (auto item:map1) {
        map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item.second);
        map<string, boost::any> toMap2;
        for (auto item:map2) {
           toMap2[item.first] = item.second;
        }
         toMap1[item.first] = toMap2;
      }
      privateData = make_shared<map<string, map<string, boost::any>>>(toMap1);
    }
  }


  virtual ~ListMessageResponseBodyMessagesContentDingNormalCard() = default;
};
class ListMessageResponseBodyMessagesContentMarkdown : public Darabonba::Model {
public:
  shared_ptr<string> value{};

  ListMessageResponseBodyMessagesContentMarkdown() {}

  explicit ListMessageResponseBodyMessagesContentMarkdown(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~ListMessageResponseBodyMessagesContentMarkdown() = default;
};
class ListMessageResponseBodyMessagesContentStructViewPartsDataPart : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};

  ListMessageResponseBodyMessagesContentStructViewPartsDataPart() {}

  explicit ListMessageResponseBodyMessagesContentStructViewPartsDataPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["data"]));
    }
  }


  virtual ~ListMessageResponseBodyMessagesContentStructViewPartsDataPart() = default;
};
class ListMessageResponseBodyMessagesContentStructViewPartsReasonPart : public Darabonba::Model {
public:
  shared_ptr<string> reason{};

  ListMessageResponseBodyMessagesContentStructViewPartsReasonPart() {}

  explicit ListMessageResponseBodyMessagesContentStructViewPartsReasonPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reason) {
      res["reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("reason") != m.end() && !m["reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["reason"]));
    }
  }


  virtual ~ListMessageResponseBodyMessagesContentStructViewPartsReasonPart() = default;
};
class ListMessageResponseBodyMessagesContentStructViewPartsRecommendPartRecommends : public Darabonba::Model {
public:
  shared_ptr<string> mobileUrl{};
  shared_ptr<string> text{};
  shared_ptr<string> url{};

  ListMessageResponseBodyMessagesContentStructViewPartsRecommendPartRecommends() {}

  explicit ListMessageResponseBodyMessagesContentStructViewPartsRecommendPartRecommends(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mobileUrl) {
      res["mobileUrl"] = boost::any(*mobileUrl);
    }
    if (text) {
      res["text"] = boost::any(*text);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("mobileUrl") != m.end() && !m["mobileUrl"].empty()) {
      mobileUrl = make_shared<string>(boost::any_cast<string>(m["mobileUrl"]));
    }
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~ListMessageResponseBodyMessagesContentStructViewPartsRecommendPartRecommends() = default;
};
class ListMessageResponseBodyMessagesContentStructViewPartsRecommendPart : public Darabonba::Model {
public:
  shared_ptr<vector<ListMessageResponseBodyMessagesContentStructViewPartsRecommendPartRecommends>> recommends{};

  ListMessageResponseBodyMessagesContentStructViewPartsRecommendPart() {}

  explicit ListMessageResponseBodyMessagesContentStructViewPartsRecommendPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommends) {
      vector<boost::any> temp1;
      for(auto item1:*recommends){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["recommends"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("recommends") != m.end() && !m["recommends"].empty()) {
      if (typeid(vector<boost::any>) == m["recommends"].type()) {
        vector<ListMessageResponseBodyMessagesContentStructViewPartsRecommendPartRecommends> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["recommends"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMessageResponseBodyMessagesContentStructViewPartsRecommendPartRecommends model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recommends = make_shared<vector<ListMessageResponseBodyMessagesContentStructViewPartsRecommendPartRecommends>>(expect1);
      }
    }
  }


  virtual ~ListMessageResponseBodyMessagesContentStructViewPartsRecommendPart() = default;
};
class ListMessageResponseBodyMessagesContentStructViewPartsReferencePartReferences : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceCode{};
  shared_ptr<string> sourceIcon{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  ListMessageResponseBodyMessagesContentStructViewPartsReferencePartReferences() {}

  explicit ListMessageResponseBodyMessagesContentStructViewPartsReferencePartReferences(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceCode) {
      res["sourceCode"] = boost::any(*sourceCode);
    }
    if (sourceIcon) {
      res["sourceIcon"] = boost::any(*sourceIcon);
    }
    if (summary) {
      res["summary"] = boost::any(*summary);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceCode") != m.end() && !m["sourceCode"].empty()) {
      sourceCode = make_shared<string>(boost::any_cast<string>(m["sourceCode"]));
    }
    if (m.find("sourceIcon") != m.end() && !m["sourceIcon"].empty()) {
      sourceIcon = make_shared<string>(boost::any_cast<string>(m["sourceIcon"]));
    }
    if (m.find("summary") != m.end() && !m["summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["summary"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~ListMessageResponseBodyMessagesContentStructViewPartsReferencePartReferences() = default;
};
class ListMessageResponseBodyMessagesContentStructViewPartsReferencePart : public Darabonba::Model {
public:
  shared_ptr<vector<ListMessageResponseBodyMessagesContentStructViewPartsReferencePartReferences>> references{};

  ListMessageResponseBodyMessagesContentStructViewPartsReferencePart() {}

  explicit ListMessageResponseBodyMessagesContentStructViewPartsReferencePart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (references) {
      vector<boost::any> temp1;
      for(auto item1:*references){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["references"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("references") != m.end() && !m["references"].empty()) {
      if (typeid(vector<boost::any>) == m["references"].type()) {
        vector<ListMessageResponseBodyMessagesContentStructViewPartsReferencePartReferences> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["references"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMessageResponseBodyMessagesContentStructViewPartsReferencePartReferences model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        references = make_shared<vector<ListMessageResponseBodyMessagesContentStructViewPartsReferencePartReferences>>(expect1);
      }
    }
  }


  virtual ~ListMessageResponseBodyMessagesContentStructViewPartsReferencePart() = default;
};
class ListMessageResponseBodyMessagesContentStructViewPartsTextPart : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  ListMessageResponseBodyMessagesContentStructViewPartsTextPart() {}

  explicit ListMessageResponseBodyMessagesContentStructViewPartsTextPart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("text") != m.end() && !m["text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["text"]));
    }
  }


  virtual ~ListMessageResponseBodyMessagesContentStructViewPartsTextPart() = default;
};
class ListMessageResponseBodyMessagesContentStructViewParts : public Darabonba::Model {
public:
  shared_ptr<bool> append{};
  shared_ptr<ListMessageResponseBodyMessagesContentStructViewPartsDataPart> dataPart{};
  shared_ptr<bool> finish{};
  shared_ptr<string> partDesc{};
  shared_ptr<string> partId{};
  shared_ptr<ListMessageResponseBodyMessagesContentStructViewPartsReasonPart> reasonPart{};
  shared_ptr<ListMessageResponseBodyMessagesContentStructViewPartsRecommendPart> recommendPart{};
  shared_ptr<ListMessageResponseBodyMessagesContentStructViewPartsReferencePart> referencePart{};
  shared_ptr<ListMessageResponseBodyMessagesContentStructViewPartsTextPart> textPart{};
  shared_ptr<string> type{};

  ListMessageResponseBodyMessagesContentStructViewParts() {}

  explicit ListMessageResponseBodyMessagesContentStructViewParts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (append) {
      res["append"] = boost::any(*append);
    }
    if (dataPart) {
      res["dataPart"] = dataPart ? boost::any(dataPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (finish) {
      res["finish"] = boost::any(*finish);
    }
    if (partDesc) {
      res["partDesc"] = boost::any(*partDesc);
    }
    if (partId) {
      res["partId"] = boost::any(*partId);
    }
    if (reasonPart) {
      res["reasonPart"] = reasonPart ? boost::any(reasonPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recommendPart) {
      res["recommendPart"] = recommendPart ? boost::any(recommendPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (referencePart) {
      res["referencePart"] = referencePart ? boost::any(referencePart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (textPart) {
      res["textPart"] = textPart ? boost::any(textPart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("append") != m.end() && !m["append"].empty()) {
      append = make_shared<bool>(boost::any_cast<bool>(m["append"]));
    }
    if (m.find("dataPart") != m.end() && !m["dataPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["dataPart"].type()) {
        ListMessageResponseBodyMessagesContentStructViewPartsDataPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dataPart"]));
        dataPart = make_shared<ListMessageResponseBodyMessagesContentStructViewPartsDataPart>(model1);
      }
    }
    if (m.find("finish") != m.end() && !m["finish"].empty()) {
      finish = make_shared<bool>(boost::any_cast<bool>(m["finish"]));
    }
    if (m.find("partDesc") != m.end() && !m["partDesc"].empty()) {
      partDesc = make_shared<string>(boost::any_cast<string>(m["partDesc"]));
    }
    if (m.find("partId") != m.end() && !m["partId"].empty()) {
      partId = make_shared<string>(boost::any_cast<string>(m["partId"]));
    }
    if (m.find("reasonPart") != m.end() && !m["reasonPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["reasonPart"].type()) {
        ListMessageResponseBodyMessagesContentStructViewPartsReasonPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["reasonPart"]));
        reasonPart = make_shared<ListMessageResponseBodyMessagesContentStructViewPartsReasonPart>(model1);
      }
    }
    if (m.find("recommendPart") != m.end() && !m["recommendPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["recommendPart"].type()) {
        ListMessageResponseBodyMessagesContentStructViewPartsRecommendPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["recommendPart"]));
        recommendPart = make_shared<ListMessageResponseBodyMessagesContentStructViewPartsRecommendPart>(model1);
      }
    }
    if (m.find("referencePart") != m.end() && !m["referencePart"].empty()) {
      if (typeid(map<string, boost::any>) == m["referencePart"].type()) {
        ListMessageResponseBodyMessagesContentStructViewPartsReferencePart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["referencePart"]));
        referencePart = make_shared<ListMessageResponseBodyMessagesContentStructViewPartsReferencePart>(model1);
      }
    }
    if (m.find("textPart") != m.end() && !m["textPart"].empty()) {
      if (typeid(map<string, boost::any>) == m["textPart"].type()) {
        ListMessageResponseBodyMessagesContentStructViewPartsTextPart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["textPart"]));
        textPart = make_shared<ListMessageResponseBodyMessagesContentStructViewPartsTextPart>(model1);
      }
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ListMessageResponseBodyMessagesContentStructViewParts() = default;
};
class ListMessageResponseBodyMessagesContentStructView : public Darabonba::Model {
public:
  shared_ptr<vector<ListMessageResponseBodyMessagesContentStructViewParts>> parts{};

  ListMessageResponseBodyMessagesContentStructView() {}

  explicit ListMessageResponseBodyMessagesContentStructView(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parts) {
      vector<boost::any> temp1;
      for(auto item1:*parts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["parts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("parts") != m.end() && !m["parts"].empty()) {
      if (typeid(vector<boost::any>) == m["parts"].type()) {
        vector<ListMessageResponseBodyMessagesContentStructViewParts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["parts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMessageResponseBodyMessagesContentStructViewParts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parts = make_shared<vector<ListMessageResponseBodyMessagesContentStructViewParts>>(expect1);
      }
    }
  }


  virtual ~ListMessageResponseBodyMessagesContentStructView() = default;
};
class ListMessageResponseBodyMessagesContentText : public Darabonba::Model {
public:
  shared_ptr<string> value{};

  ListMessageResponseBodyMessagesContentText() {}

  explicit ListMessageResponseBodyMessagesContentText(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~ListMessageResponseBodyMessagesContentText() = default;
};
class ListMessageResponseBodyMessagesContent : public Darabonba::Model {
public:
  shared_ptr<ListMessageResponseBodyMessagesContentCardCallback> cardCallback{};
  shared_ptr<ListMessageResponseBodyMessagesContentDingCard> dingCard{};
  shared_ptr<ListMessageResponseBodyMessagesContentDingNormalCard> dingNormalCard{};
  shared_ptr<ListMessageResponseBodyMessagesContentMarkdown> markdown{};
  shared_ptr<ListMessageResponseBodyMessagesContentStructView> structView{};
  shared_ptr<ListMessageResponseBodyMessagesContentText> text{};
  shared_ptr<string> type{};

  ListMessageResponseBodyMessagesContent() {}

  explicit ListMessageResponseBodyMessagesContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cardCallback) {
      res["cardCallback"] = cardCallback ? boost::any(cardCallback->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dingCard) {
      res["dingCard"] = dingCard ? boost::any(dingCard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dingNormalCard) {
      res["dingNormalCard"] = dingNormalCard ? boost::any(dingNormalCard->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (markdown) {
      res["markdown"] = markdown ? boost::any(markdown->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (structView) {
      res["structView"] = structView ? boost::any(structView->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (text) {
      res["text"] = text ? boost::any(text->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cardCallback") != m.end() && !m["cardCallback"].empty()) {
      if (typeid(map<string, boost::any>) == m["cardCallback"].type()) {
        ListMessageResponseBodyMessagesContentCardCallback model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["cardCallback"]));
        cardCallback = make_shared<ListMessageResponseBodyMessagesContentCardCallback>(model1);
      }
    }
    if (m.find("dingCard") != m.end() && !m["dingCard"].empty()) {
      if (typeid(map<string, boost::any>) == m["dingCard"].type()) {
        ListMessageResponseBodyMessagesContentDingCard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dingCard"]));
        dingCard = make_shared<ListMessageResponseBodyMessagesContentDingCard>(model1);
      }
    }
    if (m.find("dingNormalCard") != m.end() && !m["dingNormalCard"].empty()) {
      if (typeid(map<string, boost::any>) == m["dingNormalCard"].type()) {
        ListMessageResponseBodyMessagesContentDingNormalCard model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["dingNormalCard"]));
        dingNormalCard = make_shared<ListMessageResponseBodyMessagesContentDingNormalCard>(model1);
      }
    }
    if (m.find("markdown") != m.end() && !m["markdown"].empty()) {
      if (typeid(map<string, boost::any>) == m["markdown"].type()) {
        ListMessageResponseBodyMessagesContentMarkdown model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["markdown"]));
        markdown = make_shared<ListMessageResponseBodyMessagesContentMarkdown>(model1);
      }
    }
    if (m.find("structView") != m.end() && !m["structView"].empty()) {
      if (typeid(map<string, boost::any>) == m["structView"].type()) {
        ListMessageResponseBodyMessagesContentStructView model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["structView"]));
        structView = make_shared<ListMessageResponseBodyMessagesContentStructView>(model1);
      }
    }
    if (m.find("text") != m.end() && !m["text"].empty()) {
      if (typeid(map<string, boost::any>) == m["text"].type()) {
        ListMessageResponseBodyMessagesContentText model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["text"]));
        text = make_shared<ListMessageResponseBodyMessagesContentText>(model1);
      }
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ListMessageResponseBodyMessagesContent() = default;
};
class ListMessageResponseBodyMessages : public Darabonba::Model {
public:
  shared_ptr<ListMessageResponseBodyMessagesContent> content{};
  shared_ptr<string> contentDesc{};
  shared_ptr<long> createAt{};
  shared_ptr<string> id{};
  shared_ptr<string> role{};
  shared_ptr<string> runId{};
  shared_ptr<string> threadId{};

  ListMessageResponseBodyMessages() {}

  explicit ListMessageResponseBodyMessages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contentDesc) {
      res["contentDesc"] = boost::any(*contentDesc);
    }
    if (createAt) {
      res["createAt"] = boost::any(*createAt);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (role) {
      res["role"] = boost::any(*role);
    }
    if (runId) {
      res["runId"] = boost::any(*runId);
    }
    if (threadId) {
      res["threadId"] = boost::any(*threadId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      if (typeid(map<string, boost::any>) == m["content"].type()) {
        ListMessageResponseBodyMessagesContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["content"]));
        content = make_shared<ListMessageResponseBodyMessagesContent>(model1);
      }
    }
    if (m.find("contentDesc") != m.end() && !m["contentDesc"].empty()) {
      contentDesc = make_shared<string>(boost::any_cast<string>(m["contentDesc"]));
    }
    if (m.find("createAt") != m.end() && !m["createAt"].empty()) {
      createAt = make_shared<long>(boost::any_cast<long>(m["createAt"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("role") != m.end() && !m["role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["role"]));
    }
    if (m.find("runId") != m.end() && !m["runId"].empty()) {
      runId = make_shared<string>(boost::any_cast<string>(m["runId"]));
    }
    if (m.find("threadId") != m.end() && !m["threadId"].empty()) {
      threadId = make_shared<string>(boost::any_cast<string>(m["threadId"]));
    }
  }


  virtual ~ListMessageResponseBodyMessages() = default;
};
class ListMessageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListMessageResponseBodyMessages>> messages{};
  shared_ptr<string> requestId{};

  ListMessageResponseBody() {}

  explicit ListMessageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messages) {
      vector<boost::any> temp1;
      for(auto item1:*messages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["messages"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("messages") != m.end() && !m["messages"].empty()) {
      if (typeid(vector<boost::any>) == m["messages"].type()) {
        vector<ListMessageResponseBodyMessages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["messages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMessageResponseBodyMessages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        messages = make_shared<vector<ListMessageResponseBodyMessages>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListMessageResponseBody() = default;
};
class ListMessageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMessageResponseBody> body{};

  ListMessageResponse() {}

  explicit ListMessageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMessageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMessageResponseBody>(model1);
      }
    }
  }


  virtual ~ListMessageResponse() = default;
};
class ListMultiDimTableRecordsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListMultiDimTableRecordsHeadersAccountContext() {}

  explicit ListMultiDimTableRecordsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListMultiDimTableRecordsHeadersAccountContext() = default;
};
class ListMultiDimTableRecordsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ListMultiDimTableRecordsHeadersAccountContext> accountContext{};

  ListMultiDimTableRecordsHeaders() {}

  explicit ListMultiDimTableRecordsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ListMultiDimTableRecordsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ListMultiDimTableRecordsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ListMultiDimTableRecordsHeaders() = default;
};
class ListMultiDimTableRecordsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ListMultiDimTableRecordsShrinkHeaders() {}

  explicit ListMultiDimTableRecordsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ListMultiDimTableRecordsShrinkHeaders() = default;
};
class ListMultiDimTableRecordsRequestFilterConditions : public Darabonba::Model {
public:
  shared_ptr<string> field{};
  shared_ptr<string> operator_{};
  shared_ptr<vector<boost::any>> value{};

  ListMultiDimTableRecordsRequestFilterConditions() {}

  explicit ListMultiDimTableRecordsRequestFilterConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Value"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      value = make_shared<vector<boost::any>>(toVec1);
    }
  }


  virtual ~ListMultiDimTableRecordsRequestFilterConditions() = default;
};
class ListMultiDimTableRecordsRequestFilter : public Darabonba::Model {
public:
  shared_ptr<string> combination{};
  shared_ptr<vector<ListMultiDimTableRecordsRequestFilterConditions>> conditions{};

  ListMultiDimTableRecordsRequestFilter() {}

  explicit ListMultiDimTableRecordsRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (combination) {
      res["Combination"] = boost::any(*combination);
    }
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conditions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Combination") != m.end() && !m["Combination"].empty()) {
      combination = make_shared<string>(boost::any_cast<string>(m["Combination"]));
    }
    if (m.find("Conditions") != m.end() && !m["Conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["Conditions"].type()) {
        vector<ListMultiDimTableRecordsRequestFilterConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMultiDimTableRecordsRequestFilterConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<ListMultiDimTableRecordsRequestFilterConditions>>(expect1);
      }
    }
  }


  virtual ~ListMultiDimTableRecordsRequestFilter() = default;
};
class ListMultiDimTableRecordsRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  ListMultiDimTableRecordsRequestTenantContext() {}

  explicit ListMultiDimTableRecordsRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~ListMultiDimTableRecordsRequestTenantContext() = default;
};
class ListMultiDimTableRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<ListMultiDimTableRecordsRequestFilter> filter{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> sheetIdOrName{};
  shared_ptr<ListMultiDimTableRecordsRequestTenantContext> tenantContext{};

  ListMultiDimTableRecordsRequest() {}

  explicit ListMultiDimTableRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (filter) {
      res["Filter"] = filter ? boost::any(filter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (sheetIdOrName) {
      res["SheetIdOrName"] = boost::any(*sheetIdOrName);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(map<string, boost::any>) == m["Filter"].type()) {
        ListMultiDimTableRecordsRequestFilter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Filter"]));
        filter = make_shared<ListMultiDimTableRecordsRequestFilter>(model1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("SheetIdOrName") != m.end() && !m["SheetIdOrName"].empty()) {
      sheetIdOrName = make_shared<string>(boost::any_cast<string>(m["SheetIdOrName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        ListMultiDimTableRecordsRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<ListMultiDimTableRecordsRequestTenantContext>(model1);
      }
    }
  }


  virtual ~ListMultiDimTableRecordsRequest() = default;
};
class ListMultiDimTableRecordsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<string> filterShrink{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> sheetIdOrName{};
  shared_ptr<string> tenantContextShrink{};

  ListMultiDimTableRecordsShrinkRequest() {}

  explicit ListMultiDimTableRecordsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (filterShrink) {
      res["Filter"] = boost::any(*filterShrink);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (sheetIdOrName) {
      res["SheetIdOrName"] = boost::any(*sheetIdOrName);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      filterShrink = make_shared<string>(boost::any_cast<string>(m["Filter"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("SheetIdOrName") != m.end() && !m["SheetIdOrName"].empty()) {
      sheetIdOrName = make_shared<string>(boost::any_cast<string>(m["SheetIdOrName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~ListMultiDimTableRecordsShrinkRequest() = default;
};
class ListMultiDimTableRecordsResponseBodyRecordsCreatedBy : public Darabonba::Model {
public:
  shared_ptr<string> userId{};

  ListMultiDimTableRecordsResponseBodyRecordsCreatedBy() {}

  explicit ListMultiDimTableRecordsResponseBodyRecordsCreatedBy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListMultiDimTableRecordsResponseBodyRecordsCreatedBy() = default;
};
class ListMultiDimTableRecordsResponseBodyRecordsLastModifiedBy : public Darabonba::Model {
public:
  shared_ptr<string> userId{};

  ListMultiDimTableRecordsResponseBodyRecordsLastModifiedBy() {}

  explicit ListMultiDimTableRecordsResponseBodyRecordsLastModifiedBy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListMultiDimTableRecordsResponseBodyRecordsLastModifiedBy() = default;
};
class ListMultiDimTableRecordsResponseBodyRecords : public Darabonba::Model {
public:
  shared_ptr<ListMultiDimTableRecordsResponseBodyRecordsCreatedBy> createdBy{};
  shared_ptr<long> createdTime{};
  shared_ptr<map<string, boost::any>> fields{};
  shared_ptr<string> id{};
  shared_ptr<ListMultiDimTableRecordsResponseBodyRecordsLastModifiedBy> lastModifiedBy{};
  shared_ptr<long> lastModifiedTime{};

  ListMultiDimTableRecordsResponseBodyRecords() {}

  explicit ListMultiDimTableRecordsResponseBodyRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdBy) {
      res["CreatedBy"] = createdBy ? boost::any(createdBy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (fields) {
      res["Fields"] = boost::any(*fields);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastModifiedBy) {
      res["LastModifiedBy"] = lastModifiedBy ? boost::any(lastModifiedBy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (lastModifiedTime) {
      res["LastModifiedTime"] = boost::any(*lastModifiedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedBy") != m.end() && !m["CreatedBy"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreatedBy"].type()) {
        ListMultiDimTableRecordsResponseBodyRecordsCreatedBy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreatedBy"]));
        createdBy = make_shared<ListMultiDimTableRecordsResponseBodyRecordsCreatedBy>(model1);
      }
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("Fields") != m.end() && !m["Fields"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Fields"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      fields = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LastModifiedBy") != m.end() && !m["LastModifiedBy"].empty()) {
      if (typeid(map<string, boost::any>) == m["LastModifiedBy"].type()) {
        ListMultiDimTableRecordsResponseBodyRecordsLastModifiedBy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LastModifiedBy"]));
        lastModifiedBy = make_shared<ListMultiDimTableRecordsResponseBodyRecordsLastModifiedBy>(model1);
      }
    }
    if (m.find("LastModifiedTime") != m.end() && !m["LastModifiedTime"].empty()) {
      lastModifiedTime = make_shared<long>(boost::any_cast<long>(m["LastModifiedTime"]));
    }
  }


  virtual ~ListMultiDimTableRecordsResponseBodyRecords() = default;
};
class ListMultiDimTableRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> hasMore{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListMultiDimTableRecordsResponseBodyRecords>> records{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  ListMultiDimTableRecordsResponseBody() {}

  explicit ListMultiDimTableRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasMore) {
      res["hasMore"] = boost::any(*hasMore);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (records) {
      vector<boost::any> temp1;
      for(auto item1:*records){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["records"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hasMore") != m.end() && !m["hasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["hasMore"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("records") != m.end() && !m["records"].empty()) {
      if (typeid(vector<boost::any>) == m["records"].type()) {
        vector<ListMultiDimTableRecordsResponseBodyRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMultiDimTableRecordsResponseBodyRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        records = make_shared<vector<ListMultiDimTableRecordsResponseBodyRecords>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~ListMultiDimTableRecordsResponseBody() = default;
};
class ListMultiDimTableRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMultiDimTableRecordsResponseBody> body{};

  ListMultiDimTableRecordsResponse() {}

  explicit ListMultiDimTableRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMultiDimTableRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMultiDimTableRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMultiDimTableRecordsResponse() = default;
};
class ListNavigationByFormTypeHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListNavigationByFormTypeHeadersAccountContext() {}

  explicit ListNavigationByFormTypeHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListNavigationByFormTypeHeadersAccountContext() = default;
};
class ListNavigationByFormTypeHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ListNavigationByFormTypeHeadersAccountContext> accountContext{};

  ListNavigationByFormTypeHeaders() {}

  explicit ListNavigationByFormTypeHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ListNavigationByFormTypeHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ListNavigationByFormTypeHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ListNavigationByFormTypeHeaders() = default;
};
class ListNavigationByFormTypeShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ListNavigationByFormTypeShrinkHeaders() {}

  explicit ListNavigationByFormTypeShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ListNavigationByFormTypeShrinkHeaders() = default;
};
class ListNavigationByFormTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> formType{};
  shared_ptr<string> language{};
  shared_ptr<string> systemToken{};

  ListNavigationByFormTypeRequest() {}

  explicit ListNavigationByFormTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (formType) {
      res["FormType"] = boost::any(*formType);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("FormType") != m.end() && !m["FormType"].empty()) {
      formType = make_shared<string>(boost::any_cast<string>(m["FormType"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~ListNavigationByFormTypeRequest() = default;
};
class ListNavigationByFormTypeResponseBodyResultTitle : public Darabonba::Model {
public:
  shared_ptr<string> nameInChinese{};
  shared_ptr<string> nameInEnglish{};
  shared_ptr<string> type{};

  ListNavigationByFormTypeResponseBodyResultTitle() {}

  explicit ListNavigationByFormTypeResponseBodyResultTitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameInChinese) {
      res["NameInChinese"] = boost::any(*nameInChinese);
    }
    if (nameInEnglish) {
      res["NameInEnglish"] = boost::any(*nameInEnglish);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameInChinese") != m.end() && !m["NameInChinese"].empty()) {
      nameInChinese = make_shared<string>(boost::any_cast<string>(m["NameInChinese"]));
    }
    if (m.find("NameInEnglish") != m.end() && !m["NameInEnglish"].empty()) {
      nameInEnglish = make_shared<string>(boost::any_cast<string>(m["NameInEnglish"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListNavigationByFormTypeResponseBodyResultTitle() = default;
};
class ListNavigationByFormTypeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> formUuid{};
  shared_ptr<string> processCode{};
  shared_ptr<ListNavigationByFormTypeResponseBodyResultTitle> title{};

  ListNavigationByFormTypeResponseBodyResult() {}

  explicit ListNavigationByFormTypeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (processCode) {
      res["ProcessCode"] = boost::any(*processCode);
    }
    if (title) {
      res["Title"] = title ? boost::any(title->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("ProcessCode") != m.end() && !m["ProcessCode"].empty()) {
      processCode = make_shared<string>(boost::any_cast<string>(m["ProcessCode"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      if (typeid(map<string, boost::any>) == m["Title"].type()) {
        ListNavigationByFormTypeResponseBodyResultTitle model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Title"]));
        title = make_shared<ListNavigationByFormTypeResponseBodyResultTitle>(model1);
      }
    }
  }


  virtual ~ListNavigationByFormTypeResponseBodyResult() = default;
};
class ListNavigationByFormTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListNavigationByFormTypeResponseBodyResult>> result{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  ListNavigationByFormTypeResponseBody() {}

  explicit ListNavigationByFormTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<ListNavigationByFormTypeResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNavigationByFormTypeResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListNavigationByFormTypeResponseBodyResult>>(expect1);
      }
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~ListNavigationByFormTypeResponseBody() = default;
};
class ListNavigationByFormTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNavigationByFormTypeResponseBody> body{};

  ListNavigationByFormTypeResponse() {}

  explicit ListNavigationByFormTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNavigationByFormTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNavigationByFormTypeResponseBody>(model1);
      }
    }
  }


  virtual ~ListNavigationByFormTypeResponse() = default;
};
class ListNodesHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListNodesHeadersAccountContext() {}

  explicit ListNodesHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListNodesHeadersAccountContext() = default;
};
class ListNodesHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ListNodesHeadersAccountContext> accountContext{};

  ListNodesHeaders() {}

  explicit ListNodesHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ListNodesHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ListNodesHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ListNodesHeaders() = default;
};
class ListNodesShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ListNodesShrinkHeaders() {}

  explicit ListNodesShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ListNodesShrinkHeaders() = default;
};
class ListNodesRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  ListNodesRequestTenantContext() {}

  explicit ListNodesRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~ListNodesRequestTenantContext() = default;
};
class ListNodesRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> parentNodeId{};
  shared_ptr<ListNodesRequestTenantContext> tenantContext{};
  shared_ptr<bool> withPermissionRole{};

  ListNodesRequest() {}

  explicit ListNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (parentNodeId) {
      res["ParentNodeId"] = boost::any(*parentNodeId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (withPermissionRole) {
      res["WithPermissionRole"] = boost::any(*withPermissionRole);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ParentNodeId") != m.end() && !m["ParentNodeId"].empty()) {
      parentNodeId = make_shared<string>(boost::any_cast<string>(m["ParentNodeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        ListNodesRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<ListNodesRequestTenantContext>(model1);
      }
    }
    if (m.find("WithPermissionRole") != m.end() && !m["WithPermissionRole"].empty()) {
      withPermissionRole = make_shared<bool>(boost::any_cast<bool>(m["WithPermissionRole"]));
    }
  }


  virtual ~ListNodesRequest() = default;
};
class ListNodesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> parentNodeId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<bool> withPermissionRole{};

  ListNodesShrinkRequest() {}

  explicit ListNodesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (parentNodeId) {
      res["ParentNodeId"] = boost::any(*parentNodeId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (withPermissionRole) {
      res["WithPermissionRole"] = boost::any(*withPermissionRole);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ParentNodeId") != m.end() && !m["ParentNodeId"].empty()) {
      parentNodeId = make_shared<string>(boost::any_cast<string>(m["ParentNodeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WithPermissionRole") != m.end() && !m["WithPermissionRole"].empty()) {
      withPermissionRole = make_shared<bool>(boost::any_cast<bool>(m["WithPermissionRole"]));
    }
  }


  virtual ~ListNodesShrinkRequest() = default;
};
class ListNodesResponseBodyNodesStatisticalInfo : public Darabonba::Model {
public:
  shared_ptr<long> wordCount{};

  ListNodesResponseBodyNodesStatisticalInfo() {}

  explicit ListNodesResponseBodyNodesStatisticalInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (wordCount) {
      res["WordCount"] = boost::any(*wordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WordCount") != m.end() && !m["WordCount"].empty()) {
      wordCount = make_shared<long>(boost::any_cast<long>(m["WordCount"]));
    }
  }


  virtual ~ListNodesResponseBodyNodesStatisticalInfo() = default;
};
class ListNodesResponseBodyNodes : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> extension{};
  shared_ptr<bool> hasChildren{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> name{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> permissionRole{};
  shared_ptr<long> size{};
  shared_ptr<ListNodesResponseBodyNodesStatisticalInfo> statisticalInfo{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  ListNodesResponseBodyNodes() {}

  explicit ListNodesResponseBodyNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (hasChildren) {
      res["HasChildren"] = boost::any(*hasChildren);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (permissionRole) {
      res["PermissionRole"] = boost::any(*permissionRole);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (statisticalInfo) {
      res["StatisticalInfo"] = statisticalInfo ? boost::any(statisticalInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("HasChildren") != m.end() && !m["HasChildren"].empty()) {
      hasChildren = make_shared<bool>(boost::any_cast<bool>(m["HasChildren"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["ModifierId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("PermissionRole") != m.end() && !m["PermissionRole"].empty()) {
      permissionRole = make_shared<string>(boost::any_cast<string>(m["PermissionRole"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StatisticalInfo") != m.end() && !m["StatisticalInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatisticalInfo"].type()) {
        ListNodesResponseBodyNodesStatisticalInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatisticalInfo"]));
        statisticalInfo = make_shared<ListNodesResponseBodyNodesStatisticalInfo>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListNodesResponseBodyNodes() = default;
};
class ListNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListNodesResponseBodyNodes>> nodes{};
  shared_ptr<string> requestId{};

  ListNodesResponseBody() {}

  explicit ListNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["nodes"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("nodes") != m.end() && !m["nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["nodes"].type()) {
        vector<ListNodesResponseBodyNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<ListNodesResponseBodyNodes>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListNodesResponseBody() = default;
};
class ListNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNodesResponseBody> body{};

  ListNodesResponse() {}

  explicit ListNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNodesResponseBody>(model1);
      }
    }
  }


  virtual ~ListNodesResponse() = default;
};
class ListPermissionsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListPermissionsHeadersAccountContext() {}

  explicit ListPermissionsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListPermissionsHeadersAccountContext() = default;
};
class ListPermissionsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ListPermissionsHeadersAccountContext> accountContext{};

  ListPermissionsHeaders() {}

  explicit ListPermissionsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ListPermissionsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ListPermissionsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ListPermissionsHeaders() = default;
};
class ListPermissionsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ListPermissionsShrinkHeaders() {}

  explicit ListPermissionsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ListPermissionsShrinkHeaders() = default;
};
class ListPermissionsRequestOption : public Darabonba::Model {
public:
  shared_ptr<vector<string>> filterRoleIds{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  ListPermissionsRequestOption() {}

  explicit ListPermissionsRequestOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filterRoleIds) {
      res["FilterRoleIds"] = boost::any(*filterRoleIds);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilterRoleIds") != m.end() && !m["FilterRoleIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterRoleIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterRoleIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterRoleIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~ListPermissionsRequestOption() = default;
};
class ListPermissionsRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  ListPermissionsRequestTenantContext() {}

  explicit ListPermissionsRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~ListPermissionsRequestTenantContext() = default;
};
class ListPermissionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryUuid{};
  shared_ptr<ListPermissionsRequestOption> option{};
  shared_ptr<ListPermissionsRequestTenantContext> tenantContext{};

  ListPermissionsRequest() {}

  explicit ListPermissionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryUuid) {
      res["DentryUuid"] = boost::any(*dentryUuid);
    }
    if (option) {
      res["Option"] = option ? boost::any(option->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryUuid") != m.end() && !m["DentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["DentryUuid"]));
    }
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      if (typeid(map<string, boost::any>) == m["Option"].type()) {
        ListPermissionsRequestOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Option"]));
        option = make_shared<ListPermissionsRequestOption>(model1);
      }
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        ListPermissionsRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<ListPermissionsRequestTenantContext>(model1);
      }
    }
  }


  virtual ~ListPermissionsRequest() = default;
};
class ListPermissionsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryUuid{};
  shared_ptr<string> optionShrink{};
  shared_ptr<string> tenantContextShrink{};

  ListPermissionsShrinkRequest() {}

  explicit ListPermissionsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryUuid) {
      res["DentryUuid"] = boost::any(*dentryUuid);
    }
    if (optionShrink) {
      res["Option"] = boost::any(*optionShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryUuid") != m.end() && !m["DentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["DentryUuid"]));
    }
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      optionShrink = make_shared<string>(boost::any_cast<string>(m["Option"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~ListPermissionsShrinkRequest() = default;
};
class ListPermissionsResponseBodyPermissionsMember : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<string> id{};
  shared_ptr<string> type{};

  ListPermissionsResponseBodyPermissionsMember() {}

  explicit ListPermissionsResponseBodyPermissionsMember(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListPermissionsResponseBodyPermissionsMember() = default;
};
class ListPermissionsResponseBodyPermissionsRole : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  ListPermissionsResponseBodyPermissionsRole() {}

  explicit ListPermissionsResponseBodyPermissionsRole(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListPermissionsResponseBodyPermissionsRole() = default;
};
class ListPermissionsResponseBodyPermissions : public Darabonba::Model {
public:
  shared_ptr<string> dentryUuid{};
  shared_ptr<ListPermissionsResponseBodyPermissionsMember> member{};
  shared_ptr<ListPermissionsResponseBodyPermissionsRole> role{};

  ListPermissionsResponseBodyPermissions() {}

  explicit ListPermissionsResponseBodyPermissions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryUuid) {
      res["DentryUuid"] = boost::any(*dentryUuid);
    }
    if (member) {
      res["Member"] = member ? boost::any(member->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (role) {
      res["Role"] = role ? boost::any(role->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryUuid") != m.end() && !m["DentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["DentryUuid"]));
    }
    if (m.find("Member") != m.end() && !m["Member"].empty()) {
      if (typeid(map<string, boost::any>) == m["Member"].type()) {
        ListPermissionsResponseBodyPermissionsMember model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Member"]));
        member = make_shared<ListPermissionsResponseBodyPermissionsMember>(model1);
      }
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      if (typeid(map<string, boost::any>) == m["Role"].type()) {
        ListPermissionsResponseBodyPermissionsRole model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Role"]));
        role = make_shared<ListPermissionsResponseBodyPermissionsRole>(model1);
      }
    }
  }


  virtual ~ListPermissionsResponseBodyPermissions() = default;
};
class ListPermissionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListPermissionsResponseBodyPermissions>> permissions{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  ListPermissionsResponseBody() {}

  explicit ListPermissionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["duration"] = boost::any(*duration);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (permissions) {
      vector<boost::any> temp1;
      for(auto item1:*permissions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["permissions"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("duration") != m.end() && !m["duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["duration"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("permissions") != m.end() && !m["permissions"].empty()) {
      if (typeid(vector<boost::any>) == m["permissions"].type()) {
        vector<ListPermissionsResponseBodyPermissions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["permissions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPermissionsResponseBodyPermissions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        permissions = make_shared<vector<ListPermissionsResponseBodyPermissions>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~ListPermissionsResponseBody() = default;
};
class ListPermissionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPermissionsResponseBody> body{};

  ListPermissionsResponse() {}

  explicit ListPermissionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPermissionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPermissionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListPermissionsResponse() = default;
};
class ListReportHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListReportHeadersAccountContext() {}

  explicit ListReportHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListReportHeadersAccountContext() = default;
};
class ListReportHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ListReportHeadersAccountContext> accountContext{};

  ListReportHeaders() {}

  explicit ListReportHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ListReportHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ListReportHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ListReportHeaders() = default;
};
class ListReportShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ListReportShrinkHeaders() {}

  explicit ListReportShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ListReportShrinkHeaders() = default;
};
class ListReportRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  ListReportRequestTenantContext() {}

  explicit ListReportRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~ListReportRequestTenantContext() = default;
};
class ListReportRequest : public Darabonba::Model {
public:
  shared_ptr<long> cursor{};
  shared_ptr<long> endTime{};
  shared_ptr<long> modifiedEndTime{};
  shared_ptr<long> modifiedStartTime{};
  shared_ptr<long> size{};
  shared_ptr<long> startTime{};
  shared_ptr<string> templateName{};
  shared_ptr<ListReportRequestTenantContext> tenantContext{};

  ListReportRequest() {}

  explicit ListReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cursor) {
      res["Cursor"] = boost::any(*cursor);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (modifiedEndTime) {
      res["ModifiedEndTime"] = boost::any(*modifiedEndTime);
    }
    if (modifiedStartTime) {
      res["ModifiedStartTime"] = boost::any(*modifiedStartTime);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cursor") != m.end() && !m["Cursor"].empty()) {
      cursor = make_shared<long>(boost::any_cast<long>(m["Cursor"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ModifiedEndTime") != m.end() && !m["ModifiedEndTime"].empty()) {
      modifiedEndTime = make_shared<long>(boost::any_cast<long>(m["ModifiedEndTime"]));
    }
    if (m.find("ModifiedStartTime") != m.end() && !m["ModifiedStartTime"].empty()) {
      modifiedStartTime = make_shared<long>(boost::any_cast<long>(m["ModifiedStartTime"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        ListReportRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<ListReportRequestTenantContext>(model1);
      }
    }
  }


  virtual ~ListReportRequest() = default;
};
class ListReportShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> cursor{};
  shared_ptr<long> endTime{};
  shared_ptr<long> modifiedEndTime{};
  shared_ptr<long> modifiedStartTime{};
  shared_ptr<long> size{};
  shared_ptr<long> startTime{};
  shared_ptr<string> templateName{};
  shared_ptr<string> tenantContextShrink{};

  ListReportShrinkRequest() {}

  explicit ListReportShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cursor) {
      res["Cursor"] = boost::any(*cursor);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (modifiedEndTime) {
      res["ModifiedEndTime"] = boost::any(*modifiedEndTime);
    }
    if (modifiedStartTime) {
      res["ModifiedStartTime"] = boost::any(*modifiedStartTime);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cursor") != m.end() && !m["Cursor"].empty()) {
      cursor = make_shared<long>(boost::any_cast<long>(m["Cursor"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ModifiedEndTime") != m.end() && !m["ModifiedEndTime"].empty()) {
      modifiedEndTime = make_shared<long>(boost::any_cast<long>(m["ModifiedEndTime"]));
    }
    if (m.find("ModifiedStartTime") != m.end() && !m["ModifiedStartTime"].empty()) {
      modifiedStartTime = make_shared<long>(boost::any_cast<long>(m["ModifiedStartTime"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~ListReportShrinkRequest() = default;
};
class ListReportResponseBodyDataListContents : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> sort{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ListReportResponseBodyDataListContents() {}

  explicit ListReportResponseBodyDataListContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListReportResponseBodyDataListContents() = default;
};
class ListReportResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<ListReportResponseBodyDataListContents>> contents{};
  shared_ptr<long> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> creatorName{};
  shared_ptr<string> deptName{};
  shared_ptr<vector<string>> images{};
  shared_ptr<string> latitude{};
  shared_ptr<string> longitude{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<string> remark{};
  shared_ptr<string> reportId{};
  shared_ptr<string> templateName{};

  ListReportResponseBodyDataList() {}

  explicit ListReportResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contents) {
      vector<boost::any> temp1;
      for(auto item1:*contents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contents"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (deptName) {
      res["DeptName"] = boost::any(*deptName);
    }
    if (images) {
      res["Images"] = boost::any(*images);
    }
    if (latitude) {
      res["Latitude"] = boost::any(*latitude);
    }
    if (longitude) {
      res["Longitude"] = boost::any(*longitude);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      if (typeid(vector<boost::any>) == m["Contents"].type()) {
        vector<ListReportResponseBodyDataListContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListReportResponseBodyDataListContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contents = make_shared<vector<ListReportResponseBodyDataListContents>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("DeptName") != m.end() && !m["DeptName"].empty()) {
      deptName = make_shared<string>(boost::any_cast<string>(m["DeptName"]));
    }
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Images"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Images"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      images = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Latitude") != m.end() && !m["Latitude"].empty()) {
      latitude = make_shared<string>(boost::any_cast<string>(m["Latitude"]));
    }
    if (m.find("Longitude") != m.end() && !m["Longitude"].empty()) {
      longitude = make_shared<string>(boost::any_cast<string>(m["Longitude"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~ListReportResponseBodyDataList() = default;
};
class ListReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListReportResponseBodyDataList>> dataList{};
  shared_ptr<bool> hasMore{};
  shared_ptr<long> nextCursor{};
  shared_ptr<string> requestId{};
  shared_ptr<long> size{};

  ListReportResponseBody() {}

  explicit ListReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataList) {
      vector<boost::any> temp1;
      for(auto item1:*dataList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dataList"] = boost::any(temp1);
    }
    if (hasMore) {
      res["hasMore"] = boost::any(*hasMore);
    }
    if (nextCursor) {
      res["nextCursor"] = boost::any(*nextCursor);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dataList") != m.end() && !m["dataList"].empty()) {
      if (typeid(vector<boost::any>) == m["dataList"].type()) {
        vector<ListReportResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dataList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListReportResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataList = make_shared<vector<ListReportResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("hasMore") != m.end() && !m["hasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["hasMore"]));
    }
    if (m.find("nextCursor") != m.end() && !m["nextCursor"].empty()) {
      nextCursor = make_shared<long>(boost::any_cast<long>(m["nextCursor"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
  }


  virtual ~ListReportResponseBody() = default;
};
class ListReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListReportResponseBody> body{};

  ListReportResponse() {}

  explicit ListReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListReportResponseBody>(model1);
      }
    }
  }


  virtual ~ListReportResponse() = default;
};
class ListSkillHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListSkillHeadersAccountContext() {}

  explicit ListSkillHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListSkillHeadersAccountContext() = default;
};
class ListSkillHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ListSkillHeadersAccountContext> accountContext{};

  ListSkillHeaders() {}

  explicit ListSkillHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ListSkillHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ListSkillHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ListSkillHeaders() = default;
};
class ListSkillShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ListSkillShrinkHeaders() {}

  explicit ListSkillShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ListSkillShrinkHeaders() = default;
};
class ListSkillRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};

  ListSkillRequest() {}

  explicit ListSkillRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["groupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("groupId") != m.end() && !m["groupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["groupId"]));
    }
  }


  virtual ~ListSkillRequest() = default;
};
class ListSkillResponseBody : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};
  shared_ptr<string> requestId{};

  ListSkillResponseBody() {}

  explicit ListSkillResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListSkillResponseBody() = default;
};
class ListSkillResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSkillResponseBody> body{};

  ListSkillResponse() {}

  explicit ListSkillResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSkillResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSkillResponseBody>(model1);
      }
    }
  }


  virtual ~ListSkillResponse() = default;
};
class ListTableDataByFormInstanceIdTableIdHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListTableDataByFormInstanceIdTableIdHeadersAccountContext() {}

  explicit ListTableDataByFormInstanceIdTableIdHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListTableDataByFormInstanceIdTableIdHeadersAccountContext() = default;
};
class ListTableDataByFormInstanceIdTableIdHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ListTableDataByFormInstanceIdTableIdHeadersAccountContext> accountContext{};

  ListTableDataByFormInstanceIdTableIdHeaders() {}

  explicit ListTableDataByFormInstanceIdTableIdHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ListTableDataByFormInstanceIdTableIdHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ListTableDataByFormInstanceIdTableIdHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ListTableDataByFormInstanceIdTableIdHeaders() = default;
};
class ListTableDataByFormInstanceIdTableIdShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ListTableDataByFormInstanceIdTableIdShrinkHeaders() {}

  explicit ListTableDataByFormInstanceIdTableIdShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ListTableDataByFormInstanceIdTableIdShrinkHeaders() = default;
};
class ListTableDataByFormInstanceIdTableIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> formInstanceId{};
  shared_ptr<string> formUuid{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> systemToken{};
  shared_ptr<string> tableFieldId{};

  ListTableDataByFormInstanceIdTableIdRequest() {}

  explicit ListTableDataByFormInstanceIdTableIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (formInstanceId) {
      res["FormInstanceId"] = boost::any(*formInstanceId);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    if (tableFieldId) {
      res["TableFieldId"] = boost::any(*tableFieldId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("FormInstanceId") != m.end() && !m["FormInstanceId"].empty()) {
      formInstanceId = make_shared<string>(boost::any_cast<string>(m["FormInstanceId"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
    if (m.find("TableFieldId") != m.end() && !m["TableFieldId"].empty()) {
      tableFieldId = make_shared<string>(boost::any_cast<string>(m["TableFieldId"]));
    }
  }


  virtual ~ListTableDataByFormInstanceIdTableIdRequest() = default;
};
class ListTableDataByFormInstanceIdTableIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  ListTableDataByFormInstanceIdTableIdResponseBody() {}

  explicit ListTableDataByFormInstanceIdTableIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~ListTableDataByFormInstanceIdTableIdResponseBody() = default;
};
class ListTableDataByFormInstanceIdTableIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTableDataByFormInstanceIdTableIdResponseBody> body{};

  ListTableDataByFormInstanceIdTableIdResponse() {}

  explicit ListTableDataByFormInstanceIdTableIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTableDataByFormInstanceIdTableIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTableDataByFormInstanceIdTableIdResponseBody>(model1);
      }
    }
  }


  virtual ~ListTableDataByFormInstanceIdTableIdResponse() = default;
};
class ListTeamsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListTeamsHeadersAccountContext() {}

  explicit ListTeamsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListTeamsHeadersAccountContext() = default;
};
class ListTeamsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ListTeamsHeadersAccountContext> accountContext{};

  ListTeamsHeaders() {}

  explicit ListTeamsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ListTeamsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ListTeamsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ListTeamsHeaders() = default;
};
class ListTeamsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ListTeamsShrinkHeaders() {}

  explicit ListTeamsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ListTeamsShrinkHeaders() = default;
};
class ListTeamsRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  ListTeamsRequestTenantContext() {}

  explicit ListTeamsRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~ListTeamsRequestTenantContext() = default;
};
class ListTeamsRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<ListTeamsRequestTenantContext> tenantContext{};

  ListTeamsRequest() {}

  explicit ListTeamsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        ListTeamsRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<ListTeamsRequestTenantContext>(model1);
      }
    }
  }


  virtual ~ListTeamsRequest() = default;
};
class ListTeamsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> tenantContextShrink{};

  ListTeamsShrinkRequest() {}

  explicit ListTeamsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~ListTeamsShrinkRequest() = default;
};
class ListTeamsResponseBodyTeamsIcon : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ListTeamsResponseBodyTeamsIcon() {}

  explicit ListTeamsResponseBodyTeamsIcon(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTeamsResponseBodyTeamsIcon() = default;
};
class ListTeamsResponseBodyTeams : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<string> cover{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<ListTeamsResponseBodyTeamsIcon> icon{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> name{};
  shared_ptr<string> teamId{};

  ListTeamsResponseBodyTeams() {}

  explicit ListTeamsResponseBodyTeams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (cover) {
      res["Cover"] = boost::any(*cover);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (icon) {
      res["Icon"] = icon ? boost::any(icon->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (teamId) {
      res["TeamId"] = boost::any(*teamId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      cover = make_shared<string>(boost::any_cast<string>(m["Cover"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      if (typeid(map<string, boost::any>) == m["Icon"].type()) {
        ListTeamsResponseBodyTeamsIcon model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Icon"]));
        icon = make_shared<ListTeamsResponseBodyTeamsIcon>(model1);
      }
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["ModifierId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TeamId") != m.end() && !m["TeamId"].empty()) {
      teamId = make_shared<string>(boost::any_cast<string>(m["TeamId"]));
    }
  }


  virtual ~ListTeamsResponseBodyTeams() = default;
};
class ListTeamsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListTeamsResponseBodyTeams>> teams{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  ListTeamsResponseBody() {}

  explicit ListTeamsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (teams) {
      vector<boost::any> temp1;
      for(auto item1:*teams){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["teams"] = boost::any(temp1);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("teams") != m.end() && !m["teams"].empty()) {
      if (typeid(vector<boost::any>) == m["teams"].type()) {
        vector<ListTeamsResponseBodyTeams> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["teams"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTeamsResponseBodyTeams model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        teams = make_shared<vector<ListTeamsResponseBodyTeams>>(expect1);
      }
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~ListTeamsResponseBody() = default;
};
class ListTeamsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTeamsResponseBody> body{};

  ListTeamsResponse() {}

  explicit ListTeamsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTeamsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTeamsResponseBody>(model1);
      }
    }
  }


  virtual ~ListTeamsResponse() = default;
};
class ListTemplateHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListTemplateHeadersAccountContext() {}

  explicit ListTemplateHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListTemplateHeadersAccountContext() = default;
};
class ListTemplateHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ListTemplateHeadersAccountContext> accountContext{};

  ListTemplateHeaders() {}

  explicit ListTemplateHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ListTemplateHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ListTemplateHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ListTemplateHeaders() = default;
};
class ListTemplateShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ListTemplateShrinkHeaders() {}

  explicit ListTemplateShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ListTemplateShrinkHeaders() = default;
};
class ListTemplateRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  ListTemplateRequestTenantContext() {}

  explicit ListTemplateRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~ListTemplateRequestTenantContext() = default;
};
class ListTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> templateType{};
  shared_ptr<ListTemplateRequestTenantContext> tenantContext{};
  shared_ptr<string> workspaceId{};

  ListTemplateRequest() {}

  explicit ListTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        ListTemplateRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<ListTemplateRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListTemplateRequest() = default;
};
class ListTemplateShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> templateType{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workspaceId{};

  ListTemplateShrinkRequest() {}

  explicit ListTemplateShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListTemplateShrinkRequest() = default;
};
class ListTemplateResponseBodyTemplateList : public Darabonba::Model {
public:
  shared_ptr<string> coverUrl{};
  shared_ptr<long> createTime{};
  shared_ptr<string> docType{};
  shared_ptr<string> id{};
  shared_ptr<string> templateType{};
  shared_ptr<string> title{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> workspaceId{};

  ListTemplateResponseBodyTemplateList() {}

  explicit ListTemplateResponseBodyTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverUrl) {
      res["CoverUrl"] = boost::any(*coverUrl);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverUrl") != m.end() && !m["CoverUrl"].empty()) {
      coverUrl = make_shared<string>(boost::any_cast<string>(m["CoverUrl"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListTemplateResponseBodyTemplateList() = default;
};
class ListTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> hasMore{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListTemplateResponseBodyTemplateList>> templateList{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  ListTemplateResponseBody() {}

  explicit ListTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasMore) {
      res["hasMore"] = boost::any(*hasMore);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (templateList) {
      vector<boost::any> temp1;
      for(auto item1:*templateList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["templateList"] = boost::any(temp1);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hasMore") != m.end() && !m["hasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["hasMore"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("templateList") != m.end() && !m["templateList"].empty()) {
      if (typeid(vector<boost::any>) == m["templateList"].type()) {
        vector<ListTemplateResponseBodyTemplateList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["templateList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTemplateResponseBodyTemplateList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templateList = make_shared<vector<ListTemplateResponseBodyTemplateList>>(expect1);
      }
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~ListTemplateResponseBody() = default;
};
class ListTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTemplateResponseBody> body{};

  ListTemplateResponse() {}

  explicit ListTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~ListTemplateResponse() = default;
};
class ListTicketOperateRecordHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListTicketOperateRecordHeadersAccountContext() {}

  explicit ListTicketOperateRecordHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListTicketOperateRecordHeadersAccountContext() = default;
};
class ListTicketOperateRecordHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ListTicketOperateRecordHeadersAccountContext> accountContext{};

  ListTicketOperateRecordHeaders() {}

  explicit ListTicketOperateRecordHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ListTicketOperateRecordHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ListTicketOperateRecordHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ListTicketOperateRecordHeaders() = default;
};
class ListTicketOperateRecordShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ListTicketOperateRecordShrinkHeaders() {}

  explicit ListTicketOperateRecordShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ListTicketOperateRecordShrinkHeaders() = default;
};
class ListTicketOperateRecordRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  ListTicketOperateRecordRequestTenantContext() {}

  explicit ListTicketOperateRecordRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~ListTicketOperateRecordRequestTenantContext() = default;
};
class ListTicketOperateRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> openTeamId{};
  shared_ptr<string> openTicketId{};
  shared_ptr<ListTicketOperateRecordRequestTenantContext> tenantContext{};

  ListTicketOperateRecordRequest() {}

  explicit ListTicketOperateRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openTeamId) {
      res["OpenTeamId"] = boost::any(*openTeamId);
    }
    if (openTicketId) {
      res["OpenTicketId"] = boost::any(*openTicketId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpenTeamId") != m.end() && !m["OpenTeamId"].empty()) {
      openTeamId = make_shared<string>(boost::any_cast<string>(m["OpenTeamId"]));
    }
    if (m.find("OpenTicketId") != m.end() && !m["OpenTicketId"].empty()) {
      openTicketId = make_shared<string>(boost::any_cast<string>(m["OpenTicketId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        ListTicketOperateRecordRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<ListTicketOperateRecordRequestTenantContext>(model1);
      }
    }
  }


  virtual ~ListTicketOperateRecordRequest() = default;
};
class ListTicketOperateRecordShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> openTeamId{};
  shared_ptr<string> openTicketId{};
  shared_ptr<string> tenantContextShrink{};

  ListTicketOperateRecordShrinkRequest() {}

  explicit ListTicketOperateRecordShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openTeamId) {
      res["OpenTeamId"] = boost::any(*openTeamId);
    }
    if (openTicketId) {
      res["OpenTicketId"] = boost::any(*openTicketId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpenTeamId") != m.end() && !m["OpenTeamId"].empty()) {
      openTeamId = make_shared<string>(boost::any_cast<string>(m["OpenTeamId"]));
    }
    if (m.find("OpenTicketId") != m.end() && !m["OpenTicketId"].empty()) {
      openTicketId = make_shared<string>(boost::any_cast<string>(m["OpenTicketId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~ListTicketOperateRecordShrinkRequest() = default;
};
class ListTicketOperateRecordResponseBodyRecordsOperator : public Darabonba::Model {
public:
  shared_ptr<string> nickName{};
  shared_ptr<string> unionId{};

  ListTicketOperateRecordResponseBodyRecordsOperator() {}

  explicit ListTicketOperateRecordResponseBodyRecordsOperator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (unionId) {
      res["UnionId"] = boost::any(*unionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("UnionId") != m.end() && !m["UnionId"].empty()) {
      unionId = make_shared<string>(boost::any_cast<string>(m["UnionId"]));
    }
  }


  virtual ~ListTicketOperateRecordResponseBodyRecordsOperator() = default;
};
class ListTicketOperateRecordResponseBodyRecordsTicketMemoAttachments : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> key{};

  ListTicketOperateRecordResponseBodyRecordsTicketMemoAttachments() {}

  explicit ListTicketOperateRecordResponseBodyRecordsTicketMemoAttachments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~ListTicketOperateRecordResponseBodyRecordsTicketMemoAttachments() = default;
};
class ListTicketOperateRecordResponseBodyRecordsTicketMemo : public Darabonba::Model {
public:
  shared_ptr<vector<ListTicketOperateRecordResponseBodyRecordsTicketMemoAttachments>> attachments{};
  shared_ptr<string> memo{};

  ListTicketOperateRecordResponseBodyRecordsTicketMemo() {}

  explicit ListTicketOperateRecordResponseBodyRecordsTicketMemo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachments) {
      vector<boost::any> temp1;
      for(auto item1:*attachments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attachments"] = boost::any(temp1);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attachments") != m.end() && !m["Attachments"].empty()) {
      if (typeid(vector<boost::any>) == m["Attachments"].type()) {
        vector<ListTicketOperateRecordResponseBodyRecordsTicketMemoAttachments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attachments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTicketOperateRecordResponseBodyRecordsTicketMemoAttachments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attachments = make_shared<vector<ListTicketOperateRecordResponseBodyRecordsTicketMemoAttachments>>(expect1);
      }
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
  }


  virtual ~ListTicketOperateRecordResponseBodyRecordsTicketMemo() = default;
};
class ListTicketOperateRecordResponseBodyRecords : public Darabonba::Model {
public:
  shared_ptr<string> openTicketId{};
  shared_ptr<string> operateData{};
  shared_ptr<string> operateTime{};
  shared_ptr<string> operation{};
  shared_ptr<string> operationDisplayName{};
  shared_ptr<ListTicketOperateRecordResponseBodyRecordsOperator> operator_{};
  shared_ptr<ListTicketOperateRecordResponseBodyRecordsTicketMemo> ticketMemo{};

  ListTicketOperateRecordResponseBodyRecords() {}

  explicit ListTicketOperateRecordResponseBodyRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openTicketId) {
      res["OpenTicketId"] = boost::any(*openTicketId);
    }
    if (operateData) {
      res["OperateData"] = boost::any(*operateData);
    }
    if (operateTime) {
      res["OperateTime"] = boost::any(*operateTime);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (operationDisplayName) {
      res["OperationDisplayName"] = boost::any(*operationDisplayName);
    }
    if (operator_) {
      res["Operator"] = operator_ ? boost::any(operator_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ticketMemo) {
      res["TicketMemo"] = ticketMemo ? boost::any(ticketMemo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpenTicketId") != m.end() && !m["OpenTicketId"].empty()) {
      openTicketId = make_shared<string>(boost::any_cast<string>(m["OpenTicketId"]));
    }
    if (m.find("OperateData") != m.end() && !m["OperateData"].empty()) {
      operateData = make_shared<string>(boost::any_cast<string>(m["OperateData"]));
    }
    if (m.find("OperateTime") != m.end() && !m["OperateTime"].empty()) {
      operateTime = make_shared<string>(boost::any_cast<string>(m["OperateTime"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("OperationDisplayName") != m.end() && !m["OperationDisplayName"].empty()) {
      operationDisplayName = make_shared<string>(boost::any_cast<string>(m["OperationDisplayName"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      if (typeid(map<string, boost::any>) == m["Operator"].type()) {
        ListTicketOperateRecordResponseBodyRecordsOperator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Operator"]));
        operator_ = make_shared<ListTicketOperateRecordResponseBodyRecordsOperator>(model1);
      }
    }
    if (m.find("TicketMemo") != m.end() && !m["TicketMemo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TicketMemo"].type()) {
        ListTicketOperateRecordResponseBodyRecordsTicketMemo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TicketMemo"]));
        ticketMemo = make_shared<ListTicketOperateRecordResponseBodyRecordsTicketMemo>(model1);
      }
    }
  }


  virtual ~ListTicketOperateRecordResponseBodyRecords() = default;
};
class ListTicketOperateRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListTicketOperateRecordResponseBodyRecords>> records{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  ListTicketOperateRecordResponseBody() {}

  explicit ListTicketOperateRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (records) {
      vector<boost::any> temp1;
      for(auto item1:*records){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["records"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("records") != m.end() && !m["records"].empty()) {
      if (typeid(vector<boost::any>) == m["records"].type()) {
        vector<ListTicketOperateRecordResponseBodyRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["records"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTicketOperateRecordResponseBodyRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        records = make_shared<vector<ListTicketOperateRecordResponseBodyRecords>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~ListTicketOperateRecordResponseBody() = default;
};
class ListTicketOperateRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTicketOperateRecordResponseBody> body{};

  ListTicketOperateRecordResponse() {}

  explicit ListTicketOperateRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTicketOperateRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTicketOperateRecordResponseBody>(model1);
      }
    }
  }


  virtual ~ListTicketOperateRecordResponse() = default;
};
class ListWorkspacesHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListWorkspacesHeadersAccountContext() {}

  explicit ListWorkspacesHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListWorkspacesHeadersAccountContext() = default;
};
class ListWorkspacesHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ListWorkspacesHeadersAccountContext> accountContext{};

  ListWorkspacesHeaders() {}

  explicit ListWorkspacesHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ListWorkspacesHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ListWorkspacesHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ListWorkspacesHeaders() = default;
};
class ListWorkspacesShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ListWorkspacesShrinkHeaders() {}

  explicit ListWorkspacesShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ListWorkspacesShrinkHeaders() = default;
};
class ListWorkspacesRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  ListWorkspacesRequestTenantContext() {}

  explicit ListWorkspacesRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~ListWorkspacesRequestTenantContext() = default;
};
class ListWorkspacesRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> teamId{};
  shared_ptr<ListWorkspacesRequestTenantContext> tenantContext{};
  shared_ptr<bool> withPermissionRole{};

  ListWorkspacesRequest() {}

  explicit ListWorkspacesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (teamId) {
      res["TeamId"] = boost::any(*teamId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (withPermissionRole) {
      res["WithPermissionRole"] = boost::any(*withPermissionRole);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("TeamId") != m.end() && !m["TeamId"].empty()) {
      teamId = make_shared<string>(boost::any_cast<string>(m["TeamId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        ListWorkspacesRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<ListWorkspacesRequestTenantContext>(model1);
      }
    }
    if (m.find("WithPermissionRole") != m.end() && !m["WithPermissionRole"].empty()) {
      withPermissionRole = make_shared<bool>(boost::any_cast<bool>(m["WithPermissionRole"]));
    }
  }


  virtual ~ListWorkspacesRequest() = default;
};
class ListWorkspacesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> teamId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<bool> withPermissionRole{};

  ListWorkspacesShrinkRequest() {}

  explicit ListWorkspacesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (teamId) {
      res["TeamId"] = boost::any(*teamId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (withPermissionRole) {
      res["WithPermissionRole"] = boost::any(*withPermissionRole);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("TeamId") != m.end() && !m["TeamId"].empty()) {
      teamId = make_shared<string>(boost::any_cast<string>(m["TeamId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WithPermissionRole") != m.end() && !m["WithPermissionRole"].empty()) {
      withPermissionRole = make_shared<bool>(boost::any_cast<bool>(m["WithPermissionRole"]));
    }
  }


  virtual ~ListWorkspacesShrinkRequest() = default;
};
class ListWorkspacesResponseBodyWorkspacesIcon : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ListWorkspacesResponseBodyWorkspacesIcon() {}

  explicit ListWorkspacesResponseBodyWorkspacesIcon(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListWorkspacesResponseBodyWorkspacesIcon() = default;
};
class ListWorkspacesResponseBodyWorkspaces : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<string> cover{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<ListWorkspacesResponseBodyWorkspacesIcon> icon{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> name{};
  shared_ptr<string> permissionRole{};
  shared_ptr<string> rootNodeId{};
  shared_ptr<string> teamId{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  ListWorkspacesResponseBodyWorkspaces() {}

  explicit ListWorkspacesResponseBodyWorkspaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (cover) {
      res["Cover"] = boost::any(*cover);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (icon) {
      res["Icon"] = icon ? boost::any(icon->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (permissionRole) {
      res["PermissionRole"] = boost::any(*permissionRole);
    }
    if (rootNodeId) {
      res["RootNodeId"] = boost::any(*rootNodeId);
    }
    if (teamId) {
      res["TeamId"] = boost::any(*teamId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      cover = make_shared<string>(boost::any_cast<string>(m["Cover"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      if (typeid(map<string, boost::any>) == m["Icon"].type()) {
        ListWorkspacesResponseBodyWorkspacesIcon model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Icon"]));
        icon = make_shared<ListWorkspacesResponseBodyWorkspacesIcon>(model1);
      }
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["ModifierId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PermissionRole") != m.end() && !m["PermissionRole"].empty()) {
      permissionRole = make_shared<string>(boost::any_cast<string>(m["PermissionRole"]));
    }
    if (m.find("RootNodeId") != m.end() && !m["RootNodeId"].empty()) {
      rootNodeId = make_shared<string>(boost::any_cast<string>(m["RootNodeId"]));
    }
    if (m.find("TeamId") != m.end() && !m["TeamId"].empty()) {
      teamId = make_shared<string>(boost::any_cast<string>(m["TeamId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListWorkspacesResponseBodyWorkspaces() = default;
};
class ListWorkspacesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListWorkspacesResponseBodyWorkspaces>> workspaces{};

  ListWorkspacesResponseBody() {}

  explicit ListWorkspacesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (workspaces) {
      vector<boost::any> temp1;
      for(auto item1:*workspaces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["workspaces"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("workspaces") != m.end() && !m["workspaces"].empty()) {
      if (typeid(vector<boost::any>) == m["workspaces"].type()) {
        vector<ListWorkspacesResponseBodyWorkspaces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["workspaces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWorkspacesResponseBodyWorkspaces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workspaces = make_shared<vector<ListWorkspacesResponseBodyWorkspaces>>(expect1);
      }
    }
  }


  virtual ~ListWorkspacesResponseBody() = default;
};
class ListWorkspacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWorkspacesResponseBody> body{};

  ListWorkspacesResponse() {}

  explicit ListWorkspacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWorkspacesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWorkspacesResponseBody>(model1);
      }
    }
  }


  virtual ~ListWorkspacesResponse() = default;
};
class PatchEventHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  PatchEventHeadersAccountContext() {}

  explicit PatchEventHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~PatchEventHeadersAccountContext() = default;
};
class PatchEventHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<PatchEventHeadersAccountContext> accountContext{};

  PatchEventHeaders() {}

  explicit PatchEventHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        PatchEventHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<PatchEventHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~PatchEventHeaders() = default;
};
class PatchEventShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  PatchEventShrinkHeaders() {}

  explicit PatchEventShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~PatchEventShrinkHeaders() = default;
};
class PatchEventRequestAttendees : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<bool> isOptional{};

  PatchEventRequestAttendees() {}

  explicit PatchEventRequestAttendees(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isOptional) {
      res["isOptional"] = boost::any(*isOptional);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("isOptional") != m.end() && !m["isOptional"].empty()) {
      isOptional = make_shared<bool>(boost::any_cast<bool>(m["isOptional"]));
    }
  }


  virtual ~PatchEventRequestAttendees() = default;
};
class PatchEventRequestCardInstances : public Darabonba::Model {
public:
  shared_ptr<string> outTrackId{};
  shared_ptr<string> scenario{};

  PatchEventRequestCardInstances() {}

  explicit PatchEventRequestCardInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outTrackId) {
      res["OutTrackId"] = boost::any(*outTrackId);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutTrackId") != m.end() && !m["OutTrackId"].empty()) {
      outTrackId = make_shared<string>(boost::any_cast<string>(m["OutTrackId"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
  }


  virtual ~PatchEventRequestCardInstances() = default;
};
class PatchEventRequestEnd : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  PatchEventRequestEnd() {}

  explicit PatchEventRequestEnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["date"] = boost::any(*date);
    }
    if (dateTime) {
      res["dateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["timeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("date") != m.end() && !m["date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["date"]));
    }
    if (m.find("dateTime") != m.end() && !m["dateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["dateTime"]));
    }
    if (m.find("timeZone") != m.end() && !m["timeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["timeZone"]));
    }
  }


  virtual ~PatchEventRequestEnd() = default;
};
class PatchEventRequestLocation : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};

  PatchEventRequestLocation() {}

  explicit PatchEventRequestLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["displayName"] = boost::any(*displayName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("displayName") != m.end() && !m["displayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["displayName"]));
    }
  }


  virtual ~PatchEventRequestLocation() = default;
};
class PatchEventRequestRecurrencePattern : public Darabonba::Model {
public:
  shared_ptr<long> dayOfMonth{};
  shared_ptr<string> daysOfWeek{};
  shared_ptr<string> index{};
  shared_ptr<long> interval{};
  shared_ptr<string> type{};

  PatchEventRequestRecurrencePattern() {}

  explicit PatchEventRequestRecurrencePattern(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dayOfMonth) {
      res["dayOfMonth"] = boost::any(*dayOfMonth);
    }
    if (daysOfWeek) {
      res["daysOfWeek"] = boost::any(*daysOfWeek);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (interval) {
      res["interval"] = boost::any(*interval);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dayOfMonth") != m.end() && !m["dayOfMonth"].empty()) {
      dayOfMonth = make_shared<long>(boost::any_cast<long>(m["dayOfMonth"]));
    }
    if (m.find("daysOfWeek") != m.end() && !m["daysOfWeek"].empty()) {
      daysOfWeek = make_shared<string>(boost::any_cast<string>(m["daysOfWeek"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("interval") != m.end() && !m["interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["interval"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~PatchEventRequestRecurrencePattern() = default;
};
class PatchEventRequestRecurrenceRange : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<long> numberOfOccurrences{};
  shared_ptr<string> type{};

  PatchEventRequestRecurrenceRange() {}

  explicit PatchEventRequestRecurrenceRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["endDate"] = boost::any(*endDate);
    }
    if (numberOfOccurrences) {
      res["numberOfOccurrences"] = boost::any(*numberOfOccurrences);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endDate") != m.end() && !m["endDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["endDate"]));
    }
    if (m.find("numberOfOccurrences") != m.end() && !m["numberOfOccurrences"].empty()) {
      numberOfOccurrences = make_shared<long>(boost::any_cast<long>(m["numberOfOccurrences"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~PatchEventRequestRecurrenceRange() = default;
};
class PatchEventRequestRecurrence : public Darabonba::Model {
public:
  shared_ptr<PatchEventRequestRecurrencePattern> pattern{};
  shared_ptr<PatchEventRequestRecurrenceRange> range{};

  PatchEventRequestRecurrence() {}

  explicit PatchEventRequestRecurrence(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pattern) {
      res["pattern"] = pattern ? boost::any(pattern->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (range) {
      res["range"] = range ? boost::any(range->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("pattern") != m.end() && !m["pattern"].empty()) {
      if (typeid(map<string, boost::any>) == m["pattern"].type()) {
        PatchEventRequestRecurrencePattern model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["pattern"]));
        pattern = make_shared<PatchEventRequestRecurrencePattern>(model1);
      }
    }
    if (m.find("range") != m.end() && !m["range"].empty()) {
      if (typeid(map<string, boost::any>) == m["range"].type()) {
        PatchEventRequestRecurrenceRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["range"]));
        range = make_shared<PatchEventRequestRecurrenceRange>(model1);
      }
    }
  }


  virtual ~PatchEventRequestRecurrence() = default;
};
class PatchEventRequestReminders : public Darabonba::Model {
public:
  shared_ptr<string> method{};
  shared_ptr<long> minutes{};

  PatchEventRequestReminders() {}

  explicit PatchEventRequestReminders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["method"] = boost::any(*method);
    }
    if (minutes) {
      res["minutes"] = boost::any(*minutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("method") != m.end() && !m["method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["method"]));
    }
    if (m.find("minutes") != m.end() && !m["minutes"].empty()) {
      minutes = make_shared<long>(boost::any_cast<long>(m["minutes"]));
    }
  }


  virtual ~PatchEventRequestReminders() = default;
};
class PatchEventRequestStart : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  PatchEventRequestStart() {}

  explicit PatchEventRequestStart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["date"] = boost::any(*date);
    }
    if (dateTime) {
      res["dateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["timeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("date") != m.end() && !m["date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["date"]));
    }
    if (m.find("dateTime") != m.end() && !m["dateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["dateTime"]));
    }
    if (m.find("timeZone") != m.end() && !m["timeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["timeZone"]));
    }
  }


  virtual ~PatchEventRequestStart() = default;
};
class PatchEventRequest : public Darabonba::Model {
public:
  shared_ptr<vector<PatchEventRequestAttendees>> attendees{};
  shared_ptr<string> calendarId{};
  shared_ptr<vector<PatchEventRequestCardInstances>> cardInstances{};
  shared_ptr<string> description{};
  shared_ptr<PatchEventRequestEnd> end{};
  shared_ptr<string> eventId{};
  shared_ptr<map<string, string>> extra{};
  shared_ptr<bool> isAllDay{};
  shared_ptr<PatchEventRequestLocation> location{};
  shared_ptr<PatchEventRequestRecurrence> recurrence{};
  shared_ptr<vector<PatchEventRequestReminders>> reminders{};
  shared_ptr<PatchEventRequestStart> start{};
  shared_ptr<string> summary{};

  PatchEventRequest() {}

  explicit PatchEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendees) {
      vector<boost::any> temp1;
      for(auto item1:*attendees){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attendees"] = boost::any(temp1);
    }
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (cardInstances) {
      vector<boost::any> temp1;
      for(auto item1:*cardInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CardInstances"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (end) {
      res["End"] = end ? boost::any(end->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (isAllDay) {
      res["IsAllDay"] = boost::any(*isAllDay);
    }
    if (location) {
      res["Location"] = location ? boost::any(location->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recurrence) {
      res["Recurrence"] = recurrence ? boost::any(recurrence->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reminders) {
      vector<boost::any> temp1;
      for(auto item1:*reminders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Reminders"] = boost::any(temp1);
    }
    if (start) {
      res["Start"] = start ? boost::any(start->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attendees") != m.end() && !m["Attendees"].empty()) {
      if (typeid(vector<boost::any>) == m["Attendees"].type()) {
        vector<PatchEventRequestAttendees> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attendees"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PatchEventRequestAttendees model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attendees = make_shared<vector<PatchEventRequestAttendees>>(expect1);
      }
    }
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("CardInstances") != m.end() && !m["CardInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["CardInstances"].type()) {
        vector<PatchEventRequestCardInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CardInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PatchEventRequestCardInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cardInstances = make_shared<vector<PatchEventRequestCardInstances>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      if (typeid(map<string, boost::any>) == m["End"].type()) {
        PatchEventRequestEnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["End"]));
        end = make_shared<PatchEventRequestEnd>(model1);
      }
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Extra"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extra = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("IsAllDay") != m.end() && !m["IsAllDay"].empty()) {
      isAllDay = make_shared<bool>(boost::any_cast<bool>(m["IsAllDay"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      if (typeid(map<string, boost::any>) == m["Location"].type()) {
        PatchEventRequestLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Location"]));
        location = make_shared<PatchEventRequestLocation>(model1);
      }
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      if (typeid(map<string, boost::any>) == m["Recurrence"].type()) {
        PatchEventRequestRecurrence model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Recurrence"]));
        recurrence = make_shared<PatchEventRequestRecurrence>(model1);
      }
    }
    if (m.find("Reminders") != m.end() && !m["Reminders"].empty()) {
      if (typeid(vector<boost::any>) == m["Reminders"].type()) {
        vector<PatchEventRequestReminders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Reminders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PatchEventRequestReminders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reminders = make_shared<vector<PatchEventRequestReminders>>(expect1);
      }
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      if (typeid(map<string, boost::any>) == m["Start"].type()) {
        PatchEventRequestStart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Start"]));
        start = make_shared<PatchEventRequestStart>(model1);
      }
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~PatchEventRequest() = default;
};
class PatchEventShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> attendeesShrink{};
  shared_ptr<string> calendarId{};
  shared_ptr<string> cardInstancesShrink{};
  shared_ptr<string> description{};
  shared_ptr<string> endShrink{};
  shared_ptr<string> eventId{};
  shared_ptr<string> extraShrink{};
  shared_ptr<bool> isAllDay{};
  shared_ptr<string> locationShrink{};
  shared_ptr<string> recurrenceShrink{};
  shared_ptr<string> remindersShrink{};
  shared_ptr<string> startShrink{};
  shared_ptr<string> summary{};

  PatchEventShrinkRequest() {}

  explicit PatchEventShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendeesShrink) {
      res["Attendees"] = boost::any(*attendeesShrink);
    }
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (cardInstancesShrink) {
      res["CardInstances"] = boost::any(*cardInstancesShrink);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endShrink) {
      res["End"] = boost::any(*endShrink);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (extraShrink) {
      res["Extra"] = boost::any(*extraShrink);
    }
    if (isAllDay) {
      res["IsAllDay"] = boost::any(*isAllDay);
    }
    if (locationShrink) {
      res["Location"] = boost::any(*locationShrink);
    }
    if (recurrenceShrink) {
      res["Recurrence"] = boost::any(*recurrenceShrink);
    }
    if (remindersShrink) {
      res["Reminders"] = boost::any(*remindersShrink);
    }
    if (startShrink) {
      res["Start"] = boost::any(*startShrink);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attendees") != m.end() && !m["Attendees"].empty()) {
      attendeesShrink = make_shared<string>(boost::any_cast<string>(m["Attendees"]));
    }
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("CardInstances") != m.end() && !m["CardInstances"].empty()) {
      cardInstancesShrink = make_shared<string>(boost::any_cast<string>(m["CardInstances"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      endShrink = make_shared<string>(boost::any_cast<string>(m["End"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extraShrink = make_shared<string>(boost::any_cast<string>(m["Extra"]));
    }
    if (m.find("IsAllDay") != m.end() && !m["IsAllDay"].empty()) {
      isAllDay = make_shared<bool>(boost::any_cast<bool>(m["IsAllDay"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      locationShrink = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrenceShrink = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("Reminders") != m.end() && !m["Reminders"].empty()) {
      remindersShrink = make_shared<string>(boost::any_cast<string>(m["Reminders"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      startShrink = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~PatchEventShrinkRequest() = default;
};
class PatchEventResponseBodyAttendees : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> id{};
  shared_ptr<bool> isOptional{};
  shared_ptr<string> responseStatus{};
  shared_ptr<bool> self{};

  PatchEventResponseBodyAttendees() {}

  explicit PatchEventResponseBodyAttendees(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isOptional) {
      res["IsOptional"] = boost::any(*isOptional);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (self) {
      res["Self"] = boost::any(*self);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IsOptional") != m.end() && !m["IsOptional"].empty()) {
      isOptional = make_shared<bool>(boost::any_cast<bool>(m["IsOptional"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("Self") != m.end() && !m["Self"].empty()) {
      self = make_shared<bool>(boost::any_cast<bool>(m["Self"]));
    }
  }


  virtual ~PatchEventResponseBodyAttendees() = default;
};
class PatchEventResponseBodyEnd : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  PatchEventResponseBodyEnd() {}

  explicit PatchEventResponseBodyEnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~PatchEventResponseBodyEnd() = default;
};
class PatchEventResponseBodyLocation : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<vector<string>> meetingRooms{};

  PatchEventResponseBodyLocation() {}

  explicit PatchEventResponseBodyLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (meetingRooms) {
      res["MeetingRooms"] = boost::any(*meetingRooms);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("MeetingRooms") != m.end() && !m["MeetingRooms"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MeetingRooms"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MeetingRooms"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      meetingRooms = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~PatchEventResponseBodyLocation() = default;
};
class PatchEventResponseBodyOrganizer : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> id{};
  shared_ptr<string> responseStatus{};
  shared_ptr<bool> self{};

  PatchEventResponseBodyOrganizer() {}

  explicit PatchEventResponseBodyOrganizer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (self) {
      res["Self"] = boost::any(*self);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("Self") != m.end() && !m["Self"].empty()) {
      self = make_shared<bool>(boost::any_cast<bool>(m["Self"]));
    }
  }


  virtual ~PatchEventResponseBodyOrganizer() = default;
};
class PatchEventResponseBodyRecurrencePattern : public Darabonba::Model {
public:
  shared_ptr<long> dayOfMonth{};
  shared_ptr<string> daysOfWeek{};
  shared_ptr<string> index{};
  shared_ptr<long> interval{};
  shared_ptr<string> type{};

  PatchEventResponseBodyRecurrencePattern() {}

  explicit PatchEventResponseBodyRecurrencePattern(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dayOfMonth) {
      res["DayOfMonth"] = boost::any(*dayOfMonth);
    }
    if (daysOfWeek) {
      res["DaysOfWeek"] = boost::any(*daysOfWeek);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DayOfMonth") != m.end() && !m["DayOfMonth"].empty()) {
      dayOfMonth = make_shared<long>(boost::any_cast<long>(m["DayOfMonth"]));
    }
    if (m.find("DaysOfWeek") != m.end() && !m["DaysOfWeek"].empty()) {
      daysOfWeek = make_shared<string>(boost::any_cast<string>(m["DaysOfWeek"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~PatchEventResponseBodyRecurrencePattern() = default;
};
class PatchEventResponseBodyRecurrenceRange : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<long> numberOfOccurrences{};
  shared_ptr<string> type{};

  PatchEventResponseBodyRecurrenceRange() {}

  explicit PatchEventResponseBodyRecurrenceRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (numberOfOccurrences) {
      res["NumberOfOccurrences"] = boost::any(*numberOfOccurrences);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("NumberOfOccurrences") != m.end() && !m["NumberOfOccurrences"].empty()) {
      numberOfOccurrences = make_shared<long>(boost::any_cast<long>(m["NumberOfOccurrences"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~PatchEventResponseBodyRecurrenceRange() = default;
};
class PatchEventResponseBodyRecurrence : public Darabonba::Model {
public:
  shared_ptr<PatchEventResponseBodyRecurrencePattern> pattern{};
  shared_ptr<PatchEventResponseBodyRecurrenceRange> range{};

  PatchEventResponseBodyRecurrence() {}

  explicit PatchEventResponseBodyRecurrence(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pattern) {
      res["Pattern"] = pattern ? boost::any(pattern->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (range) {
      res["Range"] = range ? boost::any(range->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pattern"].type()) {
        PatchEventResponseBodyRecurrencePattern model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pattern"]));
        pattern = make_shared<PatchEventResponseBodyRecurrencePattern>(model1);
      }
    }
    if (m.find("Range") != m.end() && !m["Range"].empty()) {
      if (typeid(map<string, boost::any>) == m["Range"].type()) {
        PatchEventResponseBodyRecurrenceRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Range"]));
        range = make_shared<PatchEventResponseBodyRecurrenceRange>(model1);
      }
    }
  }


  virtual ~PatchEventResponseBodyRecurrence() = default;
};
class PatchEventResponseBodyReminders : public Darabonba::Model {
public:
  shared_ptr<string> method{};
  shared_ptr<string> minutes{};

  PatchEventResponseBodyReminders() {}

  explicit PatchEventResponseBodyReminders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (minutes) {
      res["Minutes"] = boost::any(*minutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Minutes") != m.end() && !m["Minutes"].empty()) {
      minutes = make_shared<string>(boost::any_cast<string>(m["Minutes"]));
    }
  }


  virtual ~PatchEventResponseBodyReminders() = default;
};
class PatchEventResponseBodyStart : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  PatchEventResponseBodyStart() {}

  explicit PatchEventResponseBodyStart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~PatchEventResponseBodyStart() = default;
};
class PatchEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<PatchEventResponseBodyAttendees>> attendees{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<PatchEventResponseBodyEnd> end{};
  shared_ptr<string> id{};
  shared_ptr<bool> isAllDay{};
  shared_ptr<PatchEventResponseBodyLocation> location{};
  shared_ptr<PatchEventResponseBodyOrganizer> organizer{};
  shared_ptr<PatchEventResponseBodyRecurrence> recurrence{};
  shared_ptr<vector<PatchEventResponseBodyReminders>> reminders{};
  shared_ptr<string> requestId{};
  shared_ptr<PatchEventResponseBodyStart> start{};
  shared_ptr<string> summary{};
  shared_ptr<string> updateTime{};

  PatchEventResponseBody() {}

  explicit PatchEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendees) {
      vector<boost::any> temp1;
      for(auto item1:*attendees){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["attendees"] = boost::any(temp1);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (end) {
      res["end"] = end ? boost::any(end->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isAllDay) {
      res["isAllDay"] = boost::any(*isAllDay);
    }
    if (location) {
      res["location"] = location ? boost::any(location->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (organizer) {
      res["organizer"] = organizer ? boost::any(organizer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recurrence) {
      res["recurrence"] = recurrence ? boost::any(recurrence->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reminders) {
      vector<boost::any> temp1;
      for(auto item1:*reminders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["reminders"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (start) {
      res["start"] = start ? boost::any(start->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (summary) {
      res["summary"] = boost::any(*summary);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("attendees") != m.end() && !m["attendees"].empty()) {
      if (typeid(vector<boost::any>) == m["attendees"].type()) {
        vector<PatchEventResponseBodyAttendees> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["attendees"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PatchEventResponseBodyAttendees model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attendees = make_shared<vector<PatchEventResponseBodyAttendees>>(expect1);
      }
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("end") != m.end() && !m["end"].empty()) {
      if (typeid(map<string, boost::any>) == m["end"].type()) {
        PatchEventResponseBodyEnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["end"]));
        end = make_shared<PatchEventResponseBodyEnd>(model1);
      }
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("isAllDay") != m.end() && !m["isAllDay"].empty()) {
      isAllDay = make_shared<bool>(boost::any_cast<bool>(m["isAllDay"]));
    }
    if (m.find("location") != m.end() && !m["location"].empty()) {
      if (typeid(map<string, boost::any>) == m["location"].type()) {
        PatchEventResponseBodyLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["location"]));
        location = make_shared<PatchEventResponseBodyLocation>(model1);
      }
    }
    if (m.find("organizer") != m.end() && !m["organizer"].empty()) {
      if (typeid(map<string, boost::any>) == m["organizer"].type()) {
        PatchEventResponseBodyOrganizer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["organizer"]));
        organizer = make_shared<PatchEventResponseBodyOrganizer>(model1);
      }
    }
    if (m.find("recurrence") != m.end() && !m["recurrence"].empty()) {
      if (typeid(map<string, boost::any>) == m["recurrence"].type()) {
        PatchEventResponseBodyRecurrence model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["recurrence"]));
        recurrence = make_shared<PatchEventResponseBodyRecurrence>(model1);
      }
    }
    if (m.find("reminders") != m.end() && !m["reminders"].empty()) {
      if (typeid(vector<boost::any>) == m["reminders"].type()) {
        vector<PatchEventResponseBodyReminders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["reminders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PatchEventResponseBodyReminders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reminders = make_shared<vector<PatchEventResponseBodyReminders>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("start") != m.end() && !m["start"].empty()) {
      if (typeid(map<string, boost::any>) == m["start"].type()) {
        PatchEventResponseBodyStart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["start"]));
        start = make_shared<PatchEventResponseBodyStart>(model1);
      }
    }
    if (m.find("summary") != m.end() && !m["summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["summary"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["updateTime"]));
    }
  }


  virtual ~PatchEventResponseBody() = default;
};
class PatchEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PatchEventResponseBody> body{};

  PatchEventResponse() {}

  explicit PatchEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PatchEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PatchEventResponseBody>(model1);
      }
    }
  }


  virtual ~PatchEventResponse() = default;
};
class QueryCloudRecordTextHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryCloudRecordTextHeadersAccountContext() {}

  explicit QueryCloudRecordTextHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryCloudRecordTextHeadersAccountContext() = default;
};
class QueryCloudRecordTextHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryCloudRecordTextHeadersAccountContext> accountContext{};

  QueryCloudRecordTextHeaders() {}

  explicit QueryCloudRecordTextHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryCloudRecordTextHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryCloudRecordTextHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryCloudRecordTextHeaders() = default;
};
class QueryCloudRecordTextShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryCloudRecordTextShrinkHeaders() {}

  explicit QueryCloudRecordTextShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryCloudRecordTextShrinkHeaders() = default;
};
class QueryCloudRecordTextRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryCloudRecordTextRequestTenantContext() {}

  explicit QueryCloudRecordTextRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryCloudRecordTextRequestTenantContext() = default;
};
class QueryCloudRecordTextRequest : public Darabonba::Model {
public:
  shared_ptr<string> direction{};
  shared_ptr<long> maxResults{};
  shared_ptr<long> nextToken{};
  shared_ptr<long> startTime{};
  shared_ptr<QueryCloudRecordTextRequestTenantContext> tenantContext{};
  shared_ptr<string> conferenceId{};

  QueryCloudRecordTextRequest() {}

  explicit QueryCloudRecordTextRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryCloudRecordTextRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryCloudRecordTextRequestTenantContext>(model1);
      }
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~QueryCloudRecordTextRequest() = default;
};
class QueryCloudRecordTextShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> direction{};
  shared_ptr<long> maxResults{};
  shared_ptr<long> nextToken{};
  shared_ptr<long> startTime{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> conferenceId{};

  QueryCloudRecordTextShrinkRequest() {}

  explicit QueryCloudRecordTextShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~QueryCloudRecordTextShrinkRequest() = default;
};
class QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<string> word{};
  shared_ptr<string> wordId{};

  QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList() {}

  explicit QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (word) {
      res["Word"] = boost::any(*word);
    }
    if (wordId) {
      res["WordId"] = boost::any(*wordId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Word") != m.end() && !m["Word"].empty()) {
      word = make_shared<string>(boost::any_cast<string>(m["Word"]));
    }
    if (m.find("WordId") != m.end() && !m["WordId"].empty()) {
      wordId = make_shared<string>(boost::any_cast<string>(m["WordId"]));
    }
  }


  virtual ~QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList() = default;
};
class QueryCloudRecordTextResponseBodyParagraphListSentenceList : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> sentence{};
  shared_ptr<long> startTime{};
  shared_ptr<string> userId{};
  shared_ptr<vector<QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList>> wordList{};

  QueryCloudRecordTextResponseBodyParagraphListSentenceList() {}

  explicit QueryCloudRecordTextResponseBodyParagraphListSentenceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (sentence) {
      res["Sentence"] = boost::any(*sentence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (wordList) {
      vector<boost::any> temp1;
      for(auto item1:*wordList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WordList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Sentence") != m.end() && !m["Sentence"].empty()) {
      sentence = make_shared<string>(boost::any_cast<string>(m["Sentence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WordList") != m.end() && !m["WordList"].empty()) {
      if (typeid(vector<boost::any>) == m["WordList"].type()) {
        vector<QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WordList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wordList = make_shared<vector<QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList>>(expect1);
      }
    }
  }


  virtual ~QueryCloudRecordTextResponseBodyParagraphListSentenceList() = default;
};
class QueryCloudRecordTextResponseBodyParagraphList : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> nextTtoken{};
  shared_ptr<string> nickName{};
  shared_ptr<string> paragraph{};
  shared_ptr<long> recordId{};
  shared_ptr<vector<QueryCloudRecordTextResponseBodyParagraphListSentenceList>> sentenceList{};
  shared_ptr<long> startTime{};
  shared_ptr<long> status{};
  shared_ptr<string> userId{};

  QueryCloudRecordTextResponseBodyParagraphList() {}

  explicit QueryCloudRecordTextResponseBodyParagraphList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (nextTtoken) {
      res["NextTtoken"] = boost::any(*nextTtoken);
    }
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (paragraph) {
      res["Paragraph"] = boost::any(*paragraph);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (sentenceList) {
      vector<boost::any> temp1;
      for(auto item1:*sentenceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SentenceList"] = boost::any(temp1);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("NextTtoken") != m.end() && !m["NextTtoken"].empty()) {
      nextTtoken = make_shared<long>(boost::any_cast<long>(m["NextTtoken"]));
    }
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("Paragraph") != m.end() && !m["Paragraph"].empty()) {
      paragraph = make_shared<string>(boost::any_cast<string>(m["Paragraph"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<long>(boost::any_cast<long>(m["RecordId"]));
    }
    if (m.find("SentenceList") != m.end() && !m["SentenceList"].empty()) {
      if (typeid(vector<boost::any>) == m["SentenceList"].type()) {
        vector<QueryCloudRecordTextResponseBodyParagraphListSentenceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SentenceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCloudRecordTextResponseBodyParagraphListSentenceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sentenceList = make_shared<vector<QueryCloudRecordTextResponseBodyParagraphListSentenceList>>(expect1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryCloudRecordTextResponseBodyParagraphList() = default;
};
class QueryCloudRecordTextResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> hasMore{};
  shared_ptr<vector<QueryCloudRecordTextResponseBodyParagraphList>> paragraphList{};
  shared_ptr<string> requestId{};

  QueryCloudRecordTextResponseBody() {}

  explicit QueryCloudRecordTextResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasMore) {
      res["hasMore"] = boost::any(*hasMore);
    }
    if (paragraphList) {
      vector<boost::any> temp1;
      for(auto item1:*paragraphList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["paragraphList"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hasMore") != m.end() && !m["hasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["hasMore"]));
    }
    if (m.find("paragraphList") != m.end() && !m["paragraphList"].empty()) {
      if (typeid(vector<boost::any>) == m["paragraphList"].type()) {
        vector<QueryCloudRecordTextResponseBodyParagraphList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["paragraphList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCloudRecordTextResponseBodyParagraphList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        paragraphList = make_shared<vector<QueryCloudRecordTextResponseBodyParagraphList>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~QueryCloudRecordTextResponseBody() = default;
};
class QueryCloudRecordTextResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryCloudRecordTextResponseBody> body{};

  QueryCloudRecordTextResponse() {}

  explicit QueryCloudRecordTextResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCloudRecordTextResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCloudRecordTextResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCloudRecordTextResponse() = default;
};
class QueryCloudRecordVideoHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryCloudRecordVideoHeadersAccountContext() {}

  explicit QueryCloudRecordVideoHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryCloudRecordVideoHeadersAccountContext() = default;
};
class QueryCloudRecordVideoHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryCloudRecordVideoHeadersAccountContext> accountContext{};

  QueryCloudRecordVideoHeaders() {}

  explicit QueryCloudRecordVideoHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryCloudRecordVideoHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryCloudRecordVideoHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryCloudRecordVideoHeaders() = default;
};
class QueryCloudRecordVideoShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryCloudRecordVideoShrinkHeaders() {}

  explicit QueryCloudRecordVideoShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryCloudRecordVideoShrinkHeaders() = default;
};
class QueryCloudRecordVideoRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryCloudRecordVideoRequestTenantContext() {}

  explicit QueryCloudRecordVideoRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryCloudRecordVideoRequestTenantContext() = default;
};
class QueryCloudRecordVideoRequest : public Darabonba::Model {
public:
  shared_ptr<QueryCloudRecordVideoRequestTenantContext> tenantContext{};
  shared_ptr<string> conferenceId{};

  QueryCloudRecordVideoRequest() {}

  explicit QueryCloudRecordVideoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryCloudRecordVideoRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryCloudRecordVideoRequestTenantContext>(model1);
      }
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~QueryCloudRecordVideoRequest() = default;
};
class QueryCloudRecordVideoShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> conferenceId{};

  QueryCloudRecordVideoShrinkRequest() {}

  explicit QueryCloudRecordVideoShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~QueryCloudRecordVideoShrinkRequest() = default;
};
class QueryCloudRecordVideoResponseBodyVideoList : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<long> endTime{};
  shared_ptr<long> fileSize{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> recordId{};
  shared_ptr<long> recordType{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> userId{};

  QueryCloudRecordVideoResponseBodyVideoList() {}

  explicit QueryCloudRecordVideoResponseBodyVideoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (recordType) {
      res["RecordType"] = boost::any(*recordType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["FileSize"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("RecordType") != m.end() && !m["RecordType"].empty()) {
      recordType = make_shared<long>(boost::any_cast<long>(m["RecordType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryCloudRecordVideoResponseBodyVideoList() = default;
};
class QueryCloudRecordVideoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<QueryCloudRecordVideoResponseBodyVideoList>> videoList{};

  QueryCloudRecordVideoResponseBody() {}

  explicit QueryCloudRecordVideoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (videoList) {
      vector<boost::any> temp1;
      for(auto item1:*videoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["videoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("videoList") != m.end() && !m["videoList"].empty()) {
      if (typeid(vector<boost::any>) == m["videoList"].type()) {
        vector<QueryCloudRecordVideoResponseBodyVideoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["videoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCloudRecordVideoResponseBodyVideoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoList = make_shared<vector<QueryCloudRecordVideoResponseBodyVideoList>>(expect1);
      }
    }
  }


  virtual ~QueryCloudRecordVideoResponseBody() = default;
};
class QueryCloudRecordVideoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryCloudRecordVideoResponseBody> body{};

  QueryCloudRecordVideoResponse() {}

  explicit QueryCloudRecordVideoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCloudRecordVideoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCloudRecordVideoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCloudRecordVideoResponse() = default;
};
class QueryCloudRecordVideoPlayInfoHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryCloudRecordVideoPlayInfoHeadersAccountContext() {}

  explicit QueryCloudRecordVideoPlayInfoHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryCloudRecordVideoPlayInfoHeadersAccountContext() = default;
};
class QueryCloudRecordVideoPlayInfoHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryCloudRecordVideoPlayInfoHeadersAccountContext> accountContext{};

  QueryCloudRecordVideoPlayInfoHeaders() {}

  explicit QueryCloudRecordVideoPlayInfoHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryCloudRecordVideoPlayInfoHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryCloudRecordVideoPlayInfoHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryCloudRecordVideoPlayInfoHeaders() = default;
};
class QueryCloudRecordVideoPlayInfoShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryCloudRecordVideoPlayInfoShrinkHeaders() {}

  explicit QueryCloudRecordVideoPlayInfoShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryCloudRecordVideoPlayInfoShrinkHeaders() = default;
};
class QueryCloudRecordVideoPlayInfoRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryCloudRecordVideoPlayInfoRequestTenantContext() {}

  explicit QueryCloudRecordVideoPlayInfoRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryCloudRecordVideoPlayInfoRequestTenantContext() = default;
};
class QueryCloudRecordVideoPlayInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> conferenceId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> regionId{};
  shared_ptr<QueryCloudRecordVideoPlayInfoRequestTenantContext> tenantContext{};

  QueryCloudRecordVideoPlayInfoRequest() {}

  explicit QueryCloudRecordVideoPlayInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conferenceId) {
      res["ConferenceId"] = boost::any(*conferenceId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConferenceId") != m.end() && !m["ConferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["ConferenceId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryCloudRecordVideoPlayInfoRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryCloudRecordVideoPlayInfoRequestTenantContext>(model1);
      }
    }
  }


  virtual ~QueryCloudRecordVideoPlayInfoRequest() = default;
};
class QueryCloudRecordVideoPlayInfoShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> conferenceId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> tenantContextShrink{};

  QueryCloudRecordVideoPlayInfoShrinkRequest() {}

  explicit QueryCloudRecordVideoPlayInfoShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conferenceId) {
      res["ConferenceId"] = boost::any(*conferenceId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConferenceId") != m.end() && !m["ConferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["ConferenceId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~QueryCloudRecordVideoPlayInfoShrinkRequest() = default;
};
class QueryCloudRecordVideoPlayInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<long> fileSize{};
  shared_ptr<string> mp4FileUrl{};
  shared_ptr<string> playUrl{};
  shared_ptr<string> requestId{};
  shared_ptr<long> status{};

  QueryCloudRecordVideoPlayInfoResponseBody() {}

  explicit QueryCloudRecordVideoPlayInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["duration"] = boost::any(*duration);
    }
    if (fileSize) {
      res["fileSize"] = boost::any(*fileSize);
    }
    if (mp4FileUrl) {
      res["mp4FileUrl"] = boost::any(*mp4FileUrl);
    }
    if (playUrl) {
      res["playUrl"] = boost::any(*playUrl);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("duration") != m.end() && !m["duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["duration"]));
    }
    if (m.find("fileSize") != m.end() && !m["fileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["fileSize"]));
    }
    if (m.find("mp4FileUrl") != m.end() && !m["mp4FileUrl"].empty()) {
      mp4FileUrl = make_shared<string>(boost::any_cast<string>(m["mp4FileUrl"]));
    }
    if (m.find("playUrl") != m.end() && !m["playUrl"].empty()) {
      playUrl = make_shared<string>(boost::any_cast<string>(m["playUrl"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
  }


  virtual ~QueryCloudRecordVideoPlayInfoResponseBody() = default;
};
class QueryCloudRecordVideoPlayInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryCloudRecordVideoPlayInfoResponseBody> body{};

  QueryCloudRecordVideoPlayInfoResponse() {}

  explicit QueryCloudRecordVideoPlayInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCloudRecordVideoPlayInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCloudRecordVideoPlayInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCloudRecordVideoPlayInfoResponse() = default;
};
class QueryConferenceInfoHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryConferenceInfoHeadersAccountContext() {}

  explicit QueryConferenceInfoHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryConferenceInfoHeadersAccountContext() = default;
};
class QueryConferenceInfoHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryConferenceInfoHeadersAccountContext> accountContext{};

  QueryConferenceInfoHeaders() {}

  explicit QueryConferenceInfoHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryConferenceInfoHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryConferenceInfoHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryConferenceInfoHeaders() = default;
};
class QueryConferenceInfoShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryConferenceInfoShrinkHeaders() {}

  explicit QueryConferenceInfoShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryConferenceInfoShrinkHeaders() = default;
};
class QueryConferenceInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> conferenceId{};

  QueryConferenceInfoRequest() {}

  explicit QueryConferenceInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~QueryConferenceInfoRequest() = default;
};
class QueryConferenceInfoResponseBodyConfInfo : public Darabonba::Model {
public:
  shared_ptr<long> activeNum{};
  shared_ptr<long> attendNum{};
  shared_ptr<long> confDuration{};
  shared_ptr<string> conferenceId{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> creatorNick{};
  shared_ptr<long> endTime{};
  shared_ptr<string> externalLinkUrl{};
  shared_ptr<long> invitedNum{};
  shared_ptr<string> roomCode{};
  shared_ptr<long> startTime{};
  shared_ptr<long> status{};
  shared_ptr<string> title{};

  QueryConferenceInfoResponseBodyConfInfo() {}

  explicit QueryConferenceInfoResponseBodyConfInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeNum) {
      res["ActiveNum"] = boost::any(*activeNum);
    }
    if (attendNum) {
      res["AttendNum"] = boost::any(*attendNum);
    }
    if (confDuration) {
      res["ConfDuration"] = boost::any(*confDuration);
    }
    if (conferenceId) {
      res["ConferenceId"] = boost::any(*conferenceId);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (creatorNick) {
      res["CreatorNick"] = boost::any(*creatorNick);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (externalLinkUrl) {
      res["ExternalLinkUrl"] = boost::any(*externalLinkUrl);
    }
    if (invitedNum) {
      res["InvitedNum"] = boost::any(*invitedNum);
    }
    if (roomCode) {
      res["RoomCode"] = boost::any(*roomCode);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveNum") != m.end() && !m["ActiveNum"].empty()) {
      activeNum = make_shared<long>(boost::any_cast<long>(m["ActiveNum"]));
    }
    if (m.find("AttendNum") != m.end() && !m["AttendNum"].empty()) {
      attendNum = make_shared<long>(boost::any_cast<long>(m["AttendNum"]));
    }
    if (m.find("ConfDuration") != m.end() && !m["ConfDuration"].empty()) {
      confDuration = make_shared<long>(boost::any_cast<long>(m["ConfDuration"]));
    }
    if (m.find("ConferenceId") != m.end() && !m["ConferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["ConferenceId"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("CreatorNick") != m.end() && !m["CreatorNick"].empty()) {
      creatorNick = make_shared<string>(boost::any_cast<string>(m["CreatorNick"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ExternalLinkUrl") != m.end() && !m["ExternalLinkUrl"].empty()) {
      externalLinkUrl = make_shared<string>(boost::any_cast<string>(m["ExternalLinkUrl"]));
    }
    if (m.find("InvitedNum") != m.end() && !m["InvitedNum"].empty()) {
      invitedNum = make_shared<long>(boost::any_cast<long>(m["InvitedNum"]));
    }
    if (m.find("RoomCode") != m.end() && !m["RoomCode"].empty()) {
      roomCode = make_shared<string>(boost::any_cast<string>(m["RoomCode"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~QueryConferenceInfoResponseBodyConfInfo() = default;
};
class QueryConferenceInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryConferenceInfoResponseBodyConfInfo> confInfo{};
  shared_ptr<string> requestId{};

  QueryConferenceInfoResponseBody() {}

  explicit QueryConferenceInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (confInfo) {
      res["confInfo"] = confInfo ? boost::any(confInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("confInfo") != m.end() && !m["confInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["confInfo"].type()) {
        QueryConferenceInfoResponseBodyConfInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["confInfo"]));
        confInfo = make_shared<QueryConferenceInfoResponseBodyConfInfo>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~QueryConferenceInfoResponseBody() = default;
};
class QueryConferenceInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryConferenceInfoResponseBody> body{};

  QueryConferenceInfoResponse() {}

  explicit QueryConferenceInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryConferenceInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryConferenceInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryConferenceInfoResponse() = default;
};
class QueryConferenceInfoByRoomCodeHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryConferenceInfoByRoomCodeHeadersAccountContext() {}

  explicit QueryConferenceInfoByRoomCodeHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryConferenceInfoByRoomCodeHeadersAccountContext() = default;
};
class QueryConferenceInfoByRoomCodeHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryConferenceInfoByRoomCodeHeadersAccountContext> accountContext{};

  QueryConferenceInfoByRoomCodeHeaders() {}

  explicit QueryConferenceInfoByRoomCodeHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryConferenceInfoByRoomCodeHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryConferenceInfoByRoomCodeHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryConferenceInfoByRoomCodeHeaders() = default;
};
class QueryConferenceInfoByRoomCodeShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryConferenceInfoByRoomCodeShrinkHeaders() {}

  explicit QueryConferenceInfoByRoomCodeShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryConferenceInfoByRoomCodeShrinkHeaders() = default;
};
class QueryConferenceInfoByRoomCodeRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryConferenceInfoByRoomCodeRequestTenantContext() {}

  explicit QueryConferenceInfoByRoomCodeRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryConferenceInfoByRoomCodeRequestTenantContext() = default;
};
class QueryConferenceInfoByRoomCodeRequest : public Darabonba::Model {
public:
  shared_ptr<QueryConferenceInfoByRoomCodeRequestTenantContext> tenantContext{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> roomCode{};

  QueryConferenceInfoByRoomCodeRequest() {}

  explicit QueryConferenceInfoByRoomCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (roomCode) {
      res["roomCode"] = boost::any(*roomCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryConferenceInfoByRoomCodeRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryConferenceInfoByRoomCodeRequestTenantContext>(model1);
      }
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("roomCode") != m.end() && !m["roomCode"].empty()) {
      roomCode = make_shared<string>(boost::any_cast<string>(m["roomCode"]));
    }
  }


  virtual ~QueryConferenceInfoByRoomCodeRequest() = default;
};
class QueryConferenceInfoByRoomCodeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> roomCode{};

  QueryConferenceInfoByRoomCodeShrinkRequest() {}

  explicit QueryConferenceInfoByRoomCodeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (roomCode) {
      res["roomCode"] = boost::any(*roomCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("roomCode") != m.end() && !m["roomCode"].empty()) {
      roomCode = make_shared<string>(boost::any_cast<string>(m["roomCode"]));
    }
  }


  virtual ~QueryConferenceInfoByRoomCodeShrinkRequest() = default;
};
class QueryConferenceInfoByRoomCodeResponseBodyConferenceList : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<long> confDuration{};
  shared_ptr<string> conferenceId{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> creatorNick{};
  shared_ptr<long> endTime{};
  shared_ptr<string> externalLinkUrl{};
  shared_ptr<string> roomCode{};
  shared_ptr<string> scheduleConferenceId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> status{};
  shared_ptr<string> title{};

  QueryConferenceInfoByRoomCodeResponseBodyConferenceList() {}

  explicit QueryConferenceInfoByRoomCodeResponseBodyConferenceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (confDuration) {
      res["ConfDuration"] = boost::any(*confDuration);
    }
    if (conferenceId) {
      res["ConferenceId"] = boost::any(*conferenceId);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (creatorNick) {
      res["CreatorNick"] = boost::any(*creatorNick);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (externalLinkUrl) {
      res["ExternalLinkUrl"] = boost::any(*externalLinkUrl);
    }
    if (roomCode) {
      res["RoomCode"] = boost::any(*roomCode);
    }
    if (scheduleConferenceId) {
      res["ScheduleConferenceId"] = boost::any(*scheduleConferenceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ConfDuration") != m.end() && !m["ConfDuration"].empty()) {
      confDuration = make_shared<long>(boost::any_cast<long>(m["ConfDuration"]));
    }
    if (m.find("ConferenceId") != m.end() && !m["ConferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["ConferenceId"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("CreatorNick") != m.end() && !m["CreatorNick"].empty()) {
      creatorNick = make_shared<string>(boost::any_cast<string>(m["CreatorNick"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ExternalLinkUrl") != m.end() && !m["ExternalLinkUrl"].empty()) {
      externalLinkUrl = make_shared<string>(boost::any_cast<string>(m["ExternalLinkUrl"]));
    }
    if (m.find("RoomCode") != m.end() && !m["RoomCode"].empty()) {
      roomCode = make_shared<string>(boost::any_cast<string>(m["RoomCode"]));
    }
    if (m.find("ScheduleConferenceId") != m.end() && !m["ScheduleConferenceId"].empty()) {
      scheduleConferenceId = make_shared<string>(boost::any_cast<string>(m["ScheduleConferenceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~QueryConferenceInfoByRoomCodeResponseBodyConferenceList() = default;
};
class QueryConferenceInfoByRoomCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryConferenceInfoByRoomCodeResponseBodyConferenceList>> conferenceList{};
  shared_ptr<string> dingtalkRequestId{};
  shared_ptr<bool> hasMore{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  QueryConferenceInfoByRoomCodeResponseBody() {}

  explicit QueryConferenceInfoByRoomCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conferenceList) {
      vector<boost::any> temp1;
      for(auto item1:*conferenceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["conferenceList"] = boost::any(temp1);
    }
    if (dingtalkRequestId) {
      res["dingtalkRequestId"] = boost::any(*dingtalkRequestId);
    }
    if (hasMore) {
      res["hasMore"] = boost::any(*hasMore);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("conferenceList") != m.end() && !m["conferenceList"].empty()) {
      if (typeid(vector<boost::any>) == m["conferenceList"].type()) {
        vector<QueryConferenceInfoByRoomCodeResponseBodyConferenceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["conferenceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryConferenceInfoByRoomCodeResponseBodyConferenceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conferenceList = make_shared<vector<QueryConferenceInfoByRoomCodeResponseBodyConferenceList>>(expect1);
      }
    }
    if (m.find("dingtalkRequestId") != m.end() && !m["dingtalkRequestId"].empty()) {
      dingtalkRequestId = make_shared<string>(boost::any_cast<string>(m["dingtalkRequestId"]));
    }
    if (m.find("hasMore") != m.end() && !m["hasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["hasMore"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~QueryConferenceInfoByRoomCodeResponseBody() = default;
};
class QueryConferenceInfoByRoomCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryConferenceInfoByRoomCodeResponseBody> body{};

  QueryConferenceInfoByRoomCodeResponse() {}

  explicit QueryConferenceInfoByRoomCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryConferenceInfoByRoomCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryConferenceInfoByRoomCodeResponseBody>(model1);
      }
    }
  }


  virtual ~QueryConferenceInfoByRoomCodeResponse() = default;
};
class QueryConferenceMembersHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryConferenceMembersHeadersAccountContext() {}

  explicit QueryConferenceMembersHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryConferenceMembersHeadersAccountContext() = default;
};
class QueryConferenceMembersHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryConferenceMembersHeadersAccountContext> accountContext{};

  QueryConferenceMembersHeaders() {}

  explicit QueryConferenceMembersHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryConferenceMembersHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryConferenceMembersHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryConferenceMembersHeaders() = default;
};
class QueryConferenceMembersShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryConferenceMembersShrinkHeaders() {}

  explicit QueryConferenceMembersShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryConferenceMembersShrinkHeaders() = default;
};
class QueryConferenceMembersRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryConferenceMembersRequestTenantContext() {}

  explicit QueryConferenceMembersRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryConferenceMembersRequestTenantContext() = default;
};
class QueryConferenceMembersRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<QueryConferenceMembersRequestTenantContext> tenantContext{};
  shared_ptr<string> conferenceId{};

  QueryConferenceMembersRequest() {}

  explicit QueryConferenceMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryConferenceMembersRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryConferenceMembersRequestTenantContext>(model1);
      }
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~QueryConferenceMembersRequest() = default;
};
class QueryConferenceMembersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> conferenceId{};

  QueryConferenceMembersShrinkRequest() {}

  explicit QueryConferenceMembersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~QueryConferenceMembersShrinkRequest() = default;
};
class QueryConferenceMembersResponseBodyMemberModels : public Darabonba::Model {
public:
  shared_ptr<long> attendStatus{};
  shared_ptr<bool> coHost{};
  shared_ptr<string> conferenceId{};
  shared_ptr<long> duration{};
  shared_ptr<bool> host{};
  shared_ptr<long> joinTime{};
  shared_ptr<long> leaveTime{};
  shared_ptr<bool> outerOrgMember{};
  shared_ptr<bool> pstnJoin{};
  shared_ptr<string> userId{};
  shared_ptr<string> userNick{};

  QueryConferenceMembersResponseBodyMemberModels() {}

  explicit QueryConferenceMembersResponseBodyMemberModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendStatus) {
      res["AttendStatus"] = boost::any(*attendStatus);
    }
    if (coHost) {
      res["CoHost"] = boost::any(*coHost);
    }
    if (conferenceId) {
      res["ConferenceId"] = boost::any(*conferenceId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (joinTime) {
      res["JoinTime"] = boost::any(*joinTime);
    }
    if (leaveTime) {
      res["LeaveTime"] = boost::any(*leaveTime);
    }
    if (outerOrgMember) {
      res["OuterOrgMember"] = boost::any(*outerOrgMember);
    }
    if (pstnJoin) {
      res["PstnJoin"] = boost::any(*pstnJoin);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userNick) {
      res["UserNick"] = boost::any(*userNick);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttendStatus") != m.end() && !m["AttendStatus"].empty()) {
      attendStatus = make_shared<long>(boost::any_cast<long>(m["AttendStatus"]));
    }
    if (m.find("CoHost") != m.end() && !m["CoHost"].empty()) {
      coHost = make_shared<bool>(boost::any_cast<bool>(m["CoHost"]));
    }
    if (m.find("ConferenceId") != m.end() && !m["ConferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["ConferenceId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<bool>(boost::any_cast<bool>(m["Host"]));
    }
    if (m.find("JoinTime") != m.end() && !m["JoinTime"].empty()) {
      joinTime = make_shared<long>(boost::any_cast<long>(m["JoinTime"]));
    }
    if (m.find("LeaveTime") != m.end() && !m["LeaveTime"].empty()) {
      leaveTime = make_shared<long>(boost::any_cast<long>(m["LeaveTime"]));
    }
    if (m.find("OuterOrgMember") != m.end() && !m["OuterOrgMember"].empty()) {
      outerOrgMember = make_shared<bool>(boost::any_cast<bool>(m["OuterOrgMember"]));
    }
    if (m.find("PstnJoin") != m.end() && !m["PstnJoin"].empty()) {
      pstnJoin = make_shared<bool>(boost::any_cast<bool>(m["PstnJoin"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserNick") != m.end() && !m["UserNick"].empty()) {
      userNick = make_shared<string>(boost::any_cast<string>(m["UserNick"]));
    }
  }


  virtual ~QueryConferenceMembersResponseBodyMemberModels() = default;
};
class QueryConferenceMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryConferenceMembersResponseBodyMemberModels>> memberModels{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  QueryConferenceMembersResponseBody() {}

  explicit QueryConferenceMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberModels) {
      vector<boost::any> temp1;
      for(auto item1:*memberModels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["memberModels"] = boost::any(temp1);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("memberModels") != m.end() && !m["memberModels"].empty()) {
      if (typeid(vector<boost::any>) == m["memberModels"].type()) {
        vector<QueryConferenceMembersResponseBodyMemberModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["memberModels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryConferenceMembersResponseBodyMemberModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        memberModels = make_shared<vector<QueryConferenceMembersResponseBodyMemberModels>>(expect1);
      }
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~QueryConferenceMembersResponseBody() = default;
};
class QueryConferenceMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryConferenceMembersResponseBody> body{};

  QueryConferenceMembersResponse() {}

  explicit QueryConferenceMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryConferenceMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryConferenceMembersResponseBody>(model1);
      }
    }
  }


  virtual ~QueryConferenceMembersResponse() = default;
};
class QueryDentriesInfoHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryDentriesInfoHeadersAccountContext() {}

  explicit QueryDentriesInfoHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryDentriesInfoHeadersAccountContext() = default;
};
class QueryDentriesInfoHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryDentriesInfoHeadersAccountContext> accountContext{};

  QueryDentriesInfoHeaders() {}

  explicit QueryDentriesInfoHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryDentriesInfoHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryDentriesInfoHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryDentriesInfoHeaders() = default;
};
class QueryDentriesInfoShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryDentriesInfoShrinkHeaders() {}

  explicit QueryDentriesInfoShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryDentriesInfoShrinkHeaders() = default;
};
class QueryDentriesInfoRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryDentriesInfoRequestTenantContext() {}

  explicit QueryDentriesInfoRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryDentriesInfoRequestTenantContext() = default;
};
class QueryDentriesInfoRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> appIdsForAppProperties{};
  shared_ptr<string> dentryId{};
  shared_ptr<string> spaceId{};
  shared_ptr<QueryDentriesInfoRequestTenantContext> tenantContext{};
  shared_ptr<string> unionId{};
  shared_ptr<bool> withThumbnail{};

  QueryDentriesInfoRequest() {}

  explicit QueryDentriesInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appIdsForAppProperties) {
      res["AppIdsForAppProperties"] = boost::any(*appIdsForAppProperties);
    }
    if (dentryId) {
      res["DentryId"] = boost::any(*dentryId);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (unionId) {
      res["UnionId"] = boost::any(*unionId);
    }
    if (withThumbnail) {
      res["WithThumbnail"] = boost::any(*withThumbnail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppIdsForAppProperties") != m.end() && !m["AppIdsForAppProperties"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AppIdsForAppProperties"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AppIdsForAppProperties"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      appIdsForAppProperties = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DentryId") != m.end() && !m["DentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["DentryId"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryDentriesInfoRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryDentriesInfoRequestTenantContext>(model1);
      }
    }
    if (m.find("UnionId") != m.end() && !m["UnionId"].empty()) {
      unionId = make_shared<string>(boost::any_cast<string>(m["UnionId"]));
    }
    if (m.find("WithThumbnail") != m.end() && !m["WithThumbnail"].empty()) {
      withThumbnail = make_shared<bool>(boost::any_cast<bool>(m["WithThumbnail"]));
    }
  }


  virtual ~QueryDentriesInfoRequest() = default;
};
class QueryDentriesInfoShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appIdsForAppPropertiesShrink{};
  shared_ptr<string> dentryId{};
  shared_ptr<string> spaceId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> unionId{};
  shared_ptr<bool> withThumbnail{};

  QueryDentriesInfoShrinkRequest() {}

  explicit QueryDentriesInfoShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appIdsForAppPropertiesShrink) {
      res["AppIdsForAppProperties"] = boost::any(*appIdsForAppPropertiesShrink);
    }
    if (dentryId) {
      res["DentryId"] = boost::any(*dentryId);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (unionId) {
      res["UnionId"] = boost::any(*unionId);
    }
    if (withThumbnail) {
      res["WithThumbnail"] = boost::any(*withThumbnail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppIdsForAppProperties") != m.end() && !m["AppIdsForAppProperties"].empty()) {
      appIdsForAppPropertiesShrink = make_shared<string>(boost::any_cast<string>(m["AppIdsForAppProperties"]));
    }
    if (m.find("DentryId") != m.end() && !m["DentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["DentryId"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("UnionId") != m.end() && !m["UnionId"].empty()) {
      unionId = make_shared<string>(boost::any_cast<string>(m["UnionId"]));
    }
    if (m.find("WithThumbnail") != m.end() && !m["WithThumbnail"].empty()) {
      withThumbnail = make_shared<bool>(boost::any_cast<bool>(m["WithThumbnail"]));
    }
  }


  virtual ~QueryDentriesInfoShrinkRequest() = default;
};
class QueryDentriesInfoResponseBodyDentryProperties : public Darabonba::Model {
public:
  shared_ptr<bool> readOnly{};

  QueryDentriesInfoResponseBodyDentryProperties() {}

  explicit QueryDentriesInfoResponseBodyDentryProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (readOnly) {
      res["ReadOnly"] = boost::any(*readOnly);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReadOnly") != m.end() && !m["ReadOnly"].empty()) {
      readOnly = make_shared<bool>(boost::any_cast<bool>(m["ReadOnly"]));
    }
  }


  virtual ~QueryDentriesInfoResponseBodyDentryProperties() = default;
};
class QueryDentriesInfoResponseBodyDentryThumbnail : public Darabonba::Model {
public:
  shared_ptr<long> height{};
  shared_ptr<string> url{};
  shared_ptr<long> width{};

  QueryDentriesInfoResponseBodyDentryThumbnail() {}

  explicit QueryDentriesInfoResponseBodyDentryThumbnail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~QueryDentriesInfoResponseBodyDentryThumbnail() = default;
};
class QueryDentriesInfoResponseBodyDentry : public Darabonba::Model {
public:
  shared_ptr<map<string, vector<DentryAppPropertiesValue>>> appProperties{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> extension{};
  shared_ptr<string> id{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> name{};
  shared_ptr<string> parentId{};
  shared_ptr<string> partitionType{};
  shared_ptr<string> path{};
  shared_ptr<QueryDentriesInfoResponseBodyDentryProperties> properties{};
  shared_ptr<long> size{};
  shared_ptr<string> spaceId{};
  shared_ptr<string> status{};
  shared_ptr<string> storageDriver{};
  shared_ptr<QueryDentriesInfoResponseBodyDentryThumbnail> thumbnail{};
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};
  shared_ptr<long> version{};

  QueryDentriesInfoResponseBodyDentry() {}

  explicit QueryDentriesInfoResponseBodyDentry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appProperties) {
      map<string, boost::any> temp1;
      for(auto item1:*appProperties){
        vector<boost::any> temp2;
        for(auto item2:item1.second){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1[item1.first] = boost::any(temp2);
      }
      res["AppProperties"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (partitionType) {
      res["PartitionType"] = boost::any(*partitionType);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageDriver) {
      res["StorageDriver"] = boost::any(*storageDriver);
    }
    if (thumbnail) {
      res["Thumbnail"] = thumbnail ? boost::any(thumbnail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppProperties") != m.end() && !m["AppProperties"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppProperties"].type()) {
        map<string, vector<DentryAppPropertiesValue>> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["AppProperties"])){
          if (typeid(vector<boost::any>) == item1.second.type()) {
            vector<DentryAppPropertiesValue> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1.second)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                DentryAppPropertiesValue model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1[item1.first] = expect2;
          }
        }
        appProperties = make_shared<map<string, vector<DentryAppPropertiesValue>>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["ModifierId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("PartitionType") != m.end() && !m["PartitionType"].empty()) {
      partitionType = make_shared<string>(boost::any_cast<string>(m["PartitionType"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        QueryDentriesInfoResponseBodyDentryProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<QueryDentriesInfoResponseBodyDentryProperties>(model1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageDriver") != m.end() && !m["StorageDriver"].empty()) {
      storageDriver = make_shared<string>(boost::any_cast<string>(m["StorageDriver"]));
    }
    if (m.find("Thumbnail") != m.end() && !m["Thumbnail"].empty()) {
      if (typeid(map<string, boost::any>) == m["Thumbnail"].type()) {
        QueryDentriesInfoResponseBodyDentryThumbnail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Thumbnail"]));
        thumbnail = make_shared<QueryDentriesInfoResponseBodyDentryThumbnail>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~QueryDentriesInfoResponseBodyDentry() = default;
};
class QueryDentriesInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryDentriesInfoResponseBodyDentry> dentry{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  QueryDentriesInfoResponseBody() {}

  explicit QueryDentriesInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentry) {
      res["Dentry"] = dentry ? boost::any(dentry->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dentry") != m.end() && !m["Dentry"].empty()) {
      if (typeid(map<string, boost::any>) == m["Dentry"].type()) {
        QueryDentriesInfoResponseBodyDentry model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Dentry"]));
        dentry = make_shared<QueryDentriesInfoResponseBodyDentry>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~QueryDentriesInfoResponseBody() = default;
};
class QueryDentriesInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDentriesInfoResponseBody> body{};

  QueryDentriesInfoResponse() {}

  explicit QueryDentriesInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDentriesInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDentriesInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDentriesInfoResponse() = default;
};
class QueryDentryHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryDentryHeadersAccountContext() {}

  explicit QueryDentryHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryDentryHeadersAccountContext() = default;
};
class QueryDentryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryDentryHeadersAccountContext> accountContext{};

  QueryDentryHeaders() {}

  explicit QueryDentryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryDentryHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryDentryHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryDentryHeaders() = default;
};
class QueryDentryShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryDentryShrinkHeaders() {}

  explicit QueryDentryShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryDentryShrinkHeaders() = default;
};
class QueryDentryRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryDentryRequestTenantContext() {}

  explicit QueryDentryRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryDentryRequestTenantContext() = default;
};
class QueryDentryRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryId{};
  shared_ptr<bool> includeSpace{};
  shared_ptr<string> spaceId{};
  shared_ptr<QueryDentryRequestTenantContext> tenantContext{};

  QueryDentryRequest() {}

  explicit QueryDentryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryId) {
      res["DentryId"] = boost::any(*dentryId);
    }
    if (includeSpace) {
      res["IncludeSpace"] = boost::any(*includeSpace);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryId") != m.end() && !m["DentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["DentryId"]));
    }
    if (m.find("IncludeSpace") != m.end() && !m["IncludeSpace"].empty()) {
      includeSpace = make_shared<bool>(boost::any_cast<bool>(m["IncludeSpace"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryDentryRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryDentryRequestTenantContext>(model1);
      }
    }
  }


  virtual ~QueryDentryRequest() = default;
};
class QueryDentryShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryId{};
  shared_ptr<bool> includeSpace{};
  shared_ptr<string> spaceId{};
  shared_ptr<string> tenantContextShrink{};

  QueryDentryShrinkRequest() {}

  explicit QueryDentryShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryId) {
      res["DentryId"] = boost::any(*dentryId);
    }
    if (includeSpace) {
      res["IncludeSpace"] = boost::any(*includeSpace);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryId") != m.end() && !m["DentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["DentryId"]));
    }
    if (m.find("IncludeSpace") != m.end() && !m["IncludeSpace"].empty()) {
      includeSpace = make_shared<bool>(boost::any_cast<bool>(m["IncludeSpace"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~QueryDentryShrinkRequest() = default;
};
class QueryDentryResponseBodyCreator : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> userId{};

  QueryDentryResponseBodyCreator() {}

  explicit QueryDentryResponseBodyCreator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryDentryResponseBodyCreator() = default;
};
class QueryDentryResponseBodyLinkSourceInfoIconUrl : public Darabonba::Model {
public:
  shared_ptr<string> line{};
  shared_ptr<string> small{};

  QueryDentryResponseBodyLinkSourceInfoIconUrl() {}

  explicit QueryDentryResponseBodyLinkSourceInfoIconUrl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (small) {
      res["Small"] = boost::any(*small);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("Small") != m.end() && !m["Small"].empty()) {
      small = make_shared<string>(boost::any_cast<string>(m["Small"]));
    }
  }


  virtual ~QueryDentryResponseBodyLinkSourceInfoIconUrl() = default;
};
class QueryDentryResponseBodyLinkSourceInfo : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<QueryDentryResponseBodyLinkSourceInfoIconUrl> iconUrl{};
  shared_ptr<string> id{};
  shared_ptr<long> linkType{};
  shared_ptr<string> spaceId{};

  QueryDentryResponseBodyLinkSourceInfo() {}

  explicit QueryDentryResponseBodyLinkSourceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (iconUrl) {
      res["IconUrl"] = iconUrl ? boost::any(iconUrl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (linkType) {
      res["LinkType"] = boost::any(*linkType);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("IconUrl") != m.end() && !m["IconUrl"].empty()) {
      if (typeid(map<string, boost::any>) == m["IconUrl"].type()) {
        QueryDentryResponseBodyLinkSourceInfoIconUrl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IconUrl"]));
        iconUrl = make_shared<QueryDentryResponseBodyLinkSourceInfoIconUrl>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LinkType") != m.end() && !m["LinkType"].empty()) {
      linkType = make_shared<long>(boost::any_cast<long>(m["LinkType"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
  }


  virtual ~QueryDentryResponseBodyLinkSourceInfo() = default;
};
class QueryDentryResponseBodySpaceHdIconVO : public Darabonba::Model {
public:
  shared_ptr<string> icon{};
  shared_ptr<string> type{};

  QueryDentryResponseBodySpaceHdIconVO() {}

  explicit QueryDentryResponseBodySpaceHdIconVO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryDentryResponseBodySpaceHdIconVO() = default;
};
class QueryDentryResponseBodySpaceIconVO : public Darabonba::Model {
public:
  shared_ptr<string> icon{};
  shared_ptr<string> type{};

  QueryDentryResponseBodySpaceIconVO() {}

  explicit QueryDentryResponseBodySpaceIconVO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryDentryResponseBodySpaceIconVO() = default;
};
class QueryDentryResponseBodySpaceOwner : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> userId{};

  QueryDentryResponseBodySpaceOwner() {}

  explicit QueryDentryResponseBodySpaceOwner(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryDentryResponseBodySpaceOwner() = default;
};
class QueryDentryResponseBodySpaceRecentListCreator : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> userId{};

  QueryDentryResponseBodySpaceRecentListCreator() {}

  explicit QueryDentryResponseBodySpaceRecentListCreator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryDentryResponseBodySpaceRecentListCreator() = default;
};
class QueryDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl : public Darabonba::Model {
public:
  shared_ptr<string> line{};
  shared_ptr<string> small{};

  QueryDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl() {}

  explicit QueryDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (small) {
      res["Small"] = boost::any(*small);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("Small") != m.end() && !m["Small"].empty()) {
      small = make_shared<string>(boost::any_cast<string>(m["Small"]));
    }
  }


  virtual ~QueryDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl() = default;
};
class QueryDentryResponseBodySpaceRecentListLinkSourceInfo : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<QueryDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl> iconUrl{};
  shared_ptr<string> id{};
  shared_ptr<long> linkType{};
  shared_ptr<string> spaceId{};

  QueryDentryResponseBodySpaceRecentListLinkSourceInfo() {}

  explicit QueryDentryResponseBodySpaceRecentListLinkSourceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (iconUrl) {
      res["IconUrl"] = iconUrl ? boost::any(iconUrl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (linkType) {
      res["LinkType"] = boost::any(*linkType);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("IconUrl") != m.end() && !m["IconUrl"].empty()) {
      if (typeid(map<string, boost::any>) == m["IconUrl"].type()) {
        QueryDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IconUrl"]));
        iconUrl = make_shared<QueryDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LinkType") != m.end() && !m["LinkType"].empty()) {
      linkType = make_shared<long>(boost::any_cast<long>(m["LinkType"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
  }


  virtual ~QueryDentryResponseBodySpaceRecentListLinkSourceInfo() = default;
};
class QueryDentryResponseBodySpaceRecentListStatisticalInfo : public Darabonba::Model {
public:
  shared_ptr<long> wordCount{};

  QueryDentryResponseBodySpaceRecentListStatisticalInfo() {}

  explicit QueryDentryResponseBodySpaceRecentListStatisticalInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (wordCount) {
      res["WordCount"] = boost::any(*wordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WordCount") != m.end() && !m["WordCount"].empty()) {
      wordCount = make_shared<long>(boost::any_cast<long>(m["WordCount"]));
    }
  }


  virtual ~QueryDentryResponseBodySpaceRecentListStatisticalInfo() = default;
};
class QueryDentryResponseBodySpaceRecentListUpdater : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> userId{};

  QueryDentryResponseBodySpaceRecentListUpdater() {}

  explicit QueryDentryResponseBodySpaceRecentListUpdater(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryDentryResponseBodySpaceRecentListUpdater() = default;
};
class QueryDentryResponseBodySpaceRecentListVisitorInfo : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dentryActions{};
  shared_ptr<string> roleCode{};
  shared_ptr<vector<string>> spaceActions{};

  QueryDentryResponseBodySpaceRecentListVisitorInfo() {}

  explicit QueryDentryResponseBodySpaceRecentListVisitorInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryActions) {
      res["DentryActions"] = boost::any(*dentryActions);
    }
    if (roleCode) {
      res["RoleCode"] = boost::any(*roleCode);
    }
    if (spaceActions) {
      res["SpaceActions"] = boost::any(*spaceActions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryActions") != m.end() && !m["DentryActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DentryActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DentryActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dentryActions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoleCode") != m.end() && !m["RoleCode"].empty()) {
      roleCode = make_shared<string>(boost::any_cast<string>(m["RoleCode"]));
    }
    if (m.find("SpaceActions") != m.end() && !m["SpaceActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SpaceActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SpaceActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      spaceActions = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryDentryResponseBodySpaceRecentListVisitorInfo() = default;
};
class QueryDentryResponseBodySpaceRecentList : public Darabonba::Model {
public:
  shared_ptr<string> contentType{};
  shared_ptr<long> createdTime{};
  shared_ptr<QueryDentryResponseBodySpaceRecentListCreator> creator{};
  shared_ptr<string> dentryId{};
  shared_ptr<string> dentryType{};
  shared_ptr<string> dentryUuid{};
  shared_ptr<string> docKey{};
  shared_ptr<string> extension{};
  shared_ptr<bool> hasChildren{};
  shared_ptr<QueryDentryResponseBodySpaceRecentListLinkSourceInfo> linkSourceInfo{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<boost::any> space{};
  shared_ptr<string> spaceId{};
  shared_ptr<QueryDentryResponseBodySpaceRecentListStatisticalInfo> statisticalInfo{};
  shared_ptr<long> updatedTime{};
  shared_ptr<QueryDentryResponseBodySpaceRecentListUpdater> updater{};
  shared_ptr<string> url{};
  shared_ptr<QueryDentryResponseBodySpaceRecentListVisitorInfo> visitorInfo{};

  QueryDentryResponseBodySpaceRecentList() {}

  explicit QueryDentryResponseBodySpaceRecentList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (creator) {
      res["Creator"] = creator ? boost::any(creator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dentryId) {
      res["DentryId"] = boost::any(*dentryId);
    }
    if (dentryType) {
      res["DentryType"] = boost::any(*dentryType);
    }
    if (dentryUuid) {
      res["DentryUuid"] = boost::any(*dentryUuid);
    }
    if (docKey) {
      res["DocKey"] = boost::any(*docKey);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (hasChildren) {
      res["HasChildren"] = boost::any(*hasChildren);
    }
    if (linkSourceInfo) {
      res["LinkSourceInfo"] = linkSourceInfo ? boost::any(linkSourceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (space) {
      res["Space"] = boost::any(*space);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (statisticalInfo) {
      res["StatisticalInfo"] = statisticalInfo ? boost::any(statisticalInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    if (updater) {
      res["Updater"] = updater ? boost::any(updater->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (visitorInfo) {
      res["VisitorInfo"] = visitorInfo ? boost::any(visitorInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      if (typeid(map<string, boost::any>) == m["Creator"].type()) {
        QueryDentryResponseBodySpaceRecentListCreator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Creator"]));
        creator = make_shared<QueryDentryResponseBodySpaceRecentListCreator>(model1);
      }
    }
    if (m.find("DentryId") != m.end() && !m["DentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["DentryId"]));
    }
    if (m.find("DentryType") != m.end() && !m["DentryType"].empty()) {
      dentryType = make_shared<string>(boost::any_cast<string>(m["DentryType"]));
    }
    if (m.find("DentryUuid") != m.end() && !m["DentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["DentryUuid"]));
    }
    if (m.find("DocKey") != m.end() && !m["DocKey"].empty()) {
      docKey = make_shared<string>(boost::any_cast<string>(m["DocKey"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("HasChildren") != m.end() && !m["HasChildren"].empty()) {
      hasChildren = make_shared<bool>(boost::any_cast<bool>(m["HasChildren"]));
    }
    if (m.find("LinkSourceInfo") != m.end() && !m["LinkSourceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["LinkSourceInfo"].type()) {
        QueryDentryResponseBodySpaceRecentListLinkSourceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LinkSourceInfo"]));
        linkSourceInfo = make_shared<QueryDentryResponseBodySpaceRecentListLinkSourceInfo>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Space") != m.end() && !m["Space"].empty()) {
      space = make_shared<boost::any>(boost::any_cast<boost::any>(m["Space"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("StatisticalInfo") != m.end() && !m["StatisticalInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatisticalInfo"].type()) {
        QueryDentryResponseBodySpaceRecentListStatisticalInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatisticalInfo"]));
        statisticalInfo = make_shared<QueryDentryResponseBodySpaceRecentListStatisticalInfo>(model1);
      }
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["UpdatedTime"]));
    }
    if (m.find("Updater") != m.end() && !m["Updater"].empty()) {
      if (typeid(map<string, boost::any>) == m["Updater"].type()) {
        QueryDentryResponseBodySpaceRecentListUpdater model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Updater"]));
        updater = make_shared<QueryDentryResponseBodySpaceRecentListUpdater>(model1);
      }
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("VisitorInfo") != m.end() && !m["VisitorInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["VisitorInfo"].type()) {
        QueryDentryResponseBodySpaceRecentListVisitorInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VisitorInfo"]));
        visitorInfo = make_shared<QueryDentryResponseBodySpaceRecentListVisitorInfo>(model1);
      }
    }
  }


  virtual ~QueryDentryResponseBodySpaceRecentList() = default;
};
class QueryDentryResponseBodySpaceVisitorInfo : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dentryActions{};
  shared_ptr<string> roleCode{};
  shared_ptr<vector<string>> spaceActions{};

  QueryDentryResponseBodySpaceVisitorInfo() {}

  explicit QueryDentryResponseBodySpaceVisitorInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryActions) {
      res["DentryActions"] = boost::any(*dentryActions);
    }
    if (roleCode) {
      res["RoleCode"] = boost::any(*roleCode);
    }
    if (spaceActions) {
      res["SpaceActions"] = boost::any(*spaceActions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryActions") != m.end() && !m["DentryActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DentryActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DentryActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dentryActions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoleCode") != m.end() && !m["RoleCode"].empty()) {
      roleCode = make_shared<string>(boost::any_cast<string>(m["RoleCode"]));
    }
    if (m.find("SpaceActions") != m.end() && !m["SpaceActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SpaceActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SpaceActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      spaceActions = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryDentryResponseBodySpaceVisitorInfo() = default;
};
class QueryDentryResponseBodySpace : public Darabonba::Model {
public:
  shared_ptr<string> cover{};
  shared_ptr<string> description{};
  shared_ptr<QueryDentryResponseBodySpaceHdIconVO> hdIconVO{};
  shared_ptr<QueryDentryResponseBodySpaceIconVO> iconVO{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<QueryDentryResponseBodySpaceOwner> owner{};
  shared_ptr<vector<QueryDentryResponseBodySpaceRecentList>> recentList{};
  shared_ptr<long> type{};
  shared_ptr<string> url{};
  shared_ptr<QueryDentryResponseBodySpaceVisitorInfo> visitorInfo{};

  QueryDentryResponseBodySpace() {}

  explicit QueryDentryResponseBodySpace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cover) {
      res["Cover"] = boost::any(*cover);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hdIconVO) {
      res["HdIconVO"] = hdIconVO ? boost::any(hdIconVO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (iconVO) {
      res["IconVO"] = iconVO ? boost::any(iconVO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = owner ? boost::any(owner->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recentList) {
      vector<boost::any> temp1;
      for(auto item1:*recentList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecentList"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (visitorInfo) {
      res["VisitorInfo"] = visitorInfo ? boost::any(visitorInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      cover = make_shared<string>(boost::any_cast<string>(m["Cover"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HdIconVO") != m.end() && !m["HdIconVO"].empty()) {
      if (typeid(map<string, boost::any>) == m["HdIconVO"].type()) {
        QueryDentryResponseBodySpaceHdIconVO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HdIconVO"]));
        hdIconVO = make_shared<QueryDentryResponseBodySpaceHdIconVO>(model1);
      }
    }
    if (m.find("IconVO") != m.end() && !m["IconVO"].empty()) {
      if (typeid(map<string, boost::any>) == m["IconVO"].type()) {
        QueryDentryResponseBodySpaceIconVO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IconVO"]));
        iconVO = make_shared<QueryDentryResponseBodySpaceIconVO>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      if (typeid(map<string, boost::any>) == m["Owner"].type()) {
        QueryDentryResponseBodySpaceOwner model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Owner"]));
        owner = make_shared<QueryDentryResponseBodySpaceOwner>(model1);
      }
    }
    if (m.find("RecentList") != m.end() && !m["RecentList"].empty()) {
      if (typeid(vector<boost::any>) == m["RecentList"].type()) {
        vector<QueryDentryResponseBodySpaceRecentList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecentList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDentryResponseBodySpaceRecentList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recentList = make_shared<vector<QueryDentryResponseBodySpaceRecentList>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("VisitorInfo") != m.end() && !m["VisitorInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["VisitorInfo"].type()) {
        QueryDentryResponseBodySpaceVisitorInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VisitorInfo"]));
        visitorInfo = make_shared<QueryDentryResponseBodySpaceVisitorInfo>(model1);
      }
    }
  }


  virtual ~QueryDentryResponseBodySpace() = default;
};
class QueryDentryResponseBodyUpdater : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> userId{};

  QueryDentryResponseBodyUpdater() {}

  explicit QueryDentryResponseBodyUpdater(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryDentryResponseBodyUpdater() = default;
};
class QueryDentryResponseBodyVisitorInfo : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dentryActions{};
  shared_ptr<string> roleCode{};
  shared_ptr<vector<string>> spaceActions{};

  QueryDentryResponseBodyVisitorInfo() {}

  explicit QueryDentryResponseBodyVisitorInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryActions) {
      res["DentryActions"] = boost::any(*dentryActions);
    }
    if (roleCode) {
      res["RoleCode"] = boost::any(*roleCode);
    }
    if (spaceActions) {
      res["SpaceActions"] = boost::any(*spaceActions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryActions") != m.end() && !m["DentryActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DentryActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DentryActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dentryActions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoleCode") != m.end() && !m["RoleCode"].empty()) {
      roleCode = make_shared<string>(boost::any_cast<string>(m["RoleCode"]));
    }
    if (m.find("SpaceActions") != m.end() && !m["SpaceActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SpaceActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SpaceActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      spaceActions = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryDentryResponseBodyVisitorInfo() = default;
};
class QueryDentryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> contentType{};
  shared_ptr<long> createdTime{};
  shared_ptr<QueryDentryResponseBodyCreator> creator{};
  shared_ptr<string> dentryId{};
  shared_ptr<string> dentryType{};
  shared_ptr<string> dentryUuid{};
  shared_ptr<string> docKey{};
  shared_ptr<string> extension{};
  shared_ptr<bool> hasChildren{};
  shared_ptr<QueryDentryResponseBodyLinkSourceInfo> linkSourceInfo{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryDentryResponseBodySpace> space{};
  shared_ptr<string> spaceId{};
  shared_ptr<long> updatedTime{};
  shared_ptr<QueryDentryResponseBodyUpdater> updater{};
  shared_ptr<string> url{};
  shared_ptr<QueryDentryResponseBodyVisitorInfo> visitorInfo{};

  QueryDentryResponseBody() {}

  explicit QueryDentryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentType) {
      res["contentType"] = boost::any(*contentType);
    }
    if (createdTime) {
      res["createdTime"] = boost::any(*createdTime);
    }
    if (creator) {
      res["creator"] = creator ? boost::any(creator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dentryId) {
      res["dentryId"] = boost::any(*dentryId);
    }
    if (dentryType) {
      res["dentryType"] = boost::any(*dentryType);
    }
    if (dentryUuid) {
      res["dentryUuid"] = boost::any(*dentryUuid);
    }
    if (docKey) {
      res["docKey"] = boost::any(*docKey);
    }
    if (extension) {
      res["extension"] = boost::any(*extension);
    }
    if (hasChildren) {
      res["hasChildren"] = boost::any(*hasChildren);
    }
    if (linkSourceInfo) {
      res["linkSourceInfo"] = linkSourceInfo ? boost::any(linkSourceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (space) {
      res["space"] = space ? boost::any(space->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spaceId) {
      res["spaceId"] = boost::any(*spaceId);
    }
    if (updatedTime) {
      res["updatedTime"] = boost::any(*updatedTime);
    }
    if (updater) {
      res["updater"] = updater ? boost::any(updater->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    if (visitorInfo) {
      res["visitorInfo"] = visitorInfo ? boost::any(visitorInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("contentType") != m.end() && !m["contentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["contentType"]));
    }
    if (m.find("createdTime") != m.end() && !m["createdTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["createdTime"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      if (typeid(map<string, boost::any>) == m["creator"].type()) {
        QueryDentryResponseBodyCreator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["creator"]));
        creator = make_shared<QueryDentryResponseBodyCreator>(model1);
      }
    }
    if (m.find("dentryId") != m.end() && !m["dentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["dentryId"]));
    }
    if (m.find("dentryType") != m.end() && !m["dentryType"].empty()) {
      dentryType = make_shared<string>(boost::any_cast<string>(m["dentryType"]));
    }
    if (m.find("dentryUuid") != m.end() && !m["dentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["dentryUuid"]));
    }
    if (m.find("docKey") != m.end() && !m["docKey"].empty()) {
      docKey = make_shared<string>(boost::any_cast<string>(m["docKey"]));
    }
    if (m.find("extension") != m.end() && !m["extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["extension"]));
    }
    if (m.find("hasChildren") != m.end() && !m["hasChildren"].empty()) {
      hasChildren = make_shared<bool>(boost::any_cast<bool>(m["hasChildren"]));
    }
    if (m.find("linkSourceInfo") != m.end() && !m["linkSourceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["linkSourceInfo"].type()) {
        QueryDentryResponseBodyLinkSourceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["linkSourceInfo"]));
        linkSourceInfo = make_shared<QueryDentryResponseBodyLinkSourceInfo>(model1);
      }
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("space") != m.end() && !m["space"].empty()) {
      if (typeid(map<string, boost::any>) == m["space"].type()) {
        QueryDentryResponseBodySpace model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["space"]));
        space = make_shared<QueryDentryResponseBodySpace>(model1);
      }
    }
    if (m.find("spaceId") != m.end() && !m["spaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["spaceId"]));
    }
    if (m.find("updatedTime") != m.end() && !m["updatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["updatedTime"]));
    }
    if (m.find("updater") != m.end() && !m["updater"].empty()) {
      if (typeid(map<string, boost::any>) == m["updater"].type()) {
        QueryDentryResponseBodyUpdater model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["updater"]));
        updater = make_shared<QueryDentryResponseBodyUpdater>(model1);
      }
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
    if (m.find("visitorInfo") != m.end() && !m["visitorInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["visitorInfo"].type()) {
        QueryDentryResponseBodyVisitorInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["visitorInfo"]));
        visitorInfo = make_shared<QueryDentryResponseBodyVisitorInfo>(model1);
      }
    }
  }


  virtual ~QueryDentryResponseBody() = default;
};
class QueryDentryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDentryResponseBody> body{};

  QueryDentryResponse() {}

  explicit QueryDentryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDentryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDentryResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDentryResponse() = default;
};
class QueryGroupLiveInfoHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryGroupLiveInfoHeadersAccountContext() {}

  explicit QueryGroupLiveInfoHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryGroupLiveInfoHeadersAccountContext() = default;
};
class QueryGroupLiveInfoHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryGroupLiveInfoHeadersAccountContext> accountContext{};

  QueryGroupLiveInfoHeaders() {}

  explicit QueryGroupLiveInfoHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryGroupLiveInfoHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryGroupLiveInfoHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryGroupLiveInfoHeaders() = default;
};
class QueryGroupLiveInfoShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryGroupLiveInfoShrinkHeaders() {}

  explicit QueryGroupLiveInfoShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryGroupLiveInfoShrinkHeaders() = default;
};
class QueryGroupLiveInfoRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryGroupLiveInfoRequestTenantContext() {}

  explicit QueryGroupLiveInfoRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryGroupLiveInfoRequestTenantContext() = default;
};
class QueryGroupLiveInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> anchorUnionId{};
  shared_ptr<string> liveUuid{};
  shared_ptr<QueryGroupLiveInfoRequestTenantContext> tenantContext{};

  QueryGroupLiveInfoRequest() {}

  explicit QueryGroupLiveInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anchorUnionId) {
      res["AnchorUnionId"] = boost::any(*anchorUnionId);
    }
    if (liveUuid) {
      res["LiveUuid"] = boost::any(*liveUuid);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnchorUnionId") != m.end() && !m["AnchorUnionId"].empty()) {
      anchorUnionId = make_shared<string>(boost::any_cast<string>(m["AnchorUnionId"]));
    }
    if (m.find("LiveUuid") != m.end() && !m["LiveUuid"].empty()) {
      liveUuid = make_shared<string>(boost::any_cast<string>(m["LiveUuid"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryGroupLiveInfoRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryGroupLiveInfoRequestTenantContext>(model1);
      }
    }
  }


  virtual ~QueryGroupLiveInfoRequest() = default;
};
class QueryGroupLiveInfoShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> anchorUnionId{};
  shared_ptr<string> liveUuid{};
  shared_ptr<string> tenantContextShrink{};

  QueryGroupLiveInfoShrinkRequest() {}

  explicit QueryGroupLiveInfoShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anchorUnionId) {
      res["AnchorUnionId"] = boost::any(*anchorUnionId);
    }
    if (liveUuid) {
      res["LiveUuid"] = boost::any(*liveUuid);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnchorUnionId") != m.end() && !m["AnchorUnionId"].empty()) {
      anchorUnionId = make_shared<string>(boost::any_cast<string>(m["AnchorUnionId"]));
    }
    if (m.find("LiveUuid") != m.end() && !m["LiveUuid"].empty()) {
      liveUuid = make_shared<string>(boost::any_cast<string>(m["LiveUuid"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~QueryGroupLiveInfoShrinkRequest() = default;
};
class QueryGroupLiveInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> coverUrl{};
  shared_ptr<long> duration{};
  shared_ptr<long> endTime{};
  shared_ptr<string> introduction{};
  shared_ptr<string> liveId{};
  shared_ptr<string> livePlayUrl{};
  shared_ptr<long> liveStatus{};
  shared_ptr<long> playbackDuration{};
  shared_ptr<string> replayUrl{};
  shared_ptr<string> requestId{};
  shared_ptr<string> staffId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> subscribeCount{};
  shared_ptr<string> title{};
  shared_ptr<long> uv{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  QueryGroupLiveInfoResponseBody() {}

  explicit QueryGroupLiveInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverUrl) {
      res["coverUrl"] = boost::any(*coverUrl);
    }
    if (duration) {
      res["duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (introduction) {
      res["introduction"] = boost::any(*introduction);
    }
    if (liveId) {
      res["liveId"] = boost::any(*liveId);
    }
    if (livePlayUrl) {
      res["livePlayUrl"] = boost::any(*livePlayUrl);
    }
    if (liveStatus) {
      res["liveStatus"] = boost::any(*liveStatus);
    }
    if (playbackDuration) {
      res["playbackDuration"] = boost::any(*playbackDuration);
    }
    if (replayUrl) {
      res["replayUrl"] = boost::any(*replayUrl);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (staffId) {
      res["staffId"] = boost::any(*staffId);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (subscribeCount) {
      res["subscribeCount"] = boost::any(*subscribeCount);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (uv) {
      res["uv"] = boost::any(*uv);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("coverUrl") != m.end() && !m["coverUrl"].empty()) {
      coverUrl = make_shared<string>(boost::any_cast<string>(m["coverUrl"]));
    }
    if (m.find("duration") != m.end() && !m["duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["duration"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("introduction") != m.end() && !m["introduction"].empty()) {
      introduction = make_shared<string>(boost::any_cast<string>(m["introduction"]));
    }
    if (m.find("liveId") != m.end() && !m["liveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["liveId"]));
    }
    if (m.find("livePlayUrl") != m.end() && !m["livePlayUrl"].empty()) {
      livePlayUrl = make_shared<string>(boost::any_cast<string>(m["livePlayUrl"]));
    }
    if (m.find("liveStatus") != m.end() && !m["liveStatus"].empty()) {
      liveStatus = make_shared<long>(boost::any_cast<long>(m["liveStatus"]));
    }
    if (m.find("playbackDuration") != m.end() && !m["playbackDuration"].empty()) {
      playbackDuration = make_shared<long>(boost::any_cast<long>(m["playbackDuration"]));
    }
    if (m.find("replayUrl") != m.end() && !m["replayUrl"].empty()) {
      replayUrl = make_shared<string>(boost::any_cast<string>(m["replayUrl"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("staffId") != m.end() && !m["staffId"].empty()) {
      staffId = make_shared<string>(boost::any_cast<string>(m["staffId"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("subscribeCount") != m.end() && !m["subscribeCount"].empty()) {
      subscribeCount = make_shared<long>(boost::any_cast<long>(m["subscribeCount"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("uv") != m.end() && !m["uv"].empty()) {
      uv = make_shared<long>(boost::any_cast<long>(m["uv"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~QueryGroupLiveInfoResponseBody() = default;
};
class QueryGroupLiveInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryGroupLiveInfoResponseBody> body{};

  QueryGroupLiveInfoResponse() {}

  explicit QueryGroupLiveInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryGroupLiveInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryGroupLiveInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryGroupLiveInfoResponse() = default;
};
class QueryLiveInfoHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryLiveInfoHeadersAccountContext() {}

  explicit QueryLiveInfoHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryLiveInfoHeadersAccountContext() = default;
};
class QueryLiveInfoHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryLiveInfoHeadersAccountContext> accountContext{};

  QueryLiveInfoHeaders() {}

  explicit QueryLiveInfoHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryLiveInfoHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryLiveInfoHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryLiveInfoHeaders() = default;
};
class QueryLiveInfoShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryLiveInfoShrinkHeaders() {}

  explicit QueryLiveInfoShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryLiveInfoShrinkHeaders() = default;
};
class QueryLiveInfoRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryLiveInfoRequestTenantContext() {}

  explicit QueryLiveInfoRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryLiveInfoRequestTenantContext() = default;
};
class QueryLiveInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveId{};
  shared_ptr<QueryLiveInfoRequestTenantContext> tenantContext{};

  QueryLiveInfoRequest() {}

  explicit QueryLiveInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveId) {
      res["LiveId"] = boost::any(*liveId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveId") != m.end() && !m["LiveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["LiveId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryLiveInfoRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryLiveInfoRequestTenantContext>(model1);
      }
    }
  }


  virtual ~QueryLiveInfoRequest() = default;
};
class QueryLiveInfoShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveId{};
  shared_ptr<string> tenantContextShrink{};

  QueryLiveInfoShrinkRequest() {}

  explicit QueryLiveInfoShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveId) {
      res["LiveId"] = boost::any(*liveId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveId") != m.end() && !m["LiveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["LiveId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~QueryLiveInfoShrinkRequest() = default;
};
class QueryLiveInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> coverUrl{};
  shared_ptr<long> duration{};
  shared_ptr<long> endTime{};
  shared_ptr<string> introduction{};
  shared_ptr<string> liveId{};
  shared_ptr<string> livePlayUrl{};
  shared_ptr<long> liveStatus{};
  shared_ptr<long> playbackDuration{};
  shared_ptr<string> requestId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> subscribeCount{};
  shared_ptr<string> title{};
  shared_ptr<long> uv{};

  QueryLiveInfoResponseBody() {}

  explicit QueryLiveInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverUrl) {
      res["coverUrl"] = boost::any(*coverUrl);
    }
    if (duration) {
      res["duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (introduction) {
      res["introduction"] = boost::any(*introduction);
    }
    if (liveId) {
      res["liveId"] = boost::any(*liveId);
    }
    if (livePlayUrl) {
      res["livePlayUrl"] = boost::any(*livePlayUrl);
    }
    if (liveStatus) {
      res["liveStatus"] = boost::any(*liveStatus);
    }
    if (playbackDuration) {
      res["playbackDuration"] = boost::any(*playbackDuration);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (subscribeCount) {
      res["subscribeCount"] = boost::any(*subscribeCount);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (uv) {
      res["uv"] = boost::any(*uv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("coverUrl") != m.end() && !m["coverUrl"].empty()) {
      coverUrl = make_shared<string>(boost::any_cast<string>(m["coverUrl"]));
    }
    if (m.find("duration") != m.end() && !m["duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["duration"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("introduction") != m.end() && !m["introduction"].empty()) {
      introduction = make_shared<string>(boost::any_cast<string>(m["introduction"]));
    }
    if (m.find("liveId") != m.end() && !m["liveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["liveId"]));
    }
    if (m.find("livePlayUrl") != m.end() && !m["livePlayUrl"].empty()) {
      livePlayUrl = make_shared<string>(boost::any_cast<string>(m["livePlayUrl"]));
    }
    if (m.find("liveStatus") != m.end() && !m["liveStatus"].empty()) {
      liveStatus = make_shared<long>(boost::any_cast<long>(m["liveStatus"]));
    }
    if (m.find("playbackDuration") != m.end() && !m["playbackDuration"].empty()) {
      playbackDuration = make_shared<long>(boost::any_cast<long>(m["playbackDuration"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("subscribeCount") != m.end() && !m["subscribeCount"].empty()) {
      subscribeCount = make_shared<long>(boost::any_cast<long>(m["subscribeCount"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("uv") != m.end() && !m["uv"].empty()) {
      uv = make_shared<long>(boost::any_cast<long>(m["uv"]));
    }
  }


  virtual ~QueryLiveInfoResponseBody() = default;
};
class QueryLiveInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryLiveInfoResponseBody> body{};

  QueryLiveInfoResponse() {}

  explicit QueryLiveInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryLiveInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryLiveInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryLiveInfoResponse() = default;
};
class QueryLiveWatchDetailHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryLiveWatchDetailHeadersAccountContext() {}

  explicit QueryLiveWatchDetailHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryLiveWatchDetailHeadersAccountContext() = default;
};
class QueryLiveWatchDetailHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryLiveWatchDetailHeadersAccountContext> accountContext{};

  QueryLiveWatchDetailHeaders() {}

  explicit QueryLiveWatchDetailHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryLiveWatchDetailHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryLiveWatchDetailHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryLiveWatchDetailHeaders() = default;
};
class QueryLiveWatchDetailShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryLiveWatchDetailShrinkHeaders() {}

  explicit QueryLiveWatchDetailShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryLiveWatchDetailShrinkHeaders() = default;
};
class QueryLiveWatchDetailRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryLiveWatchDetailRequestTenantContext() {}

  explicit QueryLiveWatchDetailRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryLiveWatchDetailRequestTenantContext() = default;
};
class QueryLiveWatchDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveId{};
  shared_ptr<QueryLiveWatchDetailRequestTenantContext> tenantContext{};

  QueryLiveWatchDetailRequest() {}

  explicit QueryLiveWatchDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveId) {
      res["LiveId"] = boost::any(*liveId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveId") != m.end() && !m["LiveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["LiveId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryLiveWatchDetailRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryLiveWatchDetailRequestTenantContext>(model1);
      }
    }
  }


  virtual ~QueryLiveWatchDetailRequest() = default;
};
class QueryLiveWatchDetailShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveId{};
  shared_ptr<string> tenantContextShrink{};

  QueryLiveWatchDetailShrinkRequest() {}

  explicit QueryLiveWatchDetailShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveId) {
      res["LiveId"] = boost::any(*liveId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveId") != m.end() && !m["LiveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["LiveId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~QueryLiveWatchDetailShrinkRequest() = default;
};
class QueryLiveWatchDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> avgWatchTime{};
  shared_ptr<long> liveUv{};
  shared_ptr<long> msgCount{};
  shared_ptr<long> playbackUv{};
  shared_ptr<long> praiseCount{};
  shared_ptr<long> pv{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalWatchTime{};
  shared_ptr<long> uv{};

  QueryLiveWatchDetailResponseBody() {}

  explicit QueryLiveWatchDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgWatchTime) {
      res["avgWatchTime"] = boost::any(*avgWatchTime);
    }
    if (liveUv) {
      res["liveUv"] = boost::any(*liveUv);
    }
    if (msgCount) {
      res["msgCount"] = boost::any(*msgCount);
    }
    if (playbackUv) {
      res["playbackUv"] = boost::any(*playbackUv);
    }
    if (praiseCount) {
      res["praiseCount"] = boost::any(*praiseCount);
    }
    if (pv) {
      res["pv"] = boost::any(*pv);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalWatchTime) {
      res["totalWatchTime"] = boost::any(*totalWatchTime);
    }
    if (uv) {
      res["uv"] = boost::any(*uv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avgWatchTime") != m.end() && !m["avgWatchTime"].empty()) {
      avgWatchTime = make_shared<long>(boost::any_cast<long>(m["avgWatchTime"]));
    }
    if (m.find("liveUv") != m.end() && !m["liveUv"].empty()) {
      liveUv = make_shared<long>(boost::any_cast<long>(m["liveUv"]));
    }
    if (m.find("msgCount") != m.end() && !m["msgCount"].empty()) {
      msgCount = make_shared<long>(boost::any_cast<long>(m["msgCount"]));
    }
    if (m.find("playbackUv") != m.end() && !m["playbackUv"].empty()) {
      playbackUv = make_shared<long>(boost::any_cast<long>(m["playbackUv"]));
    }
    if (m.find("praiseCount") != m.end() && !m["praiseCount"].empty()) {
      praiseCount = make_shared<long>(boost::any_cast<long>(m["praiseCount"]));
    }
    if (m.find("pv") != m.end() && !m["pv"].empty()) {
      pv = make_shared<long>(boost::any_cast<long>(m["pv"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalWatchTime") != m.end() && !m["totalWatchTime"].empty()) {
      totalWatchTime = make_shared<long>(boost::any_cast<long>(m["totalWatchTime"]));
    }
    if (m.find("uv") != m.end() && !m["uv"].empty()) {
      uv = make_shared<long>(boost::any_cast<long>(m["uv"]));
    }
  }


  virtual ~QueryLiveWatchDetailResponseBody() = default;
};
class QueryLiveWatchDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryLiveWatchDetailResponseBody> body{};

  QueryLiveWatchDetailResponse() {}

  explicit QueryLiveWatchDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryLiveWatchDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryLiveWatchDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryLiveWatchDetailResponse() = default;
};
class QueryLiveWatchUserListHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryLiveWatchUserListHeadersAccountContext() {}

  explicit QueryLiveWatchUserListHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryLiveWatchUserListHeadersAccountContext() = default;
};
class QueryLiveWatchUserListHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryLiveWatchUserListHeadersAccountContext> accountContext{};

  QueryLiveWatchUserListHeaders() {}

  explicit QueryLiveWatchUserListHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryLiveWatchUserListHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryLiveWatchUserListHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryLiveWatchUserListHeaders() = default;
};
class QueryLiveWatchUserListShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryLiveWatchUserListShrinkHeaders() {}

  explicit QueryLiveWatchUserListShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryLiveWatchUserListShrinkHeaders() = default;
};
class QueryLiveWatchUserListRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryLiveWatchUserListRequestTenantContext() {}

  explicit QueryLiveWatchUserListRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryLiveWatchUserListRequestTenantContext() = default;
};
class QueryLiveWatchUserListRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<QueryLiveWatchUserListRequestTenantContext> tenantContext{};

  QueryLiveWatchUserListRequest() {}

  explicit QueryLiveWatchUserListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveId) {
      res["LiveId"] = boost::any(*liveId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveId") != m.end() && !m["LiveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["LiveId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryLiveWatchUserListRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryLiveWatchUserListRequestTenantContext>(model1);
      }
    }
  }


  virtual ~QueryLiveWatchUserListRequest() = default;
};
class QueryLiveWatchUserListShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> tenantContextShrink{};

  QueryLiveWatchUserListShrinkRequest() {}

  explicit QueryLiveWatchUserListShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveId) {
      res["LiveId"] = boost::any(*liveId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveId") != m.end() && !m["LiveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["LiveId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~QueryLiveWatchUserListShrinkRequest() = default;
};
class QueryLiveWatchUserListResponseBodyOrgUsesList : public Darabonba::Model {
public:
  shared_ptr<string> deptName{};
  shared_ptr<string> name{};
  shared_ptr<string> userId{};
  shared_ptr<long> watchLiveTime{};
  shared_ptr<long> watchPlaybackTime{};
  shared_ptr<long> watchProgressMs{};

  QueryLiveWatchUserListResponseBodyOrgUsesList() {}

  explicit QueryLiveWatchUserListResponseBodyOrgUsesList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deptName) {
      res["DeptName"] = boost::any(*deptName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (watchLiveTime) {
      res["WatchLiveTime"] = boost::any(*watchLiveTime);
    }
    if (watchPlaybackTime) {
      res["WatchPlaybackTime"] = boost::any(*watchPlaybackTime);
    }
    if (watchProgressMs) {
      res["WatchProgressMs"] = boost::any(*watchProgressMs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeptName") != m.end() && !m["DeptName"].empty()) {
      deptName = make_shared<string>(boost::any_cast<string>(m["DeptName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WatchLiveTime") != m.end() && !m["WatchLiveTime"].empty()) {
      watchLiveTime = make_shared<long>(boost::any_cast<long>(m["WatchLiveTime"]));
    }
    if (m.find("WatchPlaybackTime") != m.end() && !m["WatchPlaybackTime"].empty()) {
      watchPlaybackTime = make_shared<long>(boost::any_cast<long>(m["WatchPlaybackTime"]));
    }
    if (m.find("WatchProgressMs") != m.end() && !m["WatchProgressMs"].empty()) {
      watchProgressMs = make_shared<long>(boost::any_cast<long>(m["WatchProgressMs"]));
    }
  }


  virtual ~QueryLiveWatchUserListResponseBodyOrgUsesList() = default;
};
class QueryLiveWatchUserListResponseBodyOutOrgUserList : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> watchLiveTime{};
  shared_ptr<long> watchPlaybackTime{};
  shared_ptr<long> watchProgressMs{};

  QueryLiveWatchUserListResponseBodyOutOrgUserList() {}

  explicit QueryLiveWatchUserListResponseBodyOutOrgUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (watchLiveTime) {
      res["WatchLiveTime"] = boost::any(*watchLiveTime);
    }
    if (watchPlaybackTime) {
      res["WatchPlaybackTime"] = boost::any(*watchPlaybackTime);
    }
    if (watchProgressMs) {
      res["WatchProgressMs"] = boost::any(*watchProgressMs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("WatchLiveTime") != m.end() && !m["WatchLiveTime"].empty()) {
      watchLiveTime = make_shared<long>(boost::any_cast<long>(m["WatchLiveTime"]));
    }
    if (m.find("WatchPlaybackTime") != m.end() && !m["WatchPlaybackTime"].empty()) {
      watchPlaybackTime = make_shared<long>(boost::any_cast<long>(m["WatchPlaybackTime"]));
    }
    if (m.find("WatchProgressMs") != m.end() && !m["WatchProgressMs"].empty()) {
      watchProgressMs = make_shared<long>(boost::any_cast<long>(m["WatchProgressMs"]));
    }
  }


  virtual ~QueryLiveWatchUserListResponseBodyOutOrgUserList() = default;
};
class QueryLiveWatchUserListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryLiveWatchUserListResponseBodyOrgUsesList>> orgUsesList{};
  shared_ptr<vector<QueryLiveWatchUserListResponseBodyOutOrgUserList>> outOrgUserList{};
  shared_ptr<string> requestId{};

  QueryLiveWatchUserListResponseBody() {}

  explicit QueryLiveWatchUserListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orgUsesList) {
      vector<boost::any> temp1;
      for(auto item1:*orgUsesList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["orgUsesList"] = boost::any(temp1);
    }
    if (outOrgUserList) {
      vector<boost::any> temp1;
      for(auto item1:*outOrgUserList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["outOrgUserList"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("orgUsesList") != m.end() && !m["orgUsesList"].empty()) {
      if (typeid(vector<boost::any>) == m["orgUsesList"].type()) {
        vector<QueryLiveWatchUserListResponseBodyOrgUsesList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["orgUsesList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryLiveWatchUserListResponseBodyOrgUsesList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        orgUsesList = make_shared<vector<QueryLiveWatchUserListResponseBodyOrgUsesList>>(expect1);
      }
    }
    if (m.find("outOrgUserList") != m.end() && !m["outOrgUserList"].empty()) {
      if (typeid(vector<boost::any>) == m["outOrgUserList"].type()) {
        vector<QueryLiveWatchUserListResponseBodyOutOrgUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["outOrgUserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryLiveWatchUserListResponseBodyOutOrgUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outOrgUserList = make_shared<vector<QueryLiveWatchUserListResponseBodyOutOrgUserList>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~QueryLiveWatchUserListResponseBody() = default;
};
class QueryLiveWatchUserListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryLiveWatchUserListResponseBody> body{};

  QueryLiveWatchUserListResponse() {}

  explicit QueryLiveWatchUserListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryLiveWatchUserListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryLiveWatchUserListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryLiveWatchUserListResponse() = default;
};
class QueryMeetingRoomHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryMeetingRoomHeadersAccountContext() {}

  explicit QueryMeetingRoomHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryMeetingRoomHeadersAccountContext() = default;
};
class QueryMeetingRoomHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryMeetingRoomHeadersAccountContext> accountContext{};

  QueryMeetingRoomHeaders() {}

  explicit QueryMeetingRoomHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryMeetingRoomHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryMeetingRoomHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomHeaders() = default;
};
class QueryMeetingRoomShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryMeetingRoomShrinkHeaders() {}

  explicit QueryMeetingRoomShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryMeetingRoomShrinkHeaders() = default;
};
class QueryMeetingRoomRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryMeetingRoomRequestTenantContext() {}

  explicit QueryMeetingRoomRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryMeetingRoomRequestTenantContext() = default;
};
class QueryMeetingRoomRequest : public Darabonba::Model {
public:
  shared_ptr<string> roomId{};
  shared_ptr<QueryMeetingRoomRequestTenantContext> tenantContext{};

  QueryMeetingRoomRequest() {}

  explicit QueryMeetingRoomRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryMeetingRoomRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryMeetingRoomRequestTenantContext>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomRequest() = default;
};
class QueryMeetingRoomShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> roomId{};
  shared_ptr<string> tenantContextShrink{};

  QueryMeetingRoomShrinkRequest() {}

  explicit QueryMeetingRoomShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~QueryMeetingRoomShrinkRequest() = default;
};
class QueryMeetingRoomResponseBodyResultReservationAuthorityAuthorizedMembers : public Darabonba::Model {
public:
  shared_ptr<string> memberId{};
  shared_ptr<string> memberName{};
  shared_ptr<string> memberType{};

  QueryMeetingRoomResponseBodyResultReservationAuthorityAuthorizedMembers() {}

  explicit QueryMeetingRoomResponseBodyResultReservationAuthorityAuthorizedMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberId) {
      res["MemberId"] = boost::any(*memberId);
    }
    if (memberName) {
      res["MemberName"] = boost::any(*memberName);
    }
    if (memberType) {
      res["MemberType"] = boost::any(*memberType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemberId") != m.end() && !m["MemberId"].empty()) {
      memberId = make_shared<string>(boost::any_cast<string>(m["MemberId"]));
    }
    if (m.find("MemberName") != m.end() && !m["MemberName"].empty()) {
      memberName = make_shared<string>(boost::any_cast<string>(m["MemberName"]));
    }
    if (m.find("MemberType") != m.end() && !m["MemberType"].empty()) {
      memberType = make_shared<string>(boost::any_cast<string>(m["MemberType"]));
    }
  }


  virtual ~QueryMeetingRoomResponseBodyResultReservationAuthorityAuthorizedMembers() = default;
};
class QueryMeetingRoomResponseBodyResultReservationAuthority : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMeetingRoomResponseBodyResultReservationAuthorityAuthorizedMembers>> authorizedMembers{};

  QueryMeetingRoomResponseBodyResultReservationAuthority() {}

  explicit QueryMeetingRoomResponseBodyResultReservationAuthority(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizedMembers) {
      vector<boost::any> temp1;
      for(auto item1:*authorizedMembers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizedMembers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizedMembers") != m.end() && !m["AuthorizedMembers"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizedMembers"].type()) {
        vector<QueryMeetingRoomResponseBodyResultReservationAuthorityAuthorizedMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizedMembers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMeetingRoomResponseBodyResultReservationAuthorityAuthorizedMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizedMembers = make_shared<vector<QueryMeetingRoomResponseBodyResultReservationAuthorityAuthorizedMembers>>(expect1);
      }
    }
  }


  virtual ~QueryMeetingRoomResponseBodyResultReservationAuthority() = default;
};
class QueryMeetingRoomResponseBodyResultRoomGroup : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<long> parentId{};

  QueryMeetingRoomResponseBodyResultRoomGroup() {}

  explicit QueryMeetingRoomResponseBodyResultRoomGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
  }


  virtual ~QueryMeetingRoomResponseBodyResultRoomGroup() = default;
};
class QueryMeetingRoomResponseBodyResultRoomLabels : public Darabonba::Model {
public:
  shared_ptr<long> labelId{};
  shared_ptr<string> labelName{};

  QueryMeetingRoomResponseBodyResultRoomLabels() {}

  explicit QueryMeetingRoomResponseBodyResultRoomLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (labelId) {
      res["LabelId"] = boost::any(*labelId);
    }
    if (labelName) {
      res["LabelName"] = boost::any(*labelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LabelId") != m.end() && !m["LabelId"].empty()) {
      labelId = make_shared<long>(boost::any_cast<long>(m["LabelId"]));
    }
    if (m.find("LabelName") != m.end() && !m["LabelName"].empty()) {
      labelName = make_shared<string>(boost::any_cast<string>(m["LabelName"]));
    }
  }


  virtual ~QueryMeetingRoomResponseBodyResultRoomLabels() = default;
};
class QueryMeetingRoomResponseBodyResultRoomLocation : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> title{};

  QueryMeetingRoomResponseBodyResultRoomLocation() {}

  explicit QueryMeetingRoomResponseBodyResultRoomLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~QueryMeetingRoomResponseBodyResultRoomLocation() = default;
};
class QueryMeetingRoomResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<vector<string>> deviceUnionIds{};
  shared_ptr<bool> enableCycleReservation{};
  shared_ptr<string> isvRoomId{};
  shared_ptr<QueryMeetingRoomResponseBodyResultReservationAuthority> reservationAuthority{};
  shared_ptr<long> roomCapacity{};
  shared_ptr<QueryMeetingRoomResponseBodyResultRoomGroup> roomGroup{};
  shared_ptr<string> roomId{};
  shared_ptr<vector<QueryMeetingRoomResponseBodyResultRoomLabels>> roomLabels{};
  shared_ptr<QueryMeetingRoomResponseBodyResultRoomLocation> roomLocation{};
  shared_ptr<string> roomName{};
  shared_ptr<string> roomPicture{};
  shared_ptr<string> roomStaffId{};
  shared_ptr<long> roomStatus{};
  shared_ptr<string> roomUnionId{};

  QueryMeetingRoomResponseBodyResult() {}

  explicit QueryMeetingRoomResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (deviceUnionIds) {
      res["DeviceUnionIds"] = boost::any(*deviceUnionIds);
    }
    if (enableCycleReservation) {
      res["EnableCycleReservation"] = boost::any(*enableCycleReservation);
    }
    if (isvRoomId) {
      res["IsvRoomId"] = boost::any(*isvRoomId);
    }
    if (reservationAuthority) {
      res["ReservationAuthority"] = reservationAuthority ? boost::any(reservationAuthority->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (roomCapacity) {
      res["RoomCapacity"] = boost::any(*roomCapacity);
    }
    if (roomGroup) {
      res["RoomGroup"] = roomGroup ? boost::any(roomGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    if (roomLabels) {
      vector<boost::any> temp1;
      for(auto item1:*roomLabels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RoomLabels"] = boost::any(temp1);
    }
    if (roomLocation) {
      res["RoomLocation"] = roomLocation ? boost::any(roomLocation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (roomName) {
      res["RoomName"] = boost::any(*roomName);
    }
    if (roomPicture) {
      res["RoomPicture"] = boost::any(*roomPicture);
    }
    if (roomStaffId) {
      res["RoomStaffId"] = boost::any(*roomStaffId);
    }
    if (roomStatus) {
      res["RoomStatus"] = boost::any(*roomStatus);
    }
    if (roomUnionId) {
      res["RoomUnionId"] = boost::any(*roomUnionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("DeviceUnionIds") != m.end() && !m["DeviceUnionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeviceUnionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeviceUnionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deviceUnionIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnableCycleReservation") != m.end() && !m["EnableCycleReservation"].empty()) {
      enableCycleReservation = make_shared<bool>(boost::any_cast<bool>(m["EnableCycleReservation"]));
    }
    if (m.find("IsvRoomId") != m.end() && !m["IsvRoomId"].empty()) {
      isvRoomId = make_shared<string>(boost::any_cast<string>(m["IsvRoomId"]));
    }
    if (m.find("ReservationAuthority") != m.end() && !m["ReservationAuthority"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReservationAuthority"].type()) {
        QueryMeetingRoomResponseBodyResultReservationAuthority model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReservationAuthority"]));
        reservationAuthority = make_shared<QueryMeetingRoomResponseBodyResultReservationAuthority>(model1);
      }
    }
    if (m.find("RoomCapacity") != m.end() && !m["RoomCapacity"].empty()) {
      roomCapacity = make_shared<long>(boost::any_cast<long>(m["RoomCapacity"]));
    }
    if (m.find("RoomGroup") != m.end() && !m["RoomGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoomGroup"].type()) {
        QueryMeetingRoomResponseBodyResultRoomGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoomGroup"]));
        roomGroup = make_shared<QueryMeetingRoomResponseBodyResultRoomGroup>(model1);
      }
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
    if (m.find("RoomLabels") != m.end() && !m["RoomLabels"].empty()) {
      if (typeid(vector<boost::any>) == m["RoomLabels"].type()) {
        vector<QueryMeetingRoomResponseBodyResultRoomLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RoomLabels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMeetingRoomResponseBodyResultRoomLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roomLabels = make_shared<vector<QueryMeetingRoomResponseBodyResultRoomLabels>>(expect1);
      }
    }
    if (m.find("RoomLocation") != m.end() && !m["RoomLocation"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoomLocation"].type()) {
        QueryMeetingRoomResponseBodyResultRoomLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoomLocation"]));
        roomLocation = make_shared<QueryMeetingRoomResponseBodyResultRoomLocation>(model1);
      }
    }
    if (m.find("RoomName") != m.end() && !m["RoomName"].empty()) {
      roomName = make_shared<string>(boost::any_cast<string>(m["RoomName"]));
    }
    if (m.find("RoomPicture") != m.end() && !m["RoomPicture"].empty()) {
      roomPicture = make_shared<string>(boost::any_cast<string>(m["RoomPicture"]));
    }
    if (m.find("RoomStaffId") != m.end() && !m["RoomStaffId"].empty()) {
      roomStaffId = make_shared<string>(boost::any_cast<string>(m["RoomStaffId"]));
    }
    if (m.find("RoomStatus") != m.end() && !m["RoomStatus"].empty()) {
      roomStatus = make_shared<long>(boost::any_cast<long>(m["RoomStatus"]));
    }
    if (m.find("RoomUnionId") != m.end() && !m["RoomUnionId"].empty()) {
      roomUnionId = make_shared<string>(boost::any_cast<string>(m["RoomUnionId"]));
    }
  }


  virtual ~QueryMeetingRoomResponseBodyResult() = default;
};
class QueryMeetingRoomResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryMeetingRoomResponseBodyResult> result{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  QueryMeetingRoomResponseBody() {}

  explicit QueryMeetingRoomResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        QueryMeetingRoomResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<QueryMeetingRoomResponseBodyResult>(model1);
      }
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~QueryMeetingRoomResponseBody() = default;
};
class QueryMeetingRoomResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMeetingRoomResponseBody> body{};

  QueryMeetingRoomResponse() {}

  explicit QueryMeetingRoomResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMeetingRoomResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMeetingRoomResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomResponse() = default;
};
class QueryMeetingRoomGroupHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryMeetingRoomGroupHeadersAccountContext() {}

  explicit QueryMeetingRoomGroupHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryMeetingRoomGroupHeadersAccountContext() = default;
};
class QueryMeetingRoomGroupHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryMeetingRoomGroupHeadersAccountContext> accountContext{};

  QueryMeetingRoomGroupHeaders() {}

  explicit QueryMeetingRoomGroupHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryMeetingRoomGroupHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryMeetingRoomGroupHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomGroupHeaders() = default;
};
class QueryMeetingRoomGroupShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryMeetingRoomGroupShrinkHeaders() {}

  explicit QueryMeetingRoomGroupShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryMeetingRoomGroupShrinkHeaders() = default;
};
class QueryMeetingRoomGroupRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryMeetingRoomGroupRequestTenantContext() {}

  explicit QueryMeetingRoomGroupRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryMeetingRoomGroupRequestTenantContext() = default;
};
class QueryMeetingRoomGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<QueryMeetingRoomGroupRequestTenantContext> tenantContext{};

  QueryMeetingRoomGroupRequest() {}

  explicit QueryMeetingRoomGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryMeetingRoomGroupRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryMeetingRoomGroupRequestTenantContext>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomGroupRequest() = default;
};
class QueryMeetingRoomGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> tenantContextShrink{};

  QueryMeetingRoomGroupShrinkRequest() {}

  explicit QueryMeetingRoomGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~QueryMeetingRoomGroupShrinkRequest() = default;
};
class QueryMeetingRoomGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<long> parentId{};
  shared_ptr<string> requestId{};

  QueryMeetingRoomGroupResponseBody() {}

  explicit QueryMeetingRoomGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["groupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["groupName"] = boost::any(*groupName);
    }
    if (parentId) {
      res["parentId"] = boost::any(*parentId);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("groupId") != m.end() && !m["groupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["groupId"]));
    }
    if (m.find("groupName") != m.end() && !m["groupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["groupName"]));
    }
    if (m.find("parentId") != m.end() && !m["parentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["parentId"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~QueryMeetingRoomGroupResponseBody() = default;
};
class QueryMeetingRoomGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMeetingRoomGroupResponseBody> body{};

  QueryMeetingRoomGroupResponse() {}

  explicit QueryMeetingRoomGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMeetingRoomGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMeetingRoomGroupResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomGroupResponse() = default;
};
class QueryMeetingRoomGroupListHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryMeetingRoomGroupListHeadersAccountContext() {}

  explicit QueryMeetingRoomGroupListHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryMeetingRoomGroupListHeadersAccountContext() = default;
};
class QueryMeetingRoomGroupListHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryMeetingRoomGroupListHeadersAccountContext> accountContext{};

  QueryMeetingRoomGroupListHeaders() {}

  explicit QueryMeetingRoomGroupListHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryMeetingRoomGroupListHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryMeetingRoomGroupListHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomGroupListHeaders() = default;
};
class QueryMeetingRoomGroupListShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryMeetingRoomGroupListShrinkHeaders() {}

  explicit QueryMeetingRoomGroupListShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryMeetingRoomGroupListShrinkHeaders() = default;
};
class QueryMeetingRoomGroupListRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryMeetingRoomGroupListRequestTenantContext() {}

  explicit QueryMeetingRoomGroupListRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryMeetingRoomGroupListRequestTenantContext() = default;
};
class QueryMeetingRoomGroupListRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> request{};
  shared_ptr<QueryMeetingRoomGroupListRequestTenantContext> tenantContext{};

  QueryMeetingRoomGroupListRequest() {}

  explicit QueryMeetingRoomGroupListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (request) {
      res["Request"] = boost::any(*request);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Request") != m.end() && !m["Request"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Request"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      request = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryMeetingRoomGroupListRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryMeetingRoomGroupListRequestTenantContext>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomGroupListRequest() = default;
};
class QueryMeetingRoomGroupListShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> requestShrink{};
  shared_ptr<string> tenantContextShrink{};

  QueryMeetingRoomGroupListShrinkRequest() {}

  explicit QueryMeetingRoomGroupListShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestShrink) {
      res["Request"] = boost::any(*requestShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Request") != m.end() && !m["Request"].empty()) {
      requestShrink = make_shared<string>(boost::any_cast<string>(m["Request"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~QueryMeetingRoomGroupListShrinkRequest() = default;
};
class QueryMeetingRoomGroupListResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<long> parentId{};

  QueryMeetingRoomGroupListResponseBodyResult() {}

  explicit QueryMeetingRoomGroupListResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
  }


  virtual ~QueryMeetingRoomGroupListResponseBodyResult() = default;
};
class QueryMeetingRoomGroupListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<QueryMeetingRoomGroupListResponseBodyResult>> result{};

  QueryMeetingRoomGroupListResponseBody() {}

  explicit QueryMeetingRoomGroupListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<QueryMeetingRoomGroupListResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMeetingRoomGroupListResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<QueryMeetingRoomGroupListResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~QueryMeetingRoomGroupListResponseBody() = default;
};
class QueryMeetingRoomGroupListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMeetingRoomGroupListResponseBody> body{};

  QueryMeetingRoomGroupListResponse() {}

  explicit QueryMeetingRoomGroupListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMeetingRoomGroupListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMeetingRoomGroupListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomGroupListResponse() = default;
};
class QueryMeetingRoomListHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryMeetingRoomListHeadersAccountContext() {}

  explicit QueryMeetingRoomListHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryMeetingRoomListHeadersAccountContext() = default;
};
class QueryMeetingRoomListHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryMeetingRoomListHeadersAccountContext> accountContext{};

  QueryMeetingRoomListHeaders() {}

  explicit QueryMeetingRoomListHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryMeetingRoomListHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryMeetingRoomListHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomListHeaders() = default;
};
class QueryMeetingRoomListShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryMeetingRoomListShrinkHeaders() {}

  explicit QueryMeetingRoomListShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryMeetingRoomListShrinkHeaders() = default;
};
class QueryMeetingRoomListRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryMeetingRoomListRequestTenantContext() {}

  explicit QueryMeetingRoomListRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryMeetingRoomListRequestTenantContext() = default;
};
class QueryMeetingRoomListRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<long> nextToken{};
  shared_ptr<QueryMeetingRoomListRequestTenantContext> tenantContext{};

  QueryMeetingRoomListRequest() {}

  explicit QueryMeetingRoomListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryMeetingRoomListRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryMeetingRoomListRequestTenantContext>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomListRequest() = default;
};
class QueryMeetingRoomListShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<long> nextToken{};
  shared_ptr<string> tenantContextShrink{};

  QueryMeetingRoomListShrinkRequest() {}

  explicit QueryMeetingRoomListShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~QueryMeetingRoomListShrinkRequest() = default;
};
class QueryMeetingRoomListResponseBodyResultRoomGroup : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<long> parentId{};

  QueryMeetingRoomListResponseBodyResultRoomGroup() {}

  explicit QueryMeetingRoomListResponseBodyResultRoomGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
  }


  virtual ~QueryMeetingRoomListResponseBodyResultRoomGroup() = default;
};
class QueryMeetingRoomListResponseBodyResultRoomLabels : public Darabonba::Model {
public:
  shared_ptr<long> labelId{};
  shared_ptr<string> labelName{};

  QueryMeetingRoomListResponseBodyResultRoomLabels() {}

  explicit QueryMeetingRoomListResponseBodyResultRoomLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (labelId) {
      res["LabelId"] = boost::any(*labelId);
    }
    if (labelName) {
      res["LabelName"] = boost::any(*labelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LabelId") != m.end() && !m["LabelId"].empty()) {
      labelId = make_shared<long>(boost::any_cast<long>(m["LabelId"]));
    }
    if (m.find("LabelName") != m.end() && !m["LabelName"].empty()) {
      labelName = make_shared<string>(boost::any_cast<string>(m["LabelName"]));
    }
  }


  virtual ~QueryMeetingRoomListResponseBodyResultRoomLabels() = default;
};
class QueryMeetingRoomListResponseBodyResultRoomLocation : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> title{};

  QueryMeetingRoomListResponseBodyResultRoomLocation() {}

  explicit QueryMeetingRoomListResponseBodyResultRoomLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~QueryMeetingRoomListResponseBodyResultRoomLocation() = default;
};
class QueryMeetingRoomListResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<string> isvRoomId{};
  shared_ptr<long> roomCapacity{};
  shared_ptr<QueryMeetingRoomListResponseBodyResultRoomGroup> roomGroup{};
  shared_ptr<string> roomId{};
  shared_ptr<vector<QueryMeetingRoomListResponseBodyResultRoomLabels>> roomLabels{};
  shared_ptr<QueryMeetingRoomListResponseBodyResultRoomLocation> roomLocation{};
  shared_ptr<string> roomName{};
  shared_ptr<string> roomPicture{};
  shared_ptr<string> roomStaffId{};
  shared_ptr<long> roomStatus{};

  QueryMeetingRoomListResponseBodyResult() {}

  explicit QueryMeetingRoomListResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (isvRoomId) {
      res["IsvRoomId"] = boost::any(*isvRoomId);
    }
    if (roomCapacity) {
      res["RoomCapacity"] = boost::any(*roomCapacity);
    }
    if (roomGroup) {
      res["RoomGroup"] = roomGroup ? boost::any(roomGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    if (roomLabels) {
      vector<boost::any> temp1;
      for(auto item1:*roomLabels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RoomLabels"] = boost::any(temp1);
    }
    if (roomLocation) {
      res["RoomLocation"] = roomLocation ? boost::any(roomLocation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (roomName) {
      res["RoomName"] = boost::any(*roomName);
    }
    if (roomPicture) {
      res["RoomPicture"] = boost::any(*roomPicture);
    }
    if (roomStaffId) {
      res["RoomStaffId"] = boost::any(*roomStaffId);
    }
    if (roomStatus) {
      res["RoomStatus"] = boost::any(*roomStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("IsvRoomId") != m.end() && !m["IsvRoomId"].empty()) {
      isvRoomId = make_shared<string>(boost::any_cast<string>(m["IsvRoomId"]));
    }
    if (m.find("RoomCapacity") != m.end() && !m["RoomCapacity"].empty()) {
      roomCapacity = make_shared<long>(boost::any_cast<long>(m["RoomCapacity"]));
    }
    if (m.find("RoomGroup") != m.end() && !m["RoomGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoomGroup"].type()) {
        QueryMeetingRoomListResponseBodyResultRoomGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoomGroup"]));
        roomGroup = make_shared<QueryMeetingRoomListResponseBodyResultRoomGroup>(model1);
      }
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
    if (m.find("RoomLabels") != m.end() && !m["RoomLabels"].empty()) {
      if (typeid(vector<boost::any>) == m["RoomLabels"].type()) {
        vector<QueryMeetingRoomListResponseBodyResultRoomLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RoomLabels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMeetingRoomListResponseBodyResultRoomLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roomLabels = make_shared<vector<QueryMeetingRoomListResponseBodyResultRoomLabels>>(expect1);
      }
    }
    if (m.find("RoomLocation") != m.end() && !m["RoomLocation"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoomLocation"].type()) {
        QueryMeetingRoomListResponseBodyResultRoomLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoomLocation"]));
        roomLocation = make_shared<QueryMeetingRoomListResponseBodyResultRoomLocation>(model1);
      }
    }
    if (m.find("RoomName") != m.end() && !m["RoomName"].empty()) {
      roomName = make_shared<string>(boost::any_cast<string>(m["RoomName"]));
    }
    if (m.find("RoomPicture") != m.end() && !m["RoomPicture"].empty()) {
      roomPicture = make_shared<string>(boost::any_cast<string>(m["RoomPicture"]));
    }
    if (m.find("RoomStaffId") != m.end() && !m["RoomStaffId"].empty()) {
      roomStaffId = make_shared<string>(boost::any_cast<string>(m["RoomStaffId"]));
    }
    if (m.find("RoomStatus") != m.end() && !m["RoomStatus"].empty()) {
      roomStatus = make_shared<long>(boost::any_cast<long>(m["RoomStatus"]));
    }
  }


  virtual ~QueryMeetingRoomListResponseBodyResult() = default;
};
class QueryMeetingRoomListResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> hasMore{};
  shared_ptr<long> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<QueryMeetingRoomListResponseBodyResult>> result{};

  QueryMeetingRoomListResponseBody() {}

  explicit QueryMeetingRoomListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasMore) {
      res["hasMore"] = boost::any(*hasMore);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hasMore") != m.end() && !m["hasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["hasMore"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<QueryMeetingRoomListResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMeetingRoomListResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<QueryMeetingRoomListResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~QueryMeetingRoomListResponseBody() = default;
};
class QueryMeetingRoomListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMeetingRoomListResponseBody> body{};

  QueryMeetingRoomListResponse() {}

  explicit QueryMeetingRoomListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMeetingRoomListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMeetingRoomListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomListResponse() = default;
};
class QueryMinutesHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryMinutesHeadersAccountContext() {}

  explicit QueryMinutesHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryMinutesHeadersAccountContext() = default;
};
class QueryMinutesHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryMinutesHeadersAccountContext> accountContext{};

  QueryMinutesHeaders() {}

  explicit QueryMinutesHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryMinutesHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryMinutesHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryMinutesHeaders() = default;
};
class QueryMinutesShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryMinutesShrinkHeaders() {}

  explicit QueryMinutesShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryMinutesShrinkHeaders() = default;
};
class QueryMinutesRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryMinutesRequestTenantContext() {}

  explicit QueryMinutesRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryMinutesRequestTenantContext() = default;
};
class QueryMinutesRequest : public Darabonba::Model {
public:
  shared_ptr<QueryMinutesRequestTenantContext> tenantContext{};
  shared_ptr<string> conferenceId{};

  QueryMinutesRequest() {}

  explicit QueryMinutesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryMinutesRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryMinutesRequestTenantContext>(model1);
      }
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~QueryMinutesRequest() = default;
};
class QueryMinutesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> conferenceId{};

  QueryMinutesShrinkRequest() {}

  explicit QueryMinutesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~QueryMinutesShrinkRequest() = default;
};
class QueryMinutesResponseBodyAudioList : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<long> endTime{};
  shared_ptr<long> fileSize{};
  shared_ptr<string> playUrl{};
  shared_ptr<string> recordId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> userId{};

  QueryMinutesResponseBodyAudioList() {}

  explicit QueryMinutesResponseBodyAudioList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (playUrl) {
      res["PlayUrl"] = boost::any(*playUrl);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["FileSize"]));
    }
    if (m.find("PlayUrl") != m.end() && !m["PlayUrl"].empty()) {
      playUrl = make_shared<string>(boost::any_cast<string>(m["PlayUrl"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryMinutesResponseBodyAudioList() = default;
};
class QueryMinutesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMinutesResponseBodyAudioList>> audioList{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  QueryMinutesResponseBody() {}

  explicit QueryMinutesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioList) {
      vector<boost::any> temp1;
      for(auto item1:*audioList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["audioList"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("audioList") != m.end() && !m["audioList"].empty()) {
      if (typeid(vector<boost::any>) == m["audioList"].type()) {
        vector<QueryMinutesResponseBodyAudioList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["audioList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMinutesResponseBodyAudioList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioList = make_shared<vector<QueryMinutesResponseBodyAudioList>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~QueryMinutesResponseBody() = default;
};
class QueryMinutesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMinutesResponseBody> body{};

  QueryMinutesResponse() {}

  explicit QueryMinutesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMinutesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMinutesResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMinutesResponse() = default;
};
class QueryMinutesSummaryHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryMinutesSummaryHeadersAccountContext() {}

  explicit QueryMinutesSummaryHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryMinutesSummaryHeadersAccountContext() = default;
};
class QueryMinutesSummaryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryMinutesSummaryHeadersAccountContext> accountContext{};

  QueryMinutesSummaryHeaders() {}

  explicit QueryMinutesSummaryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryMinutesSummaryHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryMinutesSummaryHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryMinutesSummaryHeaders() = default;
};
class QueryMinutesSummaryShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryMinutesSummaryShrinkHeaders() {}

  explicit QueryMinutesSummaryShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryMinutesSummaryShrinkHeaders() = default;
};
class QueryMinutesSummaryRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryMinutesSummaryRequestTenantContext() {}

  explicit QueryMinutesSummaryRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryMinutesSummaryRequestTenantContext() = default;
};
class QueryMinutesSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<QueryMinutesSummaryRequestTenantContext> tenantContext{};
  shared_ptr<string> conferenceId{};
  shared_ptr<vector<string>> summaryTypeList{};

  QueryMinutesSummaryRequest() {}

  explicit QueryMinutesSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    if (summaryTypeList) {
      res["summaryTypeList"] = boost::any(*summaryTypeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryMinutesSummaryRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryMinutesSummaryRequestTenantContext>(model1);
      }
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
    if (m.find("summaryTypeList") != m.end() && !m["summaryTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["summaryTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["summaryTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      summaryTypeList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMinutesSummaryRequest() = default;
};
class QueryMinutesSummaryShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> conferenceId{};
  shared_ptr<string> summaryTypeListShrink{};

  QueryMinutesSummaryShrinkRequest() {}

  explicit QueryMinutesSummaryShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    if (summaryTypeListShrink) {
      res["summaryTypeList"] = boost::any(*summaryTypeListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
    if (m.find("summaryTypeList") != m.end() && !m["summaryTypeList"].empty()) {
      summaryTypeListShrink = make_shared<string>(boost::any_cast<string>(m["summaryTypeList"]));
    }
  }


  virtual ~QueryMinutesSummaryShrinkRequest() = default;
};
class QueryMinutesSummaryResponseBodySummaryActions : public Darabonba::Model {
public:
  shared_ptr<long> end{};
  shared_ptr<long> id{};
  shared_ptr<long> sentenceId{};
  shared_ptr<long> start{};
  shared_ptr<string> text{};

  QueryMinutesSummaryResponseBodySummaryActions() {}

  explicit QueryMinutesSummaryResponseBodySummaryActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (sentenceId) {
      res["SentenceId"] = boost::any(*sentenceId);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("SentenceId") != m.end() && !m["SentenceId"].empty()) {
      sentenceId = make_shared<long>(boost::any_cast<long>(m["SentenceId"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~QueryMinutesSummaryResponseBodySummaryActions() = default;
};
class QueryMinutesSummaryResponseBodySummaryAutoChapters : public Darabonba::Model {
public:
  shared_ptr<long> end{};
  shared_ptr<string> headline{};
  shared_ptr<long> id{};
  shared_ptr<long> start{};
  shared_ptr<string> summary{};

  QueryMinutesSummaryResponseBodySummaryAutoChapters() {}

  explicit QueryMinutesSummaryResponseBodySummaryAutoChapters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (headline) {
      res["Headline"] = boost::any(*headline);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("Headline") != m.end() && !m["Headline"].empty()) {
      headline = make_shared<string>(boost::any_cast<string>(m["Headline"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~QueryMinutesSummaryResponseBodySummaryAutoChapters() = default;
};
class QueryMinutesSummaryResponseBodySummaryConversationalSummary : public Darabonba::Model {
public:
  shared_ptr<string> speakerId{};
  shared_ptr<string> speakerName{};
  shared_ptr<string> summary{};

  QueryMinutesSummaryResponseBodySummaryConversationalSummary() {}

  explicit QueryMinutesSummaryResponseBodySummaryConversationalSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (speakerId) {
      res["SpeakerId"] = boost::any(*speakerId);
    }
    if (speakerName) {
      res["SpeakerName"] = boost::any(*speakerName);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpeakerId") != m.end() && !m["SpeakerId"].empty()) {
      speakerId = make_shared<string>(boost::any_cast<string>(m["SpeakerId"]));
    }
    if (m.find("SpeakerName") != m.end() && !m["SpeakerName"].empty()) {
      speakerName = make_shared<string>(boost::any_cast<string>(m["SpeakerName"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~QueryMinutesSummaryResponseBodySummaryConversationalSummary() = default;
};
class QueryMinutesSummaryResponseBodySummaryKeySentences : public Darabonba::Model {
public:
  shared_ptr<long> end{};
  shared_ptr<long> id{};
  shared_ptr<long> sentenceId{};
  shared_ptr<long> start{};
  shared_ptr<string> text{};

  QueryMinutesSummaryResponseBodySummaryKeySentences() {}

  explicit QueryMinutesSummaryResponseBodySummaryKeySentences(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (sentenceId) {
      res["SentenceId"] = boost::any(*sentenceId);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("SentenceId") != m.end() && !m["SentenceId"].empty()) {
      sentenceId = make_shared<long>(boost::any_cast<long>(m["SentenceId"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~QueryMinutesSummaryResponseBodySummaryKeySentences() = default;
};
class QueryMinutesSummaryResponseBodySummaryQuestionsAnsweringSummary : public Darabonba::Model {
public:
  shared_ptr<string> answer{};
  shared_ptr<string> question{};
  shared_ptr<vector<long>> sentenceIdsOfAnswer{};
  shared_ptr<vector<long>> sentenceIdsOfQuestion{};

  QueryMinutesSummaryResponseBodySummaryQuestionsAnsweringSummary() {}

  explicit QueryMinutesSummaryResponseBodySummaryQuestionsAnsweringSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answer) {
      res["Answer"] = boost::any(*answer);
    }
    if (question) {
      res["Question"] = boost::any(*question);
    }
    if (sentenceIdsOfAnswer) {
      res["SentenceIdsOfAnswer"] = boost::any(*sentenceIdsOfAnswer);
    }
    if (sentenceIdsOfQuestion) {
      res["SentenceIdsOfQuestion"] = boost::any(*sentenceIdsOfQuestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Answer") != m.end() && !m["Answer"].empty()) {
      answer = make_shared<string>(boost::any_cast<string>(m["Answer"]));
    }
    if (m.find("Question") != m.end() && !m["Question"].empty()) {
      question = make_shared<string>(boost::any_cast<string>(m["Question"]));
    }
    if (m.find("SentenceIdsOfAnswer") != m.end() && !m["SentenceIdsOfAnswer"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["SentenceIdsOfAnswer"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SentenceIdsOfAnswer"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      sentenceIdsOfAnswer = make_shared<vector<long>>(toVec1);
    }
    if (m.find("SentenceIdsOfQuestion") != m.end() && !m["SentenceIdsOfQuestion"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["SentenceIdsOfQuestion"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SentenceIdsOfQuestion"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      sentenceIdsOfQuestion = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~QueryMinutesSummaryResponseBodySummaryQuestionsAnsweringSummary() = default;
};
class QueryMinutesSummaryResponseBodySummary : public Darabonba::Model {
public:
  shared_ptr<QueryMinutesSummaryResponseBodySummaryActions> actions{};
  shared_ptr<vector<QueryMinutesSummaryResponseBodySummaryAutoChapters>> autoChapters{};
  shared_ptr<vector<QueryMinutesSummaryResponseBodySummaryConversationalSummary>> conversationalSummary{};
  shared_ptr<QueryMinutesSummaryResponseBodySummaryKeySentences> keySentences{};
  shared_ptr<vector<string>> keywords{};
  shared_ptr<string> paragraphSummary{};
  shared_ptr<vector<QueryMinutesSummaryResponseBodySummaryQuestionsAnsweringSummary>> questionsAnsweringSummary{};

  QueryMinutesSummaryResponseBodySummary() {}

  explicit QueryMinutesSummaryResponseBodySummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actions) {
      res["Actions"] = actions ? boost::any(actions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (autoChapters) {
      vector<boost::any> temp1;
      for(auto item1:*autoChapters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AutoChapters"] = boost::any(temp1);
    }
    if (conversationalSummary) {
      vector<boost::any> temp1;
      for(auto item1:*conversationalSummary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConversationalSummary"] = boost::any(temp1);
    }
    if (keySentences) {
      res["KeySentences"] = keySentences ? boost::any(keySentences->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    if (paragraphSummary) {
      res["ParagraphSummary"] = boost::any(*paragraphSummary);
    }
    if (questionsAnsweringSummary) {
      vector<boost::any> temp1;
      for(auto item1:*questionsAnsweringSummary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QuestionsAnsweringSummary"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Actions") != m.end() && !m["Actions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Actions"].type()) {
        QueryMinutesSummaryResponseBodySummaryActions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Actions"]));
        actions = make_shared<QueryMinutesSummaryResponseBodySummaryActions>(model1);
      }
    }
    if (m.find("AutoChapters") != m.end() && !m["AutoChapters"].empty()) {
      if (typeid(vector<boost::any>) == m["AutoChapters"].type()) {
        vector<QueryMinutesSummaryResponseBodySummaryAutoChapters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AutoChapters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMinutesSummaryResponseBodySummaryAutoChapters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        autoChapters = make_shared<vector<QueryMinutesSummaryResponseBodySummaryAutoChapters>>(expect1);
      }
    }
    if (m.find("ConversationalSummary") != m.end() && !m["ConversationalSummary"].empty()) {
      if (typeid(vector<boost::any>) == m["ConversationalSummary"].type()) {
        vector<QueryMinutesSummaryResponseBodySummaryConversationalSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConversationalSummary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMinutesSummaryResponseBodySummaryConversationalSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conversationalSummary = make_shared<vector<QueryMinutesSummaryResponseBodySummaryConversationalSummary>>(expect1);
      }
    }
    if (m.find("KeySentences") != m.end() && !m["KeySentences"].empty()) {
      if (typeid(map<string, boost::any>) == m["KeySentences"].type()) {
        QueryMinutesSummaryResponseBodySummaryKeySentences model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["KeySentences"]));
        keySentences = make_shared<QueryMinutesSummaryResponseBodySummaryKeySentences>(model1);
      }
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Keywords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Keywords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      keywords = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ParagraphSummary") != m.end() && !m["ParagraphSummary"].empty()) {
      paragraphSummary = make_shared<string>(boost::any_cast<string>(m["ParagraphSummary"]));
    }
    if (m.find("QuestionsAnsweringSummary") != m.end() && !m["QuestionsAnsweringSummary"].empty()) {
      if (typeid(vector<boost::any>) == m["QuestionsAnsweringSummary"].type()) {
        vector<QueryMinutesSummaryResponseBodySummaryQuestionsAnsweringSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QuestionsAnsweringSummary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMinutesSummaryResponseBodySummaryQuestionsAnsweringSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        questionsAnsweringSummary = make_shared<vector<QueryMinutesSummaryResponseBodySummaryQuestionsAnsweringSummary>>(expect1);
      }
    }
  }


  virtual ~QueryMinutesSummaryResponseBodySummary() = default;
};
class QueryMinutesSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryMinutesSummaryResponseBodySummary> summary{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  QueryMinutesSummaryResponseBody() {}

  explicit QueryMinutesSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (summary) {
      res["summary"] = summary ? boost::any(summary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("summary") != m.end() && !m["summary"].empty()) {
      if (typeid(map<string, boost::any>) == m["summary"].type()) {
        QueryMinutesSummaryResponseBodySummary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["summary"]));
        summary = make_shared<QueryMinutesSummaryResponseBodySummary>(model1);
      }
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~QueryMinutesSummaryResponseBody() = default;
};
class QueryMinutesSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMinutesSummaryResponseBody> body{};

  QueryMinutesSummaryResponse() {}

  explicit QueryMinutesSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMinutesSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMinutesSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMinutesSummaryResponse() = default;
};
class QueryMinutesTextHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryMinutesTextHeadersAccountContext() {}

  explicit QueryMinutesTextHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryMinutesTextHeadersAccountContext() = default;
};
class QueryMinutesTextHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryMinutesTextHeadersAccountContext> accountContext{};

  QueryMinutesTextHeaders() {}

  explicit QueryMinutesTextHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryMinutesTextHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryMinutesTextHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryMinutesTextHeaders() = default;
};
class QueryMinutesTextShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryMinutesTextShrinkHeaders() {}

  explicit QueryMinutesTextShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryMinutesTextShrinkHeaders() = default;
};
class QueryMinutesTextRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryMinutesTextRequestTenantContext() {}

  explicit QueryMinutesTextRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryMinutesTextRequestTenantContext() = default;
};
class QueryMinutesTextRequest : public Darabonba::Model {
public:
  shared_ptr<QueryMinutesTextRequestTenantContext> tenantContext{};
  shared_ptr<string> conferenceId{};
  shared_ptr<string> direction{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  QueryMinutesTextRequest() {}

  explicit QueryMinutesTextRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    if (direction) {
      res["direction"] = boost::any(*direction);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryMinutesTextRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryMinutesTextRequestTenantContext>(model1);
      }
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
    if (m.find("direction") != m.end() && !m["direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["direction"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
  }


  virtual ~QueryMinutesTextRequest() = default;
};
class QueryMinutesTextShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> conferenceId{};
  shared_ptr<string> direction{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  QueryMinutesTextShrinkRequest() {}

  explicit QueryMinutesTextShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    if (direction) {
      res["direction"] = boost::any(*direction);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
    if (m.find("direction") != m.end() && !m["direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["direction"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
  }


  virtual ~QueryMinutesTextShrinkRequest() = default;
};
class QueryMinutesTextResponseBodyParagraphListSentenceListWordList : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<string> word{};
  shared_ptr<string> wordId{};

  QueryMinutesTextResponseBodyParagraphListSentenceListWordList() {}

  explicit QueryMinutesTextResponseBodyParagraphListSentenceListWordList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (word) {
      res["Word"] = boost::any(*word);
    }
    if (wordId) {
      res["WordId"] = boost::any(*wordId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Word") != m.end() && !m["Word"].empty()) {
      word = make_shared<string>(boost::any_cast<string>(m["Word"]));
    }
    if (m.find("WordId") != m.end() && !m["WordId"].empty()) {
      wordId = make_shared<string>(boost::any_cast<string>(m["WordId"]));
    }
  }


  virtual ~QueryMinutesTextResponseBodyParagraphListSentenceListWordList() = default;
};
class QueryMinutesTextResponseBodyParagraphListSentenceList : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> sentence{};
  shared_ptr<long> startTime{};
  shared_ptr<string> userId{};
  shared_ptr<vector<QueryMinutesTextResponseBodyParagraphListSentenceListWordList>> wordList{};

  QueryMinutesTextResponseBodyParagraphListSentenceList() {}

  explicit QueryMinutesTextResponseBodyParagraphListSentenceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (sentence) {
      res["Sentence"] = boost::any(*sentence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (wordList) {
      vector<boost::any> temp1;
      for(auto item1:*wordList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WordList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Sentence") != m.end() && !m["Sentence"].empty()) {
      sentence = make_shared<string>(boost::any_cast<string>(m["Sentence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WordList") != m.end() && !m["WordList"].empty()) {
      if (typeid(vector<boost::any>) == m["WordList"].type()) {
        vector<QueryMinutesTextResponseBodyParagraphListSentenceListWordList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WordList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMinutesTextResponseBodyParagraphListSentenceListWordList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wordList = make_shared<vector<QueryMinutesTextResponseBodyParagraphListSentenceListWordList>>(expect1);
      }
    }
  }


  virtual ~QueryMinutesTextResponseBodyParagraphListSentenceList() = default;
};
class QueryMinutesTextResponseBodyParagraphList : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> nickName{};
  shared_ptr<string> paragraph{};
  shared_ptr<long> paragraphId{};
  shared_ptr<long> recordId{};
  shared_ptr<vector<QueryMinutesTextResponseBodyParagraphListSentenceList>> sentenceList{};
  shared_ptr<long> startTime{};
  shared_ptr<string> userId{};

  QueryMinutesTextResponseBodyParagraphList() {}

  explicit QueryMinutesTextResponseBodyParagraphList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (paragraph) {
      res["Paragraph"] = boost::any(*paragraph);
    }
    if (paragraphId) {
      res["ParagraphId"] = boost::any(*paragraphId);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (sentenceList) {
      vector<boost::any> temp1;
      for(auto item1:*sentenceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SentenceList"] = boost::any(temp1);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("Paragraph") != m.end() && !m["Paragraph"].empty()) {
      paragraph = make_shared<string>(boost::any_cast<string>(m["Paragraph"]));
    }
    if (m.find("ParagraphId") != m.end() && !m["ParagraphId"].empty()) {
      paragraphId = make_shared<long>(boost::any_cast<long>(m["ParagraphId"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<long>(boost::any_cast<long>(m["RecordId"]));
    }
    if (m.find("SentenceList") != m.end() && !m["SentenceList"].empty()) {
      if (typeid(vector<boost::any>) == m["SentenceList"].type()) {
        vector<QueryMinutesTextResponseBodyParagraphListSentenceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SentenceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMinutesTextResponseBodyParagraphListSentenceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sentenceList = make_shared<vector<QueryMinutesTextResponseBodyParagraphListSentenceList>>(expect1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryMinutesTextResponseBodyParagraphList() = default;
};
class QueryMinutesTextResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> hasMore{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<QueryMinutesTextResponseBodyParagraphList>> paragraphList{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  QueryMinutesTextResponseBody() {}

  explicit QueryMinutesTextResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasMore) {
      res["hasMore"] = boost::any(*hasMore);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (paragraphList) {
      vector<boost::any> temp1;
      for(auto item1:*paragraphList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["paragraphList"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hasMore") != m.end() && !m["hasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["hasMore"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("paragraphList") != m.end() && !m["paragraphList"].empty()) {
      if (typeid(vector<boost::any>) == m["paragraphList"].type()) {
        vector<QueryMinutesTextResponseBodyParagraphList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["paragraphList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMinutesTextResponseBodyParagraphList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        paragraphList = make_shared<vector<QueryMinutesTextResponseBodyParagraphList>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~QueryMinutesTextResponseBody() = default;
};
class QueryMinutesTextResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMinutesTextResponseBody> body{};

  QueryMinutesTextResponse() {}

  explicit QueryMinutesTextResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMinutesTextResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMinutesTextResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMinutesTextResponse() = default;
};
class QueryOrgHonorsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryOrgHonorsHeadersAccountContext() {}

  explicit QueryOrgHonorsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryOrgHonorsHeadersAccountContext() = default;
};
class QueryOrgHonorsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryOrgHonorsHeadersAccountContext> accountContext{};

  QueryOrgHonorsHeaders() {}

  explicit QueryOrgHonorsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryOrgHonorsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryOrgHonorsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryOrgHonorsHeaders() = default;
};
class QueryOrgHonorsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryOrgHonorsShrinkHeaders() {}

  explicit QueryOrgHonorsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryOrgHonorsShrinkHeaders() = default;
};
class QueryOrgHonorsRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryOrgHonorsRequestTenantContext() {}

  explicit QueryOrgHonorsRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryOrgHonorsRequestTenantContext() = default;
};
class QueryOrgHonorsRequest : public Darabonba::Model {
public:
  shared_ptr<QueryOrgHonorsRequestTenantContext> tenantContext{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> orgId{};

  QueryOrgHonorsRequest() {}

  explicit QueryOrgHonorsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (orgId) {
      res["orgId"] = boost::any(*orgId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryOrgHonorsRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryOrgHonorsRequestTenantContext>(model1);
      }
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("orgId") != m.end() && !m["orgId"].empty()) {
      orgId = make_shared<long>(boost::any_cast<long>(m["orgId"]));
    }
  }


  virtual ~QueryOrgHonorsRequest() = default;
};
class QueryOrgHonorsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> orgId{};

  QueryOrgHonorsShrinkRequest() {}

  explicit QueryOrgHonorsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (orgId) {
      res["orgId"] = boost::any(*orgId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("orgId") != m.end() && !m["orgId"].empty()) {
      orgId = make_shared<long>(boost::any_cast<long>(m["orgId"]));
    }
  }


  virtual ~QueryOrgHonorsShrinkRequest() = default;
};
class QueryOrgHonorsResponseBodyOpenHonors : public Darabonba::Model {
public:
  shared_ptr<string> honorDesc{};
  shared_ptr<long> honorId{};
  shared_ptr<string> honorImgUrl{};
  shared_ptr<string> honorName{};
  shared_ptr<string> honorPendantImgUrl{};

  QueryOrgHonorsResponseBodyOpenHonors() {}

  explicit QueryOrgHonorsResponseBodyOpenHonors(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (honorDesc) {
      res["honorDesc"] = boost::any(*honorDesc);
    }
    if (honorId) {
      res["honorId"] = boost::any(*honorId);
    }
    if (honorImgUrl) {
      res["honorImgUrl"] = boost::any(*honorImgUrl);
    }
    if (honorName) {
      res["honorName"] = boost::any(*honorName);
    }
    if (honorPendantImgUrl) {
      res["honorPendantImgUrl"] = boost::any(*honorPendantImgUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("honorDesc") != m.end() && !m["honorDesc"].empty()) {
      honorDesc = make_shared<string>(boost::any_cast<string>(m["honorDesc"]));
    }
    if (m.find("honorId") != m.end() && !m["honorId"].empty()) {
      honorId = make_shared<long>(boost::any_cast<long>(m["honorId"]));
    }
    if (m.find("honorImgUrl") != m.end() && !m["honorImgUrl"].empty()) {
      honorImgUrl = make_shared<string>(boost::any_cast<string>(m["honorImgUrl"]));
    }
    if (m.find("honorName") != m.end() && !m["honorName"].empty()) {
      honorName = make_shared<string>(boost::any_cast<string>(m["honorName"]));
    }
    if (m.find("honorPendantImgUrl") != m.end() && !m["honorPendantImgUrl"].empty()) {
      honorPendantImgUrl = make_shared<string>(boost::any_cast<string>(m["honorPendantImgUrl"]));
    }
  }


  virtual ~QueryOrgHonorsResponseBodyOpenHonors() = default;
};
class QueryOrgHonorsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<vector<QueryOrgHonorsResponseBodyOpenHonors>> openHonors{};
  shared_ptr<string> requestId{};

  QueryOrgHonorsResponseBody() {}

  explicit QueryOrgHonorsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (openHonors) {
      vector<boost::any> temp1;
      for(auto item1:*openHonors){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["openHonors"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("openHonors") != m.end() && !m["openHonors"].empty()) {
      if (typeid(vector<boost::any>) == m["openHonors"].type()) {
        vector<QueryOrgHonorsResponseBodyOpenHonors> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["openHonors"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrgHonorsResponseBodyOpenHonors model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        openHonors = make_shared<vector<QueryOrgHonorsResponseBodyOpenHonors>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~QueryOrgHonorsResponseBody() = default;
};
class QueryOrgHonorsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryOrgHonorsResponseBody> body{};

  QueryOrgHonorsResponse() {}

  explicit QueryOrgHonorsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOrgHonorsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOrgHonorsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOrgHonorsResponse() = default;
};
class QueryOrgTodoTasksHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryOrgTodoTasksHeadersAccountContext() {}

  explicit QueryOrgTodoTasksHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryOrgTodoTasksHeadersAccountContext() = default;
};
class QueryOrgTodoTasksHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryOrgTodoTasksHeadersAccountContext> accountContext{};

  QueryOrgTodoTasksHeaders() {}

  explicit QueryOrgTodoTasksHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryOrgTodoTasksHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryOrgTodoTasksHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryOrgTodoTasksHeaders() = default;
};
class QueryOrgTodoTasksShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryOrgTodoTasksShrinkHeaders() {}

  explicit QueryOrgTodoTasksShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryOrgTodoTasksShrinkHeaders() = default;
};
class QueryOrgTodoTasksRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryOrgTodoTasksRequestTenantContext() {}

  explicit QueryOrgTodoTasksRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryOrgTodoTasksRequestTenantContext() = default;
};
class QueryOrgTodoTasksRequest : public Darabonba::Model {
public:
  shared_ptr<QueryOrgTodoTasksRequestTenantContext> tenantContext{};
  shared_ptr<bool> isDone{};
  shared_ptr<string> nextToken{};

  QueryOrgTodoTasksRequest() {}

  explicit QueryOrgTodoTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isDone) {
      res["isDone"] = boost::any(*isDone);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryOrgTodoTasksRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryOrgTodoTasksRequestTenantContext>(model1);
      }
    }
    if (m.find("isDone") != m.end() && !m["isDone"].empty()) {
      isDone = make_shared<bool>(boost::any_cast<bool>(m["isDone"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
  }


  virtual ~QueryOrgTodoTasksRequest() = default;
};
class QueryOrgTodoTasksShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<bool> isDone{};
  shared_ptr<string> nextToken{};

  QueryOrgTodoTasksShrinkRequest() {}

  explicit QueryOrgTodoTasksShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (isDone) {
      res["isDone"] = boost::any(*isDone);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("isDone") != m.end() && !m["isDone"].empty()) {
      isDone = make_shared<bool>(boost::any_cast<bool>(m["isDone"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
  }


  virtual ~QueryOrgTodoTasksShrinkRequest() = default;
};
class QueryOrgTodoTasksResponseBodyTodoCardsDetailUrl : public Darabonba::Model {
public:
  shared_ptr<string> appUrl{};
  shared_ptr<string> pcUrl{};

  QueryOrgTodoTasksResponseBodyTodoCardsDetailUrl() {}

  explicit QueryOrgTodoTasksResponseBodyTodoCardsDetailUrl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appUrl) {
      res["appUrl"] = boost::any(*appUrl);
    }
    if (pcUrl) {
      res["pcUrl"] = boost::any(*pcUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("appUrl") != m.end() && !m["appUrl"].empty()) {
      appUrl = make_shared<string>(boost::any_cast<string>(m["appUrl"]));
    }
    if (m.find("pcUrl") != m.end() && !m["pcUrl"].empty()) {
      pcUrl = make_shared<string>(boost::any_cast<string>(m["pcUrl"]));
    }
  }


  virtual ~QueryOrgTodoTasksResponseBodyTodoCardsDetailUrl() = default;
};
class QueryOrgTodoTasksResponseBodyTodoCards : public Darabonba::Model {
public:
  shared_ptr<string> bizTag{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<QueryOrgTodoTasksResponseBodyTodoCardsDetailUrl> detailUrl{};
  shared_ptr<long> dueTime{};
  shared_ptr<bool> isDone{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<long> priority{};
  shared_ptr<string> sourceId{};
  shared_ptr<string> subject{};
  shared_ptr<string> taskId{};

  QueryOrgTodoTasksResponseBodyTodoCards() {}

  explicit QueryOrgTodoTasksResponseBodyTodoCards(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizTag) {
      res["bizTag"] = boost::any(*bizTag);
    }
    if (createdTime) {
      res["createdTime"] = boost::any(*createdTime);
    }
    if (creatorId) {
      res["creatorId"] = boost::any(*creatorId);
    }
    if (detailUrl) {
      res["detailUrl"] = detailUrl ? boost::any(detailUrl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dueTime) {
      res["dueTime"] = boost::any(*dueTime);
    }
    if (isDone) {
      res["isDone"] = boost::any(*isDone);
    }
    if (modifiedTime) {
      res["modifiedTime"] = boost::any(*modifiedTime);
    }
    if (priority) {
      res["priority"] = boost::any(*priority);
    }
    if (sourceId) {
      res["sourceId"] = boost::any(*sourceId);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bizTag") != m.end() && !m["bizTag"].empty()) {
      bizTag = make_shared<string>(boost::any_cast<string>(m["bizTag"]));
    }
    if (m.find("createdTime") != m.end() && !m["createdTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["createdTime"]));
    }
    if (m.find("creatorId") != m.end() && !m["creatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["creatorId"]));
    }
    if (m.find("detailUrl") != m.end() && !m["detailUrl"].empty()) {
      if (typeid(map<string, boost::any>) == m["detailUrl"].type()) {
        QueryOrgTodoTasksResponseBodyTodoCardsDetailUrl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["detailUrl"]));
        detailUrl = make_shared<QueryOrgTodoTasksResponseBodyTodoCardsDetailUrl>(model1);
      }
    }
    if (m.find("dueTime") != m.end() && !m["dueTime"].empty()) {
      dueTime = make_shared<long>(boost::any_cast<long>(m["dueTime"]));
    }
    if (m.find("isDone") != m.end() && !m["isDone"].empty()) {
      isDone = make_shared<bool>(boost::any_cast<bool>(m["isDone"]));
    }
    if (m.find("modifiedTime") != m.end() && !m["modifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["modifiedTime"]));
    }
    if (m.find("priority") != m.end() && !m["priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["priority"]));
    }
    if (m.find("sourceId") != m.end() && !m["sourceId"].empty()) {
      sourceId = make_shared<string>(boost::any_cast<string>(m["sourceId"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
  }


  virtual ~QueryOrgTodoTasksResponseBodyTodoCards() = default;
};
class QueryOrgTodoTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<QueryOrgTodoTasksResponseBodyTodoCards>> todoCards{};

  QueryOrgTodoTasksResponseBody() {}

  explicit QueryOrgTodoTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (todoCards) {
      vector<boost::any> temp1;
      for(auto item1:*todoCards){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["todoCards"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("todoCards") != m.end() && !m["todoCards"].empty()) {
      if (typeid(vector<boost::any>) == m["todoCards"].type()) {
        vector<QueryOrgTodoTasksResponseBodyTodoCards> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["todoCards"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrgTodoTasksResponseBodyTodoCards model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        todoCards = make_shared<vector<QueryOrgTodoTasksResponseBodyTodoCards>>(expect1);
      }
    }
  }


  virtual ~QueryOrgTodoTasksResponseBody() = default;
};
class QueryOrgTodoTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryOrgTodoTasksResponseBody> body{};

  QueryOrgTodoTasksResponse() {}

  explicit QueryOrgTodoTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOrgTodoTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOrgTodoTasksResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOrgTodoTasksResponse() = default;
};
class QueryRecordMinutesUrlHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryRecordMinutesUrlHeadersAccountContext() {}

  explicit QueryRecordMinutesUrlHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryRecordMinutesUrlHeadersAccountContext() = default;
};
class QueryRecordMinutesUrlHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryRecordMinutesUrlHeadersAccountContext> accountContext{};

  QueryRecordMinutesUrlHeaders() {}

  explicit QueryRecordMinutesUrlHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryRecordMinutesUrlHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryRecordMinutesUrlHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryRecordMinutesUrlHeaders() = default;
};
class QueryRecordMinutesUrlShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryRecordMinutesUrlShrinkHeaders() {}

  explicit QueryRecordMinutesUrlShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryRecordMinutesUrlShrinkHeaders() = default;
};
class QueryRecordMinutesUrlRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryRecordMinutesUrlRequestTenantContext() {}

  explicit QueryRecordMinutesUrlRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryRecordMinutesUrlRequestTenantContext() = default;
};
class QueryRecordMinutesUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> conferenceId{};
  shared_ptr<QueryRecordMinutesUrlRequestTenantContext> tenantContext{};

  QueryRecordMinutesUrlRequest() {}

  explicit QueryRecordMinutesUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (conferenceId) {
      res["ConferenceId"] = boost::any(*conferenceId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ConferenceId") != m.end() && !m["ConferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["ConferenceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryRecordMinutesUrlRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryRecordMinutesUrlRequestTenantContext>(model1);
      }
    }
  }


  virtual ~QueryRecordMinutesUrlRequest() = default;
};
class QueryRecordMinutesUrlShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> conferenceId{};
  shared_ptr<string> tenantContextShrink{};

  QueryRecordMinutesUrlShrinkRequest() {}

  explicit QueryRecordMinutesUrlShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (conferenceId) {
      res["ConferenceId"] = boost::any(*conferenceId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ConferenceId") != m.end() && !m["ConferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["ConferenceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~QueryRecordMinutesUrlShrinkRequest() = default;
};
class QueryRecordMinutesUrlResponseBodyRecordMinutesUrls : public Darabonba::Model {
public:
  shared_ptr<string> recordMinutesUrl{};

  QueryRecordMinutesUrlResponseBodyRecordMinutesUrls() {}

  explicit QueryRecordMinutesUrlResponseBodyRecordMinutesUrls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordMinutesUrl) {
      res["RecordMinutesUrl"] = boost::any(*recordMinutesUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordMinutesUrl") != m.end() && !m["RecordMinutesUrl"].empty()) {
      recordMinutesUrl = make_shared<string>(boost::any_cast<string>(m["RecordMinutesUrl"]));
    }
  }


  virtual ~QueryRecordMinutesUrlResponseBodyRecordMinutesUrls() = default;
};
class QueryRecordMinutesUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryRecordMinutesUrlResponseBodyRecordMinutesUrls>> recordMinutesUrls{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  QueryRecordMinutesUrlResponseBody() {}

  explicit QueryRecordMinutesUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordMinutesUrls) {
      vector<boost::any> temp1;
      for(auto item1:*recordMinutesUrls){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["recordMinutesUrls"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("recordMinutesUrls") != m.end() && !m["recordMinutesUrls"].empty()) {
      if (typeid(vector<boost::any>) == m["recordMinutesUrls"].type()) {
        vector<QueryRecordMinutesUrlResponseBodyRecordMinutesUrls> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["recordMinutesUrls"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryRecordMinutesUrlResponseBodyRecordMinutesUrls model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordMinutesUrls = make_shared<vector<QueryRecordMinutesUrlResponseBodyRecordMinutesUrls>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~QueryRecordMinutesUrlResponseBody() = default;
};
class QueryRecordMinutesUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryRecordMinutesUrlResponseBody> body{};

  QueryRecordMinutesUrlResponse() {}

  explicit QueryRecordMinutesUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryRecordMinutesUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryRecordMinutesUrlResponseBody>(model1);
      }
    }
  }


  virtual ~QueryRecordMinutesUrlResponse() = default;
};
class QueryReportDetailHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryReportDetailHeadersAccountContext() {}

  explicit QueryReportDetailHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryReportDetailHeadersAccountContext() = default;
};
class QueryReportDetailHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryReportDetailHeadersAccountContext> accountContext{};

  QueryReportDetailHeaders() {}

  explicit QueryReportDetailHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryReportDetailHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryReportDetailHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryReportDetailHeaders() = default;
};
class QueryReportDetailShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryReportDetailShrinkHeaders() {}

  explicit QueryReportDetailShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryReportDetailShrinkHeaders() = default;
};
class QueryReportDetailRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryReportDetailRequestTenantContext() {}

  explicit QueryReportDetailRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryReportDetailRequestTenantContext() = default;
};
class QueryReportDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> reportId{};
  shared_ptr<QueryReportDetailRequestTenantContext> tenantContext{};

  QueryReportDetailRequest() {}

  explicit QueryReportDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryReportDetailRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryReportDetailRequestTenantContext>(model1);
      }
    }
  }


  virtual ~QueryReportDetailRequest() = default;
};
class QueryReportDetailShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> reportId{};
  shared_ptr<string> tenantContextShrink{};

  QueryReportDetailShrinkRequest() {}

  explicit QueryReportDetailShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~QueryReportDetailShrinkRequest() = default;
};
class QueryReportDetailResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<vector<string>> images{};
  shared_ptr<string> key{};
  shared_ptr<string> sort{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  QueryReportDetailResponseBodyContent() {}

  explicit QueryReportDetailResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (images) {
      res["Images"] = boost::any(*images);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Images"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Images"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      images = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~QueryReportDetailResponseBodyContent() = default;
};
class QueryReportDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryReportDetailResponseBodyContent>> content{};
  shared_ptr<long> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> creatorName{};
  shared_ptr<string> deptName{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<string> remark{};
  shared_ptr<string> reportId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  QueryReportDetailResponseBody() {}

  explicit QueryReportDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      vector<boost::any> temp1;
      for(auto item1:*content){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["content"] = boost::any(temp1);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["creatorId"] = boost::any(*creatorId);
    }
    if (creatorName) {
      res["creatorName"] = boost::any(*creatorName);
    }
    if (deptName) {
      res["deptName"] = boost::any(*deptName);
    }
    if (modifiedTime) {
      res["modifiedTime"] = boost::any(*modifiedTime);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (reportId) {
      res["reportId"] = boost::any(*reportId);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (templateName) {
      res["templateName"] = boost::any(*templateName);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      if (typeid(vector<boost::any>) == m["content"].type()) {
        vector<QueryReportDetailResponseBodyContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["content"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryReportDetailResponseBodyContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        content = make_shared<vector<QueryReportDetailResponseBodyContent>>(expect1);
      }
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("creatorId") != m.end() && !m["creatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["creatorId"]));
    }
    if (m.find("creatorName") != m.end() && !m["creatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["creatorName"]));
    }
    if (m.find("deptName") != m.end() && !m["deptName"].empty()) {
      deptName = make_shared<string>(boost::any_cast<string>(m["deptName"]));
    }
    if (m.find("modifiedTime") != m.end() && !m["modifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["modifiedTime"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("reportId") != m.end() && !m["reportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["reportId"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("templateName") != m.end() && !m["templateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["templateName"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~QueryReportDetailResponseBody() = default;
};
class QueryReportDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryReportDetailResponseBody> body{};

  QueryReportDetailResponse() {}

  explicit QueryReportDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryReportDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryReportDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryReportDetailResponse() = default;
};
class QueryScheduleConferenceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryScheduleConferenceHeadersAccountContext() {}

  explicit QueryScheduleConferenceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryScheduleConferenceHeadersAccountContext() = default;
};
class QueryScheduleConferenceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryScheduleConferenceHeadersAccountContext> accountContext{};

  QueryScheduleConferenceHeaders() {}

  explicit QueryScheduleConferenceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryScheduleConferenceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryScheduleConferenceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryScheduleConferenceHeaders() = default;
};
class QueryScheduleConferenceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryScheduleConferenceShrinkHeaders() {}

  explicit QueryScheduleConferenceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryScheduleConferenceShrinkHeaders() = default;
};
class QueryScheduleConferenceRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryScheduleConferenceRequestTenantContext() {}

  explicit QueryScheduleConferenceRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryScheduleConferenceRequestTenantContext() = default;
};
class QueryScheduleConferenceRequest : public Darabonba::Model {
public:
  shared_ptr<QueryScheduleConferenceRequestTenantContext> tenantContext{};
  shared_ptr<string> scheduleConferenceId{};

  QueryScheduleConferenceRequest() {}

  explicit QueryScheduleConferenceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scheduleConferenceId) {
      res["scheduleConferenceId"] = boost::any(*scheduleConferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryScheduleConferenceRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryScheduleConferenceRequestTenantContext>(model1);
      }
    }
    if (m.find("scheduleConferenceId") != m.end() && !m["scheduleConferenceId"].empty()) {
      scheduleConferenceId = make_shared<string>(boost::any_cast<string>(m["scheduleConferenceId"]));
    }
  }


  virtual ~QueryScheduleConferenceRequest() = default;
};
class QueryScheduleConferenceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> scheduleConferenceId{};

  QueryScheduleConferenceShrinkRequest() {}

  explicit QueryScheduleConferenceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (scheduleConferenceId) {
      res["scheduleConferenceId"] = boost::any(*scheduleConferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("scheduleConferenceId") != m.end() && !m["scheduleConferenceId"].empty()) {
      scheduleConferenceId = make_shared<string>(boost::any_cast<string>(m["scheduleConferenceId"]));
    }
  }


  virtual ~QueryScheduleConferenceShrinkRequest() = default;
};
class QueryScheduleConferenceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<vector<string>> phones{};
  shared_ptr<string> requestId{};
  shared_ptr<string> roomCode{};
  shared_ptr<string> scheduleConferenceId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  QueryScheduleConferenceResponseBody() {}

  explicit QueryScheduleConferenceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (phones) {
      res["phones"] = boost::any(*phones);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (roomCode) {
      res["roomCode"] = boost::any(*roomCode);
    }
    if (scheduleConferenceId) {
      res["scheduleConferenceId"] = boost::any(*scheduleConferenceId);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("phones") != m.end() && !m["phones"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["phones"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["phones"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      phones = make_shared<vector<string>>(toVec1);
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("roomCode") != m.end() && !m["roomCode"].empty()) {
      roomCode = make_shared<string>(boost::any_cast<string>(m["roomCode"]));
    }
    if (m.find("scheduleConferenceId") != m.end() && !m["scheduleConferenceId"].empty()) {
      scheduleConferenceId = make_shared<string>(boost::any_cast<string>(m["scheduleConferenceId"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~QueryScheduleConferenceResponseBody() = default;
};
class QueryScheduleConferenceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryScheduleConferenceResponseBody> body{};

  QueryScheduleConferenceResponse() {}

  explicit QueryScheduleConferenceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryScheduleConferenceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryScheduleConferenceResponseBody>(model1);
      }
    }
  }


  virtual ~QueryScheduleConferenceResponse() = default;
};
class QueryScheduleConferenceInfoHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryScheduleConferenceInfoHeadersAccountContext() {}

  explicit QueryScheduleConferenceInfoHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryScheduleConferenceInfoHeadersAccountContext() = default;
};
class QueryScheduleConferenceInfoHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryScheduleConferenceInfoHeadersAccountContext> accountContext{};

  QueryScheduleConferenceInfoHeaders() {}

  explicit QueryScheduleConferenceInfoHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryScheduleConferenceInfoHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryScheduleConferenceInfoHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryScheduleConferenceInfoHeaders() = default;
};
class QueryScheduleConferenceInfoShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryScheduleConferenceInfoShrinkHeaders() {}

  explicit QueryScheduleConferenceInfoShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryScheduleConferenceInfoShrinkHeaders() = default;
};
class QueryScheduleConferenceInfoRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryScheduleConferenceInfoRequestTenantContext() {}

  explicit QueryScheduleConferenceInfoRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryScheduleConferenceInfoRequestTenantContext() = default;
};
class QueryScheduleConferenceInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> scheduleConferenceId{};
  shared_ptr<QueryScheduleConferenceInfoRequestTenantContext> tenantContext{};

  QueryScheduleConferenceInfoRequest() {}

  explicit QueryScheduleConferenceInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (scheduleConferenceId) {
      res["ScheduleConferenceId"] = boost::any(*scheduleConferenceId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ScheduleConferenceId") != m.end() && !m["ScheduleConferenceId"].empty()) {
      scheduleConferenceId = make_shared<string>(boost::any_cast<string>(m["ScheduleConferenceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryScheduleConferenceInfoRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryScheduleConferenceInfoRequestTenantContext>(model1);
      }
    }
  }


  virtual ~QueryScheduleConferenceInfoRequest() = default;
};
class QueryScheduleConferenceInfoShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> scheduleConferenceId{};
  shared_ptr<string> tenantContextShrink{};

  QueryScheduleConferenceInfoShrinkRequest() {}

  explicit QueryScheduleConferenceInfoShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (scheduleConferenceId) {
      res["ScheduleConferenceId"] = boost::any(*scheduleConferenceId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ScheduleConferenceId") != m.end() && !m["ScheduleConferenceId"].empty()) {
      scheduleConferenceId = make_shared<string>(boost::any_cast<string>(m["ScheduleConferenceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~QueryScheduleConferenceInfoShrinkRequest() = default;
};
class QueryScheduleConferenceInfoResponseBodyConferenceList : public Darabonba::Model {
public:
  shared_ptr<string> conferenceId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> roomCode{};
  shared_ptr<long> startTime{};
  shared_ptr<long> status{};
  shared_ptr<string> title{};

  QueryScheduleConferenceInfoResponseBodyConferenceList() {}

  explicit QueryScheduleConferenceInfoResponseBodyConferenceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conferenceId) {
      res["ConferenceId"] = boost::any(*conferenceId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (roomCode) {
      res["RoomCode"] = boost::any(*roomCode);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConferenceId") != m.end() && !m["ConferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["ConferenceId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("RoomCode") != m.end() && !m["RoomCode"].empty()) {
      roomCode = make_shared<string>(boost::any_cast<string>(m["RoomCode"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~QueryScheduleConferenceInfoResponseBodyConferenceList() = default;
};
class QueryScheduleConferenceInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryScheduleConferenceInfoResponseBodyConferenceList>> conferenceList{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  QueryScheduleConferenceInfoResponseBody() {}

  explicit QueryScheduleConferenceInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conferenceList) {
      vector<boost::any> temp1;
      for(auto item1:*conferenceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["conferenceList"] = boost::any(temp1);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("conferenceList") != m.end() && !m["conferenceList"].empty()) {
      if (typeid(vector<boost::any>) == m["conferenceList"].type()) {
        vector<QueryScheduleConferenceInfoResponseBodyConferenceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["conferenceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryScheduleConferenceInfoResponseBodyConferenceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conferenceList = make_shared<vector<QueryScheduleConferenceInfoResponseBodyConferenceList>>(expect1);
      }
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~QueryScheduleConferenceInfoResponseBody() = default;
};
class QueryScheduleConferenceInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryScheduleConferenceInfoResponseBody> body{};

  QueryScheduleConferenceInfoResponse() {}

  explicit QueryScheduleConferenceInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryScheduleConferenceInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryScheduleConferenceInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryScheduleConferenceInfoResponse() = default;
};
class QueryUserHonorsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryUserHonorsHeadersAccountContext() {}

  explicit QueryUserHonorsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryUserHonorsHeadersAccountContext() = default;
};
class QueryUserHonorsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryUserHonorsHeadersAccountContext> accountContext{};

  QueryUserHonorsHeaders() {}

  explicit QueryUserHonorsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryUserHonorsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryUserHonorsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryUserHonorsHeaders() = default;
};
class QueryUserHonorsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryUserHonorsShrinkHeaders() {}

  explicit QueryUserHonorsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryUserHonorsShrinkHeaders() = default;
};
class QueryUserHonorsRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryUserHonorsRequestTenantContext() {}

  explicit QueryUserHonorsRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryUserHonorsRequestTenantContext() = default;
};
class QueryUserHonorsRequest : public Darabonba::Model {
public:
  shared_ptr<QueryUserHonorsRequestTenantContext> tenantContext{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> orgId{};
  shared_ptr<string> userId{};

  QueryUserHonorsRequest() {}

  explicit QueryUserHonorsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (orgId) {
      res["orgId"] = boost::any(*orgId);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryUserHonorsRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryUserHonorsRequestTenantContext>(model1);
      }
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("orgId") != m.end() && !m["orgId"].empty()) {
      orgId = make_shared<long>(boost::any_cast<long>(m["orgId"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~QueryUserHonorsRequest() = default;
};
class QueryUserHonorsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> orgId{};
  shared_ptr<string> userId{};

  QueryUserHonorsShrinkRequest() {}

  explicit QueryUserHonorsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (maxResults) {
      res["maxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (orgId) {
      res["orgId"] = boost::any(*orgId);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("maxResults") != m.end() && !m["maxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["maxResults"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("orgId") != m.end() && !m["orgId"].empty()) {
      orgId = make_shared<long>(boost::any_cast<long>(m["orgId"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~QueryUserHonorsShrinkRequest() = default;
};
class QueryUserHonorsResponseBodyHonorsGrantHistory : public Darabonba::Model {
public:
  shared_ptr<long> grantTime{};
  shared_ptr<string> senderUserid{};

  QueryUserHonorsResponseBodyHonorsGrantHistory() {}

  explicit QueryUserHonorsResponseBodyHonorsGrantHistory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (grantTime) {
      res["grantTime"] = boost::any(*grantTime);
    }
    if (senderUserid) {
      res["senderUserid"] = boost::any(*senderUserid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("grantTime") != m.end() && !m["grantTime"].empty()) {
      grantTime = make_shared<long>(boost::any_cast<long>(m["grantTime"]));
    }
    if (m.find("senderUserid") != m.end() && !m["senderUserid"].empty()) {
      senderUserid = make_shared<string>(boost::any_cast<string>(m["senderUserid"]));
    }
  }


  virtual ~QueryUserHonorsResponseBodyHonorsGrantHistory() = default;
};
class QueryUserHonorsResponseBodyHonors : public Darabonba::Model {
public:
  shared_ptr<long> expirationTime{};
  shared_ptr<vector<QueryUserHonorsResponseBodyHonorsGrantHistory>> grantHistory{};
  shared_ptr<string> honorDesc{};
  shared_ptr<string> honorId{};
  shared_ptr<string> honorName{};

  QueryUserHonorsResponseBodyHonors() {}

  explicit QueryUserHonorsResponseBodyHonors(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expirationTime) {
      res["expirationTime"] = boost::any(*expirationTime);
    }
    if (grantHistory) {
      vector<boost::any> temp1;
      for(auto item1:*grantHistory){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["grantHistory"] = boost::any(temp1);
    }
    if (honorDesc) {
      res["honorDesc"] = boost::any(*honorDesc);
    }
    if (honorId) {
      res["honorId"] = boost::any(*honorId);
    }
    if (honorName) {
      res["honorName"] = boost::any(*honorName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("expirationTime") != m.end() && !m["expirationTime"].empty()) {
      expirationTime = make_shared<long>(boost::any_cast<long>(m["expirationTime"]));
    }
    if (m.find("grantHistory") != m.end() && !m["grantHistory"].empty()) {
      if (typeid(vector<boost::any>) == m["grantHistory"].type()) {
        vector<QueryUserHonorsResponseBodyHonorsGrantHistory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["grantHistory"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryUserHonorsResponseBodyHonorsGrantHistory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        grantHistory = make_shared<vector<QueryUserHonorsResponseBodyHonorsGrantHistory>>(expect1);
      }
    }
    if (m.find("honorDesc") != m.end() && !m["honorDesc"].empty()) {
      honorDesc = make_shared<string>(boost::any_cast<string>(m["honorDesc"]));
    }
    if (m.find("honorId") != m.end() && !m["honorId"].empty()) {
      honorId = make_shared<string>(boost::any_cast<string>(m["honorId"]));
    }
    if (m.find("honorName") != m.end() && !m["honorName"].empty()) {
      honorName = make_shared<string>(boost::any_cast<string>(m["honorName"]));
    }
  }


  virtual ~QueryUserHonorsResponseBodyHonors() = default;
};
class QueryUserHonorsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryUserHonorsResponseBodyHonors>> honors{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  QueryUserHonorsResponseBody() {}

  explicit QueryUserHonorsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (honors) {
      vector<boost::any> temp1;
      for(auto item1:*honors){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["honors"] = boost::any(temp1);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("honors") != m.end() && !m["honors"].empty()) {
      if (typeid(vector<boost::any>) == m["honors"].type()) {
        vector<QueryUserHonorsResponseBodyHonors> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["honors"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryUserHonorsResponseBodyHonors model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        honors = make_shared<vector<QueryUserHonorsResponseBodyHonors>>(expect1);
      }
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~QueryUserHonorsResponseBody() = default;
};
class QueryUserHonorsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryUserHonorsResponseBody> body{};

  QueryUserHonorsResponse() {}

  explicit QueryUserHonorsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryUserHonorsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryUserHonorsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryUserHonorsResponse() = default;
};
class RecallHonorHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  RecallHonorHeadersAccountContext() {}

  explicit RecallHonorHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~RecallHonorHeadersAccountContext() = default;
};
class RecallHonorHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<RecallHonorHeadersAccountContext> accountContext{};

  RecallHonorHeaders() {}

  explicit RecallHonorHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        RecallHonorHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<RecallHonorHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~RecallHonorHeaders() = default;
};
class RecallHonorShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  RecallHonorShrinkHeaders() {}

  explicit RecallHonorShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~RecallHonorShrinkHeaders() = default;
};
class RecallHonorRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  RecallHonorRequestTenantContext() {}

  explicit RecallHonorRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~RecallHonorRequestTenantContext() = default;
};
class RecallHonorRequest : public Darabonba::Model {
public:
  shared_ptr<RecallHonorRequestTenantContext> tenantContext{};
  shared_ptr<string> honorId{};
  shared_ptr<long> orgId{};
  shared_ptr<string> userId{};

  RecallHonorRequest() {}

  explicit RecallHonorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (honorId) {
      res["honorId"] = boost::any(*honorId);
    }
    if (orgId) {
      res["orgId"] = boost::any(*orgId);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        RecallHonorRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<RecallHonorRequestTenantContext>(model1);
      }
    }
    if (m.find("honorId") != m.end() && !m["honorId"].empty()) {
      honorId = make_shared<string>(boost::any_cast<string>(m["honorId"]));
    }
    if (m.find("orgId") != m.end() && !m["orgId"].empty()) {
      orgId = make_shared<long>(boost::any_cast<long>(m["orgId"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~RecallHonorRequest() = default;
};
class RecallHonorShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> honorId{};
  shared_ptr<long> orgId{};
  shared_ptr<string> userId{};

  RecallHonorShrinkRequest() {}

  explicit RecallHonorShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (honorId) {
      res["honorId"] = boost::any(*honorId);
    }
    if (orgId) {
      res["orgId"] = boost::any(*orgId);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("honorId") != m.end() && !m["honorId"].empty()) {
      honorId = make_shared<string>(boost::any_cast<string>(m["honorId"]));
    }
    if (m.find("orgId") != m.end() && !m["orgId"].empty()) {
      orgId = make_shared<long>(boost::any_cast<long>(m["orgId"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~RecallHonorShrinkRequest() = default;
};
class RecallHonorResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};

  RecallHonorResponseBodyContent() {}

  explicit RecallHonorResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["data"]));
    }
  }


  virtual ~RecallHonorResponseBodyContent() = default;
};
class RecallHonorResponseBody : public Darabonba::Model {
public:
  shared_ptr<RecallHonorResponseBodyContent> content{};
  shared_ptr<string> errorCode{};
  shared_ptr<map<string, boost::any>> errorCtx{};
  shared_ptr<string> errorMsg{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RecallHonorResponseBody() {}

  explicit RecallHonorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorCtx) {
      res["errorCtx"] = boost::any(*errorCtx);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      if (typeid(map<string, boost::any>) == m["content"].type()) {
        RecallHonorResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["content"]));
        content = make_shared<RecallHonorResponseBodyContent>(model1);
      }
    }
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorCtx") != m.end() && !m["errorCtx"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["errorCtx"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      errorCtx = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["httpStatusCode"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~RecallHonorResponseBody() = default;
};
class RecallHonorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RecallHonorResponseBody> body{};

  RecallHonorResponse() {}

  explicit RecallHonorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RecallHonorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RecallHonorResponseBody>(model1);
      }
    }
  }


  virtual ~RecallHonorResponse() = default;
};
class ReceiverListReportHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ReceiverListReportHeadersAccountContext() {}

  explicit ReceiverListReportHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ReceiverListReportHeadersAccountContext() = default;
};
class ReceiverListReportHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ReceiverListReportHeadersAccountContext> accountContext{};

  ReceiverListReportHeaders() {}

  explicit ReceiverListReportHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ReceiverListReportHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ReceiverListReportHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ReceiverListReportHeaders() = default;
};
class ReceiverListReportShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ReceiverListReportShrinkHeaders() {}

  explicit ReceiverListReportShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ReceiverListReportShrinkHeaders() = default;
};
class ReceiverListReportRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  ReceiverListReportRequestTenantContext() {}

  explicit ReceiverListReportRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~ReceiverListReportRequestTenantContext() = default;
};
class ReceiverListReportRequest : public Darabonba::Model {
public:
  shared_ptr<long> offset{};
  shared_ptr<string> reportId{};
  shared_ptr<long> size{};
  shared_ptr<ReceiverListReportRequestTenantContext> tenantContext{};

  ReceiverListReportRequest() {}

  explicit ReceiverListReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        ReceiverListReportRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<ReceiverListReportRequestTenantContext>(model1);
      }
    }
  }


  virtual ~ReceiverListReportRequest() = default;
};
class ReceiverListReportShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> offset{};
  shared_ptr<string> reportId{};
  shared_ptr<long> size{};
  shared_ptr<string> tenantContextShrink{};

  ReceiverListReportShrinkRequest() {}

  explicit ReceiverListReportShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~ReceiverListReportShrinkRequest() = default;
};
class ReceiverListReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> hasMore{};
  shared_ptr<long> nextCursor{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> useridList{};

  ReceiverListReportResponseBody() {}

  explicit ReceiverListReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasMore) {
      res["hasMore"] = boost::any(*hasMore);
    }
    if (nextCursor) {
      res["nextCursor"] = boost::any(*nextCursor);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (useridList) {
      res["useridList"] = boost::any(*useridList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hasMore") != m.end() && !m["hasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["hasMore"]));
    }
    if (m.find("nextCursor") != m.end() && !m["nextCursor"].empty()) {
      nextCursor = make_shared<long>(boost::any_cast<long>(m["nextCursor"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("useridList") != m.end() && !m["useridList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["useridList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["useridList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      useridList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ReceiverListReportResponseBody() = default;
};
class ReceiverListReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReceiverListReportResponseBody> body{};

  ReceiverListReportResponse() {}

  explicit ReceiverListReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReceiverListReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReceiverListReportResponseBody>(model1);
      }
    }
  }


  virtual ~ReceiverListReportResponse() = default;
};
class RedirectTaskHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  RedirectTaskHeadersAccountContext() {}

  explicit RedirectTaskHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~RedirectTaskHeadersAccountContext() = default;
};
class RedirectTaskHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<RedirectTaskHeadersAccountContext> accountContext{};

  RedirectTaskHeaders() {}

  explicit RedirectTaskHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        RedirectTaskHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<RedirectTaskHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~RedirectTaskHeaders() = default;
};
class RedirectTaskShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  RedirectTaskShrinkHeaders() {}

  explicit RedirectTaskShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~RedirectTaskShrinkHeaders() = default;
};
class RedirectTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> byManager{};
  shared_ptr<string> language{};
  shared_ptr<string> nowActionExecutorId{};
  shared_ptr<string> processInstanceId{};
  shared_ptr<string> remark{};
  shared_ptr<string> systemToken{};
  shared_ptr<long> taskId{};

  RedirectTaskRequest() {}

  explicit RedirectTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (byManager) {
      res["ByManager"] = boost::any(*byManager);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (nowActionExecutorId) {
      res["NowActionExecutorId"] = boost::any(*nowActionExecutorId);
    }
    if (processInstanceId) {
      res["ProcessInstanceId"] = boost::any(*processInstanceId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("ByManager") != m.end() && !m["ByManager"].empty()) {
      byManager = make_shared<string>(boost::any_cast<string>(m["ByManager"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("NowActionExecutorId") != m.end() && !m["NowActionExecutorId"].empty()) {
      nowActionExecutorId = make_shared<string>(boost::any_cast<string>(m["NowActionExecutorId"]));
    }
    if (m.find("ProcessInstanceId") != m.end() && !m["ProcessInstanceId"].empty()) {
      processInstanceId = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~RedirectTaskRequest() = default;
};
class RedirectTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  RedirectTaskResponseBody() {}

  explicit RedirectTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~RedirectTaskResponseBody() = default;
};
class RedirectTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RedirectTaskResponseBody> body{};

  RedirectTaskResponse() {}

  explicit RedirectTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RedirectTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RedirectTaskResponseBody>(model1);
      }
    }
  }


  virtual ~RedirectTaskResponse() = default;
};
class RemoveAttendeeHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  RemoveAttendeeHeadersAccountContext() {}

  explicit RemoveAttendeeHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~RemoveAttendeeHeadersAccountContext() = default;
};
class RemoveAttendeeHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<RemoveAttendeeHeadersAccountContext> accountContext{};

  RemoveAttendeeHeaders() {}

  explicit RemoveAttendeeHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        RemoveAttendeeHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<RemoveAttendeeHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~RemoveAttendeeHeaders() = default;
};
class RemoveAttendeeShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  RemoveAttendeeShrinkHeaders() {}

  explicit RemoveAttendeeShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~RemoveAttendeeShrinkHeaders() = default;
};
class RemoveAttendeeRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> attendeesToRemove{};
  shared_ptr<string> calendarId{};
  shared_ptr<string> eventId{};

  RemoveAttendeeRequest() {}

  explicit RemoveAttendeeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendeesToRemove) {
      res["AttendeesToRemove"] = boost::any(*attendeesToRemove);
    }
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttendeesToRemove") != m.end() && !m["AttendeesToRemove"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AttendeesToRemove"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AttendeesToRemove"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      attendeesToRemove = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
  }


  virtual ~RemoveAttendeeRequest() = default;
};
class RemoveAttendeeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> attendeesToRemoveShrink{};
  shared_ptr<string> calendarId{};
  shared_ptr<string> eventId{};

  RemoveAttendeeShrinkRequest() {}

  explicit RemoveAttendeeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendeesToRemoveShrink) {
      res["AttendeesToRemove"] = boost::any(*attendeesToRemoveShrink);
    }
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttendeesToRemove") != m.end() && !m["AttendeesToRemove"].empty()) {
      attendeesToRemoveShrink = make_shared<string>(boost::any_cast<string>(m["AttendeesToRemove"]));
    }
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
  }


  virtual ~RemoveAttendeeShrinkRequest() = default;
};
class RemoveAttendeeResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};

  RemoveAttendeeResponseBodyContent() {}

  explicit RemoveAttendeeResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
  }


  virtual ~RemoveAttendeeResponseBodyContent() = default;
};
class RemoveAttendeeResponseBody : public Darabonba::Model {
public:
  shared_ptr<RemoveAttendeeResponseBodyContent> content{};
  shared_ptr<string> errorCode{};
  shared_ptr<map<string, boost::any>> errorCtx{};
  shared_ptr<string> errorMsg{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RemoveAttendeeResponseBody() {}

  explicit RemoveAttendeeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorCtx) {
      res["ErrorCtx"] = boost::any(*errorCtx);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        RemoveAttendeeResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<RemoveAttendeeResponseBodyContent>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorCtx") != m.end() && !m["ErrorCtx"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ErrorCtx"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      errorCtx = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RemoveAttendeeResponseBody() = default;
};
class RemoveAttendeeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveAttendeeResponseBody> body{};

  RemoveAttendeeResponse() {}

  explicit RemoveAttendeeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveAttendeeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveAttendeeResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveAttendeeResponse() = default;
};
class RemoveMeetingRoomsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  RemoveMeetingRoomsHeadersAccountContext() {}

  explicit RemoveMeetingRoomsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~RemoveMeetingRoomsHeadersAccountContext() = default;
};
class RemoveMeetingRoomsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<RemoveMeetingRoomsHeadersAccountContext> accountContext{};

  RemoveMeetingRoomsHeaders() {}

  explicit RemoveMeetingRoomsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        RemoveMeetingRoomsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<RemoveMeetingRoomsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~RemoveMeetingRoomsHeaders() = default;
};
class RemoveMeetingRoomsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  RemoveMeetingRoomsShrinkHeaders() {}

  explicit RemoveMeetingRoomsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~RemoveMeetingRoomsShrinkHeaders() = default;
};
class RemoveMeetingRoomsRequestMeetingRoomsToRemove : public Darabonba::Model {
public:
  shared_ptr<string> roomId{};

  RemoveMeetingRoomsRequestMeetingRoomsToRemove() {}

  explicit RemoveMeetingRoomsRequestMeetingRoomsToRemove(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
  }


  virtual ~RemoveMeetingRoomsRequestMeetingRoomsToRemove() = default;
};
class RemoveMeetingRoomsRequest : public Darabonba::Model {
public:
  shared_ptr<string> calendarId{};
  shared_ptr<string> eventId{};
  shared_ptr<vector<RemoveMeetingRoomsRequestMeetingRoomsToRemove>> meetingRoomsToRemove{};

  RemoveMeetingRoomsRequest() {}

  explicit RemoveMeetingRoomsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (meetingRoomsToRemove) {
      vector<boost::any> temp1;
      for(auto item1:*meetingRoomsToRemove){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MeetingRoomsToRemove"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("MeetingRoomsToRemove") != m.end() && !m["MeetingRoomsToRemove"].empty()) {
      if (typeid(vector<boost::any>) == m["MeetingRoomsToRemove"].type()) {
        vector<RemoveMeetingRoomsRequestMeetingRoomsToRemove> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MeetingRoomsToRemove"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RemoveMeetingRoomsRequestMeetingRoomsToRemove model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        meetingRoomsToRemove = make_shared<vector<RemoveMeetingRoomsRequestMeetingRoomsToRemove>>(expect1);
      }
    }
  }


  virtual ~RemoveMeetingRoomsRequest() = default;
};
class RemoveMeetingRoomsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> calendarId{};
  shared_ptr<string> eventId{};
  shared_ptr<string> meetingRoomsToRemoveShrink{};

  RemoveMeetingRoomsShrinkRequest() {}

  explicit RemoveMeetingRoomsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (meetingRoomsToRemoveShrink) {
      res["MeetingRoomsToRemove"] = boost::any(*meetingRoomsToRemoveShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("MeetingRoomsToRemove") != m.end() && !m["MeetingRoomsToRemove"].empty()) {
      meetingRoomsToRemoveShrink = make_shared<string>(boost::any_cast<string>(m["MeetingRoomsToRemove"]));
    }
  }


  virtual ~RemoveMeetingRoomsShrinkRequest() = default;
};
class RemoveMeetingRoomsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  RemoveMeetingRoomsResponseBody() {}

  explicit RemoveMeetingRoomsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~RemoveMeetingRoomsResponseBody() = default;
};
class RemoveMeetingRoomsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveMeetingRoomsResponseBody> body{};

  RemoveMeetingRoomsResponse() {}

  explicit RemoveMeetingRoomsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveMeetingRoomsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveMeetingRoomsResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveMeetingRoomsResponse() = default;
};
class RespondEventHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  RespondEventHeadersAccountContext() {}

  explicit RespondEventHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~RespondEventHeadersAccountContext() = default;
};
class RespondEventHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<RespondEventHeadersAccountContext> accountContext{};

  RespondEventHeaders() {}

  explicit RespondEventHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        RespondEventHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<RespondEventHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~RespondEventHeaders() = default;
};
class RespondEventShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  RespondEventShrinkHeaders() {}

  explicit RespondEventShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~RespondEventShrinkHeaders() = default;
};
class RespondEventRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  RespondEventRequestTenantContext() {}

  explicit RespondEventRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~RespondEventRequestTenantContext() = default;
};
class RespondEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> calendarId{};
  shared_ptr<string> eventId{};
  shared_ptr<string> responseStatus{};
  shared_ptr<RespondEventRequestTenantContext> tenantContext{};

  RespondEventRequest() {}

  explicit RespondEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        RespondEventRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<RespondEventRequestTenantContext>(model1);
      }
    }
  }


  virtual ~RespondEventRequest() = default;
};
class RespondEventShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> calendarId{};
  shared_ptr<string> eventId{};
  shared_ptr<string> responseStatus{};
  shared_ptr<string> tenantContextShrink{};

  RespondEventShrinkRequest() {}

  explicit RespondEventShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~RespondEventShrinkRequest() = default;
};
class RespondEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  RespondEventResponseBody() {}

  explicit RespondEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~RespondEventResponseBody() = default;
};
class RespondEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RespondEventResponseBody> body{};

  RespondEventResponse() {}

  explicit RespondEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RespondEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RespondEventResponseBody>(model1);
      }
    }
  }


  virtual ~RespondEventResponse() = default;
};
class RetrieveRunHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountId{};

  RetrieveRunHeaders() {}

  explicit RetrieveRunHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~RetrieveRunHeaders() = default;
};
class RetrieveRunRequest : public Darabonba::Model {
public:
  shared_ptr<string> assistantId{};
  shared_ptr<string> originalAssistantId{};
  shared_ptr<string> runId{};
  shared_ptr<string> sourceIdOfOriginalAssistantId{};
  shared_ptr<string> sourceTypeOfOriginalAssistantId{};

  RetrieveRunRequest() {}

  explicit RetrieveRunRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assistantId) {
      res["assistantId"] = boost::any(*assistantId);
    }
    if (originalAssistantId) {
      res["originalAssistantId"] = boost::any(*originalAssistantId);
    }
    if (runId) {
      res["runId"] = boost::any(*runId);
    }
    if (sourceIdOfOriginalAssistantId) {
      res["sourceIdOfOriginalAssistantId"] = boost::any(*sourceIdOfOriginalAssistantId);
    }
    if (sourceTypeOfOriginalAssistantId) {
      res["sourceTypeOfOriginalAssistantId"] = boost::any(*sourceTypeOfOriginalAssistantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assistantId") != m.end() && !m["assistantId"].empty()) {
      assistantId = make_shared<string>(boost::any_cast<string>(m["assistantId"]));
    }
    if (m.find("originalAssistantId") != m.end() && !m["originalAssistantId"].empty()) {
      originalAssistantId = make_shared<string>(boost::any_cast<string>(m["originalAssistantId"]));
    }
    if (m.find("runId") != m.end() && !m["runId"].empty()) {
      runId = make_shared<string>(boost::any_cast<string>(m["runId"]));
    }
    if (m.find("sourceIdOfOriginalAssistantId") != m.end() && !m["sourceIdOfOriginalAssistantId"].empty()) {
      sourceIdOfOriginalAssistantId = make_shared<string>(boost::any_cast<string>(m["sourceIdOfOriginalAssistantId"]));
    }
    if (m.find("sourceTypeOfOriginalAssistantId") != m.end() && !m["sourceTypeOfOriginalAssistantId"].empty()) {
      sourceTypeOfOriginalAssistantId = make_shared<string>(boost::any_cast<string>(m["sourceTypeOfOriginalAssistantId"]));
    }
  }


  virtual ~RetrieveRunRequest() = default;
};
class RetrieveRunResponseBodyRun : public Darabonba::Model {
public:
  shared_ptr<long> cancelledAt{};
  shared_ptr<long> completedAt{};
  shared_ptr<long> createAt{};
  shared_ptr<long> expiresAt{};
  shared_ptr<long> failedAt{};
  shared_ptr<string> id{};
  shared_ptr<string> lastErrorMsg{};
  shared_ptr<long> startedAt{};
  shared_ptr<string> status{};
  shared_ptr<string> threadId{};

  RetrieveRunResponseBodyRun() {}

  explicit RetrieveRunResponseBodyRun(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cancelledAt) {
      res["cancelledAt"] = boost::any(*cancelledAt);
    }
    if (completedAt) {
      res["completedAt"] = boost::any(*completedAt);
    }
    if (createAt) {
      res["createAt"] = boost::any(*createAt);
    }
    if (expiresAt) {
      res["expiresAt"] = boost::any(*expiresAt);
    }
    if (failedAt) {
      res["failedAt"] = boost::any(*failedAt);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (lastErrorMsg) {
      res["lastErrorMsg"] = boost::any(*lastErrorMsg);
    }
    if (startedAt) {
      res["startedAt"] = boost::any(*startedAt);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (threadId) {
      res["threadId"] = boost::any(*threadId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cancelledAt") != m.end() && !m["cancelledAt"].empty()) {
      cancelledAt = make_shared<long>(boost::any_cast<long>(m["cancelledAt"]));
    }
    if (m.find("completedAt") != m.end() && !m["completedAt"].empty()) {
      completedAt = make_shared<long>(boost::any_cast<long>(m["completedAt"]));
    }
    if (m.find("createAt") != m.end() && !m["createAt"].empty()) {
      createAt = make_shared<long>(boost::any_cast<long>(m["createAt"]));
    }
    if (m.find("expiresAt") != m.end() && !m["expiresAt"].empty()) {
      expiresAt = make_shared<long>(boost::any_cast<long>(m["expiresAt"]));
    }
    if (m.find("failedAt") != m.end() && !m["failedAt"].empty()) {
      failedAt = make_shared<long>(boost::any_cast<long>(m["failedAt"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("lastErrorMsg") != m.end() && !m["lastErrorMsg"].empty()) {
      lastErrorMsg = make_shared<string>(boost::any_cast<string>(m["lastErrorMsg"]));
    }
    if (m.find("startedAt") != m.end() && !m["startedAt"].empty()) {
      startedAt = make_shared<long>(boost::any_cast<long>(m["startedAt"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("threadId") != m.end() && !m["threadId"].empty()) {
      threadId = make_shared<string>(boost::any_cast<string>(m["threadId"]));
    }
  }


  virtual ~RetrieveRunResponseBodyRun() = default;
};
class RetrieveRunResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<RetrieveRunResponseBodyRun> run{};

  RetrieveRunResponseBody() {}

  explicit RetrieveRunResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (run) {
      res["run"] = run ? boost::any(run->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("run") != m.end() && !m["run"].empty()) {
      if (typeid(map<string, boost::any>) == m["run"].type()) {
        RetrieveRunResponseBodyRun model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["run"]));
        run = make_shared<RetrieveRunResponseBodyRun>(model1);
      }
    }
  }


  virtual ~RetrieveRunResponseBody() = default;
};
class RetrieveRunResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RetrieveRunResponseBody> body{};

  RetrieveRunResponse() {}

  explicit RetrieveRunResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RetrieveRunResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RetrieveRunResponseBody>(model1);
      }
    }
  }


  virtual ~RetrieveRunResponse() = default;
};
class SaveContentHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SaveContentHeadersAccountContext() {}

  explicit SaveContentHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SaveContentHeadersAccountContext() = default;
};
class SaveContentHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SaveContentHeadersAccountContext> accountContext{};

  SaveContentHeaders() {}

  explicit SaveContentHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SaveContentHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SaveContentHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SaveContentHeaders() = default;
};
class SaveContentShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SaveContentShrinkHeaders() {}

  explicit SaveContentShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SaveContentShrinkHeaders() = default;
};
class SaveContentRequestContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentType{};
  shared_ptr<string> key{};
  shared_ptr<long> sort{};
  shared_ptr<long> type{};

  SaveContentRequestContents() {}

  explicit SaveContentRequestContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<long>(boost::any_cast<long>(m["Sort"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~SaveContentRequestContents() = default;
};
class SaveContentRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  SaveContentRequestTenantContext() {}

  explicit SaveContentRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~SaveContentRequestTenantContext() = default;
};
class SaveContentRequest : public Darabonba::Model {
public:
  shared_ptr<vector<SaveContentRequestContents>> contents{};
  shared_ptr<string> ddFrom{};
  shared_ptr<string> templateId{};
  shared_ptr<SaveContentRequestTenantContext> tenantContext{};

  SaveContentRequest() {}

  explicit SaveContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contents) {
      vector<boost::any> temp1;
      for(auto item1:*contents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contents"] = boost::any(temp1);
    }
    if (ddFrom) {
      res["DdFrom"] = boost::any(*ddFrom);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      if (typeid(vector<boost::any>) == m["Contents"].type()) {
        vector<SaveContentRequestContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SaveContentRequestContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contents = make_shared<vector<SaveContentRequestContents>>(expect1);
      }
    }
    if (m.find("DdFrom") != m.end() && !m["DdFrom"].empty()) {
      ddFrom = make_shared<string>(boost::any_cast<string>(m["DdFrom"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        SaveContentRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<SaveContentRequestTenantContext>(model1);
      }
    }
  }


  virtual ~SaveContentRequest() = default;
};
class SaveContentShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> contentsShrink{};
  shared_ptr<string> ddFrom{};
  shared_ptr<string> templateId{};
  shared_ptr<string> tenantContextShrink{};

  SaveContentShrinkRequest() {}

  explicit SaveContentShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentsShrink) {
      res["Contents"] = boost::any(*contentsShrink);
    }
    if (ddFrom) {
      res["DdFrom"] = boost::any(*ddFrom);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      contentsShrink = make_shared<string>(boost::any_cast<string>(m["Contents"]));
    }
    if (m.find("DdFrom") != m.end() && !m["DdFrom"].empty()) {
      ddFrom = make_shared<string>(boost::any_cast<string>(m["DdFrom"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~SaveContentShrinkRequest() = default;
};
class SaveContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SaveContentResponseBody() {}

  explicit SaveContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~SaveContentResponseBody() = default;
};
class SaveContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveContentResponseBody> body{};

  SaveContentResponse() {}

  explicit SaveContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveContentResponseBody>(model1);
      }
    }
  }


  virtual ~SaveContentResponse() = default;
};
class SaveFormDataHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SaveFormDataHeadersAccountContext() {}

  explicit SaveFormDataHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SaveFormDataHeadersAccountContext() = default;
};
class SaveFormDataHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SaveFormDataHeadersAccountContext> accountContext{};

  SaveFormDataHeaders() {}

  explicit SaveFormDataHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SaveFormDataHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SaveFormDataHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SaveFormDataHeaders() = default;
};
class SaveFormDataShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SaveFormDataShrinkHeaders() {}

  explicit SaveFormDataShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SaveFormDataShrinkHeaders() = default;
};
class SaveFormDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> formDataJson{};
  shared_ptr<string> formUuid{};
  shared_ptr<string> language{};
  shared_ptr<string> systemToken{};

  SaveFormDataRequest() {}

  explicit SaveFormDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (formDataJson) {
      res["FormDataJson"] = boost::any(*formDataJson);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("FormDataJson") != m.end() && !m["FormDataJson"].empty()) {
      formDataJson = make_shared<string>(boost::any_cast<string>(m["FormDataJson"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~SaveFormDataRequest() = default;
};
class SaveFormDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  SaveFormDataResponseBody() {}

  explicit SaveFormDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["result"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~SaveFormDataResponseBody() = default;
};
class SaveFormDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveFormDataResponseBody> body{};

  SaveFormDataResponse() {}

  explicit SaveFormDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveFormDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveFormDataResponseBody>(model1);
      }
    }
  }


  virtual ~SaveFormDataResponse() = default;
};
class SaveFormRemarkHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SaveFormRemarkHeadersAccountContext() {}

  explicit SaveFormRemarkHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SaveFormRemarkHeadersAccountContext() = default;
};
class SaveFormRemarkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SaveFormRemarkHeadersAccountContext> accountContext{};

  SaveFormRemarkHeaders() {}

  explicit SaveFormRemarkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SaveFormRemarkHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SaveFormRemarkHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SaveFormRemarkHeaders() = default;
};
class SaveFormRemarkShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SaveFormRemarkShrinkHeaders() {}

  explicit SaveFormRemarkShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SaveFormRemarkShrinkHeaders() = default;
};
class SaveFormRemarkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> atUserId{};
  shared_ptr<string> content{};
  shared_ptr<string> formInstanceId{};
  shared_ptr<string> language{};
  shared_ptr<long> replyId{};
  shared_ptr<string> systemToken{};

  SaveFormRemarkRequest() {}

  explicit SaveFormRemarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (atUserId) {
      res["AtUserId"] = boost::any(*atUserId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (formInstanceId) {
      res["FormInstanceId"] = boost::any(*formInstanceId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (replyId) {
      res["ReplyId"] = boost::any(*replyId);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("AtUserId") != m.end() && !m["AtUserId"].empty()) {
      atUserId = make_shared<string>(boost::any_cast<string>(m["AtUserId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FormInstanceId") != m.end() && !m["FormInstanceId"].empty()) {
      formInstanceId = make_shared<string>(boost::any_cast<string>(m["FormInstanceId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("ReplyId") != m.end() && !m["ReplyId"].empty()) {
      replyId = make_shared<long>(boost::any_cast<long>(m["ReplyId"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~SaveFormRemarkRequest() = default;
};
class SaveFormRemarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> result{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  SaveFormRemarkResponseBody() {}

  explicit SaveFormRemarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<long>(boost::any_cast<long>(m["result"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~SaveFormRemarkResponseBody() = default;
};
class SaveFormRemarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveFormRemarkResponseBody> body{};

  SaveFormRemarkResponse() {}

  explicit SaveFormRemarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveFormRemarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveFormRemarkResponseBody>(model1);
      }
    }
  }


  virtual ~SaveFormRemarkResponse() = default;
};
class SearchEmployeeFieldValuesHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SearchEmployeeFieldValuesHeadersAccountContext() {}

  explicit SearchEmployeeFieldValuesHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SearchEmployeeFieldValuesHeadersAccountContext() = default;
};
class SearchEmployeeFieldValuesHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SearchEmployeeFieldValuesHeadersAccountContext> accountContext{};

  SearchEmployeeFieldValuesHeaders() {}

  explicit SearchEmployeeFieldValuesHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SearchEmployeeFieldValuesHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SearchEmployeeFieldValuesHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SearchEmployeeFieldValuesHeaders() = default;
};
class SearchEmployeeFieldValuesShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SearchEmployeeFieldValuesShrinkHeaders() {}

  explicit SearchEmployeeFieldValuesShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SearchEmployeeFieldValuesShrinkHeaders() = default;
};
class SearchEmployeeFieldValuesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> createFromTimeGMT{};
  shared_ptr<string> createToTimeGMT{};
  shared_ptr<string> formUuid{};
  shared_ptr<string> language{};
  shared_ptr<string> modifiedFromTimeGMT{};
  shared_ptr<string> modifiedToTimeGMT{};
  shared_ptr<string> originatorId{};
  shared_ptr<string> searchFieldJson{};
  shared_ptr<string> systemToken{};
  shared_ptr<string> targetFieldJson{};

  SearchEmployeeFieldValuesRequest() {}

  explicit SearchEmployeeFieldValuesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (createFromTimeGMT) {
      res["CreateFromTimeGMT"] = boost::any(*createFromTimeGMT);
    }
    if (createToTimeGMT) {
      res["CreateToTimeGMT"] = boost::any(*createToTimeGMT);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (modifiedFromTimeGMT) {
      res["ModifiedFromTimeGMT"] = boost::any(*modifiedFromTimeGMT);
    }
    if (modifiedToTimeGMT) {
      res["ModifiedToTimeGMT"] = boost::any(*modifiedToTimeGMT);
    }
    if (originatorId) {
      res["OriginatorId"] = boost::any(*originatorId);
    }
    if (searchFieldJson) {
      res["SearchFieldJson"] = boost::any(*searchFieldJson);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    if (targetFieldJson) {
      res["TargetFieldJson"] = boost::any(*targetFieldJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("CreateFromTimeGMT") != m.end() && !m["CreateFromTimeGMT"].empty()) {
      createFromTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateFromTimeGMT"]));
    }
    if (m.find("CreateToTimeGMT") != m.end() && !m["CreateToTimeGMT"].empty()) {
      createToTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateToTimeGMT"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("ModifiedFromTimeGMT") != m.end() && !m["ModifiedFromTimeGMT"].empty()) {
      modifiedFromTimeGMT = make_shared<string>(boost::any_cast<string>(m["ModifiedFromTimeGMT"]));
    }
    if (m.find("ModifiedToTimeGMT") != m.end() && !m["ModifiedToTimeGMT"].empty()) {
      modifiedToTimeGMT = make_shared<string>(boost::any_cast<string>(m["ModifiedToTimeGMT"]));
    }
    if (m.find("OriginatorId") != m.end() && !m["OriginatorId"].empty()) {
      originatorId = make_shared<string>(boost::any_cast<string>(m["OriginatorId"]));
    }
    if (m.find("SearchFieldJson") != m.end() && !m["SearchFieldJson"].empty()) {
      searchFieldJson = make_shared<string>(boost::any_cast<string>(m["SearchFieldJson"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
    if (m.find("TargetFieldJson") != m.end() && !m["TargetFieldJson"].empty()) {
      targetFieldJson = make_shared<string>(boost::any_cast<string>(m["TargetFieldJson"]));
    }
  }


  virtual ~SearchEmployeeFieldValuesRequest() = default;
};
class SearchEmployeeFieldValuesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  SearchEmployeeFieldValuesResponseBody() {}

  explicit SearchEmployeeFieldValuesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["result"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~SearchEmployeeFieldValuesResponseBody() = default;
};
class SearchEmployeeFieldValuesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchEmployeeFieldValuesResponseBody> body{};

  SearchEmployeeFieldValuesResponse() {}

  explicit SearchEmployeeFieldValuesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchEmployeeFieldValuesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchEmployeeFieldValuesResponseBody>(model1);
      }
    }
  }


  virtual ~SearchEmployeeFieldValuesResponse() = default;
};
class SearchFormDataIdListHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SearchFormDataIdListHeadersAccountContext() {}

  explicit SearchFormDataIdListHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SearchFormDataIdListHeadersAccountContext() = default;
};
class SearchFormDataIdListHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SearchFormDataIdListHeadersAccountContext> accountContext{};

  SearchFormDataIdListHeaders() {}

  explicit SearchFormDataIdListHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SearchFormDataIdListHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SearchFormDataIdListHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SearchFormDataIdListHeaders() = default;
};
class SearchFormDataIdListShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SearchFormDataIdListShrinkHeaders() {}

  explicit SearchFormDataIdListShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SearchFormDataIdListShrinkHeaders() = default;
};
class SearchFormDataIdListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> createFromTimeGMT{};
  shared_ptr<string> createToTimeGMT{};
  shared_ptr<string> formUuid{};
  shared_ptr<string> language{};
  shared_ptr<string> modifiedFromTimeGMT{};
  shared_ptr<string> modifiedToTimeGMT{};
  shared_ptr<string> originatorId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchFieldJson{};
  shared_ptr<string> systemToken{};

  SearchFormDataIdListRequest() {}

  explicit SearchFormDataIdListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (createFromTimeGMT) {
      res["CreateFromTimeGMT"] = boost::any(*createFromTimeGMT);
    }
    if (createToTimeGMT) {
      res["CreateToTimeGMT"] = boost::any(*createToTimeGMT);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (modifiedFromTimeGMT) {
      res["ModifiedFromTimeGMT"] = boost::any(*modifiedFromTimeGMT);
    }
    if (modifiedToTimeGMT) {
      res["ModifiedToTimeGMT"] = boost::any(*modifiedToTimeGMT);
    }
    if (originatorId) {
      res["OriginatorId"] = boost::any(*originatorId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchFieldJson) {
      res["SearchFieldJson"] = boost::any(*searchFieldJson);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("CreateFromTimeGMT") != m.end() && !m["CreateFromTimeGMT"].empty()) {
      createFromTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateFromTimeGMT"]));
    }
    if (m.find("CreateToTimeGMT") != m.end() && !m["CreateToTimeGMT"].empty()) {
      createToTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateToTimeGMT"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("ModifiedFromTimeGMT") != m.end() && !m["ModifiedFromTimeGMT"].empty()) {
      modifiedFromTimeGMT = make_shared<string>(boost::any_cast<string>(m["ModifiedFromTimeGMT"]));
    }
    if (m.find("ModifiedToTimeGMT") != m.end() && !m["ModifiedToTimeGMT"].empty()) {
      modifiedToTimeGMT = make_shared<string>(boost::any_cast<string>(m["ModifiedToTimeGMT"]));
    }
    if (m.find("OriginatorId") != m.end() && !m["OriginatorId"].empty()) {
      originatorId = make_shared<string>(boost::any_cast<string>(m["OriginatorId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchFieldJson") != m.end() && !m["SearchFieldJson"].empty()) {
      searchFieldJson = make_shared<string>(boost::any_cast<string>(m["SearchFieldJson"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~SearchFormDataIdListRequest() = default;
};
class SearchFormDataIdListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  SearchFormDataIdListResponseBody() {}

  explicit SearchFormDataIdListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~SearchFormDataIdListResponseBody() = default;
};
class SearchFormDataIdListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchFormDataIdListResponseBody> body{};

  SearchFormDataIdListResponse() {}

  explicit SearchFormDataIdListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchFormDataIdListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchFormDataIdListResponseBody>(model1);
      }
    }
  }


  virtual ~SearchFormDataIdListResponse() = default;
};
class SearchFormDataSecondGenerationHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SearchFormDataSecondGenerationHeadersAccountContext() {}

  explicit SearchFormDataSecondGenerationHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SearchFormDataSecondGenerationHeadersAccountContext() = default;
};
class SearchFormDataSecondGenerationHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SearchFormDataSecondGenerationHeadersAccountContext> accountContext{};

  SearchFormDataSecondGenerationHeaders() {}

  explicit SearchFormDataSecondGenerationHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SearchFormDataSecondGenerationHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SearchFormDataSecondGenerationHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SearchFormDataSecondGenerationHeaders() = default;
};
class SearchFormDataSecondGenerationShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SearchFormDataSecondGenerationShrinkHeaders() {}

  explicit SearchFormDataSecondGenerationShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SearchFormDataSecondGenerationShrinkHeaders() = default;
};
class SearchFormDataSecondGenerationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> createFromTimeGMT{};
  shared_ptr<string> createToTimeGMT{};
  shared_ptr<string> formUuid{};
  shared_ptr<string> modifiedFromTimeGMT{};
  shared_ptr<string> modifiedToTimeGMT{};
  shared_ptr<string> orderConfigJson{};
  shared_ptr<string> originatorId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchCondition{};
  shared_ptr<string> systemToken{};

  SearchFormDataSecondGenerationRequest() {}

  explicit SearchFormDataSecondGenerationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (createFromTimeGMT) {
      res["CreateFromTimeGMT"] = boost::any(*createFromTimeGMT);
    }
    if (createToTimeGMT) {
      res["CreateToTimeGMT"] = boost::any(*createToTimeGMT);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (modifiedFromTimeGMT) {
      res["ModifiedFromTimeGMT"] = boost::any(*modifiedFromTimeGMT);
    }
    if (modifiedToTimeGMT) {
      res["ModifiedToTimeGMT"] = boost::any(*modifiedToTimeGMT);
    }
    if (orderConfigJson) {
      res["OrderConfigJson"] = boost::any(*orderConfigJson);
    }
    if (originatorId) {
      res["OriginatorId"] = boost::any(*originatorId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchCondition) {
      res["SearchCondition"] = boost::any(*searchCondition);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("CreateFromTimeGMT") != m.end() && !m["CreateFromTimeGMT"].empty()) {
      createFromTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateFromTimeGMT"]));
    }
    if (m.find("CreateToTimeGMT") != m.end() && !m["CreateToTimeGMT"].empty()) {
      createToTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateToTimeGMT"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("ModifiedFromTimeGMT") != m.end() && !m["ModifiedFromTimeGMT"].empty()) {
      modifiedFromTimeGMT = make_shared<string>(boost::any_cast<string>(m["ModifiedFromTimeGMT"]));
    }
    if (m.find("ModifiedToTimeGMT") != m.end() && !m["ModifiedToTimeGMT"].empty()) {
      modifiedToTimeGMT = make_shared<string>(boost::any_cast<string>(m["ModifiedToTimeGMT"]));
    }
    if (m.find("OrderConfigJson") != m.end() && !m["OrderConfigJson"].empty()) {
      orderConfigJson = make_shared<string>(boost::any_cast<string>(m["OrderConfigJson"]));
    }
    if (m.find("OriginatorId") != m.end() && !m["OriginatorId"].empty()) {
      originatorId = make_shared<string>(boost::any_cast<string>(m["OriginatorId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchCondition") != m.end() && !m["SearchCondition"].empty()) {
      searchCondition = make_shared<string>(boost::any_cast<string>(m["SearchCondition"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~SearchFormDataSecondGenerationRequest() = default;
};
class SearchFormDataSecondGenerationResponseBodyDataModifyUserName : public Darabonba::Model {
public:
  shared_ptr<string> nameInChinese{};
  shared_ptr<string> nameInEnglish{};

  SearchFormDataSecondGenerationResponseBodyDataModifyUserName() {}

  explicit SearchFormDataSecondGenerationResponseBodyDataModifyUserName(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameInChinese) {
      res["NameInChinese"] = boost::any(*nameInChinese);
    }
    if (nameInEnglish) {
      res["NameInEnglish"] = boost::any(*nameInEnglish);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameInChinese") != m.end() && !m["NameInChinese"].empty()) {
      nameInChinese = make_shared<string>(boost::any_cast<string>(m["NameInChinese"]));
    }
    if (m.find("NameInEnglish") != m.end() && !m["NameInEnglish"].empty()) {
      nameInEnglish = make_shared<string>(boost::any_cast<string>(m["NameInEnglish"]));
    }
  }


  virtual ~SearchFormDataSecondGenerationResponseBodyDataModifyUserName() = default;
};
class SearchFormDataSecondGenerationResponseBodyDataModifyUser : public Darabonba::Model {
public:
  shared_ptr<SearchFormDataSecondGenerationResponseBodyDataModifyUserName> name{};
  shared_ptr<string> userId{};

  SearchFormDataSecondGenerationResponseBodyDataModifyUser() {}

  explicit SearchFormDataSecondGenerationResponseBodyDataModifyUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = name ? boost::any(name->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      if (typeid(map<string, boost::any>) == m["Name"].type()) {
        SearchFormDataSecondGenerationResponseBodyDataModifyUserName model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Name"]));
        name = make_shared<SearchFormDataSecondGenerationResponseBodyDataModifyUserName>(model1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SearchFormDataSecondGenerationResponseBodyDataModifyUser() = default;
};
class SearchFormDataSecondGenerationResponseBodyDataOriginatorName : public Darabonba::Model {
public:
  shared_ptr<string> nameInChinese{};
  shared_ptr<string> nameInEnglish{};

  SearchFormDataSecondGenerationResponseBodyDataOriginatorName() {}

  explicit SearchFormDataSecondGenerationResponseBodyDataOriginatorName(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameInChinese) {
      res["NameInChinese"] = boost::any(*nameInChinese);
    }
    if (nameInEnglish) {
      res["NameInEnglish"] = boost::any(*nameInEnglish);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameInChinese") != m.end() && !m["NameInChinese"].empty()) {
      nameInChinese = make_shared<string>(boost::any_cast<string>(m["NameInChinese"]));
    }
    if (m.find("NameInEnglish") != m.end() && !m["NameInEnglish"].empty()) {
      nameInEnglish = make_shared<string>(boost::any_cast<string>(m["NameInEnglish"]));
    }
  }


  virtual ~SearchFormDataSecondGenerationResponseBodyDataOriginatorName() = default;
};
class SearchFormDataSecondGenerationResponseBodyDataOriginator : public Darabonba::Model {
public:
  shared_ptr<SearchFormDataSecondGenerationResponseBodyDataOriginatorName> name{};
  shared_ptr<string> userId{};

  SearchFormDataSecondGenerationResponseBodyDataOriginator() {}

  explicit SearchFormDataSecondGenerationResponseBodyDataOriginator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = name ? boost::any(name->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      if (typeid(map<string, boost::any>) == m["Name"].type()) {
        SearchFormDataSecondGenerationResponseBodyDataOriginatorName model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Name"]));
        name = make_shared<SearchFormDataSecondGenerationResponseBodyDataOriginatorName>(model1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SearchFormDataSecondGenerationResponseBodyDataOriginator() = default;
};
class SearchFormDataSecondGenerationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> createTimeGMT{};
  shared_ptr<string> creatorUserId{};
  shared_ptr<map<string, boost::any>> formData{};
  shared_ptr<string> formInstanceId{};
  shared_ptr<string> formUuid{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceValue{};
  shared_ptr<string> modifiedTimeGMT{};
  shared_ptr<string> modifier{};
  shared_ptr<SearchFormDataSecondGenerationResponseBodyDataModifyUser> modifyUser{};
  shared_ptr<SearchFormDataSecondGenerationResponseBodyDataOriginator> originator{};
  shared_ptr<string> sequence{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> title{};
  shared_ptr<long> version{};

  SearchFormDataSecondGenerationResponseBodyData() {}

  explicit SearchFormDataSecondGenerationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTimeGMT) {
      res["CreateTimeGMT"] = boost::any(*createTimeGMT);
    }
    if (creatorUserId) {
      res["CreatorUserId"] = boost::any(*creatorUserId);
    }
    if (formData) {
      res["FormData"] = boost::any(*formData);
    }
    if (formInstanceId) {
      res["FormInstanceId"] = boost::any(*formInstanceId);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceValue) {
      res["InstanceValue"] = boost::any(*instanceValue);
    }
    if (modifiedTimeGMT) {
      res["ModifiedTimeGMT"] = boost::any(*modifiedTimeGMT);
    }
    if (modifier) {
      res["Modifier"] = boost::any(*modifier);
    }
    if (modifyUser) {
      res["ModifyUser"] = modifyUser ? boost::any(modifyUser->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (originator) {
      res["Originator"] = originator ? boost::any(originator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTimeGMT") != m.end() && !m["CreateTimeGMT"].empty()) {
      createTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateTimeGMT"]));
    }
    if (m.find("CreatorUserId") != m.end() && !m["CreatorUserId"].empty()) {
      creatorUserId = make_shared<string>(boost::any_cast<string>(m["CreatorUserId"]));
    }
    if (m.find("FormData") != m.end() && !m["FormData"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["FormData"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      formData = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("FormInstanceId") != m.end() && !m["FormInstanceId"].empty()) {
      formInstanceId = make_shared<string>(boost::any_cast<string>(m["FormInstanceId"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceValue") != m.end() && !m["InstanceValue"].empty()) {
      instanceValue = make_shared<string>(boost::any_cast<string>(m["InstanceValue"]));
    }
    if (m.find("ModifiedTimeGMT") != m.end() && !m["ModifiedTimeGMT"].empty()) {
      modifiedTimeGMT = make_shared<string>(boost::any_cast<string>(m["ModifiedTimeGMT"]));
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["Modifier"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModifyUser"].type()) {
        SearchFormDataSecondGenerationResponseBodyDataModifyUser model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModifyUser"]));
        modifyUser = make_shared<SearchFormDataSecondGenerationResponseBodyDataModifyUser>(model1);
      }
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      if (typeid(map<string, boost::any>) == m["Originator"].type()) {
        SearchFormDataSecondGenerationResponseBodyDataOriginator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Originator"]));
        originator = make_shared<SearchFormDataSecondGenerationResponseBodyDataOriginator>(model1);
      }
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~SearchFormDataSecondGenerationResponseBodyData() = default;
};
class SearchFormDataSecondGenerationResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<SearchFormDataSecondGenerationResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  SearchFormDataSecondGenerationResponseBody() {}

  explicit SearchFormDataSecondGenerationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<SearchFormDataSecondGenerationResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchFormDataSecondGenerationResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<SearchFormDataSecondGenerationResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~SearchFormDataSecondGenerationResponseBody() = default;
};
class SearchFormDataSecondGenerationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchFormDataSecondGenerationResponseBody> body{};

  SearchFormDataSecondGenerationResponse() {}

  explicit SearchFormDataSecondGenerationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchFormDataSecondGenerationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchFormDataSecondGenerationResponseBody>(model1);
      }
    }
  }


  virtual ~SearchFormDataSecondGenerationResponse() = default;
};
class SearchFormDataSecondGenerationNoTableFieldHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SearchFormDataSecondGenerationNoTableFieldHeadersAccountContext() {}

  explicit SearchFormDataSecondGenerationNoTableFieldHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SearchFormDataSecondGenerationNoTableFieldHeadersAccountContext() = default;
};
class SearchFormDataSecondGenerationNoTableFieldHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SearchFormDataSecondGenerationNoTableFieldHeadersAccountContext> accountContext{};

  SearchFormDataSecondGenerationNoTableFieldHeaders() {}

  explicit SearchFormDataSecondGenerationNoTableFieldHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SearchFormDataSecondGenerationNoTableFieldHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SearchFormDataSecondGenerationNoTableFieldHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SearchFormDataSecondGenerationNoTableFieldHeaders() = default;
};
class SearchFormDataSecondGenerationNoTableFieldShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SearchFormDataSecondGenerationNoTableFieldShrinkHeaders() {}

  explicit SearchFormDataSecondGenerationNoTableFieldShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SearchFormDataSecondGenerationNoTableFieldShrinkHeaders() = default;
};
class SearchFormDataSecondGenerationNoTableFieldRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> createFromTimeGMT{};
  shared_ptr<string> createToTimeGMT{};
  shared_ptr<string> formUuid{};
  shared_ptr<string> modifiedFromTimeGMT{};
  shared_ptr<string> modifiedToTimeGMT{};
  shared_ptr<string> orderConfigJson{};
  shared_ptr<string> originatorId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchCondition{};
  shared_ptr<string> systemToken{};

  SearchFormDataSecondGenerationNoTableFieldRequest() {}

  explicit SearchFormDataSecondGenerationNoTableFieldRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (createFromTimeGMT) {
      res["CreateFromTimeGMT"] = boost::any(*createFromTimeGMT);
    }
    if (createToTimeGMT) {
      res["CreateToTimeGMT"] = boost::any(*createToTimeGMT);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (modifiedFromTimeGMT) {
      res["ModifiedFromTimeGMT"] = boost::any(*modifiedFromTimeGMT);
    }
    if (modifiedToTimeGMT) {
      res["ModifiedToTimeGMT"] = boost::any(*modifiedToTimeGMT);
    }
    if (orderConfigJson) {
      res["OrderConfigJson"] = boost::any(*orderConfigJson);
    }
    if (originatorId) {
      res["OriginatorId"] = boost::any(*originatorId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchCondition) {
      res["SearchCondition"] = boost::any(*searchCondition);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("CreateFromTimeGMT") != m.end() && !m["CreateFromTimeGMT"].empty()) {
      createFromTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateFromTimeGMT"]));
    }
    if (m.find("CreateToTimeGMT") != m.end() && !m["CreateToTimeGMT"].empty()) {
      createToTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateToTimeGMT"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("ModifiedFromTimeGMT") != m.end() && !m["ModifiedFromTimeGMT"].empty()) {
      modifiedFromTimeGMT = make_shared<string>(boost::any_cast<string>(m["ModifiedFromTimeGMT"]));
    }
    if (m.find("ModifiedToTimeGMT") != m.end() && !m["ModifiedToTimeGMT"].empty()) {
      modifiedToTimeGMT = make_shared<string>(boost::any_cast<string>(m["ModifiedToTimeGMT"]));
    }
    if (m.find("OrderConfigJson") != m.end() && !m["OrderConfigJson"].empty()) {
      orderConfigJson = make_shared<string>(boost::any_cast<string>(m["OrderConfigJson"]));
    }
    if (m.find("OriginatorId") != m.end() && !m["OriginatorId"].empty()) {
      originatorId = make_shared<string>(boost::any_cast<string>(m["OriginatorId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchCondition") != m.end() && !m["SearchCondition"].empty()) {
      searchCondition = make_shared<string>(boost::any_cast<string>(m["SearchCondition"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~SearchFormDataSecondGenerationNoTableFieldRequest() = default;
};
class SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUserName : public Darabonba::Model {
public:
  shared_ptr<string> nameInChinese{};
  shared_ptr<string> nameInEnglish{};

  SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUserName() {}

  explicit SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUserName(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameInChinese) {
      res["NameInChinese"] = boost::any(*nameInChinese);
    }
    if (nameInEnglish) {
      res["NameInEnglish"] = boost::any(*nameInEnglish);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameInChinese") != m.end() && !m["NameInChinese"].empty()) {
      nameInChinese = make_shared<string>(boost::any_cast<string>(m["NameInChinese"]));
    }
    if (m.find("NameInEnglish") != m.end() && !m["NameInEnglish"].empty()) {
      nameInEnglish = make_shared<string>(boost::any_cast<string>(m["NameInEnglish"]));
    }
  }


  virtual ~SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUserName() = default;
};
class SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUser : public Darabonba::Model {
public:
  shared_ptr<SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUserName> name{};
  shared_ptr<string> userId{};

  SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUser() {}

  explicit SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = name ? boost::any(name->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      if (typeid(map<string, boost::any>) == m["Name"].type()) {
        SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUserName model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Name"]));
        name = make_shared<SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUserName>(model1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUser() = default;
};
class SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginatorName : public Darabonba::Model {
public:
  shared_ptr<string> nameInChinese{};
  shared_ptr<string> nameInEnglish{};

  SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginatorName() {}

  explicit SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginatorName(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameInChinese) {
      res["NameInChinese"] = boost::any(*nameInChinese);
    }
    if (nameInEnglish) {
      res["NameInEnglish"] = boost::any(*nameInEnglish);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameInChinese") != m.end() && !m["NameInChinese"].empty()) {
      nameInChinese = make_shared<string>(boost::any_cast<string>(m["NameInChinese"]));
    }
    if (m.find("NameInEnglish") != m.end() && !m["NameInEnglish"].empty()) {
      nameInEnglish = make_shared<string>(boost::any_cast<string>(m["NameInEnglish"]));
    }
  }


  virtual ~SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginatorName() = default;
};
class SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginator : public Darabonba::Model {
public:
  shared_ptr<SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginatorName> name{};
  shared_ptr<string> userId{};

  SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginator() {}

  explicit SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = name ? boost::any(name->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      if (typeid(map<string, boost::any>) == m["Name"].type()) {
        SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginatorName model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Name"]));
        name = make_shared<SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginatorName>(model1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginator() = default;
};
class SearchFormDataSecondGenerationNoTableFieldResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> createTimeGMT{};
  shared_ptr<string> creatorUserId{};
  shared_ptr<map<string, boost::any>> formData{};
  shared_ptr<string> formInstanceId{};
  shared_ptr<string> formUuid{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceValue{};
  shared_ptr<string> modifiedTimeGMT{};
  shared_ptr<string> modifier{};
  shared_ptr<SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUser> modifyUser{};
  shared_ptr<SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginator> originator{};
  shared_ptr<string> sequence{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> title{};
  shared_ptr<long> version{};

  SearchFormDataSecondGenerationNoTableFieldResponseBodyData() {}

  explicit SearchFormDataSecondGenerationNoTableFieldResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTimeGMT) {
      res["CreateTimeGMT"] = boost::any(*createTimeGMT);
    }
    if (creatorUserId) {
      res["CreatorUserId"] = boost::any(*creatorUserId);
    }
    if (formData) {
      res["FormData"] = boost::any(*formData);
    }
    if (formInstanceId) {
      res["FormInstanceId"] = boost::any(*formInstanceId);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceValue) {
      res["InstanceValue"] = boost::any(*instanceValue);
    }
    if (modifiedTimeGMT) {
      res["ModifiedTimeGMT"] = boost::any(*modifiedTimeGMT);
    }
    if (modifier) {
      res["Modifier"] = boost::any(*modifier);
    }
    if (modifyUser) {
      res["ModifyUser"] = modifyUser ? boost::any(modifyUser->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (originator) {
      res["Originator"] = originator ? boost::any(originator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTimeGMT") != m.end() && !m["CreateTimeGMT"].empty()) {
      createTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateTimeGMT"]));
    }
    if (m.find("CreatorUserId") != m.end() && !m["CreatorUserId"].empty()) {
      creatorUserId = make_shared<string>(boost::any_cast<string>(m["CreatorUserId"]));
    }
    if (m.find("FormData") != m.end() && !m["FormData"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["FormData"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      formData = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("FormInstanceId") != m.end() && !m["FormInstanceId"].empty()) {
      formInstanceId = make_shared<string>(boost::any_cast<string>(m["FormInstanceId"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceValue") != m.end() && !m["InstanceValue"].empty()) {
      instanceValue = make_shared<string>(boost::any_cast<string>(m["InstanceValue"]));
    }
    if (m.find("ModifiedTimeGMT") != m.end() && !m["ModifiedTimeGMT"].empty()) {
      modifiedTimeGMT = make_shared<string>(boost::any_cast<string>(m["ModifiedTimeGMT"]));
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["Modifier"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModifyUser"].type()) {
        SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUser model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModifyUser"]));
        modifyUser = make_shared<SearchFormDataSecondGenerationNoTableFieldResponseBodyDataModifyUser>(model1);
      }
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      if (typeid(map<string, boost::any>) == m["Originator"].type()) {
        SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Originator"]));
        originator = make_shared<SearchFormDataSecondGenerationNoTableFieldResponseBodyDataOriginator>(model1);
      }
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~SearchFormDataSecondGenerationNoTableFieldResponseBodyData() = default;
};
class SearchFormDataSecondGenerationNoTableFieldResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<SearchFormDataSecondGenerationNoTableFieldResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  SearchFormDataSecondGenerationNoTableFieldResponseBody() {}

  explicit SearchFormDataSecondGenerationNoTableFieldResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<SearchFormDataSecondGenerationNoTableFieldResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchFormDataSecondGenerationNoTableFieldResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<SearchFormDataSecondGenerationNoTableFieldResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~SearchFormDataSecondGenerationNoTableFieldResponseBody() = default;
};
class SearchFormDataSecondGenerationNoTableFieldResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchFormDataSecondGenerationNoTableFieldResponseBody> body{};

  SearchFormDataSecondGenerationNoTableFieldResponse() {}

  explicit SearchFormDataSecondGenerationNoTableFieldResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchFormDataSecondGenerationNoTableFieldResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchFormDataSecondGenerationNoTableFieldResponseBody>(model1);
      }
    }
  }


  virtual ~SearchFormDataSecondGenerationNoTableFieldResponse() = default;
};
class SearchFormDatasHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SearchFormDatasHeadersAccountContext() {}

  explicit SearchFormDatasHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SearchFormDatasHeadersAccountContext() = default;
};
class SearchFormDatasHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SearchFormDatasHeadersAccountContext> accountContext{};

  SearchFormDatasHeaders() {}

  explicit SearchFormDatasHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SearchFormDatasHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SearchFormDatasHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SearchFormDatasHeaders() = default;
};
class SearchFormDatasShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SearchFormDatasShrinkHeaders() {}

  explicit SearchFormDatasShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SearchFormDatasShrinkHeaders() = default;
};
class SearchFormDatasRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> createFromTimeGMT{};
  shared_ptr<string> createToTimeGMT{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> dynamicOrder{};
  shared_ptr<string> formUuid{};
  shared_ptr<string> language{};
  shared_ptr<string> modifiedFromTimeGMT{};
  shared_ptr<string> modifiedToTimeGMT{};
  shared_ptr<string> originatorId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchFieldJson{};
  shared_ptr<string> systemToken{};

  SearchFormDatasRequest() {}

  explicit SearchFormDatasRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (createFromTimeGMT) {
      res["CreateFromTimeGMT"] = boost::any(*createFromTimeGMT);
    }
    if (createToTimeGMT) {
      res["CreateToTimeGMT"] = boost::any(*createToTimeGMT);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (dynamicOrder) {
      res["DynamicOrder"] = boost::any(*dynamicOrder);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (modifiedFromTimeGMT) {
      res["ModifiedFromTimeGMT"] = boost::any(*modifiedFromTimeGMT);
    }
    if (modifiedToTimeGMT) {
      res["ModifiedToTimeGMT"] = boost::any(*modifiedToTimeGMT);
    }
    if (originatorId) {
      res["OriginatorId"] = boost::any(*originatorId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchFieldJson) {
      res["SearchFieldJson"] = boost::any(*searchFieldJson);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("CreateFromTimeGMT") != m.end() && !m["CreateFromTimeGMT"].empty()) {
      createFromTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateFromTimeGMT"]));
    }
    if (m.find("CreateToTimeGMT") != m.end() && !m["CreateToTimeGMT"].empty()) {
      createToTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreateToTimeGMT"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DynamicOrder") != m.end() && !m["DynamicOrder"].empty()) {
      dynamicOrder = make_shared<string>(boost::any_cast<string>(m["DynamicOrder"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("ModifiedFromTimeGMT") != m.end() && !m["ModifiedFromTimeGMT"].empty()) {
      modifiedFromTimeGMT = make_shared<string>(boost::any_cast<string>(m["ModifiedFromTimeGMT"]));
    }
    if (m.find("ModifiedToTimeGMT") != m.end() && !m["ModifiedToTimeGMT"].empty()) {
      modifiedToTimeGMT = make_shared<string>(boost::any_cast<string>(m["ModifiedToTimeGMT"]));
    }
    if (m.find("OriginatorId") != m.end() && !m["OriginatorId"].empty()) {
      originatorId = make_shared<string>(boost::any_cast<string>(m["OriginatorId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchFieldJson") != m.end() && !m["SearchFieldJson"].empty()) {
      searchFieldJson = make_shared<string>(boost::any_cast<string>(m["SearchFieldJson"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~SearchFormDatasRequest() = default;
};
class SearchFormDatasResponseBodyDataModifyUserUserName : public Darabonba::Model {
public:
  shared_ptr<string> nameInChinese{};
  shared_ptr<string> nameInEnglish{};
  shared_ptr<string> type{};

  SearchFormDatasResponseBodyDataModifyUserUserName() {}

  explicit SearchFormDatasResponseBodyDataModifyUserUserName(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameInChinese) {
      res["NameInChinese"] = boost::any(*nameInChinese);
    }
    if (nameInEnglish) {
      res["NameInEnglish"] = boost::any(*nameInEnglish);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameInChinese") != m.end() && !m["NameInChinese"].empty()) {
      nameInChinese = make_shared<string>(boost::any_cast<string>(m["NameInChinese"]));
    }
    if (m.find("NameInEnglish") != m.end() && !m["NameInEnglish"].empty()) {
      nameInEnglish = make_shared<string>(boost::any_cast<string>(m["NameInEnglish"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SearchFormDatasResponseBodyDataModifyUserUserName() = default;
};
class SearchFormDatasResponseBodyDataModifyUser : public Darabonba::Model {
public:
  shared_ptr<string> userId{};
  shared_ptr<SearchFormDatasResponseBodyDataModifyUserUserName> userName{};

  SearchFormDatasResponseBodyDataModifyUser() {}

  explicit SearchFormDatasResponseBodyDataModifyUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userName) {
      res["UserName"] = userName ? boost::any(userName->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserName"].type()) {
        SearchFormDatasResponseBodyDataModifyUserUserName model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserName"]));
        userName = make_shared<SearchFormDatasResponseBodyDataModifyUserUserName>(model1);
      }
    }
  }


  virtual ~SearchFormDatasResponseBodyDataModifyUser() = default;
};
class SearchFormDatasResponseBodyDataOriginatorUserName : public Darabonba::Model {
public:
  shared_ptr<string> nameInChinese{};
  shared_ptr<string> nameInEnglish{};
  shared_ptr<string> type{};

  SearchFormDatasResponseBodyDataOriginatorUserName() {}

  explicit SearchFormDatasResponseBodyDataOriginatorUserName(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameInChinese) {
      res["NameInChinese"] = boost::any(*nameInChinese);
    }
    if (nameInEnglish) {
      res["NameInEnglish"] = boost::any(*nameInEnglish);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameInChinese") != m.end() && !m["NameInChinese"].empty()) {
      nameInChinese = make_shared<string>(boost::any_cast<string>(m["NameInChinese"]));
    }
    if (m.find("NameInEnglish") != m.end() && !m["NameInEnglish"].empty()) {
      nameInEnglish = make_shared<string>(boost::any_cast<string>(m["NameInEnglish"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SearchFormDatasResponseBodyDataOriginatorUserName() = default;
};
class SearchFormDatasResponseBodyDataOriginator : public Darabonba::Model {
public:
  shared_ptr<string> userId{};
  shared_ptr<SearchFormDatasResponseBodyDataOriginatorUserName> userName{};

  SearchFormDatasResponseBodyDataOriginator() {}

  explicit SearchFormDatasResponseBodyDataOriginator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userName) {
      res["UserName"] = userName ? boost::any(userName->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserName"].type()) {
        SearchFormDatasResponseBodyDataOriginatorUserName model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserName"]));
        userName = make_shared<SearchFormDatasResponseBodyDataOriginatorUserName>(model1);
      }
    }
  }


  virtual ~SearchFormDatasResponseBodyDataOriginator() = default;
};
class SearchFormDatasResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> createdTimeGMT{};
  shared_ptr<string> creatorUserId{};
  shared_ptr<long> dataId{};
  shared_ptr<map<string, boost::any>> formData{};
  shared_ptr<string> formInstanceId{};
  shared_ptr<string> formUuid{};
  shared_ptr<string> instanceValue{};
  shared_ptr<string> modelUuid{};
  shared_ptr<string> modifiedTimeGMT{};
  shared_ptr<string> modifierUserId{};
  shared_ptr<SearchFormDatasResponseBodyDataModifyUser> modifyUser{};
  shared_ptr<SearchFormDatasResponseBodyDataOriginator> originator{};
  shared_ptr<string> sequence{};
  shared_ptr<string> serialNo{};
  shared_ptr<string> title{};
  shared_ptr<long> version{};

  SearchFormDatasResponseBodyData() {}

  explicit SearchFormDatasResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTimeGMT) {
      res["CreatedTimeGMT"] = boost::any(*createdTimeGMT);
    }
    if (creatorUserId) {
      res["CreatorUserId"] = boost::any(*creatorUserId);
    }
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (formData) {
      res["FormData"] = boost::any(*formData);
    }
    if (formInstanceId) {
      res["FormInstanceId"] = boost::any(*formInstanceId);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (instanceValue) {
      res["InstanceValue"] = boost::any(*instanceValue);
    }
    if (modelUuid) {
      res["ModelUuid"] = boost::any(*modelUuid);
    }
    if (modifiedTimeGMT) {
      res["ModifiedTimeGMT"] = boost::any(*modifiedTimeGMT);
    }
    if (modifierUserId) {
      res["ModifierUserId"] = boost::any(*modifierUserId);
    }
    if (modifyUser) {
      res["ModifyUser"] = modifyUser ? boost::any(modifyUser->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (originator) {
      res["Originator"] = originator ? boost::any(originator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (serialNo) {
      res["SerialNo"] = boost::any(*serialNo);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTimeGMT") != m.end() && !m["CreatedTimeGMT"].empty()) {
      createdTimeGMT = make_shared<string>(boost::any_cast<string>(m["CreatedTimeGMT"]));
    }
    if (m.find("CreatorUserId") != m.end() && !m["CreatorUserId"].empty()) {
      creatorUserId = make_shared<string>(boost::any_cast<string>(m["CreatorUserId"]));
    }
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<long>(boost::any_cast<long>(m["DataId"]));
    }
    if (m.find("FormData") != m.end() && !m["FormData"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["FormData"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      formData = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("FormInstanceId") != m.end() && !m["FormInstanceId"].empty()) {
      formInstanceId = make_shared<string>(boost::any_cast<string>(m["FormInstanceId"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("InstanceValue") != m.end() && !m["InstanceValue"].empty()) {
      instanceValue = make_shared<string>(boost::any_cast<string>(m["InstanceValue"]));
    }
    if (m.find("ModelUuid") != m.end() && !m["ModelUuid"].empty()) {
      modelUuid = make_shared<string>(boost::any_cast<string>(m["ModelUuid"]));
    }
    if (m.find("ModifiedTimeGMT") != m.end() && !m["ModifiedTimeGMT"].empty()) {
      modifiedTimeGMT = make_shared<string>(boost::any_cast<string>(m["ModifiedTimeGMT"]));
    }
    if (m.find("ModifierUserId") != m.end() && !m["ModifierUserId"].empty()) {
      modifierUserId = make_shared<string>(boost::any_cast<string>(m["ModifierUserId"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModifyUser"].type()) {
        SearchFormDatasResponseBodyDataModifyUser model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModifyUser"]));
        modifyUser = make_shared<SearchFormDatasResponseBodyDataModifyUser>(model1);
      }
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      if (typeid(map<string, boost::any>) == m["Originator"].type()) {
        SearchFormDatasResponseBodyDataOriginator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Originator"]));
        originator = make_shared<SearchFormDatasResponseBodyDataOriginator>(model1);
      }
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<string>(boost::any_cast<string>(m["Sequence"]));
    }
    if (m.find("SerialNo") != m.end() && !m["SerialNo"].empty()) {
      serialNo = make_shared<string>(boost::any_cast<string>(m["SerialNo"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~SearchFormDatasResponseBodyData() = default;
};
class SearchFormDatasResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<SearchFormDatasResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  SearchFormDatasResponseBody() {}

  explicit SearchFormDatasResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["currentPage"] = boost::any(*currentPage);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("currentPage") != m.end() && !m["currentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["currentPage"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<SearchFormDatasResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchFormDatasResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<SearchFormDatasResponseBodyData>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~SearchFormDatasResponseBody() = default;
};
class SearchFormDatasResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchFormDatasResponseBody> body{};

  SearchFormDatasResponse() {}

  explicit SearchFormDatasResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchFormDatasResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchFormDatasResponseBody>(model1);
      }
    }
  }


  virtual ~SearchFormDatasResponse() = default;
};
class SearchInnerGroupsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SearchInnerGroupsHeadersAccountContext() {}

  explicit SearchInnerGroupsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SearchInnerGroupsHeadersAccountContext() = default;
};
class SearchInnerGroupsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SearchInnerGroupsHeadersAccountContext> accountContext{};

  SearchInnerGroupsHeaders() {}

  explicit SearchInnerGroupsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SearchInnerGroupsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SearchInnerGroupsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SearchInnerGroupsHeaders() = default;
};
class SearchInnerGroupsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SearchInnerGroupsShrinkHeaders() {}

  explicit SearchInnerGroupsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SearchInnerGroupsShrinkHeaders() = default;
};
class SearchInnerGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> searchKey{};

  SearchInnerGroupsRequest() {}

  explicit SearchInnerGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
  }


  virtual ~SearchInnerGroupsRequest() = default;
};
class SearchInnerGroupsResponseBodyGroupInfos : public Darabonba::Model {
public:
  shared_ptr<string> icon{};
  shared_ptr<string> memberAmount{};
  shared_ptr<string> openConversationId{};
  shared_ptr<string> title{};

  SearchInnerGroupsResponseBodyGroupInfos() {}

  explicit SearchInnerGroupsResponseBodyGroupInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (memberAmount) {
      res["MemberAmount"] = boost::any(*memberAmount);
    }
    if (openConversationId) {
      res["OpenConversationId"] = boost::any(*openConversationId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("MemberAmount") != m.end() && !m["MemberAmount"].empty()) {
      memberAmount = make_shared<string>(boost::any_cast<string>(m["MemberAmount"]));
    }
    if (m.find("OpenConversationId") != m.end() && !m["OpenConversationId"].empty()) {
      openConversationId = make_shared<string>(boost::any_cast<string>(m["OpenConversationId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~SearchInnerGroupsResponseBodyGroupInfos() = default;
};
class SearchInnerGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<SearchInnerGroupsResponseBodyGroupInfos>> groupInfos{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  SearchInnerGroupsResponseBody() {}

  explicit SearchInnerGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupInfos) {
      vector<boost::any> temp1;
      for(auto item1:*groupInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["groupInfos"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("groupInfos") != m.end() && !m["groupInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["groupInfos"].type()) {
        vector<SearchInnerGroupsResponseBodyGroupInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["groupInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchInnerGroupsResponseBodyGroupInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupInfos = make_shared<vector<SearchInnerGroupsResponseBodyGroupInfos>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~SearchInnerGroupsResponseBody() = default;
};
class SearchInnerGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchInnerGroupsResponseBody> body{};

  SearchInnerGroupsResponse() {}

  explicit SearchInnerGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchInnerGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchInnerGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~SearchInnerGroupsResponse() = default;
};
class SendBannerHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SendBannerHeadersAccountContext() {}

  explicit SendBannerHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SendBannerHeadersAccountContext() = default;
};
class SendBannerHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SendBannerHeadersAccountContext> accountContext{};

  SendBannerHeaders() {}

  explicit SendBannerHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SendBannerHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SendBannerHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SendBannerHeaders() = default;
};
class SendBannerShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SendBannerShrinkHeaders() {}

  explicit SendBannerShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SendBannerShrinkHeaders() = default;
};
class SendBannerRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  SendBannerRequestTenantContext() {}

  explicit SendBannerRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~SendBannerRequestTenantContext() = default;
};
class SendBannerRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<SendBannerRequestTenantContext> tenantContext{};

  SendBannerRequest() {}

  explicit SendBannerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        SendBannerRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<SendBannerRequestTenantContext>(model1);
      }
    }
  }


  virtual ~SendBannerRequest() = default;
};
class SendBannerShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> contentShrink{};
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<string> tenantContextShrink{};

  SendBannerShrinkRequest() {}

  explicit SendBannerShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentShrink) {
      res["Content"] = boost::any(*contentShrink);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      contentShrink = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~SendBannerShrinkRequest() = default;
};
class SendBannerResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<boost::any>> arguments{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  SendBannerResponseBody() {}

  explicit SendBannerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arguments) {
      res["arguments"] = boost::any(*arguments);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arguments") != m.end() && !m["arguments"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["arguments"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["arguments"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      arguments = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~SendBannerResponseBody() = default;
};
class SendBannerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendBannerResponseBody> body{};

  SendBannerResponse() {}

  explicit SendBannerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendBannerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendBannerResponseBody>(model1);
      }
    }
  }


  virtual ~SendBannerResponse() = default;
};
class SendPopupHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SendPopupHeadersAccountContext() {}

  explicit SendPopupHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SendPopupHeadersAccountContext() = default;
};
class SendPopupHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SendPopupHeadersAccountContext> accountContext{};

  SendPopupHeaders() {}

  explicit SendPopupHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SendPopupHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SendPopupHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SendPopupHeaders() = default;
};
class SendPopupShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SendPopupShrinkHeaders() {}

  explicit SendPopupShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SendPopupShrinkHeaders() = default;
};
class SendPopupRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  SendPopupRequestTenantContext() {}

  explicit SendPopupRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~SendPopupRequestTenantContext() = default;
};
class SendPopupRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<SendPopupRequestTenantContext> tenantContext{};

  SendPopupRequest() {}

  explicit SendPopupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        SendPopupRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<SendPopupRequestTenantContext>(model1);
      }
    }
  }


  virtual ~SendPopupRequest() = default;
};
class SendPopupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> contentShrink{};
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<string> tenantContextShrink{};

  SendPopupShrinkRequest() {}

  explicit SendPopupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentShrink) {
      res["Content"] = boost::any(*contentShrink);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      contentShrink = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~SendPopupShrinkRequest() = default;
};
class SendPopupResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<boost::any>> arguments{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  SendPopupResponseBody() {}

  explicit SendPopupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arguments) {
      res["arguments"] = boost::any(*arguments);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arguments") != m.end() && !m["arguments"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["arguments"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["arguments"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      arguments = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~SendPopupResponseBody() = default;
};
class SendPopupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendPopupResponseBody> body{};

  SendPopupResponse() {}

  explicit SendPopupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendPopupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendPopupResponseBody>(model1);
      }
    }
  }


  virtual ~SendPopupResponse() = default;
};
class SendSearchShadeHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SendSearchShadeHeadersAccountContext() {}

  explicit SendSearchShadeHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SendSearchShadeHeadersAccountContext() = default;
};
class SendSearchShadeHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SendSearchShadeHeadersAccountContext> accountContext{};

  SendSearchShadeHeaders() {}

  explicit SendSearchShadeHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SendSearchShadeHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SendSearchShadeHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SendSearchShadeHeaders() = default;
};
class SendSearchShadeShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SendSearchShadeShrinkHeaders() {}

  explicit SendSearchShadeShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SendSearchShadeShrinkHeaders() = default;
};
class SendSearchShadeRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  SendSearchShadeRequestTenantContext() {}

  explicit SendSearchShadeRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~SendSearchShadeRequestTenantContext() = default;
};
class SendSearchShadeRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<SendSearchShadeRequestTenantContext> tenantContext{};

  SendSearchShadeRequest() {}

  explicit SendSearchShadeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        SendSearchShadeRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<SendSearchShadeRequestTenantContext>(model1);
      }
    }
  }


  virtual ~SendSearchShadeRequest() = default;
};
class SendSearchShadeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> contentShrink{};
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<string> tenantContextShrink{};

  SendSearchShadeShrinkRequest() {}

  explicit SendSearchShadeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentShrink) {
      res["Content"] = boost::any(*contentShrink);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      contentShrink = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~SendSearchShadeShrinkRequest() = default;
};
class SendSearchShadeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<boost::any>> arguments{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  SendSearchShadeResponseBody() {}

  explicit SendSearchShadeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arguments) {
      res["arguments"] = boost::any(*arguments);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("arguments") != m.end() && !m["arguments"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["arguments"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["arguments"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      arguments = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~SendSearchShadeResponseBody() = default;
};
class SendSearchShadeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendSearchShadeResponseBody> body{};

  SendSearchShadeResponse() {}

  explicit SendSearchShadeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendSearchShadeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendSearchShadeResponseBody>(model1);
      }
    }
  }


  virtual ~SendSearchShadeResponse() = default;
};
class SetColumnsVisibilityHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SetColumnsVisibilityHeadersAccountContext() {}

  explicit SetColumnsVisibilityHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SetColumnsVisibilityHeadersAccountContext() = default;
};
class SetColumnsVisibilityHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SetColumnsVisibilityHeadersAccountContext> accountContext{};

  SetColumnsVisibilityHeaders() {}

  explicit SetColumnsVisibilityHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SetColumnsVisibilityHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SetColumnsVisibilityHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SetColumnsVisibilityHeaders() = default;
};
class SetColumnsVisibilityShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SetColumnsVisibilityShrinkHeaders() {}

  explicit SetColumnsVisibilityShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SetColumnsVisibilityShrinkHeaders() = default;
};
class SetColumnsVisibilityRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  SetColumnsVisibilityRequestTenantContext() {}

  explicit SetColumnsVisibilityRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~SetColumnsVisibilityRequestTenantContext() = default;
};
class SetColumnsVisibilityRequest : public Darabonba::Model {
public:
  shared_ptr<long> column{};
  shared_ptr<long> columnCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<SetColumnsVisibilityRequestTenantContext> tenantContext{};
  shared_ptr<string> visibility{};
  shared_ptr<string> workbookId{};

  SetColumnsVisibilityRequest() {}

  explicit SetColumnsVisibilityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (column) {
      res["Column"] = boost::any(*column);
    }
    if (columnCount) {
      res["ColumnCount"] = boost::any(*columnCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Column") != m.end() && !m["Column"].empty()) {
      column = make_shared<long>(boost::any_cast<long>(m["Column"]));
    }
    if (m.find("ColumnCount") != m.end() && !m["ColumnCount"].empty()) {
      columnCount = make_shared<long>(boost::any_cast<long>(m["ColumnCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        SetColumnsVisibilityRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<SetColumnsVisibilityRequestTenantContext>(model1);
      }
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~SetColumnsVisibilityRequest() = default;
};
class SetColumnsVisibilityShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> column{};
  shared_ptr<long> columnCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> visibility{};
  shared_ptr<string> workbookId{};

  SetColumnsVisibilityShrinkRequest() {}

  explicit SetColumnsVisibilityShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (column) {
      res["Column"] = boost::any(*column);
    }
    if (columnCount) {
      res["ColumnCount"] = boost::any(*columnCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Column") != m.end() && !m["Column"].empty()) {
      column = make_shared<long>(boost::any_cast<long>(m["Column"]));
    }
    if (m.find("ColumnCount") != m.end() && !m["ColumnCount"].empty()) {
      columnCount = make_shared<long>(boost::any_cast<long>(m["ColumnCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~SetColumnsVisibilityShrinkRequest() = default;
};
class SetColumnsVisibilityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  SetColumnsVisibilityResponseBody() {}

  explicit SetColumnsVisibilityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~SetColumnsVisibilityResponseBody() = default;
};
class SetColumnsVisibilityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetColumnsVisibilityResponseBody> body{};

  SetColumnsVisibilityResponse() {}

  explicit SetColumnsVisibilityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetColumnsVisibilityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetColumnsVisibilityResponseBody>(model1);
      }
    }
  }


  virtual ~SetColumnsVisibilityResponse() = default;
};
class SetConferenceHostsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SetConferenceHostsHeadersAccountContext() {}

  explicit SetConferenceHostsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SetConferenceHostsHeadersAccountContext() = default;
};
class SetConferenceHostsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SetConferenceHostsHeadersAccountContext> accountContext{};

  SetConferenceHostsHeaders() {}

  explicit SetConferenceHostsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SetConferenceHostsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SetConferenceHostsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SetConferenceHostsHeaders() = default;
};
class SetConferenceHostsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SetConferenceHostsShrinkHeaders() {}

  explicit SetConferenceHostsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SetConferenceHostsShrinkHeaders() = default;
};
class SetConferenceHostsRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  SetConferenceHostsRequestTenantContext() {}

  explicit SetConferenceHostsRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~SetConferenceHostsRequestTenantContext() = default;
};
class SetConferenceHostsRequest : public Darabonba::Model {
public:
  shared_ptr<string> operationType{};
  shared_ptr<SetConferenceHostsRequestTenantContext> tenantContext{};
  shared_ptr<vector<string>> userIds{};
  shared_ptr<string> conferenceId{};

  SetConferenceHostsRequest() {}

  explicit SetConferenceHostsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<string>(boost::any_cast<string>(m["OperationType"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        SetConferenceHostsRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<SetConferenceHostsRequestTenantContext>(model1);
      }
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~SetConferenceHostsRequest() = default;
};
class SetConferenceHostsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> operationType{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> userIdsShrink{};
  shared_ptr<string> conferenceId{};

  SetConferenceHostsShrinkRequest() {}

  explicit SetConferenceHostsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (userIdsShrink) {
      res["UserIds"] = boost::any(*userIdsShrink);
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<string>(boost::any_cast<string>(m["OperationType"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      userIdsShrink = make_shared<string>(boost::any_cast<string>(m["UserIds"]));
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~SetConferenceHostsShrinkRequest() = default;
};
class SetConferenceHostsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  SetConferenceHostsResponseBody() {}

  explicit SetConferenceHostsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~SetConferenceHostsResponseBody() = default;
};
class SetConferenceHostsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetConferenceHostsResponseBody> body{};

  SetConferenceHostsResponse() {}

  explicit SetConferenceHostsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetConferenceHostsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetConferenceHostsResponseBody>(model1);
      }
    }
  }


  virtual ~SetConferenceHostsResponse() = default;
};
class SetRowsVisibilityHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SetRowsVisibilityHeadersAccountContext() {}

  explicit SetRowsVisibilityHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SetRowsVisibilityHeadersAccountContext() = default;
};
class SetRowsVisibilityHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SetRowsVisibilityHeadersAccountContext> accountContext{};

  SetRowsVisibilityHeaders() {}

  explicit SetRowsVisibilityHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SetRowsVisibilityHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SetRowsVisibilityHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SetRowsVisibilityHeaders() = default;
};
class SetRowsVisibilityShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SetRowsVisibilityShrinkHeaders() {}

  explicit SetRowsVisibilityShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SetRowsVisibilityShrinkHeaders() = default;
};
class SetRowsVisibilityRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  SetRowsVisibilityRequestTenantContext() {}

  explicit SetRowsVisibilityRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~SetRowsVisibilityRequestTenantContext() = default;
};
class SetRowsVisibilityRequest : public Darabonba::Model {
public:
  shared_ptr<long> row{};
  shared_ptr<long> rowCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<SetRowsVisibilityRequestTenantContext> tenantContext{};
  shared_ptr<string> visibility{};
  shared_ptr<string> workbookId{};

  SetRowsVisibilityRequest() {}

  explicit SetRowsVisibilityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (row) {
      res["Row"] = boost::any(*row);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Row") != m.end() && !m["Row"].empty()) {
      row = make_shared<long>(boost::any_cast<long>(m["Row"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["RowCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        SetRowsVisibilityRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<SetRowsVisibilityRequestTenantContext>(model1);
      }
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~SetRowsVisibilityRequest() = default;
};
class SetRowsVisibilityShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> row{};
  shared_ptr<long> rowCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> visibility{};
  shared_ptr<string> workbookId{};

  SetRowsVisibilityShrinkRequest() {}

  explicit SetRowsVisibilityShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (row) {
      res["Row"] = boost::any(*row);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Row") != m.end() && !m["Row"].empty()) {
      row = make_shared<long>(boost::any_cast<long>(m["Row"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["RowCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~SetRowsVisibilityShrinkRequest() = default;
};
class SetRowsVisibilityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  SetRowsVisibilityResponseBody() {}

  explicit SetRowsVisibilityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~SetRowsVisibilityResponseBody() = default;
};
class SetRowsVisibilityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetRowsVisibilityResponseBody> body{};

  SetRowsVisibilityResponse() {}

  explicit SetRowsVisibilityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetRowsVisibilityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetRowsVisibilityResponseBody>(model1);
      }
    }
  }


  virtual ~SetRowsVisibilityResponse() = default;
};
class SimpleListReportHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SimpleListReportHeadersAccountContext() {}

  explicit SimpleListReportHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SimpleListReportHeadersAccountContext() = default;
};
class SimpleListReportHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SimpleListReportHeadersAccountContext> accountContext{};

  SimpleListReportHeaders() {}

  explicit SimpleListReportHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SimpleListReportHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SimpleListReportHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SimpleListReportHeaders() = default;
};
class SimpleListReportShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SimpleListReportShrinkHeaders() {}

  explicit SimpleListReportShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SimpleListReportShrinkHeaders() = default;
};
class SimpleListReportRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  SimpleListReportRequestTenantContext() {}

  explicit SimpleListReportRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~SimpleListReportRequestTenantContext() = default;
};
class SimpleListReportRequest : public Darabonba::Model {
public:
  shared_ptr<long> cursor{};
  shared_ptr<long> endTime{};
  shared_ptr<long> size{};
  shared_ptr<long> startTime{};
  shared_ptr<string> templateName{};
  shared_ptr<SimpleListReportRequestTenantContext> tenantContext{};

  SimpleListReportRequest() {}

  explicit SimpleListReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cursor) {
      res["Cursor"] = boost::any(*cursor);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cursor") != m.end() && !m["Cursor"].empty()) {
      cursor = make_shared<long>(boost::any_cast<long>(m["Cursor"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        SimpleListReportRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<SimpleListReportRequestTenantContext>(model1);
      }
    }
  }


  virtual ~SimpleListReportRequest() = default;
};
class SimpleListReportShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> cursor{};
  shared_ptr<long> endTime{};
  shared_ptr<long> size{};
  shared_ptr<long> startTime{};
  shared_ptr<string> templateName{};
  shared_ptr<string> tenantContextShrink{};

  SimpleListReportShrinkRequest() {}

  explicit SimpleListReportShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cursor) {
      res["Cursor"] = boost::any(*cursor);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cursor") != m.end() && !m["Cursor"].empty()) {
      cursor = make_shared<long>(boost::any_cast<long>(m["Cursor"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~SimpleListReportShrinkRequest() = default;
};
class SimpleListReportResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> creatorName{};
  shared_ptr<string> deptName{};
  shared_ptr<string> remark{};
  shared_ptr<string> reportId{};
  shared_ptr<string> templateName{};

  SimpleListReportResponseBodyDataList() {}

  explicit SimpleListReportResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (deptName) {
      res["DeptName"] = boost::any(*deptName);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("DeptName") != m.end() && !m["DeptName"].empty()) {
      deptName = make_shared<string>(boost::any_cast<string>(m["DeptName"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~SimpleListReportResponseBodyDataList() = default;
};
class SimpleListReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<SimpleListReportResponseBodyDataList>> dataList{};
  shared_ptr<bool> hasMore{};
  shared_ptr<long> nextCursor{};
  shared_ptr<string> requestId{};
  shared_ptr<long> size{};

  SimpleListReportResponseBody() {}

  explicit SimpleListReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataList) {
      vector<boost::any> temp1;
      for(auto item1:*dataList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dataList"] = boost::any(temp1);
    }
    if (hasMore) {
      res["hasMore"] = boost::any(*hasMore);
    }
    if (nextCursor) {
      res["nextCursor"] = boost::any(*nextCursor);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dataList") != m.end() && !m["dataList"].empty()) {
      if (typeid(vector<boost::any>) == m["dataList"].type()) {
        vector<SimpleListReportResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dataList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SimpleListReportResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataList = make_shared<vector<SimpleListReportResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("hasMore") != m.end() && !m["hasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["hasMore"]));
    }
    if (m.find("nextCursor") != m.end() && !m["nextCursor"].empty()) {
      nextCursor = make_shared<long>(boost::any_cast<long>(m["nextCursor"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
  }


  virtual ~SimpleListReportResponseBody() = default;
};
class SimpleListReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SimpleListReportResponseBody> body{};

  SimpleListReportResponse() {}

  explicit SimpleListReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SimpleListReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SimpleListReportResponseBody>(model1);
      }
    }
  }


  virtual ~SimpleListReportResponse() = default;
};
class StartCloudRecordHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  StartCloudRecordHeadersAccountContext() {}

  explicit StartCloudRecordHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~StartCloudRecordHeadersAccountContext() = default;
};
class StartCloudRecordHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<StartCloudRecordHeadersAccountContext> accountContext{};

  StartCloudRecordHeaders() {}

  explicit StartCloudRecordHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        StartCloudRecordHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<StartCloudRecordHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~StartCloudRecordHeaders() = default;
};
class StartCloudRecordShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  StartCloudRecordShrinkHeaders() {}

  explicit StartCloudRecordShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~StartCloudRecordShrinkHeaders() = default;
};
class StartCloudRecordRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  StartCloudRecordRequestTenantContext() {}

  explicit StartCloudRecordRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~StartCloudRecordRequestTenantContext() = default;
};
class StartCloudRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> mode{};
  shared_ptr<string> smallWindowPosition{};
  shared_ptr<StartCloudRecordRequestTenantContext> tenantContext{};
  shared_ptr<string> conferenceId{};

  StartCloudRecordRequest() {}

  explicit StartCloudRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (smallWindowPosition) {
      res["SmallWindowPosition"] = boost::any(*smallWindowPosition);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("SmallWindowPosition") != m.end() && !m["SmallWindowPosition"].empty()) {
      smallWindowPosition = make_shared<string>(boost::any_cast<string>(m["SmallWindowPosition"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        StartCloudRecordRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<StartCloudRecordRequestTenantContext>(model1);
      }
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~StartCloudRecordRequest() = default;
};
class StartCloudRecordShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> mode{};
  shared_ptr<string> smallWindowPosition{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> conferenceId{};

  StartCloudRecordShrinkRequest() {}

  explicit StartCloudRecordShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (smallWindowPosition) {
      res["SmallWindowPosition"] = boost::any(*smallWindowPosition);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("SmallWindowPosition") != m.end() && !m["SmallWindowPosition"].empty()) {
      smallWindowPosition = make_shared<string>(boost::any_cast<string>(m["SmallWindowPosition"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~StartCloudRecordShrinkRequest() = default;
};
class StartCloudRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> requestId{};

  StartCloudRecordResponseBody() {}

  explicit StartCloudRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~StartCloudRecordResponseBody() = default;
};
class StartCloudRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartCloudRecordResponseBody> body{};

  StartCloudRecordResponse() {}

  explicit StartCloudRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartCloudRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartCloudRecordResponseBody>(model1);
      }
    }
  }


  virtual ~StartCloudRecordResponse() = default;
};
class StartInstanceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  StartInstanceHeadersAccountContext() {}

  explicit StartInstanceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~StartInstanceHeadersAccountContext() = default;
};
class StartInstanceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<StartInstanceHeadersAccountContext> accountContext{};

  StartInstanceHeaders() {}

  explicit StartInstanceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        StartInstanceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<StartInstanceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~StartInstanceHeaders() = default;
};
class StartInstanceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  StartInstanceShrinkHeaders() {}

  explicit StartInstanceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~StartInstanceShrinkHeaders() = default;
};
class StartInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> departmentId{};
  shared_ptr<string> formDataJson{};
  shared_ptr<string> formUuid{};
  shared_ptr<string> language{};
  shared_ptr<string> processCode{};
  shared_ptr<string> processData{};
  shared_ptr<string> systemToken{};

  StartInstanceRequest() {}

  explicit StartInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (departmentId) {
      res["DepartmentId"] = boost::any(*departmentId);
    }
    if (formDataJson) {
      res["FormDataJson"] = boost::any(*formDataJson);
    }
    if (formUuid) {
      res["FormUuid"] = boost::any(*formUuid);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (processCode) {
      res["ProcessCode"] = boost::any(*processCode);
    }
    if (processData) {
      res["ProcessData"] = boost::any(*processData);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("DepartmentId") != m.end() && !m["DepartmentId"].empty()) {
      departmentId = make_shared<string>(boost::any_cast<string>(m["DepartmentId"]));
    }
    if (m.find("FormDataJson") != m.end() && !m["FormDataJson"].empty()) {
      formDataJson = make_shared<string>(boost::any_cast<string>(m["FormDataJson"]));
    }
    if (m.find("FormUuid") != m.end() && !m["FormUuid"].empty()) {
      formUuid = make_shared<string>(boost::any_cast<string>(m["FormUuid"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("ProcessCode") != m.end() && !m["ProcessCode"].empty()) {
      processCode = make_shared<string>(boost::any_cast<string>(m["ProcessCode"]));
    }
    if (m.find("ProcessData") != m.end() && !m["ProcessData"].empty()) {
      processData = make_shared<string>(boost::any_cast<string>(m["ProcessData"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~StartInstanceRequest() = default;
};
class StartInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  StartInstanceResponseBody() {}

  explicit StartInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["result"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~StartInstanceResponseBody() = default;
};
class StartInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartInstanceResponseBody> body{};

  StartInstanceResponse() {}

  explicit StartInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~StartInstanceResponse() = default;
};
class StartMinutesHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  StartMinutesHeadersAccountContext() {}

  explicit StartMinutesHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~StartMinutesHeadersAccountContext() = default;
};
class StartMinutesHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<StartMinutesHeadersAccountContext> accountContext{};

  StartMinutesHeaders() {}

  explicit StartMinutesHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        StartMinutesHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<StartMinutesHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~StartMinutesHeaders() = default;
};
class StartMinutesShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  StartMinutesShrinkHeaders() {}

  explicit StartMinutesShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~StartMinutesShrinkHeaders() = default;
};
class StartMinutesRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  StartMinutesRequestTenantContext() {}

  explicit StartMinutesRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~StartMinutesRequestTenantContext() = default;
};
class StartMinutesRequest : public Darabonba::Model {
public:
  shared_ptr<StartMinutesRequestTenantContext> tenantContext{};
  shared_ptr<string> conferenceId{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<bool> recordAudio{};

  StartMinutesRequest() {}

  explicit StartMinutesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    if (ownerUserId) {
      res["ownerUserId"] = boost::any(*ownerUserId);
    }
    if (recordAudio) {
      res["recordAudio"] = boost::any(*recordAudio);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        StartMinutesRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<StartMinutesRequestTenantContext>(model1);
      }
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
    if (m.find("ownerUserId") != m.end() && !m["ownerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["ownerUserId"]));
    }
    if (m.find("recordAudio") != m.end() && !m["recordAudio"].empty()) {
      recordAudio = make_shared<bool>(boost::any_cast<bool>(m["recordAudio"]));
    }
  }


  virtual ~StartMinutesRequest() = default;
};
class StartMinutesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> conferenceId{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<bool> recordAudio{};

  StartMinutesShrinkRequest() {}

  explicit StartMinutesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    if (ownerUserId) {
      res["ownerUserId"] = boost::any(*ownerUserId);
    }
    if (recordAudio) {
      res["recordAudio"] = boost::any(*recordAudio);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
    if (m.find("ownerUserId") != m.end() && !m["ownerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["ownerUserId"]));
    }
    if (m.find("recordAudio") != m.end() && !m["recordAudio"].empty()) {
      recordAudio = make_shared<bool>(boost::any_cast<bool>(m["recordAudio"]));
    }
  }


  virtual ~StartMinutesShrinkRequest() = default;
};
class StartMinutesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  StartMinutesResponseBody() {}

  explicit StartMinutesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~StartMinutesResponseBody() = default;
};
class StartMinutesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartMinutesResponseBody> body{};

  StartMinutesResponse() {}

  explicit StartMinutesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartMinutesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartMinutesResponseBody>(model1);
      }
    }
  }


  virtual ~StartMinutesResponse() = default;
};
class StatisticsListByTypeReportHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  StatisticsListByTypeReportHeadersAccountContext() {}

  explicit StatisticsListByTypeReportHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~StatisticsListByTypeReportHeadersAccountContext() = default;
};
class StatisticsListByTypeReportHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<StatisticsListByTypeReportHeadersAccountContext> accountContext{};

  StatisticsListByTypeReportHeaders() {}

  explicit StatisticsListByTypeReportHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        StatisticsListByTypeReportHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<StatisticsListByTypeReportHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~StatisticsListByTypeReportHeaders() = default;
};
class StatisticsListByTypeReportShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  StatisticsListByTypeReportShrinkHeaders() {}

  explicit StatisticsListByTypeReportShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~StatisticsListByTypeReportShrinkHeaders() = default;
};
class StatisticsListByTypeReportRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  StatisticsListByTypeReportRequestTenantContext() {}

  explicit StatisticsListByTypeReportRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~StatisticsListByTypeReportRequestTenantContext() = default;
};
class StatisticsListByTypeReportRequest : public Darabonba::Model {
public:
  shared_ptr<long> offset{};
  shared_ptr<string> reportId{};
  shared_ptr<long> size{};
  shared_ptr<StatisticsListByTypeReportRequestTenantContext> tenantContext{};
  shared_ptr<long> type{};

  StatisticsListByTypeReportRequest() {}

  explicit StatisticsListByTypeReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        StatisticsListByTypeReportRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<StatisticsListByTypeReportRequestTenantContext>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~StatisticsListByTypeReportRequest() = default;
};
class StatisticsListByTypeReportShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> offset{};
  shared_ptr<string> reportId{};
  shared_ptr<long> size{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<long> type{};

  StatisticsListByTypeReportShrinkRequest() {}

  explicit StatisticsListByTypeReportShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~StatisticsListByTypeReportShrinkRequest() = default;
};
class StatisticsListByTypeReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> hasMore{};
  shared_ptr<long> nextCursor{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> useridList{};

  StatisticsListByTypeReportResponseBody() {}

  explicit StatisticsListByTypeReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasMore) {
      res["hasMore"] = boost::any(*hasMore);
    }
    if (nextCursor) {
      res["nextCursor"] = boost::any(*nextCursor);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (useridList) {
      res["useridList"] = boost::any(*useridList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hasMore") != m.end() && !m["hasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["hasMore"]));
    }
    if (m.find("nextCursor") != m.end() && !m["nextCursor"].empty()) {
      nextCursor = make_shared<long>(boost::any_cast<long>(m["nextCursor"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("useridList") != m.end() && !m["useridList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["useridList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["useridList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      useridList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~StatisticsListByTypeReportResponseBody() = default;
};
class StatisticsListByTypeReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StatisticsListByTypeReportResponseBody> body{};

  StatisticsListByTypeReportResponse() {}

  explicit StatisticsListByTypeReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StatisticsListByTypeReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StatisticsListByTypeReportResponseBody>(model1);
      }
    }
  }


  virtual ~StatisticsListByTypeReportResponse() = default;
};
class StatisticsReportHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  StatisticsReportHeadersAccountContext() {}

  explicit StatisticsReportHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~StatisticsReportHeadersAccountContext() = default;
};
class StatisticsReportHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<StatisticsReportHeadersAccountContext> accountContext{};

  StatisticsReportHeaders() {}

  explicit StatisticsReportHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        StatisticsReportHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<StatisticsReportHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~StatisticsReportHeaders() = default;
};
class StatisticsReportShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  StatisticsReportShrinkHeaders() {}

  explicit StatisticsReportShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~StatisticsReportShrinkHeaders() = default;
};
class StatisticsReportRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  StatisticsReportRequestTenantContext() {}

  explicit StatisticsReportRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~StatisticsReportRequestTenantContext() = default;
};
class StatisticsReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> reportId{};
  shared_ptr<StatisticsReportRequestTenantContext> tenantContext{};

  StatisticsReportRequest() {}

  explicit StatisticsReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        StatisticsReportRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<StatisticsReportRequestTenantContext>(model1);
      }
    }
  }


  virtual ~StatisticsReportRequest() = default;
};
class StatisticsReportShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> reportId{};
  shared_ptr<string> tenantContextShrink{};

  StatisticsReportShrinkRequest() {}

  explicit StatisticsReportShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~StatisticsReportShrinkRequest() = default;
};
class StatisticsReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> commentNum{};
  shared_ptr<long> commentUserNum{};
  shared_ptr<long> likeNum{};
  shared_ptr<long> readNum{};
  shared_ptr<string> requestId{};

  StatisticsReportResponseBody() {}

  explicit StatisticsReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commentNum) {
      res["commentNum"] = boost::any(*commentNum);
    }
    if (commentUserNum) {
      res["commentUserNum"] = boost::any(*commentUserNum);
    }
    if (likeNum) {
      res["likeNum"] = boost::any(*likeNum);
    }
    if (readNum) {
      res["readNum"] = boost::any(*readNum);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commentNum") != m.end() && !m["commentNum"].empty()) {
      commentNum = make_shared<long>(boost::any_cast<long>(m["commentNum"]));
    }
    if (m.find("commentUserNum") != m.end() && !m["commentUserNum"].empty()) {
      commentUserNum = make_shared<long>(boost::any_cast<long>(m["commentUserNum"]));
    }
    if (m.find("likeNum") != m.end() && !m["likeNum"].empty()) {
      likeNum = make_shared<long>(boost::any_cast<long>(m["likeNum"]));
    }
    if (m.find("readNum") != m.end() && !m["readNum"].empty()) {
      readNum = make_shared<long>(boost::any_cast<long>(m["readNum"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~StatisticsReportResponseBody() = default;
};
class StatisticsReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StatisticsReportResponseBody> body{};

  StatisticsReportResponse() {}

  explicit StatisticsReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StatisticsReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StatisticsReportResponseBody>(model1);
      }
    }
  }


  virtual ~StatisticsReportResponse() = default;
};
class StopCloudRecordHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  StopCloudRecordHeadersAccountContext() {}

  explicit StopCloudRecordHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~StopCloudRecordHeadersAccountContext() = default;
};
class StopCloudRecordHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<StopCloudRecordHeadersAccountContext> accountContext{};

  StopCloudRecordHeaders() {}

  explicit StopCloudRecordHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        StopCloudRecordHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<StopCloudRecordHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~StopCloudRecordHeaders() = default;
};
class StopCloudRecordShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  StopCloudRecordShrinkHeaders() {}

  explicit StopCloudRecordShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~StopCloudRecordShrinkHeaders() = default;
};
class StopCloudRecordRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  StopCloudRecordRequestTenantContext() {}

  explicit StopCloudRecordRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~StopCloudRecordRequestTenantContext() = default;
};
class StopCloudRecordRequest : public Darabonba::Model {
public:
  shared_ptr<StopCloudRecordRequestTenantContext> tenantContext{};
  shared_ptr<string> conferenceId{};

  StopCloudRecordRequest() {}

  explicit StopCloudRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        StopCloudRecordRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<StopCloudRecordRequestTenantContext>(model1);
      }
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~StopCloudRecordRequest() = default;
};
class StopCloudRecordShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> conferenceId{};

  StopCloudRecordShrinkRequest() {}

  explicit StopCloudRecordShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~StopCloudRecordShrinkRequest() = default;
};
class StopCloudRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> requestId{};

  StopCloudRecordResponseBody() {}

  explicit StopCloudRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~StopCloudRecordResponseBody() = default;
};
class StopCloudRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopCloudRecordResponseBody> body{};

  StopCloudRecordResponse() {}

  explicit StopCloudRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopCloudRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopCloudRecordResponseBody>(model1);
      }
    }
  }


  virtual ~StopCloudRecordResponse() = default;
};
class StopMinutesHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  StopMinutesHeadersAccountContext() {}

  explicit StopMinutesHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~StopMinutesHeadersAccountContext() = default;
};
class StopMinutesHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<StopMinutesHeadersAccountContext> accountContext{};

  StopMinutesHeaders() {}

  explicit StopMinutesHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        StopMinutesHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<StopMinutesHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~StopMinutesHeaders() = default;
};
class StopMinutesShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  StopMinutesShrinkHeaders() {}

  explicit StopMinutesShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~StopMinutesShrinkHeaders() = default;
};
class StopMinutesRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  StopMinutesRequestTenantContext() {}

  explicit StopMinutesRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~StopMinutesRequestTenantContext() = default;
};
class StopMinutesRequest : public Darabonba::Model {
public:
  shared_ptr<StopMinutesRequestTenantContext> tenantContext{};
  shared_ptr<string> conferenceId{};

  StopMinutesRequest() {}

  explicit StopMinutesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        StopMinutesRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<StopMinutesRequestTenantContext>(model1);
      }
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~StopMinutesRequest() = default;
};
class StopMinutesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> conferenceId{};

  StopMinutesShrinkRequest() {}

  explicit StopMinutesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~StopMinutesShrinkRequest() = default;
};
class StopMinutesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  StopMinutesResponseBody() {}

  explicit StopMinutesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~StopMinutesResponseBody() = default;
};
class StopMinutesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopMinutesResponseBody> body{};

  StopMinutesResponse() {}

  explicit StopMinutesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopMinutesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopMinutesResponseBody>(model1);
      }
    }
  }


  virtual ~StopMinutesResponse() = default;
};
class SubscribeCalendarHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SubscribeCalendarHeadersAccountContext() {}

  explicit SubscribeCalendarHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SubscribeCalendarHeadersAccountContext() = default;
};
class SubscribeCalendarHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SubscribeCalendarHeadersAccountContext> accountContext{};

  SubscribeCalendarHeaders() {}

  explicit SubscribeCalendarHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SubscribeCalendarHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SubscribeCalendarHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SubscribeCalendarHeaders() = default;
};
class SubscribeCalendarShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SubscribeCalendarShrinkHeaders() {}

  explicit SubscribeCalendarShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SubscribeCalendarShrinkHeaders() = default;
};
class SubscribeCalendarRequest : public Darabonba::Model {
public:
  shared_ptr<string> calendarId{};

  SubscribeCalendarRequest() {}

  explicit SubscribeCalendarRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
  }


  virtual ~SubscribeCalendarRequest() = default;
};
class SubscribeCalendarResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SubscribeCalendarResponseBody() {}

  explicit SubscribeCalendarResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~SubscribeCalendarResponseBody() = default;
};
class SubscribeCalendarResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubscribeCalendarResponseBody> body{};

  SubscribeCalendarResponse() {}

  explicit SubscribeCalendarResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubscribeCalendarResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubscribeCalendarResponseBody>(model1);
      }
    }
  }


  virtual ~SubscribeCalendarResponse() = default;
};
class SubscribeEventHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SubscribeEventHeadersAccountContext() {}

  explicit SubscribeEventHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SubscribeEventHeadersAccountContext() = default;
};
class SubscribeEventHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SubscribeEventHeadersAccountContext> accountContext{};

  SubscribeEventHeaders() {}

  explicit SubscribeEventHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SubscribeEventHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SubscribeEventHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SubscribeEventHeaders() = default;
};
class SubscribeEventShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SubscribeEventShrinkHeaders() {}

  explicit SubscribeEventShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SubscribeEventShrinkHeaders() = default;
};
class SubscribeEventRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  SubscribeEventRequestTenantContext() {}

  explicit SubscribeEventRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~SubscribeEventRequestTenantContext() = default;
};
class SubscribeEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> scope{};
  shared_ptr<string> scopeId{};
  shared_ptr<SubscribeEventRequestTenantContext> tenantContext{};

  SubscribeEventRequest() {}

  explicit SubscribeEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (scopeId) {
      res["ScopeId"] = boost::any(*scopeId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("ScopeId") != m.end() && !m["ScopeId"].empty()) {
      scopeId = make_shared<string>(boost::any_cast<string>(m["ScopeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        SubscribeEventRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<SubscribeEventRequestTenantContext>(model1);
      }
    }
  }


  virtual ~SubscribeEventRequest() = default;
};
class SubscribeEventShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> scope{};
  shared_ptr<string> scopeId{};
  shared_ptr<string> tenantContextShrink{};

  SubscribeEventShrinkRequest() {}

  explicit SubscribeEventShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (scopeId) {
      res["ScopeId"] = boost::any(*scopeId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("ScopeId") != m.end() && !m["ScopeId"].empty()) {
      scopeId = make_shared<string>(boost::any_cast<string>(m["ScopeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~SubscribeEventShrinkRequest() = default;
};
class SubscribeEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  SubscribeEventResponseBody() {}

  explicit SubscribeEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~SubscribeEventResponseBody() = default;
};
class SubscribeEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubscribeEventResponseBody> body{};

  SubscribeEventResponse() {}

  explicit SubscribeEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubscribeEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubscribeEventResponseBody>(model1);
      }
    }
  }


  virtual ~SubscribeEventResponse() = default;
};
class SwitchMainOrgHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SwitchMainOrgHeadersAccountContext() {}

  explicit SwitchMainOrgHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SwitchMainOrgHeadersAccountContext() = default;
};
class SwitchMainOrgHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SwitchMainOrgHeadersAccountContext> accountContext{};

  SwitchMainOrgHeaders() {}

  explicit SwitchMainOrgHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SwitchMainOrgHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SwitchMainOrgHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SwitchMainOrgHeaders() = default;
};
class SwitchMainOrgShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SwitchMainOrgShrinkHeaders() {}

  explicit SwitchMainOrgShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SwitchMainOrgShrinkHeaders() = default;
};
class SwitchMainOrgRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  SwitchMainOrgRequestTenantContext() {}

  explicit SwitchMainOrgRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~SwitchMainOrgRequestTenantContext() = default;
};
class SwitchMainOrgRequest : public Darabonba::Model {
public:
  shared_ptr<long> targetOrgId{};
  shared_ptr<SwitchMainOrgRequestTenantContext> tenantContext{};

  SwitchMainOrgRequest() {}

  explicit SwitchMainOrgRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetOrgId) {
      res["TargetOrgId"] = boost::any(*targetOrgId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetOrgId") != m.end() && !m["TargetOrgId"].empty()) {
      targetOrgId = make_shared<long>(boost::any_cast<long>(m["TargetOrgId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        SwitchMainOrgRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<SwitchMainOrgRequestTenantContext>(model1);
      }
    }
  }


  virtual ~SwitchMainOrgRequest() = default;
};
class SwitchMainOrgShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> targetOrgId{};
  shared_ptr<string> tenantContextShrink{};

  SwitchMainOrgShrinkRequest() {}

  explicit SwitchMainOrgShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetOrgId) {
      res["TargetOrgId"] = boost::any(*targetOrgId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetOrgId") != m.end() && !m["TargetOrgId"].empty()) {
      targetOrgId = make_shared<long>(boost::any_cast<long>(m["TargetOrgId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~SwitchMainOrgShrinkRequest() = default;
};
class SwitchMainOrgResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};

  SwitchMainOrgResponseBodyContent() {}

  explicit SwitchMainOrgResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["data"]));
    }
  }


  virtual ~SwitchMainOrgResponseBodyContent() = default;
};
class SwitchMainOrgResponseBody : public Darabonba::Model {
public:
  shared_ptr<SwitchMainOrgResponseBodyContent> content{};
  shared_ptr<string> errorCode{};
  shared_ptr<map<string, boost::any>> errorCtx{};
  shared_ptr<string> errorMsg{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SwitchMainOrgResponseBody() {}

  explicit SwitchMainOrgResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorCtx) {
      res["errorCtx"] = boost::any(*errorCtx);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      if (typeid(map<string, boost::any>) == m["content"].type()) {
        SwitchMainOrgResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["content"]));
        content = make_shared<SwitchMainOrgResponseBodyContent>(model1);
      }
    }
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorCtx") != m.end() && !m["errorCtx"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["errorCtx"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      errorCtx = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["httpStatusCode"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~SwitchMainOrgResponseBody() = default;
};
class SwitchMainOrgResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SwitchMainOrgResponseBody> body{};

  SwitchMainOrgResponse() {}

  explicit SwitchMainOrgResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SwitchMainOrgResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SwitchMainOrgResponseBody>(model1);
      }
    }
  }


  virtual ~SwitchMainOrgResponse() = default;
};
class SyncDingTypeHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SyncDingTypeHeadersAccountContext() {}

  explicit SyncDingTypeHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SyncDingTypeHeadersAccountContext() = default;
};
class SyncDingTypeHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SyncDingTypeHeadersAccountContext> accountContext{};

  SyncDingTypeHeaders() {}

  explicit SyncDingTypeHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SyncDingTypeHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SyncDingTypeHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SyncDingTypeHeaders() = default;
};
class SyncDingTypeShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SyncDingTypeShrinkHeaders() {}

  explicit SyncDingTypeShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SyncDingTypeShrinkHeaders() = default;
};
class SyncDingTypeRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  SyncDingTypeRequestTenantContext() {}

  explicit SyncDingTypeRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~SyncDingTypeRequestTenantContext() = default;
};
class SyncDingTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> dingType{};
  shared_ptr<string> isDimission{};
  shared_ptr<string> source{};
  shared_ptr<SyncDingTypeRequestTenantContext> tenantContext{};
  shared_ptr<string> workNo{};

  SyncDingTypeRequest() {}

  explicit SyncDingTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dingType) {
      res["DingType"] = boost::any(*dingType);
    }
    if (isDimission) {
      res["IsDimission"] = boost::any(*isDimission);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workNo) {
      res["WorkNo"] = boost::any(*workNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DingType") != m.end() && !m["DingType"].empty()) {
      dingType = make_shared<string>(boost::any_cast<string>(m["DingType"]));
    }
    if (m.find("IsDimission") != m.end() && !m["IsDimission"].empty()) {
      isDimission = make_shared<string>(boost::any_cast<string>(m["IsDimission"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        SyncDingTypeRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<SyncDingTypeRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkNo") != m.end() && !m["WorkNo"].empty()) {
      workNo = make_shared<string>(boost::any_cast<string>(m["WorkNo"]));
    }
  }


  virtual ~SyncDingTypeRequest() = default;
};
class SyncDingTypeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dingType{};
  shared_ptr<string> isDimission{};
  shared_ptr<string> source{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workNo{};

  SyncDingTypeShrinkRequest() {}

  explicit SyncDingTypeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dingType) {
      res["DingType"] = boost::any(*dingType);
    }
    if (isDimission) {
      res["IsDimission"] = boost::any(*isDimission);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workNo) {
      res["WorkNo"] = boost::any(*workNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DingType") != m.end() && !m["DingType"].empty()) {
      dingType = make_shared<string>(boost::any_cast<string>(m["DingType"]));
    }
    if (m.find("IsDimission") != m.end() && !m["IsDimission"].empty()) {
      isDimission = make_shared<string>(boost::any_cast<string>(m["IsDimission"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkNo") != m.end() && !m["WorkNo"].empty()) {
      workNo = make_shared<string>(boost::any_cast<string>(m["WorkNo"]));
    }
  }


  virtual ~SyncDingTypeShrinkRequest() = default;
};
class SyncDingTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  SyncDingTypeResponseBody() {}

  explicit SyncDingTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~SyncDingTypeResponseBody() = default;
};
class SyncDingTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SyncDingTypeResponseBody> body{};

  SyncDingTypeResponse() {}

  explicit SyncDingTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SyncDingTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SyncDingTypeResponseBody>(model1);
      }
    }
  }


  virtual ~SyncDingTypeResponse() = default;
};
class TerminateInstanceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  TerminateInstanceHeadersAccountContext() {}

  explicit TerminateInstanceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~TerminateInstanceHeadersAccountContext() = default;
};
class TerminateInstanceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<TerminateInstanceHeadersAccountContext> accountContext{};

  TerminateInstanceHeaders() {}

  explicit TerminateInstanceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        TerminateInstanceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<TerminateInstanceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~TerminateInstanceHeaders() = default;
};
class TerminateInstanceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  TerminateInstanceShrinkHeaders() {}

  explicit TerminateInstanceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~TerminateInstanceShrinkHeaders() = default;
};
class TerminateInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> language{};
  shared_ptr<string> processInstanceId{};
  shared_ptr<string> systemToken{};

  TerminateInstanceRequest() {}

  explicit TerminateInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (processInstanceId) {
      res["ProcessInstanceId"] = boost::any(*processInstanceId);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("ProcessInstanceId") != m.end() && !m["ProcessInstanceId"].empty()) {
      processInstanceId = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceId"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~TerminateInstanceRequest() = default;
};
class TerminateInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  TerminateInstanceResponseBody() {}

  explicit TerminateInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~TerminateInstanceResponseBody() = default;
};
class TerminateInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TerminateInstanceResponseBody> body{};

  TerminateInstanceResponse() {}

  explicit TerminateInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TerminateInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TerminateInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~TerminateInstanceResponse() = default;
};
class TransferTicketHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  TransferTicketHeadersAccountContext() {}

  explicit TransferTicketHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~TransferTicketHeadersAccountContext() = default;
};
class TransferTicketHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<TransferTicketHeadersAccountContext> accountContext{};

  TransferTicketHeaders() {}

  explicit TransferTicketHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        TransferTicketHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<TransferTicketHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~TransferTicketHeaders() = default;
};
class TransferTicketShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  TransferTicketShrinkHeaders() {}

  explicit TransferTicketShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~TransferTicketShrinkHeaders() = default;
};
class TransferTicketRequestNotify : public Darabonba::Model {
public:
  shared_ptr<vector<string>> groupNoticeReceiverUserIds{};
  shared_ptr<bool> noticeAllGroupMember{};
  shared_ptr<vector<string>> workNoticeReceiverUserIds{};

  TransferTicketRequestNotify() {}

  explicit TransferTicketRequestNotify(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupNoticeReceiverUserIds) {
      res["GroupNoticeReceiverUserIds"] = boost::any(*groupNoticeReceiverUserIds);
    }
    if (noticeAllGroupMember) {
      res["NoticeAllGroupMember"] = boost::any(*noticeAllGroupMember);
    }
    if (workNoticeReceiverUserIds) {
      res["WorkNoticeReceiverUserIds"] = boost::any(*workNoticeReceiverUserIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupNoticeReceiverUserIds") != m.end() && !m["GroupNoticeReceiverUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupNoticeReceiverUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupNoticeReceiverUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupNoticeReceiverUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NoticeAllGroupMember") != m.end() && !m["NoticeAllGroupMember"].empty()) {
      noticeAllGroupMember = make_shared<bool>(boost::any_cast<bool>(m["NoticeAllGroupMember"]));
    }
    if (m.find("WorkNoticeReceiverUserIds") != m.end() && !m["WorkNoticeReceiverUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WorkNoticeReceiverUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WorkNoticeReceiverUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      workNoticeReceiverUserIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~TransferTicketRequestNotify() = default;
};
class TransferTicketRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  TransferTicketRequestTenantContext() {}

  explicit TransferTicketRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~TransferTicketRequestTenantContext() = default;
};
class TransferTicketRequestTicketMemoAttachments : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> key{};

  TransferTicketRequestTicketMemoAttachments() {}

  explicit TransferTicketRequestTicketMemoAttachments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~TransferTicketRequestTicketMemoAttachments() = default;
};
class TransferTicketRequestTicketMemo : public Darabonba::Model {
public:
  shared_ptr<vector<TransferTicketRequestTicketMemoAttachments>> attachments{};
  shared_ptr<string> memo{};

  TransferTicketRequestTicketMemo() {}

  explicit TransferTicketRequestTicketMemo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachments) {
      vector<boost::any> temp1;
      for(auto item1:*attachments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attachments"] = boost::any(temp1);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attachments") != m.end() && !m["Attachments"].empty()) {
      if (typeid(vector<boost::any>) == m["Attachments"].type()) {
        vector<TransferTicketRequestTicketMemoAttachments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attachments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TransferTicketRequestTicketMemoAttachments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attachments = make_shared<vector<TransferTicketRequestTicketMemoAttachments>>(expect1);
      }
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
  }


  virtual ~TransferTicketRequestTicketMemo() = default;
};
class TransferTicketRequest : public Darabonba::Model {
public:
  shared_ptr<TransferTicketRequestNotify> notify{};
  shared_ptr<string> openTeamId{};
  shared_ptr<string> openTicketId{};
  shared_ptr<vector<string>> processorUserIds{};
  shared_ptr<TransferTicketRequestTenantContext> tenantContext{};
  shared_ptr<TransferTicketRequestTicketMemo> ticketMemo{};

  TransferTicketRequest() {}

  explicit TransferTicketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notify) {
      res["Notify"] = notify ? boost::any(notify->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (openTeamId) {
      res["OpenTeamId"] = boost::any(*openTeamId);
    }
    if (openTicketId) {
      res["OpenTicketId"] = boost::any(*openTicketId);
    }
    if (processorUserIds) {
      res["ProcessorUserIds"] = boost::any(*processorUserIds);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ticketMemo) {
      res["TicketMemo"] = ticketMemo ? boost::any(ticketMemo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Notify") != m.end() && !m["Notify"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notify"].type()) {
        TransferTicketRequestNotify model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notify"]));
        notify = make_shared<TransferTicketRequestNotify>(model1);
      }
    }
    if (m.find("OpenTeamId") != m.end() && !m["OpenTeamId"].empty()) {
      openTeamId = make_shared<string>(boost::any_cast<string>(m["OpenTeamId"]));
    }
    if (m.find("OpenTicketId") != m.end() && !m["OpenTicketId"].empty()) {
      openTicketId = make_shared<string>(boost::any_cast<string>(m["OpenTicketId"]));
    }
    if (m.find("ProcessorUserIds") != m.end() && !m["ProcessorUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProcessorUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProcessorUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      processorUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        TransferTicketRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<TransferTicketRequestTenantContext>(model1);
      }
    }
    if (m.find("TicketMemo") != m.end() && !m["TicketMemo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TicketMemo"].type()) {
        TransferTicketRequestTicketMemo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TicketMemo"]));
        ticketMemo = make_shared<TransferTicketRequestTicketMemo>(model1);
      }
    }
  }


  virtual ~TransferTicketRequest() = default;
};
class TransferTicketShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> notifyShrink{};
  shared_ptr<string> openTeamId{};
  shared_ptr<string> openTicketId{};
  shared_ptr<string> processorUserIdsShrink{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> ticketMemoShrink{};

  TransferTicketShrinkRequest() {}

  explicit TransferTicketShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notifyShrink) {
      res["Notify"] = boost::any(*notifyShrink);
    }
    if (openTeamId) {
      res["OpenTeamId"] = boost::any(*openTeamId);
    }
    if (openTicketId) {
      res["OpenTicketId"] = boost::any(*openTicketId);
    }
    if (processorUserIdsShrink) {
      res["ProcessorUserIds"] = boost::any(*processorUserIdsShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (ticketMemoShrink) {
      res["TicketMemo"] = boost::any(*ticketMemoShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Notify") != m.end() && !m["Notify"].empty()) {
      notifyShrink = make_shared<string>(boost::any_cast<string>(m["Notify"]));
    }
    if (m.find("OpenTeamId") != m.end() && !m["OpenTeamId"].empty()) {
      openTeamId = make_shared<string>(boost::any_cast<string>(m["OpenTeamId"]));
    }
    if (m.find("OpenTicketId") != m.end() && !m["OpenTicketId"].empty()) {
      openTicketId = make_shared<string>(boost::any_cast<string>(m["OpenTicketId"]));
    }
    if (m.find("ProcessorUserIds") != m.end() && !m["ProcessorUserIds"].empty()) {
      processorUserIdsShrink = make_shared<string>(boost::any_cast<string>(m["ProcessorUserIds"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("TicketMemo") != m.end() && !m["TicketMemo"].empty()) {
      ticketMemoShrink = make_shared<string>(boost::any_cast<string>(m["TicketMemo"]));
    }
  }


  virtual ~TransferTicketShrinkRequest() = default;
};
class TransferTicketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  TransferTicketResponseBody() {}

  explicit TransferTicketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~TransferTicketResponseBody() = default;
};
class TransferTicketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TransferTicketResponseBody> body{};

  TransferTicketResponse() {}

  explicit TransferTicketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TransferTicketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TransferTicketResponseBody>(model1);
      }
    }
  }


  virtual ~TransferTicketResponse() = default;
};
class UnsubscribeCalendarHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UnsubscribeCalendarHeadersAccountContext() {}

  explicit UnsubscribeCalendarHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UnsubscribeCalendarHeadersAccountContext() = default;
};
class UnsubscribeCalendarHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UnsubscribeCalendarHeadersAccountContext> accountContext{};

  UnsubscribeCalendarHeaders() {}

  explicit UnsubscribeCalendarHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UnsubscribeCalendarHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UnsubscribeCalendarHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UnsubscribeCalendarHeaders() = default;
};
class UnsubscribeCalendarShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UnsubscribeCalendarShrinkHeaders() {}

  explicit UnsubscribeCalendarShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UnsubscribeCalendarShrinkHeaders() = default;
};
class UnsubscribeCalendarRequest : public Darabonba::Model {
public:
  shared_ptr<string> calendarId{};

  UnsubscribeCalendarRequest() {}

  explicit UnsubscribeCalendarRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
  }


  virtual ~UnsubscribeCalendarRequest() = default;
};
class UnsubscribeCalendarResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UnsubscribeCalendarResponseBody() {}

  explicit UnsubscribeCalendarResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~UnsubscribeCalendarResponseBody() = default;
};
class UnsubscribeCalendarResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnsubscribeCalendarResponseBody> body{};

  UnsubscribeCalendarResponse() {}

  explicit UnsubscribeCalendarResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnsubscribeCalendarResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnsubscribeCalendarResponseBody>(model1);
      }
    }
  }


  virtual ~UnsubscribeCalendarResponse() = default;
};
class UnsubscribeEventHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UnsubscribeEventHeadersAccountContext() {}

  explicit UnsubscribeEventHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UnsubscribeEventHeadersAccountContext() = default;
};
class UnsubscribeEventHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UnsubscribeEventHeadersAccountContext> accountContext{};

  UnsubscribeEventHeaders() {}

  explicit UnsubscribeEventHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UnsubscribeEventHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UnsubscribeEventHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UnsubscribeEventHeaders() = default;
};
class UnsubscribeEventShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UnsubscribeEventShrinkHeaders() {}

  explicit UnsubscribeEventShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UnsubscribeEventShrinkHeaders() = default;
};
class UnsubscribeEventRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UnsubscribeEventRequestTenantContext() {}

  explicit UnsubscribeEventRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UnsubscribeEventRequestTenantContext() = default;
};
class UnsubscribeEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> scope{};
  shared_ptr<string> scopeId{};
  shared_ptr<UnsubscribeEventRequestTenantContext> tenantContext{};

  UnsubscribeEventRequest() {}

  explicit UnsubscribeEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (scopeId) {
      res["ScopeId"] = boost::any(*scopeId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("ScopeId") != m.end() && !m["ScopeId"].empty()) {
      scopeId = make_shared<string>(boost::any_cast<string>(m["ScopeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UnsubscribeEventRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UnsubscribeEventRequestTenantContext>(model1);
      }
    }
  }


  virtual ~UnsubscribeEventRequest() = default;
};
class UnsubscribeEventShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> scope{};
  shared_ptr<string> scopeId{};
  shared_ptr<string> tenantContextShrink{};

  UnsubscribeEventShrinkRequest() {}

  explicit UnsubscribeEventShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (scopeId) {
      res["ScopeId"] = boost::any(*scopeId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("ScopeId") != m.end() && !m["ScopeId"].empty()) {
      scopeId = make_shared<string>(boost::any_cast<string>(m["ScopeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~UnsubscribeEventShrinkRequest() = default;
};
class UnsubscribeEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  UnsubscribeEventResponseBody() {}

  explicit UnsubscribeEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~UnsubscribeEventResponseBody() = default;
};
class UnsubscribeEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnsubscribeEventResponseBody> body{};

  UnsubscribeEventResponse() {}

  explicit UnsubscribeEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnsubscribeEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnsubscribeEventResponseBody>(model1);
      }
    }
  }


  virtual ~UnsubscribeEventResponse() = default;
};
class UpdateConvExtensionHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateConvExtensionHeadersAccountContext() {}

  explicit UpdateConvExtensionHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateConvExtensionHeadersAccountContext() = default;
};
class UpdateConvExtensionHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateConvExtensionHeadersAccountContext> accountContext{};

  UpdateConvExtensionHeaders() {}

  explicit UpdateConvExtensionHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateConvExtensionHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateConvExtensionHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateConvExtensionHeaders() = default;
};
class UpdateConvExtensionShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateConvExtensionShrinkHeaders() {}

  explicit UpdateConvExtensionShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateConvExtensionShrinkHeaders() = default;
};
class UpdateConvExtensionRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateConvExtensionRequestTenantContext() {}

  explicit UpdateConvExtensionRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateConvExtensionRequestTenantContext() = default;
};
class UpdateConvExtensionRequest : public Darabonba::Model {
public:
  shared_ptr<string> mobileUrl{};
  shared_ptr<string> pcUrl{};
  shared_ptr<vector<string>> staffIdList{};
  shared_ptr<string> systemUid{};
  shared_ptr<UpdateConvExtensionRequestTenantContext> tenantContext{};

  UpdateConvExtensionRequest() {}

  explicit UpdateConvExtensionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mobileUrl) {
      res["MobileUrl"] = boost::any(*mobileUrl);
    }
    if (pcUrl) {
      res["PcUrl"] = boost::any(*pcUrl);
    }
    if (staffIdList) {
      res["StaffIdList"] = boost::any(*staffIdList);
    }
    if (systemUid) {
      res["SystemUid"] = boost::any(*systemUid);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MobileUrl") != m.end() && !m["MobileUrl"].empty()) {
      mobileUrl = make_shared<string>(boost::any_cast<string>(m["MobileUrl"]));
    }
    if (m.find("PcUrl") != m.end() && !m["PcUrl"].empty()) {
      pcUrl = make_shared<string>(boost::any_cast<string>(m["PcUrl"]));
    }
    if (m.find("StaffIdList") != m.end() && !m["StaffIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StaffIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StaffIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      staffIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SystemUid") != m.end() && !m["SystemUid"].empty()) {
      systemUid = make_shared<string>(boost::any_cast<string>(m["SystemUid"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateConvExtensionRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateConvExtensionRequestTenantContext>(model1);
      }
    }
  }


  virtual ~UpdateConvExtensionRequest() = default;
};
class UpdateConvExtensionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> mobileUrl{};
  shared_ptr<string> pcUrl{};
  shared_ptr<string> staffIdListShrink{};
  shared_ptr<string> systemUid{};
  shared_ptr<string> tenantContextShrink{};

  UpdateConvExtensionShrinkRequest() {}

  explicit UpdateConvExtensionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mobileUrl) {
      res["MobileUrl"] = boost::any(*mobileUrl);
    }
    if (pcUrl) {
      res["PcUrl"] = boost::any(*pcUrl);
    }
    if (staffIdListShrink) {
      res["StaffIdList"] = boost::any(*staffIdListShrink);
    }
    if (systemUid) {
      res["SystemUid"] = boost::any(*systemUid);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MobileUrl") != m.end() && !m["MobileUrl"].empty()) {
      mobileUrl = make_shared<string>(boost::any_cast<string>(m["MobileUrl"]));
    }
    if (m.find("PcUrl") != m.end() && !m["PcUrl"].empty()) {
      pcUrl = make_shared<string>(boost::any_cast<string>(m["PcUrl"]));
    }
    if (m.find("StaffIdList") != m.end() && !m["StaffIdList"].empty()) {
      staffIdListShrink = make_shared<string>(boost::any_cast<string>(m["StaffIdList"]));
    }
    if (m.find("SystemUid") != m.end() && !m["SystemUid"].empty()) {
      systemUid = make_shared<string>(boost::any_cast<string>(m["SystemUid"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~UpdateConvExtensionShrinkRequest() = default;
};
class UpdateConvExtensionResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  UpdateConvExtensionResponseBody() {}

  explicit UpdateConvExtensionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~UpdateConvExtensionResponseBody() = default;
};
class UpdateConvExtensionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateConvExtensionResponseBody> body{};

  UpdateConvExtensionResponse() {}

  explicit UpdateConvExtensionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateConvExtensionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateConvExtensionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateConvExtensionResponse() = default;
};
class UpdateFormDataHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateFormDataHeadersAccountContext() {}

  explicit UpdateFormDataHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateFormDataHeadersAccountContext() = default;
};
class UpdateFormDataHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateFormDataHeadersAccountContext> accountContext{};

  UpdateFormDataHeaders() {}

  explicit UpdateFormDataHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateFormDataHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateFormDataHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateFormDataHeaders() = default;
};
class UpdateFormDataShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateFormDataShrinkHeaders() {}

  explicit UpdateFormDataShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateFormDataShrinkHeaders() = default;
};
class UpdateFormDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> formInstanceId{};
  shared_ptr<string> language{};
  shared_ptr<string> systemToken{};
  shared_ptr<string> updateFormDataJson{};
  shared_ptr<bool> useLatestVersion{};

  UpdateFormDataRequest() {}

  explicit UpdateFormDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (formInstanceId) {
      res["FormInstanceId"] = boost::any(*formInstanceId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    if (updateFormDataJson) {
      res["UpdateFormDataJson"] = boost::any(*updateFormDataJson);
    }
    if (useLatestVersion) {
      res["UseLatestVersion"] = boost::any(*useLatestVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("FormInstanceId") != m.end() && !m["FormInstanceId"].empty()) {
      formInstanceId = make_shared<string>(boost::any_cast<string>(m["FormInstanceId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
    if (m.find("UpdateFormDataJson") != m.end() && !m["UpdateFormDataJson"].empty()) {
      updateFormDataJson = make_shared<string>(boost::any_cast<string>(m["UpdateFormDataJson"]));
    }
    if (m.find("UseLatestVersion") != m.end() && !m["UseLatestVersion"].empty()) {
      useLatestVersion = make_shared<bool>(boost::any_cast<bool>(m["UseLatestVersion"]));
    }
  }


  virtual ~UpdateFormDataRequest() = default;
};
class UpdateFormDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  UpdateFormDataResponseBody() {}

  explicit UpdateFormDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~UpdateFormDataResponseBody() = default;
};
class UpdateFormDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateFormDataResponseBody> body{};

  UpdateFormDataResponse() {}

  explicit UpdateFormDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateFormDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateFormDataResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateFormDataResponse() = default;
};
class UpdateInstanceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateInstanceHeadersAccountContext() {}

  explicit UpdateInstanceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateInstanceHeadersAccountContext() = default;
};
class UpdateInstanceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateInstanceHeadersAccountContext> accountContext{};

  UpdateInstanceHeaders() {}

  explicit UpdateInstanceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateInstanceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateInstanceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateInstanceHeaders() = default;
};
class UpdateInstanceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateInstanceShrinkHeaders() {}

  explicit UpdateInstanceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateInstanceShrinkHeaders() = default;
};
class UpdateInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> language{};
  shared_ptr<string> processInstanceId{};
  shared_ptr<string> systemToken{};
  shared_ptr<string> updateFormDataJson{};

  UpdateInstanceRequest() {}

  explicit UpdateInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (processInstanceId) {
      res["ProcessInstanceId"] = boost::any(*processInstanceId);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    if (updateFormDataJson) {
      res["UpdateFormDataJson"] = boost::any(*updateFormDataJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("ProcessInstanceId") != m.end() && !m["ProcessInstanceId"].empty()) {
      processInstanceId = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceId"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
    if (m.find("UpdateFormDataJson") != m.end() && !m["UpdateFormDataJson"].empty()) {
      updateFormDataJson = make_shared<string>(boost::any_cast<string>(m["UpdateFormDataJson"]));
    }
  }


  virtual ~UpdateInstanceRequest() = default;
};
class UpdateInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  UpdateInstanceResponseBody() {}

  explicit UpdateInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~UpdateInstanceResponseBody() = default;
};
class UpdateInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateInstanceResponseBody> body{};

  UpdateInstanceResponse() {}

  explicit UpdateInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateInstanceResponse() = default;
};
class UpdateLiveHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateLiveHeadersAccountContext() {}

  explicit UpdateLiveHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateLiveHeadersAccountContext() = default;
};
class UpdateLiveHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateLiveHeadersAccountContext> accountContext{};

  UpdateLiveHeaders() {}

  explicit UpdateLiveHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateLiveHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateLiveHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateLiveHeaders() = default;
};
class UpdateLiveShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateLiveShrinkHeaders() {}

  explicit UpdateLiveShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateLiveShrinkHeaders() = default;
};
class UpdateLiveRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateLiveRequestTenantContext() {}

  explicit UpdateLiveRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateLiveRequestTenantContext() = default;
};
class UpdateLiveRequest : public Darabonba::Model {
public:
  shared_ptr<string> coverUrl{};
  shared_ptr<string> introduction{};
  shared_ptr<string> liveId{};
  shared_ptr<long> preEndTime{};
  shared_ptr<long> preStartTime{};
  shared_ptr<UpdateLiveRequestTenantContext> tenantContext{};
  shared_ptr<string> title{};

  UpdateLiveRequest() {}

  explicit UpdateLiveRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverUrl) {
      res["CoverUrl"] = boost::any(*coverUrl);
    }
    if (introduction) {
      res["Introduction"] = boost::any(*introduction);
    }
    if (liveId) {
      res["LiveId"] = boost::any(*liveId);
    }
    if (preEndTime) {
      res["PreEndTime"] = boost::any(*preEndTime);
    }
    if (preStartTime) {
      res["PreStartTime"] = boost::any(*preStartTime);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverUrl") != m.end() && !m["CoverUrl"].empty()) {
      coverUrl = make_shared<string>(boost::any_cast<string>(m["CoverUrl"]));
    }
    if (m.find("Introduction") != m.end() && !m["Introduction"].empty()) {
      introduction = make_shared<string>(boost::any_cast<string>(m["Introduction"]));
    }
    if (m.find("LiveId") != m.end() && !m["LiveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["LiveId"]));
    }
    if (m.find("PreEndTime") != m.end() && !m["PreEndTime"].empty()) {
      preEndTime = make_shared<long>(boost::any_cast<long>(m["PreEndTime"]));
    }
    if (m.find("PreStartTime") != m.end() && !m["PreStartTime"].empty()) {
      preStartTime = make_shared<long>(boost::any_cast<long>(m["PreStartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateLiveRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateLiveRequestTenantContext>(model1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateLiveRequest() = default;
};
class UpdateLiveShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> coverUrl{};
  shared_ptr<string> introduction{};
  shared_ptr<string> liveId{};
  shared_ptr<long> preEndTime{};
  shared_ptr<long> preStartTime{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> title{};

  UpdateLiveShrinkRequest() {}

  explicit UpdateLiveShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverUrl) {
      res["CoverUrl"] = boost::any(*coverUrl);
    }
    if (introduction) {
      res["Introduction"] = boost::any(*introduction);
    }
    if (liveId) {
      res["LiveId"] = boost::any(*liveId);
    }
    if (preEndTime) {
      res["PreEndTime"] = boost::any(*preEndTime);
    }
    if (preStartTime) {
      res["PreStartTime"] = boost::any(*preStartTime);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverUrl") != m.end() && !m["CoverUrl"].empty()) {
      coverUrl = make_shared<string>(boost::any_cast<string>(m["CoverUrl"]));
    }
    if (m.find("Introduction") != m.end() && !m["Introduction"].empty()) {
      introduction = make_shared<string>(boost::any_cast<string>(m["Introduction"]));
    }
    if (m.find("LiveId") != m.end() && !m["LiveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["LiveId"]));
    }
    if (m.find("PreEndTime") != m.end() && !m["PreEndTime"].empty()) {
      preEndTime = make_shared<long>(boost::any_cast<long>(m["PreEndTime"]));
    }
    if (m.find("PreStartTime") != m.end() && !m["PreStartTime"].empty()) {
      preStartTime = make_shared<long>(boost::any_cast<long>(m["PreStartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateLiveShrinkRequest() = default;
};
class UpdateLiveResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateLiveResponseBody() {}

  explicit UpdateLiveResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateLiveResponseBody() = default;
};
class UpdateLiveResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveResponseBody> body{};

  UpdateLiveResponse() {}

  explicit UpdateLiveResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveResponse() = default;
};
class UpdateMeetingRoomHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateMeetingRoomHeadersAccountContext() {}

  explicit UpdateMeetingRoomHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateMeetingRoomHeadersAccountContext() = default;
};
class UpdateMeetingRoomHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateMeetingRoomHeadersAccountContext> accountContext{};

  UpdateMeetingRoomHeaders() {}

  explicit UpdateMeetingRoomHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateMeetingRoomHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateMeetingRoomHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateMeetingRoomHeaders() = default;
};
class UpdateMeetingRoomShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateMeetingRoomShrinkHeaders() {}

  explicit UpdateMeetingRoomShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateMeetingRoomShrinkHeaders() = default;
};
class UpdateMeetingRoomRequestReservationAuthorityAuthorizedMembers : public Darabonba::Model {
public:
  shared_ptr<string> memberId{};
  shared_ptr<string> memberName{};
  shared_ptr<string> memberType{};

  UpdateMeetingRoomRequestReservationAuthorityAuthorizedMembers() {}

  explicit UpdateMeetingRoomRequestReservationAuthorityAuthorizedMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberId) {
      res["MemberId"] = boost::any(*memberId);
    }
    if (memberName) {
      res["MemberName"] = boost::any(*memberName);
    }
    if (memberType) {
      res["MemberType"] = boost::any(*memberType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemberId") != m.end() && !m["MemberId"].empty()) {
      memberId = make_shared<string>(boost::any_cast<string>(m["MemberId"]));
    }
    if (m.find("MemberName") != m.end() && !m["MemberName"].empty()) {
      memberName = make_shared<string>(boost::any_cast<string>(m["MemberName"]));
    }
    if (m.find("MemberType") != m.end() && !m["MemberType"].empty()) {
      memberType = make_shared<string>(boost::any_cast<string>(m["MemberType"]));
    }
  }


  virtual ~UpdateMeetingRoomRequestReservationAuthorityAuthorizedMembers() = default;
};
class UpdateMeetingRoomRequestReservationAuthority : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateMeetingRoomRequestReservationAuthorityAuthorizedMembers>> authorizedMembers{};

  UpdateMeetingRoomRequestReservationAuthority() {}

  explicit UpdateMeetingRoomRequestReservationAuthority(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizedMembers) {
      vector<boost::any> temp1;
      for(auto item1:*authorizedMembers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizedMembers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizedMembers") != m.end() && !m["AuthorizedMembers"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizedMembers"].type()) {
        vector<UpdateMeetingRoomRequestReservationAuthorityAuthorizedMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizedMembers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateMeetingRoomRequestReservationAuthorityAuthorizedMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizedMembers = make_shared<vector<UpdateMeetingRoomRequestReservationAuthorityAuthorizedMembers>>(expect1);
      }
    }
  }


  virtual ~UpdateMeetingRoomRequestReservationAuthority() = default;
};
class UpdateMeetingRoomRequestRoomLocation : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> title{};

  UpdateMeetingRoomRequestRoomLocation() {}

  explicit UpdateMeetingRoomRequestRoomLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateMeetingRoomRequestRoomLocation() = default;
};
class UpdateMeetingRoomRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateMeetingRoomRequestTenantContext() {}

  explicit UpdateMeetingRoomRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateMeetingRoomRequestTenantContext() = default;
};
class UpdateMeetingRoomRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enableCycleReservation{};
  shared_ptr<long> groupId{};
  shared_ptr<string> isvRoomId{};
  shared_ptr<UpdateMeetingRoomRequestReservationAuthority> reservationAuthority{};
  shared_ptr<long> roomCapacity{};
  shared_ptr<string> roomId{};
  shared_ptr<vector<long>> roomLabelIds{};
  shared_ptr<UpdateMeetingRoomRequestRoomLocation> roomLocation{};
  shared_ptr<string> roomName{};
  shared_ptr<string> roomPicture{};
  shared_ptr<long> roomStatus{};
  shared_ptr<UpdateMeetingRoomRequestTenantContext> tenantContext{};

  UpdateMeetingRoomRequest() {}

  explicit UpdateMeetingRoomRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableCycleReservation) {
      res["EnableCycleReservation"] = boost::any(*enableCycleReservation);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (isvRoomId) {
      res["IsvRoomId"] = boost::any(*isvRoomId);
    }
    if (reservationAuthority) {
      res["ReservationAuthority"] = reservationAuthority ? boost::any(reservationAuthority->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (roomCapacity) {
      res["RoomCapacity"] = boost::any(*roomCapacity);
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    if (roomLabelIds) {
      res["RoomLabelIds"] = boost::any(*roomLabelIds);
    }
    if (roomLocation) {
      res["RoomLocation"] = roomLocation ? boost::any(roomLocation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (roomName) {
      res["RoomName"] = boost::any(*roomName);
    }
    if (roomPicture) {
      res["RoomPicture"] = boost::any(*roomPicture);
    }
    if (roomStatus) {
      res["RoomStatus"] = boost::any(*roomStatus);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableCycleReservation") != m.end() && !m["EnableCycleReservation"].empty()) {
      enableCycleReservation = make_shared<bool>(boost::any_cast<bool>(m["EnableCycleReservation"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("IsvRoomId") != m.end() && !m["IsvRoomId"].empty()) {
      isvRoomId = make_shared<string>(boost::any_cast<string>(m["IsvRoomId"]));
    }
    if (m.find("ReservationAuthority") != m.end() && !m["ReservationAuthority"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReservationAuthority"].type()) {
        UpdateMeetingRoomRequestReservationAuthority model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReservationAuthority"]));
        reservationAuthority = make_shared<UpdateMeetingRoomRequestReservationAuthority>(model1);
      }
    }
    if (m.find("RoomCapacity") != m.end() && !m["RoomCapacity"].empty()) {
      roomCapacity = make_shared<long>(boost::any_cast<long>(m["RoomCapacity"]));
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
    if (m.find("RoomLabelIds") != m.end() && !m["RoomLabelIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RoomLabelIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoomLabelIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      roomLabelIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RoomLocation") != m.end() && !m["RoomLocation"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoomLocation"].type()) {
        UpdateMeetingRoomRequestRoomLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoomLocation"]));
        roomLocation = make_shared<UpdateMeetingRoomRequestRoomLocation>(model1);
      }
    }
    if (m.find("RoomName") != m.end() && !m["RoomName"].empty()) {
      roomName = make_shared<string>(boost::any_cast<string>(m["RoomName"]));
    }
    if (m.find("RoomPicture") != m.end() && !m["RoomPicture"].empty()) {
      roomPicture = make_shared<string>(boost::any_cast<string>(m["RoomPicture"]));
    }
    if (m.find("RoomStatus") != m.end() && !m["RoomStatus"].empty()) {
      roomStatus = make_shared<long>(boost::any_cast<long>(m["RoomStatus"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateMeetingRoomRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateMeetingRoomRequestTenantContext>(model1);
      }
    }
  }


  virtual ~UpdateMeetingRoomRequest() = default;
};
class UpdateMeetingRoomShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enableCycleReservation{};
  shared_ptr<long> groupId{};
  shared_ptr<string> isvRoomId{};
  shared_ptr<string> reservationAuthorityShrink{};
  shared_ptr<long> roomCapacity{};
  shared_ptr<string> roomId{};
  shared_ptr<string> roomLabelIdsShrink{};
  shared_ptr<string> roomLocationShrink{};
  shared_ptr<string> roomName{};
  shared_ptr<string> roomPicture{};
  shared_ptr<long> roomStatus{};
  shared_ptr<string> tenantContextShrink{};

  UpdateMeetingRoomShrinkRequest() {}

  explicit UpdateMeetingRoomShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableCycleReservation) {
      res["EnableCycleReservation"] = boost::any(*enableCycleReservation);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (isvRoomId) {
      res["IsvRoomId"] = boost::any(*isvRoomId);
    }
    if (reservationAuthorityShrink) {
      res["ReservationAuthority"] = boost::any(*reservationAuthorityShrink);
    }
    if (roomCapacity) {
      res["RoomCapacity"] = boost::any(*roomCapacity);
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    if (roomLabelIdsShrink) {
      res["RoomLabelIds"] = boost::any(*roomLabelIdsShrink);
    }
    if (roomLocationShrink) {
      res["RoomLocation"] = boost::any(*roomLocationShrink);
    }
    if (roomName) {
      res["RoomName"] = boost::any(*roomName);
    }
    if (roomPicture) {
      res["RoomPicture"] = boost::any(*roomPicture);
    }
    if (roomStatus) {
      res["RoomStatus"] = boost::any(*roomStatus);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableCycleReservation") != m.end() && !m["EnableCycleReservation"].empty()) {
      enableCycleReservation = make_shared<bool>(boost::any_cast<bool>(m["EnableCycleReservation"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("IsvRoomId") != m.end() && !m["IsvRoomId"].empty()) {
      isvRoomId = make_shared<string>(boost::any_cast<string>(m["IsvRoomId"]));
    }
    if (m.find("ReservationAuthority") != m.end() && !m["ReservationAuthority"].empty()) {
      reservationAuthorityShrink = make_shared<string>(boost::any_cast<string>(m["ReservationAuthority"]));
    }
    if (m.find("RoomCapacity") != m.end() && !m["RoomCapacity"].empty()) {
      roomCapacity = make_shared<long>(boost::any_cast<long>(m["RoomCapacity"]));
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
    if (m.find("RoomLabelIds") != m.end() && !m["RoomLabelIds"].empty()) {
      roomLabelIdsShrink = make_shared<string>(boost::any_cast<string>(m["RoomLabelIds"]));
    }
    if (m.find("RoomLocation") != m.end() && !m["RoomLocation"].empty()) {
      roomLocationShrink = make_shared<string>(boost::any_cast<string>(m["RoomLocation"]));
    }
    if (m.find("RoomName") != m.end() && !m["RoomName"].empty()) {
      roomName = make_shared<string>(boost::any_cast<string>(m["RoomName"]));
    }
    if (m.find("RoomPicture") != m.end() && !m["RoomPicture"].empty()) {
      roomPicture = make_shared<string>(boost::any_cast<string>(m["RoomPicture"]));
    }
    if (m.find("RoomStatus") != m.end() && !m["RoomStatus"].empty()) {
      roomStatus = make_shared<long>(boost::any_cast<long>(m["RoomStatus"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~UpdateMeetingRoomShrinkRequest() = default;
};
class UpdateMeetingRoomResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> result{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  UpdateMeetingRoomResponseBody() {}

  explicit UpdateMeetingRoomResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~UpdateMeetingRoomResponseBody() = default;
};
class UpdateMeetingRoomResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMeetingRoomResponseBody> body{};

  UpdateMeetingRoomResponse() {}

  explicit UpdateMeetingRoomResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMeetingRoomResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMeetingRoomResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMeetingRoomResponse() = default;
};
class UpdateMeetingRoomGroupHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateMeetingRoomGroupHeadersAccountContext() {}

  explicit UpdateMeetingRoomGroupHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateMeetingRoomGroupHeadersAccountContext() = default;
};
class UpdateMeetingRoomGroupHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateMeetingRoomGroupHeadersAccountContext> accountContext{};

  UpdateMeetingRoomGroupHeaders() {}

  explicit UpdateMeetingRoomGroupHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateMeetingRoomGroupHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateMeetingRoomGroupHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateMeetingRoomGroupHeaders() = default;
};
class UpdateMeetingRoomGroupShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateMeetingRoomGroupShrinkHeaders() {}

  explicit UpdateMeetingRoomGroupShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateMeetingRoomGroupShrinkHeaders() = default;
};
class UpdateMeetingRoomGroupRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateMeetingRoomGroupRequestTenantContext() {}

  explicit UpdateMeetingRoomGroupRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateMeetingRoomGroupRequestTenantContext() = default;
};
class UpdateMeetingRoomGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<UpdateMeetingRoomGroupRequestTenantContext> tenantContext{};

  UpdateMeetingRoomGroupRequest() {}

  explicit UpdateMeetingRoomGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateMeetingRoomGroupRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateMeetingRoomGroupRequestTenantContext>(model1);
      }
    }
  }


  virtual ~UpdateMeetingRoomGroupRequest() = default;
};
class UpdateMeetingRoomGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> tenantContextShrink{};

  UpdateMeetingRoomGroupShrinkRequest() {}

  explicit UpdateMeetingRoomGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~UpdateMeetingRoomGroupShrinkRequest() = default;
};
class UpdateMeetingRoomGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UpdateMeetingRoomGroupResponseBody() {}

  explicit UpdateMeetingRoomGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~UpdateMeetingRoomGroupResponseBody() = default;
};
class UpdateMeetingRoomGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMeetingRoomGroupResponseBody> body{};

  UpdateMeetingRoomGroupResponse() {}

  explicit UpdateMeetingRoomGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMeetingRoomGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMeetingRoomGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMeetingRoomGroupResponse() = default;
};
class UpdateMultiDimTableHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateMultiDimTableHeadersAccountContext() {}

  explicit UpdateMultiDimTableHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateMultiDimTableHeadersAccountContext() = default;
};
class UpdateMultiDimTableHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateMultiDimTableHeadersAccountContext> accountContext{};

  UpdateMultiDimTableHeaders() {}

  explicit UpdateMultiDimTableHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateMultiDimTableHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateMultiDimTableHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateMultiDimTableHeaders() = default;
};
class UpdateMultiDimTableShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateMultiDimTableShrinkHeaders() {}

  explicit UpdateMultiDimTableShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateMultiDimTableShrinkHeaders() = default;
};
class UpdateMultiDimTableRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateMultiDimTableRequestTenantContext() {}

  explicit UpdateMultiDimTableRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateMultiDimTableRequestTenantContext() = default;
};
class UpdateMultiDimTableRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<string> name{};
  shared_ptr<string> sheetIdOrName{};
  shared_ptr<UpdateMultiDimTableRequestTenantContext> tenantContext{};

  UpdateMultiDimTableRequest() {}

  explicit UpdateMultiDimTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sheetIdOrName) {
      res["SheetIdOrName"] = boost::any(*sheetIdOrName);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SheetIdOrName") != m.end() && !m["SheetIdOrName"].empty()) {
      sheetIdOrName = make_shared<string>(boost::any_cast<string>(m["SheetIdOrName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateMultiDimTableRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateMultiDimTableRequestTenantContext>(model1);
      }
    }
  }


  virtual ~UpdateMultiDimTableRequest() = default;
};
class UpdateMultiDimTableShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<string> name{};
  shared_ptr<string> sheetIdOrName{};
  shared_ptr<string> tenantContextShrink{};

  UpdateMultiDimTableShrinkRequest() {}

  explicit UpdateMultiDimTableShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sheetIdOrName) {
      res["SheetIdOrName"] = boost::any(*sheetIdOrName);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SheetIdOrName") != m.end() && !m["SheetIdOrName"].empty()) {
      sheetIdOrName = make_shared<string>(boost::any_cast<string>(m["SheetIdOrName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~UpdateMultiDimTableShrinkRequest() = default;
};
class UpdateMultiDimTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  UpdateMultiDimTableResponseBody() {}

  explicit UpdateMultiDimTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~UpdateMultiDimTableResponseBody() = default;
};
class UpdateMultiDimTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMultiDimTableResponseBody> body{};

  UpdateMultiDimTableResponse() {}

  explicit UpdateMultiDimTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMultiDimTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMultiDimTableResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMultiDimTableResponse() = default;
};
class UpdateMultiDimTableFieldHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateMultiDimTableFieldHeadersAccountContext() {}

  explicit UpdateMultiDimTableFieldHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateMultiDimTableFieldHeadersAccountContext() = default;
};
class UpdateMultiDimTableFieldHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateMultiDimTableFieldHeadersAccountContext> accountContext{};

  UpdateMultiDimTableFieldHeaders() {}

  explicit UpdateMultiDimTableFieldHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateMultiDimTableFieldHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateMultiDimTableFieldHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateMultiDimTableFieldHeaders() = default;
};
class UpdateMultiDimTableFieldShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateMultiDimTableFieldShrinkHeaders() {}

  explicit UpdateMultiDimTableFieldShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateMultiDimTableFieldShrinkHeaders() = default;
};
class UpdateMultiDimTableFieldRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateMultiDimTableFieldRequestTenantContext() {}

  explicit UpdateMultiDimTableFieldRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateMultiDimTableFieldRequestTenantContext() = default;
};
class UpdateMultiDimTableFieldRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<string> fieldIdOrName{};
  shared_ptr<string> name{};
  shared_ptr<map<string, boost::any>> property{};
  shared_ptr<string> sheetIdOrName{};
  shared_ptr<UpdateMultiDimTableFieldRequestTenantContext> tenantContext{};

  UpdateMultiDimTableFieldRequest() {}

  explicit UpdateMultiDimTableFieldRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (fieldIdOrName) {
      res["FieldIdOrName"] = boost::any(*fieldIdOrName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (property) {
      res["Property"] = boost::any(*property);
    }
    if (sheetIdOrName) {
      res["SheetIdOrName"] = boost::any(*sheetIdOrName);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("FieldIdOrName") != m.end() && !m["FieldIdOrName"].empty()) {
      fieldIdOrName = make_shared<string>(boost::any_cast<string>(m["FieldIdOrName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Property"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      property = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SheetIdOrName") != m.end() && !m["SheetIdOrName"].empty()) {
      sheetIdOrName = make_shared<string>(boost::any_cast<string>(m["SheetIdOrName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateMultiDimTableFieldRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateMultiDimTableFieldRequestTenantContext>(model1);
      }
    }
  }


  virtual ~UpdateMultiDimTableFieldRequest() = default;
};
class UpdateMultiDimTableFieldShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<string> fieldIdOrName{};
  shared_ptr<string> name{};
  shared_ptr<string> propertyShrink{};
  shared_ptr<string> sheetIdOrName{};
  shared_ptr<string> tenantContextShrink{};

  UpdateMultiDimTableFieldShrinkRequest() {}

  explicit UpdateMultiDimTableFieldShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (fieldIdOrName) {
      res["FieldIdOrName"] = boost::any(*fieldIdOrName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (propertyShrink) {
      res["Property"] = boost::any(*propertyShrink);
    }
    if (sheetIdOrName) {
      res["SheetIdOrName"] = boost::any(*sheetIdOrName);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("FieldIdOrName") != m.end() && !m["FieldIdOrName"].empty()) {
      fieldIdOrName = make_shared<string>(boost::any_cast<string>(m["FieldIdOrName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      propertyShrink = make_shared<string>(boost::any_cast<string>(m["Property"]));
    }
    if (m.find("SheetIdOrName") != m.end() && !m["SheetIdOrName"].empty()) {
      sheetIdOrName = make_shared<string>(boost::any_cast<string>(m["SheetIdOrName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~UpdateMultiDimTableFieldShrinkRequest() = default;
};
class UpdateMultiDimTableFieldResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  UpdateMultiDimTableFieldResponseBody() {}

  explicit UpdateMultiDimTableFieldResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~UpdateMultiDimTableFieldResponseBody() = default;
};
class UpdateMultiDimTableFieldResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMultiDimTableFieldResponseBody> body{};

  UpdateMultiDimTableFieldResponse() {}

  explicit UpdateMultiDimTableFieldResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMultiDimTableFieldResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMultiDimTableFieldResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMultiDimTableFieldResponse() = default;
};
class UpdateMultiDimTableRecordsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateMultiDimTableRecordsHeadersAccountContext() {}

  explicit UpdateMultiDimTableRecordsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateMultiDimTableRecordsHeadersAccountContext() = default;
};
class UpdateMultiDimTableRecordsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateMultiDimTableRecordsHeadersAccountContext> accountContext{};

  UpdateMultiDimTableRecordsHeaders() {}

  explicit UpdateMultiDimTableRecordsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateMultiDimTableRecordsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateMultiDimTableRecordsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateMultiDimTableRecordsHeaders() = default;
};
class UpdateMultiDimTableRecordsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateMultiDimTableRecordsShrinkHeaders() {}

  explicit UpdateMultiDimTableRecordsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateMultiDimTableRecordsShrinkHeaders() = default;
};
class UpdateMultiDimTableRecordsRequestRecordIds : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> fields{};
  shared_ptr<string> id{};

  UpdateMultiDimTableRecordsRequestRecordIds() {}

  explicit UpdateMultiDimTableRecordsRequestRecordIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fields) {
      res["Fields"] = boost::any(*fields);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Fields") != m.end() && !m["Fields"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Fields"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      fields = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~UpdateMultiDimTableRecordsRequestRecordIds() = default;
};
class UpdateMultiDimTableRecordsRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateMultiDimTableRecordsRequestTenantContext() {}

  explicit UpdateMultiDimTableRecordsRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateMultiDimTableRecordsRequestTenantContext() = default;
};
class UpdateMultiDimTableRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<vector<UpdateMultiDimTableRecordsRequestRecordIds>> recordIds{};
  shared_ptr<string> sheetIdOrName{};
  shared_ptr<UpdateMultiDimTableRecordsRequestTenantContext> tenantContext{};

  UpdateMultiDimTableRecordsRequest() {}

  explicit UpdateMultiDimTableRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (recordIds) {
      vector<boost::any> temp1;
      for(auto item1:*recordIds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordIds"] = boost::any(temp1);
    }
    if (sheetIdOrName) {
      res["SheetIdOrName"] = boost::any(*sheetIdOrName);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("RecordIds") != m.end() && !m["RecordIds"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordIds"].type()) {
        vector<UpdateMultiDimTableRecordsRequestRecordIds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordIds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateMultiDimTableRecordsRequestRecordIds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordIds = make_shared<vector<UpdateMultiDimTableRecordsRequestRecordIds>>(expect1);
      }
    }
    if (m.find("SheetIdOrName") != m.end() && !m["SheetIdOrName"].empty()) {
      sheetIdOrName = make_shared<string>(boost::any_cast<string>(m["SheetIdOrName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateMultiDimTableRecordsRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateMultiDimTableRecordsRequestTenantContext>(model1);
      }
    }
  }


  virtual ~UpdateMultiDimTableRecordsRequest() = default;
};
class UpdateMultiDimTableRecordsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};
  shared_ptr<string> recordIdsShrink{};
  shared_ptr<string> sheetIdOrName{};
  shared_ptr<string> tenantContextShrink{};

  UpdateMultiDimTableRecordsShrinkRequest() {}

  explicit UpdateMultiDimTableRecordsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    if (recordIdsShrink) {
      res["RecordIds"] = boost::any(*recordIdsShrink);
    }
    if (sheetIdOrName) {
      res["SheetIdOrName"] = boost::any(*sheetIdOrName);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
    if (m.find("RecordIds") != m.end() && !m["RecordIds"].empty()) {
      recordIdsShrink = make_shared<string>(boost::any_cast<string>(m["RecordIds"]));
    }
    if (m.find("SheetIdOrName") != m.end() && !m["SheetIdOrName"].empty()) {
      sheetIdOrName = make_shared<string>(boost::any_cast<string>(m["SheetIdOrName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~UpdateMultiDimTableRecordsShrinkRequest() = default;
};
class UpdateMultiDimTableRecordsResponseBodyValue : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  UpdateMultiDimTableRecordsResponseBodyValue() {}

  explicit UpdateMultiDimTableRecordsResponseBodyValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~UpdateMultiDimTableRecordsResponseBodyValue() = default;
};
class UpdateMultiDimTableRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateMultiDimTableRecordsResponseBodyValue>> value{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  UpdateMultiDimTableRecordsResponseBody() {}

  explicit UpdateMultiDimTableRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      vector<boost::any> temp1;
      for(auto item1:*value){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Value"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<UpdateMultiDimTableRecordsResponseBodyValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Value"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateMultiDimTableRecordsResponseBodyValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        value = make_shared<vector<UpdateMultiDimTableRecordsResponseBodyValue>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~UpdateMultiDimTableRecordsResponseBody() = default;
};
class UpdateMultiDimTableRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMultiDimTableRecordsResponseBody> body{};

  UpdateMultiDimTableRecordsResponse() {}

  explicit UpdateMultiDimTableRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMultiDimTableRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMultiDimTableRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMultiDimTableRecordsResponse() = default;
};
class UpdatePermissionHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdatePermissionHeadersAccountContext() {}

  explicit UpdatePermissionHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdatePermissionHeadersAccountContext() = default;
};
class UpdatePermissionHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdatePermissionHeadersAccountContext> accountContext{};

  UpdatePermissionHeaders() {}

  explicit UpdatePermissionHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdatePermissionHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdatePermissionHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdatePermissionHeaders() = default;
};
class UpdatePermissionShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdatePermissionShrinkHeaders() {}

  explicit UpdatePermissionShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdatePermissionShrinkHeaders() = default;
};
class UpdatePermissionRequestMembers : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<string> id{};
  shared_ptr<string> type{};

  UpdatePermissionRequestMembers() {}

  explicit UpdatePermissionRequestMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdatePermissionRequestMembers() = default;
};
class UpdatePermissionRequestOption : public Darabonba::Model {
public:
  shared_ptr<long> duration{};

  UpdatePermissionRequestOption() {}

  explicit UpdatePermissionRequestOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
  }


  virtual ~UpdatePermissionRequestOption() = default;
};
class UpdatePermissionRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdatePermissionRequestTenantContext() {}

  explicit UpdatePermissionRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdatePermissionRequestTenantContext() = default;
};
class UpdatePermissionRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryUuid{};
  shared_ptr<vector<UpdatePermissionRequestMembers>> members{};
  shared_ptr<UpdatePermissionRequestOption> option{};
  shared_ptr<string> roleId{};
  shared_ptr<UpdatePermissionRequestTenantContext> tenantContext{};

  UpdatePermissionRequest() {}

  explicit UpdatePermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryUuid) {
      res["DentryUuid"] = boost::any(*dentryUuid);
    }
    if (members) {
      vector<boost::any> temp1;
      for(auto item1:*members){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Members"] = boost::any(temp1);
    }
    if (option) {
      res["Option"] = option ? boost::any(option->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryUuid") != m.end() && !m["DentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["DentryUuid"]));
    }
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      if (typeid(vector<boost::any>) == m["Members"].type()) {
        vector<UpdatePermissionRequestMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Members"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdatePermissionRequestMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        members = make_shared<vector<UpdatePermissionRequestMembers>>(expect1);
      }
    }
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      if (typeid(map<string, boost::any>) == m["Option"].type()) {
        UpdatePermissionRequestOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Option"]));
        option = make_shared<UpdatePermissionRequestOption>(model1);
      }
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdatePermissionRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdatePermissionRequestTenantContext>(model1);
      }
    }
  }


  virtual ~UpdatePermissionRequest() = default;
};
class UpdatePermissionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryUuid{};
  shared_ptr<string> membersShrink{};
  shared_ptr<string> optionShrink{};
  shared_ptr<string> roleId{};
  shared_ptr<string> tenantContextShrink{};

  UpdatePermissionShrinkRequest() {}

  explicit UpdatePermissionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryUuid) {
      res["DentryUuid"] = boost::any(*dentryUuid);
    }
    if (membersShrink) {
      res["Members"] = boost::any(*membersShrink);
    }
    if (optionShrink) {
      res["Option"] = boost::any(*optionShrink);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryUuid") != m.end() && !m["DentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["DentryUuid"]));
    }
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      membersShrink = make_shared<string>(boost::any_cast<string>(m["Members"]));
    }
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      optionShrink = make_shared<string>(boost::any_cast<string>(m["Option"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~UpdatePermissionShrinkRequest() = default;
};
class UpdatePermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  UpdatePermissionResponseBody() {}

  explicit UpdatePermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~UpdatePermissionResponseBody() = default;
};
class UpdatePermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePermissionResponseBody> body{};

  UpdatePermissionResponse() {}

  explicit UpdatePermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePermissionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePermissionResponse() = default;
};
class UpdateRangeHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateRangeHeadersAccountContext() {}

  explicit UpdateRangeHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateRangeHeadersAccountContext() = default;
};
class UpdateRangeHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateRangeHeadersAccountContext> accountContext{};

  UpdateRangeHeaders() {}

  explicit UpdateRangeHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateRangeHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateRangeHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateRangeHeaders() = default;
};
class UpdateRangeShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateRangeShrinkHeaders() {}

  explicit UpdateRangeShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateRangeShrinkHeaders() = default;
};
class UpdateRangeRequestHyperlinks : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> link{};
  shared_ptr<string> text{};

  UpdateRangeRequestHyperlinks() {}

  explicit UpdateRangeRequestHyperlinks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (link) {
      res["Link"] = boost::any(*link);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Link") != m.end() && !m["Link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["Link"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~UpdateRangeRequestHyperlinks() = default;
};
class UpdateRangeRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateRangeRequestTenantContext() {}

  explicit UpdateRangeRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateRangeRequestTenantContext() = default;
};
class UpdateRangeRequest : public Darabonba::Model {
public:
  shared_ptr<vector<vector<string>>> backgroundColors{};
  shared_ptr<vector<vector<undefined>>> hyperlinks{};
  shared_ptr<string> numberFormat{};
  shared_ptr<string> rangeAddress{};
  shared_ptr<string> sheetId{};
  shared_ptr<UpdateRangeRequestTenantContext> tenantContext{};
  shared_ptr<vector<vector<string>>> values{};
  shared_ptr<string> workbookId{};

  UpdateRangeRequest() {}

  explicit UpdateRangeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backgroundColors) {
      res["BackgroundColors"] = boost::any(*backgroundColors);
    }
    if (hyperlinks) {
      vector<boost::any> temp1;
      for(auto item1:*hyperlinks){
        vector<boost::any> temp2;
        for(auto item2:item1){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1 = boost::any(temp2);
      }
      res["Hyperlinks"] = boost::any(temp1);
    }
    if (numberFormat) {
      res["NumberFormat"] = boost::any(*numberFormat);
    }
    if (rangeAddress) {
      res["RangeAddress"] = boost::any(*rangeAddress);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackgroundColors") != m.end() && !m["BackgroundColors"].empty()) {
      vector<vector<string>> toVec1;
      if (typeid(vector<boost::any>) == m["BackgroundColors"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BackgroundColors"]);
        for (auto item:vec1) {
          vector<string> toVec2;
          if (typeid(vector<boost::any>) == item.type()) {
            vector<boost::any> vec2 = boost::any_cast<vector<boost::any>>(item);
            for (auto item:vec2) {
               toVec2.push_back(boost::any_cast<string>(item));
            }
          }
           toVec1 = toVec2;
        }
      }
      backgroundColors = make_shared<vector<vector<string>>>(toVec1);
    }
    if (m.find("Hyperlinks") != m.end() && !m["Hyperlinks"].empty()) {
      if (typeid(vector<boost::any>) == m["Hyperlinks"].type()) {
        vector<vector<undefined>> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hyperlinks"])){
          if (typeid(vector<boost::any>) == item1.type()) {
            vector<undefined> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                undefined model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1.push_back(expect2);
          }
        }
        hyperlinks = make_shared<vector<vector<undefined>>>(expect1);
      }
    }
    if (m.find("NumberFormat") != m.end() && !m["NumberFormat"].empty()) {
      numberFormat = make_shared<string>(boost::any_cast<string>(m["NumberFormat"]));
    }
    if (m.find("RangeAddress") != m.end() && !m["RangeAddress"].empty()) {
      rangeAddress = make_shared<string>(boost::any_cast<string>(m["RangeAddress"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateRangeRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateRangeRequestTenantContext>(model1);
      }
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<vector<string>> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
          vector<string> toVec2;
          if (typeid(vector<boost::any>) == item.type()) {
            vector<boost::any> vec2 = boost::any_cast<vector<boost::any>>(item);
            for (auto item:vec2) {
               toVec2.push_back(boost::any_cast<string>(item));
            }
          }
           toVec1 = toVec2;
        }
      }
      values = make_shared<vector<vector<string>>>(toVec1);
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~UpdateRangeRequest() = default;
};
class UpdateRangeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> backgroundColorsShrink{};
  shared_ptr<string> hyperlinksShrink{};
  shared_ptr<string> numberFormat{};
  shared_ptr<string> rangeAddress{};
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> valuesShrink{};
  shared_ptr<string> workbookId{};

  UpdateRangeShrinkRequest() {}

  explicit UpdateRangeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backgroundColorsShrink) {
      res["BackgroundColors"] = boost::any(*backgroundColorsShrink);
    }
    if (hyperlinksShrink) {
      res["Hyperlinks"] = boost::any(*hyperlinksShrink);
    }
    if (numberFormat) {
      res["NumberFormat"] = boost::any(*numberFormat);
    }
    if (rangeAddress) {
      res["RangeAddress"] = boost::any(*rangeAddress);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (valuesShrink) {
      res["Values"] = boost::any(*valuesShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackgroundColors") != m.end() && !m["BackgroundColors"].empty()) {
      backgroundColorsShrink = make_shared<string>(boost::any_cast<string>(m["BackgroundColors"]));
    }
    if (m.find("Hyperlinks") != m.end() && !m["Hyperlinks"].empty()) {
      hyperlinksShrink = make_shared<string>(boost::any_cast<string>(m["Hyperlinks"]));
    }
    if (m.find("NumberFormat") != m.end() && !m["NumberFormat"].empty()) {
      numberFormat = make_shared<string>(boost::any_cast<string>(m["NumberFormat"]));
    }
    if (m.find("RangeAddress") != m.end() && !m["RangeAddress"].empty()) {
      rangeAddress = make_shared<string>(boost::any_cast<string>(m["RangeAddress"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      valuesShrink = make_shared<string>(boost::any_cast<string>(m["Values"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~UpdateRangeShrinkRequest() = default;
};
class UpdateRangeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> a1Notation{};
  shared_ptr<string> requestId{};

  UpdateRangeResponseBody() {}

  explicit UpdateRangeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (a1Notation) {
      res["a1Notation"] = boost::any(*a1Notation);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("a1Notation") != m.end() && !m["a1Notation"].empty()) {
      a1Notation = make_shared<string>(boost::any_cast<string>(m["a1Notation"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateRangeResponseBody() = default;
};
class UpdateRangeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRangeResponseBody> body{};

  UpdateRangeResponse() {}

  explicit UpdateRangeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRangeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRangeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRangeResponse() = default;
};
class UpdateScheduleConfSettingsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateScheduleConfSettingsHeadersAccountContext() {}

  explicit UpdateScheduleConfSettingsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateScheduleConfSettingsHeadersAccountContext() = default;
};
class UpdateScheduleConfSettingsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateScheduleConfSettingsHeadersAccountContext> accountContext{};

  UpdateScheduleConfSettingsHeaders() {}

  explicit UpdateScheduleConfSettingsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateScheduleConfSettingsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateScheduleConfSettingsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateScheduleConfSettingsHeaders() = default;
};
class UpdateScheduleConfSettingsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateScheduleConfSettingsShrinkHeaders() {}

  explicit UpdateScheduleConfSettingsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateScheduleConfSettingsShrinkHeaders() = default;
};
class UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfOpenRecordSetting : public Darabonba::Model {
public:
  shared_ptr<bool> isFollowHost{};
  shared_ptr<string> mode{};
  shared_ptr<long> recordAutoStart{};
  shared_ptr<long> recordAutoStartType{};

  UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfOpenRecordSetting() {}

  explicit UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfOpenRecordSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isFollowHost) {
      res["IsFollowHost"] = boost::any(*isFollowHost);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (recordAutoStart) {
      res["RecordAutoStart"] = boost::any(*recordAutoStart);
    }
    if (recordAutoStartType) {
      res["RecordAutoStartType"] = boost::any(*recordAutoStartType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsFollowHost") != m.end() && !m["IsFollowHost"].empty()) {
      isFollowHost = make_shared<bool>(boost::any_cast<bool>(m["IsFollowHost"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("RecordAutoStart") != m.end() && !m["RecordAutoStart"].empty()) {
      recordAutoStart = make_shared<long>(boost::any_cast<long>(m["RecordAutoStart"]));
    }
    if (m.find("RecordAutoStartType") != m.end() && !m["RecordAutoStartType"].empty()) {
      recordAutoStartType = make_shared<long>(boost::any_cast<long>(m["RecordAutoStartType"]));
    }
  }


  virtual ~UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfOpenRecordSetting() = default;
};
class UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings : public Darabonba::Model {
public:
  shared_ptr<long> autoOpenMode{};
  shared_ptr<string> coolAppCode{};
  shared_ptr<string> extensionAppBizData{};

  UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings() {}

  explicit UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoOpenMode) {
      res["AutoOpenMode"] = boost::any(*autoOpenMode);
    }
    if (coolAppCode) {
      res["CoolAppCode"] = boost::any(*coolAppCode);
    }
    if (extensionAppBizData) {
      res["ExtensionAppBizData"] = boost::any(*extensionAppBizData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoOpenMode") != m.end() && !m["AutoOpenMode"].empty()) {
      autoOpenMode = make_shared<long>(boost::any_cast<long>(m["AutoOpenMode"]));
    }
    if (m.find("CoolAppCode") != m.end() && !m["CoolAppCode"].empty()) {
      coolAppCode = make_shared<string>(boost::any_cast<string>(m["CoolAppCode"]));
    }
    if (m.find("ExtensionAppBizData") != m.end() && !m["ExtensionAppBizData"].empty()) {
      extensionAppBizData = make_shared<string>(boost::any_cast<string>(m["ExtensionAppBizData"]));
    }
  }


  virtual ~UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings() = default;
};
class UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSetting : public Darabonba::Model {
public:
  shared_ptr<string> cloudRecordOwnerUserId{};
  shared_ptr<long> enableChat{};
  shared_ptr<bool> enableWebAnonymousJoin{};
  shared_ptr<long> joinBeforeHost{};
  shared_ptr<long> lockMediaStatusMicMute{};
  shared_ptr<long> lockNick{};
  shared_ptr<string> minutesOwnerUserId{};
  shared_ptr<vector<UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings>> moziConfExtensionAppSettings{};
  shared_ptr<bool> pushAllMeetingRecords{};
  shared_ptr<bool> pushCloudRecordCard{};
  shared_ptr<bool> pushMinutesCard{};
  shared_ptr<long> waitingRoom{};

  UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSetting() {}

  explicit UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudRecordOwnerUserId) {
      res["CloudRecordOwnerUserId"] = boost::any(*cloudRecordOwnerUserId);
    }
    if (enableChat) {
      res["EnableChat"] = boost::any(*enableChat);
    }
    if (enableWebAnonymousJoin) {
      res["EnableWebAnonymousJoin"] = boost::any(*enableWebAnonymousJoin);
    }
    if (joinBeforeHost) {
      res["JoinBeforeHost"] = boost::any(*joinBeforeHost);
    }
    if (lockMediaStatusMicMute) {
      res["LockMediaStatusMicMute"] = boost::any(*lockMediaStatusMicMute);
    }
    if (lockNick) {
      res["LockNick"] = boost::any(*lockNick);
    }
    if (minutesOwnerUserId) {
      res["MinutesOwnerUserId"] = boost::any(*minutesOwnerUserId);
    }
    if (moziConfExtensionAppSettings) {
      vector<boost::any> temp1;
      for(auto item1:*moziConfExtensionAppSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MoziConfExtensionAppSettings"] = boost::any(temp1);
    }
    if (pushAllMeetingRecords) {
      res["PushAllMeetingRecords"] = boost::any(*pushAllMeetingRecords);
    }
    if (pushCloudRecordCard) {
      res["PushCloudRecordCard"] = boost::any(*pushCloudRecordCard);
    }
    if (pushMinutesCard) {
      res["PushMinutesCard"] = boost::any(*pushMinutesCard);
    }
    if (waitingRoom) {
      res["WaitingRoom"] = boost::any(*waitingRoom);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloudRecordOwnerUserId") != m.end() && !m["CloudRecordOwnerUserId"].empty()) {
      cloudRecordOwnerUserId = make_shared<string>(boost::any_cast<string>(m["CloudRecordOwnerUserId"]));
    }
    if (m.find("EnableChat") != m.end() && !m["EnableChat"].empty()) {
      enableChat = make_shared<long>(boost::any_cast<long>(m["EnableChat"]));
    }
    if (m.find("EnableWebAnonymousJoin") != m.end() && !m["EnableWebAnonymousJoin"].empty()) {
      enableWebAnonymousJoin = make_shared<bool>(boost::any_cast<bool>(m["EnableWebAnonymousJoin"]));
    }
    if (m.find("JoinBeforeHost") != m.end() && !m["JoinBeforeHost"].empty()) {
      joinBeforeHost = make_shared<long>(boost::any_cast<long>(m["JoinBeforeHost"]));
    }
    if (m.find("LockMediaStatusMicMute") != m.end() && !m["LockMediaStatusMicMute"].empty()) {
      lockMediaStatusMicMute = make_shared<long>(boost::any_cast<long>(m["LockMediaStatusMicMute"]));
    }
    if (m.find("LockNick") != m.end() && !m["LockNick"].empty()) {
      lockNick = make_shared<long>(boost::any_cast<long>(m["LockNick"]));
    }
    if (m.find("MinutesOwnerUserId") != m.end() && !m["MinutesOwnerUserId"].empty()) {
      minutesOwnerUserId = make_shared<string>(boost::any_cast<string>(m["MinutesOwnerUserId"]));
    }
    if (m.find("MoziConfExtensionAppSettings") != m.end() && !m["MoziConfExtensionAppSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["MoziConfExtensionAppSettings"].type()) {
        vector<UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MoziConfExtensionAppSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        moziConfExtensionAppSettings = make_shared<vector<UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings>>(expect1);
      }
    }
    if (m.find("PushAllMeetingRecords") != m.end() && !m["PushAllMeetingRecords"].empty()) {
      pushAllMeetingRecords = make_shared<bool>(boost::any_cast<bool>(m["PushAllMeetingRecords"]));
    }
    if (m.find("PushCloudRecordCard") != m.end() && !m["PushCloudRecordCard"].empty()) {
      pushCloudRecordCard = make_shared<bool>(boost::any_cast<bool>(m["PushCloudRecordCard"]));
    }
    if (m.find("PushMinutesCard") != m.end() && !m["PushMinutesCard"].empty()) {
      pushMinutesCard = make_shared<bool>(boost::any_cast<bool>(m["PushMinutesCard"]));
    }
    if (m.find("WaitingRoom") != m.end() && !m["WaitingRoom"].empty()) {
      waitingRoom = make_shared<long>(boost::any_cast<long>(m["WaitingRoom"]));
    }
  }


  virtual ~UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSetting() = default;
};
class UpdateScheduleConfSettingsRequestScheduleConfSettingModel : public Darabonba::Model {
public:
  shared_ptr<vector<string>> cohostUserIds{};
  shared_ptr<string> confAllowedCorpId{};
  shared_ptr<string> hostUserId{};
  shared_ptr<long> lockRoom{};
  shared_ptr<UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfOpenRecordSetting> moziConfOpenRecordSetting{};
  shared_ptr<UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSetting> moziConfVirtualExtraSetting{};
  shared_ptr<long> muteOnJoin{};
  shared_ptr<long> screenShareForbidden{};

  UpdateScheduleConfSettingsRequestScheduleConfSettingModel() {}

  explicit UpdateScheduleConfSettingsRequestScheduleConfSettingModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cohostUserIds) {
      res["CohostUserIds"] = boost::any(*cohostUserIds);
    }
    if (confAllowedCorpId) {
      res["ConfAllowedCorpId"] = boost::any(*confAllowedCorpId);
    }
    if (hostUserId) {
      res["HostUserId"] = boost::any(*hostUserId);
    }
    if (lockRoom) {
      res["LockRoom"] = boost::any(*lockRoom);
    }
    if (moziConfOpenRecordSetting) {
      res["MoziConfOpenRecordSetting"] = moziConfOpenRecordSetting ? boost::any(moziConfOpenRecordSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (moziConfVirtualExtraSetting) {
      res["MoziConfVirtualExtraSetting"] = moziConfVirtualExtraSetting ? boost::any(moziConfVirtualExtraSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muteOnJoin) {
      res["MuteOnJoin"] = boost::any(*muteOnJoin);
    }
    if (screenShareForbidden) {
      res["ScreenShareForbidden"] = boost::any(*screenShareForbidden);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CohostUserIds") != m.end() && !m["CohostUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CohostUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CohostUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cohostUserIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ConfAllowedCorpId") != m.end() && !m["ConfAllowedCorpId"].empty()) {
      confAllowedCorpId = make_shared<string>(boost::any_cast<string>(m["ConfAllowedCorpId"]));
    }
    if (m.find("HostUserId") != m.end() && !m["HostUserId"].empty()) {
      hostUserId = make_shared<string>(boost::any_cast<string>(m["HostUserId"]));
    }
    if (m.find("LockRoom") != m.end() && !m["LockRoom"].empty()) {
      lockRoom = make_shared<long>(boost::any_cast<long>(m["LockRoom"]));
    }
    if (m.find("MoziConfOpenRecordSetting") != m.end() && !m["MoziConfOpenRecordSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["MoziConfOpenRecordSetting"].type()) {
        UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfOpenRecordSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MoziConfOpenRecordSetting"]));
        moziConfOpenRecordSetting = make_shared<UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfOpenRecordSetting>(model1);
      }
    }
    if (m.find("MoziConfVirtualExtraSetting") != m.end() && !m["MoziConfVirtualExtraSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["MoziConfVirtualExtraSetting"].type()) {
        UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MoziConfVirtualExtraSetting"]));
        moziConfVirtualExtraSetting = make_shared<UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSetting>(model1);
      }
    }
    if (m.find("MuteOnJoin") != m.end() && !m["MuteOnJoin"].empty()) {
      muteOnJoin = make_shared<long>(boost::any_cast<long>(m["MuteOnJoin"]));
    }
    if (m.find("ScreenShareForbidden") != m.end() && !m["ScreenShareForbidden"].empty()) {
      screenShareForbidden = make_shared<long>(boost::any_cast<long>(m["ScreenShareForbidden"]));
    }
  }


  virtual ~UpdateScheduleConfSettingsRequestScheduleConfSettingModel() = default;
};
class UpdateScheduleConfSettingsRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateScheduleConfSettingsRequestTenantContext() {}

  explicit UpdateScheduleConfSettingsRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateScheduleConfSettingsRequestTenantContext() = default;
};
class UpdateScheduleConfSettingsRequest : public Darabonba::Model {
public:
  shared_ptr<UpdateScheduleConfSettingsRequestScheduleConfSettingModel> scheduleConfSettingModel{};
  shared_ptr<string> scheduleConferenceId{};
  shared_ptr<UpdateScheduleConfSettingsRequestTenantContext> tenantContext{};

  UpdateScheduleConfSettingsRequest() {}

  explicit UpdateScheduleConfSettingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scheduleConfSettingModel) {
      res["ScheduleConfSettingModel"] = scheduleConfSettingModel ? boost::any(scheduleConfSettingModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scheduleConferenceId) {
      res["ScheduleConferenceId"] = boost::any(*scheduleConferenceId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScheduleConfSettingModel") != m.end() && !m["ScheduleConfSettingModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfSettingModel"].type()) {
        UpdateScheduleConfSettingsRequestScheduleConfSettingModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfSettingModel"]));
        scheduleConfSettingModel = make_shared<UpdateScheduleConfSettingsRequestScheduleConfSettingModel>(model1);
      }
    }
    if (m.find("ScheduleConferenceId") != m.end() && !m["ScheduleConferenceId"].empty()) {
      scheduleConferenceId = make_shared<string>(boost::any_cast<string>(m["ScheduleConferenceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateScheduleConfSettingsRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateScheduleConfSettingsRequestTenantContext>(model1);
      }
    }
  }


  virtual ~UpdateScheduleConfSettingsRequest() = default;
};
class UpdateScheduleConfSettingsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> scheduleConfSettingModelShrink{};
  shared_ptr<string> scheduleConferenceId{};
  shared_ptr<string> tenantContextShrink{};

  UpdateScheduleConfSettingsShrinkRequest() {}

  explicit UpdateScheduleConfSettingsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scheduleConfSettingModelShrink) {
      res["ScheduleConfSettingModel"] = boost::any(*scheduleConfSettingModelShrink);
    }
    if (scheduleConferenceId) {
      res["ScheduleConferenceId"] = boost::any(*scheduleConferenceId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScheduleConfSettingModel") != m.end() && !m["ScheduleConfSettingModel"].empty()) {
      scheduleConfSettingModelShrink = make_shared<string>(boost::any_cast<string>(m["ScheduleConfSettingModel"]));
    }
    if (m.find("ScheduleConferenceId") != m.end() && !m["ScheduleConferenceId"].empty()) {
      scheduleConferenceId = make_shared<string>(boost::any_cast<string>(m["ScheduleConferenceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~UpdateScheduleConfSettingsShrinkRequest() = default;
};
class UpdateScheduleConfSettingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  UpdateScheduleConfSettingsResponseBody() {}

  explicit UpdateScheduleConfSettingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~UpdateScheduleConfSettingsResponseBody() = default;
};
class UpdateScheduleConfSettingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateScheduleConfSettingsResponseBody> body{};

  UpdateScheduleConfSettingsResponse() {}

  explicit UpdateScheduleConfSettingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateScheduleConfSettingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateScheduleConfSettingsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateScheduleConfSettingsResponse() = default;
};
class UpdateScheduleConferenceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateScheduleConferenceHeadersAccountContext() {}

  explicit UpdateScheduleConferenceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateScheduleConferenceHeadersAccountContext() = default;
};
class UpdateScheduleConferenceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateScheduleConferenceHeadersAccountContext> accountContext{};

  UpdateScheduleConferenceHeaders() {}

  explicit UpdateScheduleConferenceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateScheduleConferenceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateScheduleConferenceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateScheduleConferenceHeaders() = default;
};
class UpdateScheduleConferenceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateScheduleConferenceShrinkHeaders() {}

  explicit UpdateScheduleConferenceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateScheduleConferenceShrinkHeaders() = default;
};
class UpdateScheduleConferenceRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateScheduleConferenceRequestTenantContext() {}

  explicit UpdateScheduleConferenceRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateScheduleConferenceRequestTenantContext() = default;
};
class UpdateScheduleConferenceRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> scheduleConferenceId{};
  shared_ptr<long> startTime{};
  shared_ptr<UpdateScheduleConferenceRequestTenantContext> tenantContext{};
  shared_ptr<string> title{};

  UpdateScheduleConferenceRequest() {}

  explicit UpdateScheduleConferenceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (scheduleConferenceId) {
      res["ScheduleConferenceId"] = boost::any(*scheduleConferenceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ScheduleConferenceId") != m.end() && !m["ScheduleConferenceId"].empty()) {
      scheduleConferenceId = make_shared<string>(boost::any_cast<string>(m["ScheduleConferenceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateScheduleConferenceRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateScheduleConferenceRequestTenantContext>(model1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateScheduleConferenceRequest() = default;
};
class UpdateScheduleConferenceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> scheduleConferenceId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> title{};

  UpdateScheduleConferenceShrinkRequest() {}

  explicit UpdateScheduleConferenceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (scheduleConferenceId) {
      res["ScheduleConferenceId"] = boost::any(*scheduleConferenceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ScheduleConferenceId") != m.end() && !m["ScheduleConferenceId"].empty()) {
      scheduleConferenceId = make_shared<string>(boost::any_cast<string>(m["ScheduleConferenceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateScheduleConferenceShrinkRequest() = default;
};
class UpdateScheduleConferenceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateScheduleConferenceResponseBody() {}

  explicit UpdateScheduleConferenceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateScheduleConferenceResponseBody() = default;
};
class UpdateScheduleConferenceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateScheduleConferenceResponseBody> body{};

  UpdateScheduleConferenceResponse() {}

  explicit UpdateScheduleConferenceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateScheduleConferenceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateScheduleConferenceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateScheduleConferenceResponse() = default;
};
class UpdateStatusHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateStatusHeadersAccountContext() {}

  explicit UpdateStatusHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateStatusHeadersAccountContext() = default;
};
class UpdateStatusHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateStatusHeadersAccountContext> accountContext{};

  UpdateStatusHeaders() {}

  explicit UpdateStatusHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateStatusHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateStatusHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateStatusHeaders() = default;
};
class UpdateStatusShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateStatusShrinkHeaders() {}

  explicit UpdateStatusShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateStatusShrinkHeaders() = default;
};
class UpdateStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<vector<long>> errorLines{};
  shared_ptr<string> importSequence{};
  shared_ptr<string> language{};
  shared_ptr<string> status{};
  shared_ptr<string> systemToken{};

  UpdateStatusRequest() {}

  explicit UpdateStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (errorLines) {
      res["ErrorLines"] = boost::any(*errorLines);
    }
    if (importSequence) {
      res["ImportSequence"] = boost::any(*importSequence);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("ErrorLines") != m.end() && !m["ErrorLines"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ErrorLines"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ErrorLines"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      errorLines = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ImportSequence") != m.end() && !m["ImportSequence"].empty()) {
      importSequence = make_shared<string>(boost::any_cast<string>(m["ImportSequence"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~UpdateStatusRequest() = default;
};
class UpdateStatusShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appType{};
  shared_ptr<string> errorLinesShrink{};
  shared_ptr<string> importSequence{};
  shared_ptr<string> language{};
  shared_ptr<string> status{};
  shared_ptr<string> systemToken{};

  UpdateStatusShrinkRequest() {}

  explicit UpdateStatusShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (errorLinesShrink) {
      res["ErrorLines"] = boost::any(*errorLinesShrink);
    }
    if (importSequence) {
      res["ImportSequence"] = boost::any(*importSequence);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (systemToken) {
      res["SystemToken"] = boost::any(*systemToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<string>(boost::any_cast<string>(m["AppType"]));
    }
    if (m.find("ErrorLines") != m.end() && !m["ErrorLines"].empty()) {
      errorLinesShrink = make_shared<string>(boost::any_cast<string>(m["ErrorLines"]));
    }
    if (m.find("ImportSequence") != m.end() && !m["ImportSequence"].empty()) {
      importSequence = make_shared<string>(boost::any_cast<string>(m["ImportSequence"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SystemToken") != m.end() && !m["SystemToken"].empty()) {
      systemToken = make_shared<string>(boost::any_cast<string>(m["SystemToken"]));
    }
  }


  virtual ~UpdateStatusShrinkRequest() = default;
};
class UpdateStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  UpdateStatusResponseBody() {}

  explicit UpdateStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~UpdateStatusResponseBody() = default;
};
class UpdateStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateStatusResponseBody> body{};

  UpdateStatusResponse() {}

  explicit UpdateStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateStatusResponse() = default;
};
class UpdateSubscribedCalendarsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateSubscribedCalendarsHeadersAccountContext() {}

  explicit UpdateSubscribedCalendarsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateSubscribedCalendarsHeadersAccountContext() = default;
};
class UpdateSubscribedCalendarsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateSubscribedCalendarsHeadersAccountContext> accountContext{};

  UpdateSubscribedCalendarsHeaders() {}

  explicit UpdateSubscribedCalendarsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateSubscribedCalendarsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateSubscribedCalendarsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateSubscribedCalendarsHeaders() = default;
};
class UpdateSubscribedCalendarsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateSubscribedCalendarsShrinkHeaders() {}

  explicit UpdateSubscribedCalendarsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateSubscribedCalendarsShrinkHeaders() = default;
};
class UpdateSubscribedCalendarsRequestSubscribeScope : public Darabonba::Model {
public:
  shared_ptr<vector<string>> userIds{};

  UpdateSubscribedCalendarsRequestSubscribeScope() {}

  explicit UpdateSubscribedCalendarsRequestSubscribeScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateSubscribedCalendarsRequestSubscribeScope() = default;
};
class UpdateSubscribedCalendarsRequest : public Darabonba::Model {
public:
  shared_ptr<string> calendarId{};
  shared_ptr<string> description{};
  shared_ptr<vector<string>> managers{};
  shared_ptr<string> name{};
  shared_ptr<UpdateSubscribedCalendarsRequestSubscribeScope> subscribeScope{};

  UpdateSubscribedCalendarsRequest() {}

  explicit UpdateSubscribedCalendarsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (managers) {
      res["Managers"] = boost::any(*managers);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (subscribeScope) {
      res["SubscribeScope"] = subscribeScope ? boost::any(subscribeScope->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Managers") != m.end() && !m["Managers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Managers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Managers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      managers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SubscribeScope") != m.end() && !m["SubscribeScope"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscribeScope"].type()) {
        UpdateSubscribedCalendarsRequestSubscribeScope model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscribeScope"]));
        subscribeScope = make_shared<UpdateSubscribedCalendarsRequestSubscribeScope>(model1);
      }
    }
  }


  virtual ~UpdateSubscribedCalendarsRequest() = default;
};
class UpdateSubscribedCalendarsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> calendarId{};
  shared_ptr<string> description{};
  shared_ptr<string> managersShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> subscribeScopeShrink{};

  UpdateSubscribedCalendarsShrinkRequest() {}

  explicit UpdateSubscribedCalendarsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (managersShrink) {
      res["Managers"] = boost::any(*managersShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (subscribeScopeShrink) {
      res["SubscribeScope"] = boost::any(*subscribeScopeShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Managers") != m.end() && !m["Managers"].empty()) {
      managersShrink = make_shared<string>(boost::any_cast<string>(m["Managers"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SubscribeScope") != m.end() && !m["SubscribeScope"].empty()) {
      subscribeScopeShrink = make_shared<string>(boost::any_cast<string>(m["SubscribeScope"]));
    }
  }


  virtual ~UpdateSubscribedCalendarsShrinkRequest() = default;
};
class UpdateSubscribedCalendarsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UpdateSubscribedCalendarsResponseBody() {}

  explicit UpdateSubscribedCalendarsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~UpdateSubscribedCalendarsResponseBody() = default;
};
class UpdateSubscribedCalendarsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSubscribedCalendarsResponseBody> body{};

  UpdateSubscribedCalendarsResponse() {}

  explicit UpdateSubscribedCalendarsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSubscribedCalendarsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSubscribedCalendarsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSubscribedCalendarsResponse() = default;
};
class UpdateTodoTaskHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateTodoTaskHeadersAccountContext() {}

  explicit UpdateTodoTaskHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateTodoTaskHeadersAccountContext() = default;
};
class UpdateTodoTaskHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateTodoTaskHeadersAccountContext> accountContext{};

  UpdateTodoTaskHeaders() {}

  explicit UpdateTodoTaskHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateTodoTaskHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateTodoTaskHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateTodoTaskHeaders() = default;
};
class UpdateTodoTaskShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateTodoTaskShrinkHeaders() {}

  explicit UpdateTodoTaskShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateTodoTaskShrinkHeaders() = default;
};
class UpdateTodoTaskRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateTodoTaskRequestTenantContext() {}

  explicit UpdateTodoTaskRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateTodoTaskRequestTenantContext() = default;
};
class UpdateTodoTaskRequest : public Darabonba::Model {
public:
  shared_ptr<UpdateTodoTaskRequestTenantContext> tenantContext{};
  shared_ptr<string> description{};
  shared_ptr<bool> done{};
  shared_ptr<long> dueTime{};
  shared_ptr<vector<string>> executorIds{};
  shared_ptr<vector<string>> participantIds{};
  shared_ptr<string> subject{};
  shared_ptr<string> taskId{};

  UpdateTodoTaskRequest() {}

  explicit UpdateTodoTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (done) {
      res["done"] = boost::any(*done);
    }
    if (dueTime) {
      res["dueTime"] = boost::any(*dueTime);
    }
    if (executorIds) {
      res["executorIds"] = boost::any(*executorIds);
    }
    if (participantIds) {
      res["participantIds"] = boost::any(*participantIds);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateTodoTaskRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateTodoTaskRequestTenantContext>(model1);
      }
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("done") != m.end() && !m["done"].empty()) {
      done = make_shared<bool>(boost::any_cast<bool>(m["done"]));
    }
    if (m.find("dueTime") != m.end() && !m["dueTime"].empty()) {
      dueTime = make_shared<long>(boost::any_cast<long>(m["dueTime"]));
    }
    if (m.find("executorIds") != m.end() && !m["executorIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["executorIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["executorIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      executorIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("participantIds") != m.end() && !m["participantIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["participantIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["participantIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      participantIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
  }


  virtual ~UpdateTodoTaskRequest() = default;
};
class UpdateTodoTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> description{};
  shared_ptr<bool> done{};
  shared_ptr<long> dueTime{};
  shared_ptr<string> executorIdsShrink{};
  shared_ptr<string> participantIdsShrink{};
  shared_ptr<string> subject{};
  shared_ptr<string> taskId{};

  UpdateTodoTaskShrinkRequest() {}

  explicit UpdateTodoTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (done) {
      res["done"] = boost::any(*done);
    }
    if (dueTime) {
      res["dueTime"] = boost::any(*dueTime);
    }
    if (executorIdsShrink) {
      res["executorIds"] = boost::any(*executorIdsShrink);
    }
    if (participantIdsShrink) {
      res["participantIds"] = boost::any(*participantIdsShrink);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("done") != m.end() && !m["done"].empty()) {
      done = make_shared<bool>(boost::any_cast<bool>(m["done"]));
    }
    if (m.find("dueTime") != m.end() && !m["dueTime"].empty()) {
      dueTime = make_shared<long>(boost::any_cast<long>(m["dueTime"]));
    }
    if (m.find("executorIds") != m.end() && !m["executorIds"].empty()) {
      executorIdsShrink = make_shared<string>(boost::any_cast<string>(m["executorIds"]));
    }
    if (m.find("participantIds") != m.end() && !m["participantIds"].empty()) {
      participantIdsShrink = make_shared<string>(boost::any_cast<string>(m["participantIds"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
  }


  virtual ~UpdateTodoTaskShrinkRequest() = default;
};
class UpdateTodoTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UpdateTodoTaskResponseBody() {}

  explicit UpdateTodoTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~UpdateTodoTaskResponseBody() = default;
};
class UpdateTodoTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTodoTaskResponseBody> body{};

  UpdateTodoTaskResponse() {}

  explicit UpdateTodoTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTodoTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTodoTaskResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTodoTaskResponse() = default;
};
class UpdateTodoTaskExecutorStatusHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateTodoTaskExecutorStatusHeadersAccountContext() {}

  explicit UpdateTodoTaskExecutorStatusHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateTodoTaskExecutorStatusHeadersAccountContext() = default;
};
class UpdateTodoTaskExecutorStatusHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateTodoTaskExecutorStatusHeadersAccountContext> accountContext{};

  UpdateTodoTaskExecutorStatusHeaders() {}

  explicit UpdateTodoTaskExecutorStatusHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateTodoTaskExecutorStatusHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateTodoTaskExecutorStatusHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateTodoTaskExecutorStatusHeaders() = default;
};
class UpdateTodoTaskExecutorStatusShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateTodoTaskExecutorStatusShrinkHeaders() {}

  explicit UpdateTodoTaskExecutorStatusShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateTodoTaskExecutorStatusShrinkHeaders() = default;
};
class UpdateTodoTaskExecutorStatusRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateTodoTaskExecutorStatusRequestTenantContext() {}

  explicit UpdateTodoTaskExecutorStatusRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateTodoTaskExecutorStatusRequestTenantContext() = default;
};
class UpdateTodoTaskExecutorStatusRequestExecutorStatusList : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<bool> isDone{};

  UpdateTodoTaskExecutorStatusRequestExecutorStatusList() {}

  explicit UpdateTodoTaskExecutorStatusRequestExecutorStatusList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isDone) {
      res["isDone"] = boost::any(*isDone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("isDone") != m.end() && !m["isDone"].empty()) {
      isDone = make_shared<bool>(boost::any_cast<bool>(m["isDone"]));
    }
  }


  virtual ~UpdateTodoTaskExecutorStatusRequestExecutorStatusList() = default;
};
class UpdateTodoTaskExecutorStatusRequest : public Darabonba::Model {
public:
  shared_ptr<UpdateTodoTaskExecutorStatusRequestTenantContext> tenantContext{};
  shared_ptr<vector<UpdateTodoTaskExecutorStatusRequestExecutorStatusList>> executorStatusList{};
  shared_ptr<string> operatorId{};
  shared_ptr<string> taskId{};

  UpdateTodoTaskExecutorStatusRequest() {}

  explicit UpdateTodoTaskExecutorStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (executorStatusList) {
      vector<boost::any> temp1;
      for(auto item1:*executorStatusList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["executorStatusList"] = boost::any(temp1);
    }
    if (operatorId) {
      res["operatorId"] = boost::any(*operatorId);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateTodoTaskExecutorStatusRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateTodoTaskExecutorStatusRequestTenantContext>(model1);
      }
    }
    if (m.find("executorStatusList") != m.end() && !m["executorStatusList"].empty()) {
      if (typeid(vector<boost::any>) == m["executorStatusList"].type()) {
        vector<UpdateTodoTaskExecutorStatusRequestExecutorStatusList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["executorStatusList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTodoTaskExecutorStatusRequestExecutorStatusList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        executorStatusList = make_shared<vector<UpdateTodoTaskExecutorStatusRequestExecutorStatusList>>(expect1);
      }
    }
    if (m.find("operatorId") != m.end() && !m["operatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["operatorId"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
  }


  virtual ~UpdateTodoTaskExecutorStatusRequest() = default;
};
class UpdateTodoTaskExecutorStatusShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> executorStatusListShrink{};
  shared_ptr<string> operatorId{};
  shared_ptr<string> taskId{};

  UpdateTodoTaskExecutorStatusShrinkRequest() {}

  explicit UpdateTodoTaskExecutorStatusShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (executorStatusListShrink) {
      res["executorStatusList"] = boost::any(*executorStatusListShrink);
    }
    if (operatorId) {
      res["operatorId"] = boost::any(*operatorId);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("executorStatusList") != m.end() && !m["executorStatusList"].empty()) {
      executorStatusListShrink = make_shared<string>(boost::any_cast<string>(m["executorStatusList"]));
    }
    if (m.find("operatorId") != m.end() && !m["operatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["operatorId"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
  }


  virtual ~UpdateTodoTaskExecutorStatusShrinkRequest() = default;
};
class UpdateTodoTaskExecutorStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UpdateTodoTaskExecutorStatusResponseBody() {}

  explicit UpdateTodoTaskExecutorStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~UpdateTodoTaskExecutorStatusResponseBody() = default;
};
class UpdateTodoTaskExecutorStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTodoTaskExecutorStatusResponseBody> body{};

  UpdateTodoTaskExecutorStatusResponse() {}

  explicit UpdateTodoTaskExecutorStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTodoTaskExecutorStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTodoTaskExecutorStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTodoTaskExecutorStatusResponse() = default;
};
class UpdateUserAvatarHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateUserAvatarHeadersAccountContext() {}

  explicit UpdateUserAvatarHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateUserAvatarHeadersAccountContext() = default;
};
class UpdateUserAvatarHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateUserAvatarHeadersAccountContext> accountContext{};

  UpdateUserAvatarHeaders() {}

  explicit UpdateUserAvatarHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateUserAvatarHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateUserAvatarHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateUserAvatarHeaders() = default;
};
class UpdateUserAvatarShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateUserAvatarShrinkHeaders() {}

  explicit UpdateUserAvatarShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateUserAvatarShrinkHeaders() = default;
};
class UpdateUserAvatarRequest : public Darabonba::Model {
public:
  shared_ptr<string> avatarMediaId{};

  UpdateUserAvatarRequest() {}

  explicit UpdateUserAvatarRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarMediaId) {
      res["AvatarMediaId"] = boost::any(*avatarMediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvatarMediaId") != m.end() && !m["AvatarMediaId"].empty()) {
      avatarMediaId = make_shared<string>(boost::any_cast<string>(m["AvatarMediaId"]));
    }
  }


  virtual ~UpdateUserAvatarRequest() = default;
};
class UpdateUserAvatarResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errcode{};
  shared_ptr<string> errmsg{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  UpdateUserAvatarResponseBody() {}

  explicit UpdateUserAvatarResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errcode) {
      res["errcode"] = boost::any(*errcode);
    }
    if (errmsg) {
      res["errmsg"] = boost::any(*errmsg);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errcode") != m.end() && !m["errcode"].empty()) {
      errcode = make_shared<string>(boost::any_cast<string>(m["errcode"]));
    }
    if (m.find("errmsg") != m.end() && !m["errmsg"].empty()) {
      errmsg = make_shared<string>(boost::any_cast<string>(m["errmsg"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~UpdateUserAvatarResponseBody() = default;
};
class UpdateUserAvatarResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateUserAvatarResponseBody> body{};

  UpdateUserAvatarResponse() {}

  explicit UpdateUserAvatarResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateUserAvatarResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateUserAvatarResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateUserAvatarResponse() = default;
};
class UpdateVideoConferenceSettingHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateVideoConferenceSettingHeadersAccountContext() {}

  explicit UpdateVideoConferenceSettingHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateVideoConferenceSettingHeadersAccountContext() = default;
};
class UpdateVideoConferenceSettingHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateVideoConferenceSettingHeadersAccountContext> accountContext{};

  UpdateVideoConferenceSettingHeaders() {}

  explicit UpdateVideoConferenceSettingHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateVideoConferenceSettingHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateVideoConferenceSettingHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateVideoConferenceSettingHeaders() = default;
};
class UpdateVideoConferenceSettingShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateVideoConferenceSettingShrinkHeaders() {}

  explicit UpdateVideoConferenceSettingShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateVideoConferenceSettingShrinkHeaders() = default;
};
class UpdateVideoConferenceSettingRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateVideoConferenceSettingRequestTenantContext() {}

  explicit UpdateVideoConferenceSettingRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateVideoConferenceSettingRequestTenantContext() = default;
};
class UpdateVideoConferenceSettingRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allowUnmuteSelf{};
  shared_ptr<bool> autoTransferHost{};
  shared_ptr<bool> forbiddenShareScreen{};
  shared_ptr<bool> lockConference{};
  shared_ptr<bool> muteAll{};
  shared_ptr<bool> onlyInternalEmployeesJoin{};
  shared_ptr<UpdateVideoConferenceSettingRequestTenantContext> tenantContext{};
  shared_ptr<string> conferenceId{};

  UpdateVideoConferenceSettingRequest() {}

  explicit UpdateVideoConferenceSettingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowUnmuteSelf) {
      res["AllowUnmuteSelf"] = boost::any(*allowUnmuteSelf);
    }
    if (autoTransferHost) {
      res["AutoTransferHost"] = boost::any(*autoTransferHost);
    }
    if (forbiddenShareScreen) {
      res["ForbiddenShareScreen"] = boost::any(*forbiddenShareScreen);
    }
    if (lockConference) {
      res["LockConference"] = boost::any(*lockConference);
    }
    if (muteAll) {
      res["MuteAll"] = boost::any(*muteAll);
    }
    if (onlyInternalEmployeesJoin) {
      res["OnlyInternalEmployeesJoin"] = boost::any(*onlyInternalEmployeesJoin);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowUnmuteSelf") != m.end() && !m["AllowUnmuteSelf"].empty()) {
      allowUnmuteSelf = make_shared<bool>(boost::any_cast<bool>(m["AllowUnmuteSelf"]));
    }
    if (m.find("AutoTransferHost") != m.end() && !m["AutoTransferHost"].empty()) {
      autoTransferHost = make_shared<bool>(boost::any_cast<bool>(m["AutoTransferHost"]));
    }
    if (m.find("ForbiddenShareScreen") != m.end() && !m["ForbiddenShareScreen"].empty()) {
      forbiddenShareScreen = make_shared<bool>(boost::any_cast<bool>(m["ForbiddenShareScreen"]));
    }
    if (m.find("LockConference") != m.end() && !m["LockConference"].empty()) {
      lockConference = make_shared<bool>(boost::any_cast<bool>(m["LockConference"]));
    }
    if (m.find("MuteAll") != m.end() && !m["MuteAll"].empty()) {
      muteAll = make_shared<bool>(boost::any_cast<bool>(m["MuteAll"]));
    }
    if (m.find("OnlyInternalEmployeesJoin") != m.end() && !m["OnlyInternalEmployeesJoin"].empty()) {
      onlyInternalEmployeesJoin = make_shared<bool>(boost::any_cast<bool>(m["OnlyInternalEmployeesJoin"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateVideoConferenceSettingRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateVideoConferenceSettingRequestTenantContext>(model1);
      }
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~UpdateVideoConferenceSettingRequest() = default;
};
class UpdateVideoConferenceSettingShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allowUnmuteSelf{};
  shared_ptr<bool> autoTransferHost{};
  shared_ptr<bool> forbiddenShareScreen{};
  shared_ptr<bool> lockConference{};
  shared_ptr<bool> muteAll{};
  shared_ptr<bool> onlyInternalEmployeesJoin{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> conferenceId{};

  UpdateVideoConferenceSettingShrinkRequest() {}

  explicit UpdateVideoConferenceSettingShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowUnmuteSelf) {
      res["AllowUnmuteSelf"] = boost::any(*allowUnmuteSelf);
    }
    if (autoTransferHost) {
      res["AutoTransferHost"] = boost::any(*autoTransferHost);
    }
    if (forbiddenShareScreen) {
      res["ForbiddenShareScreen"] = boost::any(*forbiddenShareScreen);
    }
    if (lockConference) {
      res["LockConference"] = boost::any(*lockConference);
    }
    if (muteAll) {
      res["MuteAll"] = boost::any(*muteAll);
    }
    if (onlyInternalEmployeesJoin) {
      res["OnlyInternalEmployeesJoin"] = boost::any(*onlyInternalEmployeesJoin);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowUnmuteSelf") != m.end() && !m["AllowUnmuteSelf"].empty()) {
      allowUnmuteSelf = make_shared<bool>(boost::any_cast<bool>(m["AllowUnmuteSelf"]));
    }
    if (m.find("AutoTransferHost") != m.end() && !m["AutoTransferHost"].empty()) {
      autoTransferHost = make_shared<bool>(boost::any_cast<bool>(m["AutoTransferHost"]));
    }
    if (m.find("ForbiddenShareScreen") != m.end() && !m["ForbiddenShareScreen"].empty()) {
      forbiddenShareScreen = make_shared<bool>(boost::any_cast<bool>(m["ForbiddenShareScreen"]));
    }
    if (m.find("LockConference") != m.end() && !m["LockConference"].empty()) {
      lockConference = make_shared<bool>(boost::any_cast<bool>(m["LockConference"]));
    }
    if (m.find("MuteAll") != m.end() && !m["MuteAll"].empty()) {
      muteAll = make_shared<bool>(boost::any_cast<bool>(m["MuteAll"]));
    }
    if (m.find("OnlyInternalEmployeesJoin") != m.end() && !m["OnlyInternalEmployeesJoin"].empty()) {
      onlyInternalEmployeesJoin = make_shared<bool>(boost::any_cast<bool>(m["OnlyInternalEmployeesJoin"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~UpdateVideoConferenceSettingShrinkRequest() = default;
};
class UpdateVideoConferenceSettingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> caseResult{};
  shared_ptr<string> code{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vendorRequestId{};
  shared_ptr<string> vendorType{};

  UpdateVideoConferenceSettingResponseBody() {}

  explicit UpdateVideoConferenceSettingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caseResult) {
      res["caseResult"] = boost::any(*caseResult);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (vendorRequestId) {
      res["vendorRequestId"] = boost::any(*vendorRequestId);
    }
    if (vendorType) {
      res["vendorType"] = boost::any(*vendorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("caseResult") != m.end() && !m["caseResult"].empty()) {
      caseResult = make_shared<string>(boost::any_cast<string>(m["caseResult"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("vendorRequestId") != m.end() && !m["vendorRequestId"].empty()) {
      vendorRequestId = make_shared<string>(boost::any_cast<string>(m["vendorRequestId"]));
    }
    if (m.find("vendorType") != m.end() && !m["vendorType"].empty()) {
      vendorType = make_shared<string>(boost::any_cast<string>(m["vendorType"]));
    }
  }


  virtual ~UpdateVideoConferenceSettingResponseBody() = default;
};
class UpdateVideoConferenceSettingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateVideoConferenceSettingResponseBody> body{};

  UpdateVideoConferenceSettingResponse() {}

  explicit UpdateVideoConferenceSettingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateVideoConferenceSettingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateVideoConferenceSettingResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateVideoConferenceSettingResponse() = default;
};
class UpdateWorkspaceDocMembersHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateWorkspaceDocMembersHeadersAccountContext() {}

  explicit UpdateWorkspaceDocMembersHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateWorkspaceDocMembersHeadersAccountContext() = default;
};
class UpdateWorkspaceDocMembersHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateWorkspaceDocMembersHeadersAccountContext> accountContext{};

  UpdateWorkspaceDocMembersHeaders() {}

  explicit UpdateWorkspaceDocMembersHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateWorkspaceDocMembersHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateWorkspaceDocMembersHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateWorkspaceDocMembersHeaders() = default;
};
class UpdateWorkspaceDocMembersShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateWorkspaceDocMembersShrinkHeaders() {}

  explicit UpdateWorkspaceDocMembersShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateWorkspaceDocMembersShrinkHeaders() = default;
};
class UpdateWorkspaceDocMembersRequestMembers : public Darabonba::Model {
public:
  shared_ptr<string> memberId{};
  shared_ptr<string> memberType{};
  shared_ptr<string> roleType{};

  UpdateWorkspaceDocMembersRequestMembers() {}

  explicit UpdateWorkspaceDocMembersRequestMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberId) {
      res["MemberId"] = boost::any(*memberId);
    }
    if (memberType) {
      res["MemberType"] = boost::any(*memberType);
    }
    if (roleType) {
      res["RoleType"] = boost::any(*roleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemberId") != m.end() && !m["MemberId"].empty()) {
      memberId = make_shared<string>(boost::any_cast<string>(m["MemberId"]));
    }
    if (m.find("MemberType") != m.end() && !m["MemberType"].empty()) {
      memberType = make_shared<string>(boost::any_cast<string>(m["MemberType"]));
    }
    if (m.find("RoleType") != m.end() && !m["RoleType"].empty()) {
      roleType = make_shared<string>(boost::any_cast<string>(m["RoleType"]));
    }
  }


  virtual ~UpdateWorkspaceDocMembersRequestMembers() = default;
};
class UpdateWorkspaceDocMembersRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateWorkspaceDocMembersRequestTenantContext() {}

  explicit UpdateWorkspaceDocMembersRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateWorkspaceDocMembersRequestTenantContext() = default;
};
class UpdateWorkspaceDocMembersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateWorkspaceDocMembersRequestMembers>> members{};
  shared_ptr<string> nodeId{};
  shared_ptr<UpdateWorkspaceDocMembersRequestTenantContext> tenantContext{};
  shared_ptr<string> workspaceId{};

  UpdateWorkspaceDocMembersRequest() {}

  explicit UpdateWorkspaceDocMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (members) {
      vector<boost::any> temp1;
      for(auto item1:*members){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Members"] = boost::any(temp1);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      if (typeid(vector<boost::any>) == m["Members"].type()) {
        vector<UpdateWorkspaceDocMembersRequestMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Members"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWorkspaceDocMembersRequestMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        members = make_shared<vector<UpdateWorkspaceDocMembersRequestMembers>>(expect1);
      }
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateWorkspaceDocMembersRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateWorkspaceDocMembersRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~UpdateWorkspaceDocMembersRequest() = default;
};
class UpdateWorkspaceDocMembersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> membersShrink{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workspaceId{};

  UpdateWorkspaceDocMembersShrinkRequest() {}

  explicit UpdateWorkspaceDocMembersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (membersShrink) {
      res["Members"] = boost::any(*membersShrink);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      membersShrink = make_shared<string>(boost::any_cast<string>(m["Members"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~UpdateWorkspaceDocMembersShrinkRequest() = default;
};
class UpdateWorkspaceDocMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateWorkspaceDocMembersResponseBody() {}

  explicit UpdateWorkspaceDocMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateWorkspaceDocMembersResponseBody() = default;
};
class UpdateWorkspaceDocMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateWorkspaceDocMembersResponseBody> body{};

  UpdateWorkspaceDocMembersResponse() {}

  explicit UpdateWorkspaceDocMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWorkspaceDocMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWorkspaceDocMembersResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateWorkspaceDocMembersResponse() = default;
};
class UpdateWorkspaceMembersHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateWorkspaceMembersHeadersAccountContext() {}

  explicit UpdateWorkspaceMembersHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateWorkspaceMembersHeadersAccountContext() = default;
};
class UpdateWorkspaceMembersHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateWorkspaceMembersHeadersAccountContext> accountContext{};

  UpdateWorkspaceMembersHeaders() {}

  explicit UpdateWorkspaceMembersHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateWorkspaceMembersHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateWorkspaceMembersHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateWorkspaceMembersHeaders() = default;
};
class UpdateWorkspaceMembersShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateWorkspaceMembersShrinkHeaders() {}

  explicit UpdateWorkspaceMembersShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateWorkspaceMembersShrinkHeaders() = default;
};
class UpdateWorkspaceMembersRequestMembers : public Darabonba::Model {
public:
  shared_ptr<string> memberId{};
  shared_ptr<string> memberType{};
  shared_ptr<string> roleType{};

  UpdateWorkspaceMembersRequestMembers() {}

  explicit UpdateWorkspaceMembersRequestMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberId) {
      res["MemberId"] = boost::any(*memberId);
    }
    if (memberType) {
      res["MemberType"] = boost::any(*memberType);
    }
    if (roleType) {
      res["RoleType"] = boost::any(*roleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemberId") != m.end() && !m["MemberId"].empty()) {
      memberId = make_shared<string>(boost::any_cast<string>(m["MemberId"]));
    }
    if (m.find("MemberType") != m.end() && !m["MemberType"].empty()) {
      memberType = make_shared<string>(boost::any_cast<string>(m["MemberType"]));
    }
    if (m.find("RoleType") != m.end() && !m["RoleType"].empty()) {
      roleType = make_shared<string>(boost::any_cast<string>(m["RoleType"]));
    }
  }


  virtual ~UpdateWorkspaceMembersRequestMembers() = default;
};
class UpdateWorkspaceMembersRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateWorkspaceMembersRequestTenantContext() {}

  explicit UpdateWorkspaceMembersRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateWorkspaceMembersRequestTenantContext() = default;
};
class UpdateWorkspaceMembersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateWorkspaceMembersRequestMembers>> members{};
  shared_ptr<UpdateWorkspaceMembersRequestTenantContext> tenantContext{};
  shared_ptr<string> workspaceId{};

  UpdateWorkspaceMembersRequest() {}

  explicit UpdateWorkspaceMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (members) {
      vector<boost::any> temp1;
      for(auto item1:*members){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Members"] = boost::any(temp1);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      if (typeid(vector<boost::any>) == m["Members"].type()) {
        vector<UpdateWorkspaceMembersRequestMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Members"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWorkspaceMembersRequestMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        members = make_shared<vector<UpdateWorkspaceMembersRequestMembers>>(expect1);
      }
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateWorkspaceMembersRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateWorkspaceMembersRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~UpdateWorkspaceMembersRequest() = default;
};
class UpdateWorkspaceMembersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> membersShrink{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workspaceId{};

  UpdateWorkspaceMembersShrinkRequest() {}

  explicit UpdateWorkspaceMembersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (membersShrink) {
      res["Members"] = boost::any(*membersShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      membersShrink = make_shared<string>(boost::any_cast<string>(m["Members"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~UpdateWorkspaceMembersShrinkRequest() = default;
};
class UpdateWorkspaceMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateWorkspaceMembersResponseBody() {}

  explicit UpdateWorkspaceMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateWorkspaceMembersResponseBody() = default;
};
class UpdateWorkspaceMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateWorkspaceMembersResponseBody> body{};

  UpdateWorkspaceMembersResponse() {}

  explicit UpdateWorkspaceMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWorkspaceMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWorkspaceMembersResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateWorkspaceMembersResponse() = default;
};
class UploadMediaHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UploadMediaHeadersAccountContext() {}

  explicit UploadMediaHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UploadMediaHeadersAccountContext() = default;
};
class UploadMediaHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UploadMediaHeadersAccountContext> accountContext{};

  UploadMediaHeaders() {}

  explicit UploadMediaHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UploadMediaHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UploadMediaHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UploadMediaHeaders() = default;
};
class UploadMediaShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UploadMediaShrinkHeaders() {}

  explicit UploadMediaShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UploadMediaShrinkHeaders() = default;
};
class UploadMediaRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UploadMediaRequestTenantContext() {}

  explicit UploadMediaRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UploadMediaRequestTenantContext() = default;
};
class UploadMediaRequest : public Darabonba::Model {
public:
  shared_ptr<UploadMediaRequestTenantContext> tenantContext{};
  shared_ptr<string> mediaName{};
  shared_ptr<string> mediaType{};
  shared_ptr<long> orgId{};
  shared_ptr<string> url{};

  UploadMediaRequest() {}

  explicit UploadMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaName) {
      res["mediaName"] = boost::any(*mediaName);
    }
    if (mediaType) {
      res["mediaType"] = boost::any(*mediaType);
    }
    if (orgId) {
      res["orgId"] = boost::any(*orgId);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UploadMediaRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UploadMediaRequestTenantContext>(model1);
      }
    }
    if (m.find("mediaName") != m.end() && !m["mediaName"].empty()) {
      mediaName = make_shared<string>(boost::any_cast<string>(m["mediaName"]));
    }
    if (m.find("mediaType") != m.end() && !m["mediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["mediaType"]));
    }
    if (m.find("orgId") != m.end() && !m["orgId"].empty()) {
      orgId = make_shared<long>(boost::any_cast<long>(m["orgId"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~UploadMediaRequest() = default;
};
class UploadMediaShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> mediaName{};
  shared_ptr<string> mediaType{};
  shared_ptr<long> orgId{};
  shared_ptr<string> url{};

  UploadMediaShrinkRequest() {}

  explicit UploadMediaShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (mediaName) {
      res["mediaName"] = boost::any(*mediaName);
    }
    if (mediaType) {
      res["mediaType"] = boost::any(*mediaType);
    }
    if (orgId) {
      res["orgId"] = boost::any(*orgId);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("mediaName") != m.end() && !m["mediaName"].empty()) {
      mediaName = make_shared<string>(boost::any_cast<string>(m["mediaName"]));
    }
    if (m.find("mediaType") != m.end() && !m["mediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["mediaType"]));
    }
    if (m.find("orgId") != m.end() && !m["orgId"].empty()) {
      orgId = make_shared<long>(boost::any_cast<long>(m["orgId"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~UploadMediaShrinkRequest() = default;
};
class UploadMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> requestId{};

  UploadMediaResponseBody() {}

  explicit UploadMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["mediaId"] = boost::any(*mediaId);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("mediaId") != m.end() && !m["mediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["mediaId"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UploadMediaResponseBody() = default;
};
class UploadMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadMediaResponseBody> body{};

  UploadMediaResponse() {}

  explicit UploadMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadMediaResponseBody>(model1);
      }
    }
  }


  virtual ~UploadMediaResponse() = default;
};
class WearOrgHonorHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  WearOrgHonorHeadersAccountContext() {}

  explicit WearOrgHonorHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~WearOrgHonorHeadersAccountContext() = default;
};
class WearOrgHonorHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<WearOrgHonorHeadersAccountContext> accountContext{};

  WearOrgHonorHeaders() {}

  explicit WearOrgHonorHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        WearOrgHonorHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<WearOrgHonorHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~WearOrgHonorHeaders() = default;
};
class WearOrgHonorShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  WearOrgHonorShrinkHeaders() {}

  explicit WearOrgHonorShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~WearOrgHonorShrinkHeaders() = default;
};
class WearOrgHonorRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  WearOrgHonorRequestTenantContext() {}

  explicit WearOrgHonorRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~WearOrgHonorRequestTenantContext() = default;
};
class WearOrgHonorRequest : public Darabonba::Model {
public:
  shared_ptr<WearOrgHonorRequestTenantContext> tenantContext{};
  shared_ptr<string> honorId{};
  shared_ptr<long> orgId{};
  shared_ptr<string> userId{};
  shared_ptr<bool> wear{};

  WearOrgHonorRequest() {}

  explicit WearOrgHonorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (honorId) {
      res["honorId"] = boost::any(*honorId);
    }
    if (orgId) {
      res["orgId"] = boost::any(*orgId);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (wear) {
      res["wear"] = boost::any(*wear);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        WearOrgHonorRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<WearOrgHonorRequestTenantContext>(model1);
      }
    }
    if (m.find("honorId") != m.end() && !m["honorId"].empty()) {
      honorId = make_shared<string>(boost::any_cast<string>(m["honorId"]));
    }
    if (m.find("orgId") != m.end() && !m["orgId"].empty()) {
      orgId = make_shared<long>(boost::any_cast<long>(m["orgId"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
    if (m.find("wear") != m.end() && !m["wear"].empty()) {
      wear = make_shared<bool>(boost::any_cast<bool>(m["wear"]));
    }
  }


  virtual ~WearOrgHonorRequest() = default;
};
class WearOrgHonorShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> honorId{};
  shared_ptr<long> orgId{};
  shared_ptr<string> userId{};
  shared_ptr<bool> wear{};

  WearOrgHonorShrinkRequest() {}

  explicit WearOrgHonorShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (honorId) {
      res["honorId"] = boost::any(*honorId);
    }
    if (orgId) {
      res["orgId"] = boost::any(*orgId);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (wear) {
      res["wear"] = boost::any(*wear);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("honorId") != m.end() && !m["honorId"].empty()) {
      honorId = make_shared<string>(boost::any_cast<string>(m["honorId"]));
    }
    if (m.find("orgId") != m.end() && !m["orgId"].empty()) {
      orgId = make_shared<long>(boost::any_cast<long>(m["orgId"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
    if (m.find("wear") != m.end() && !m["wear"].empty()) {
      wear = make_shared<bool>(boost::any_cast<bool>(m["wear"]));
    }
  }


  virtual ~WearOrgHonorShrinkRequest() = default;
};
class WearOrgHonorResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};

  WearOrgHonorResponseBodyContent() {}

  explicit WearOrgHonorResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["data"]));
    }
  }


  virtual ~WearOrgHonorResponseBodyContent() = default;
};
class WearOrgHonorResponseBody : public Darabonba::Model {
public:
  shared_ptr<WearOrgHonorResponseBodyContent> content{};
  shared_ptr<string> errorCode{};
  shared_ptr<map<string, boost::any>> errorCtx{};
  shared_ptr<string> errorMsg{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  WearOrgHonorResponseBody() {}

  explicit WearOrgHonorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorCtx) {
      res["errorCtx"] = boost::any(*errorCtx);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      if (typeid(map<string, boost::any>) == m["content"].type()) {
        WearOrgHonorResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["content"]));
        content = make_shared<WearOrgHonorResponseBodyContent>(model1);
      }
    }
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorCtx") != m.end() && !m["errorCtx"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["errorCtx"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      errorCtx = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["httpStatusCode"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~WearOrgHonorResponseBody() = default;
};
class WearOrgHonorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WearOrgHonorResponseBody> body{};

  WearOrgHonorResponse() {}

  explicit WearOrgHonorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WearOrgHonorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WearOrgHonorResponseBody>(model1);
      }
    }
  }


  virtual ~WearOrgHonorResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddAttendeeResponse addAttendeeWithOptions(shared_ptr<AddAttendeeRequest> tmpReq, shared_ptr<AddAttendeeHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddAttendeeResponse addAttendee(shared_ptr<AddAttendeeRequest> request);
  AddDriveSpaceResponse addDriveSpaceWithOptions(shared_ptr<AddDriveSpaceRequest> tmpReq, shared_ptr<AddDriveSpaceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDriveSpaceResponse addDriveSpace(shared_ptr<AddDriveSpaceRequest> request);
  AddFolderResponse addFolderWithOptions(shared_ptr<AddFolderRequest> tmpReq, shared_ptr<AddFolderHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddFolderResponse addFolder(shared_ptr<AddFolderRequest> request);
  AddMeetingRoomsResponse addMeetingRoomsWithOptions(shared_ptr<AddMeetingRoomsRequest> tmpReq, shared_ptr<AddMeetingRoomsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddMeetingRoomsResponse addMeetingRooms(shared_ptr<AddMeetingRoomsRequest> request);
  AddMultiDimTableResponse addMultiDimTableWithOptions(shared_ptr<AddMultiDimTableRequest> tmpReq, shared_ptr<AddMultiDimTableHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddMultiDimTableResponse addMultiDimTable(shared_ptr<AddMultiDimTableRequest> request);
  AddPermissionResponse addPermissionWithOptions(shared_ptr<AddPermissionRequest> tmpReq, shared_ptr<AddPermissionHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPermissionResponse addPermission(shared_ptr<AddPermissionRequest> request);
  AddRecordPermissionResponse addRecordPermissionWithOptions(shared_ptr<AddRecordPermissionRequest> tmpReq, shared_ptr<AddRecordPermissionHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddRecordPermissionResponse addRecordPermission(shared_ptr<AddRecordPermissionRequest> request);
  AddScenegroupMemberResponse addScenegroupMemberWithOptions(shared_ptr<AddScenegroupMemberRequest> request, shared_ptr<AddScenegroupMemberHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddScenegroupMemberResponse addScenegroupMember(shared_ptr<AddScenegroupMemberRequest> request);
  AddTicketMemoResponse addTicketMemoWithOptions(shared_ptr<AddTicketMemoRequest> tmpReq, shared_ptr<AddTicketMemoHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddTicketMemoResponse addTicketMemo(shared_ptr<AddTicketMemoRequest> request);
  AddWorkspaceResponse addWorkspaceWithOptions(shared_ptr<AddWorkspaceRequest> tmpReq, shared_ptr<AddWorkspaceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddWorkspaceResponse addWorkspace(shared_ptr<AddWorkspaceRequest> request);
  AddWorkspaceDocMembersResponse addWorkspaceDocMembersWithOptions(shared_ptr<AddWorkspaceDocMembersRequest> tmpReq, shared_ptr<AddWorkspaceDocMembersHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddWorkspaceDocMembersResponse addWorkspaceDocMembers(shared_ptr<AddWorkspaceDocMembersRequest> request);
  AddWorkspaceMembersResponse addWorkspaceMembersWithOptions(shared_ptr<AddWorkspaceMembersRequest> tmpReq, shared_ptr<AddWorkspaceMembersHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddWorkspaceMembersResponse addWorkspaceMembers(shared_ptr<AddWorkspaceMembersRequest> request);
  AssignTicketResponse assignTicketWithOptions(shared_ptr<AssignTicketRequest> tmpReq, shared_ptr<AssignTicketHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssignTicketResponse assignTicket(shared_ptr<AssignTicketRequest> request);
  AuthorizeSkillResponse authorizeSkillWithOptions(shared_ptr<AuthorizeSkillRequest> tmpReq, shared_ptr<AuthorizeSkillHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AuthorizeSkillResponse authorizeSkill(shared_ptr<AuthorizeSkillRequest> request);
  BatchGetFormDataByIdListResponse batchGetFormDataByIdListWithOptions(shared_ptr<BatchGetFormDataByIdListRequest> tmpReq, shared_ptr<BatchGetFormDataByIdListHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetFormDataByIdListResponse batchGetFormDataByIdList(shared_ptr<BatchGetFormDataByIdListRequest> request);
  BatchRemovalByFormInstanceIdListResponse batchRemovalByFormInstanceIdListWithOptions(shared_ptr<BatchRemovalByFormInstanceIdListRequest> tmpReq, shared_ptr<BatchRemovalByFormInstanceIdListHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchRemovalByFormInstanceIdListResponse batchRemovalByFormInstanceIdList(shared_ptr<BatchRemovalByFormInstanceIdListRequest> request);
  BatchSaveFormDataResponse batchSaveFormDataWithOptions(shared_ptr<BatchSaveFormDataRequest> tmpReq, shared_ptr<BatchSaveFormDataHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchSaveFormDataResponse batchSaveFormData(shared_ptr<BatchSaveFormDataRequest> request);
  BatchUpdateFormDataByInstanceIdResponse batchUpdateFormDataByInstanceIdWithOptions(shared_ptr<BatchUpdateFormDataByInstanceIdRequest> tmpReq, shared_ptr<BatchUpdateFormDataByInstanceIdHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUpdateFormDataByInstanceIdResponse batchUpdateFormDataByInstanceId(shared_ptr<BatchUpdateFormDataByInstanceIdRequest> request);
  BatchUpdateFormDataByInstanceMapResponse batchUpdateFormDataByInstanceMapWithOptions(shared_ptr<BatchUpdateFormDataByInstanceMapRequest> tmpReq, shared_ptr<BatchUpdateFormDataByInstanceMapHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUpdateFormDataByInstanceMapResponse batchUpdateFormDataByInstanceMap(shared_ptr<BatchUpdateFormDataByInstanceMapRequest> request);
  CancelScheduleConferenceResponse cancelScheduleConferenceWithOptions(shared_ptr<CancelScheduleConferenceRequest> tmpReq, shared_ptr<CancelScheduleConferenceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelScheduleConferenceResponse cancelScheduleConference(shared_ptr<CancelScheduleConferenceRequest> request);
  CheckAlibabaStaffResponse checkAlibabaStaffWithOptions(shared_ptr<CheckAlibabaStaffRequest> tmpReq, shared_ptr<CheckAlibabaStaffHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckAlibabaStaffResponse checkAlibabaStaff(shared_ptr<CheckAlibabaStaffRequest> request);
  CheckUserIsGroupMemberResponse checkUserIsGroupMemberWithOptions(shared_ptr<CheckUserIsGroupMemberRequest> request, shared_ptr<CheckUserIsGroupMemberHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckUserIsGroupMemberResponse checkUserIsGroupMember(shared_ptr<CheckUserIsGroupMemberRequest> request);
  ClearResponse clearWithOptions(shared_ptr<ClearRequest> tmpReq, shared_ptr<ClearHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ClearResponse clear(shared_ptr<ClearRequest> request);
  ClearDataResponse clearDataWithOptions(shared_ptr<ClearDataRequest> tmpReq, shared_ptr<ClearDataHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ClearDataResponse clearData(shared_ptr<ClearDataRequest> request);
  CloseVideoConferenceResponse closeVideoConferenceWithOptions(shared_ptr<CloseVideoConferenceRequest> tmpReq, shared_ptr<CloseVideoConferenceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloseVideoConferenceResponse closeVideoConference(shared_ptr<CloseVideoConferenceRequest> request);
  CommentListReportResponse commentListReportWithOptions(shared_ptr<CommentListReportRequest> tmpReq, shared_ptr<CommentListReportHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CommentListReportResponse commentListReport(shared_ptr<CommentListReportRequest> request);
  CommitFileResponse commitFileWithOptions(shared_ptr<CommitFileRequest> tmpReq, shared_ptr<CommitFileHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CommitFileResponse commitFile(shared_ptr<CommitFileRequest> request);
  CopyDentryResponse copyDentryWithOptions(shared_ptr<CopyDentryRequest> tmpReq, shared_ptr<CopyDentryHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopyDentryResponse copyDentry(shared_ptr<CopyDentryRequest> request);
  CreateDeliveryPlanResponse createDeliveryPlanWithOptions(shared_ptr<CreateDeliveryPlanRequest> tmpReq, shared_ptr<CreateDeliveryPlanHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDeliveryPlanResponse createDeliveryPlan(shared_ptr<CreateDeliveryPlanRequest> request);
  CreateDingtalkPersonalTodoTaskResponse createDingtalkPersonalTodoTaskWithOptions(shared_ptr<CreateDingtalkPersonalTodoTaskRequest> tmpReq, shared_ptr<CreateDingtalkPersonalTodoTaskHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDingtalkPersonalTodoTaskResponse createDingtalkPersonalTodoTask(shared_ptr<CreateDingtalkPersonalTodoTaskRequest> request);
  CreateEventResponse createEventWithOptions(shared_ptr<CreateEventRequest> tmpReq, shared_ptr<CreateEventHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEventResponse createEvent(shared_ptr<CreateEventRequest> request);
  CreateLiveResponse createLiveWithOptions(shared_ptr<CreateLiveRequest> tmpReq, shared_ptr<CreateLiveHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLiveResponse createLive(shared_ptr<CreateLiveRequest> request);
  CreateMeetingRoomResponse createMeetingRoomWithOptions(shared_ptr<CreateMeetingRoomRequest> tmpReq, shared_ptr<CreateMeetingRoomHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMeetingRoomResponse createMeetingRoom(shared_ptr<CreateMeetingRoomRequest> request);
  CreateMeetingRoomGroupResponse createMeetingRoomGroupWithOptions(shared_ptr<CreateMeetingRoomGroupRequest> tmpReq, shared_ptr<CreateMeetingRoomGroupHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMeetingRoomGroupResponse createMeetingRoomGroup(shared_ptr<CreateMeetingRoomGroupRequest> request);
  CreateMessageResponse createMessageWithOptions(shared_ptr<CreateMessageRequest> request, shared_ptr<CreateMessageHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMessageResponse createMessage(shared_ptr<CreateMessageRequest> request);
  CreateMultiDimTableFieldResponse createMultiDimTableFieldWithOptions(shared_ptr<CreateMultiDimTableFieldRequest> tmpReq, shared_ptr<CreateMultiDimTableFieldHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMultiDimTableFieldResponse createMultiDimTableField(shared_ptr<CreateMultiDimTableFieldRequest> request);
  CreateOrUpdateFormDataResponse createOrUpdateFormDataWithOptions(shared_ptr<CreateOrUpdateFormDataRequest> request, shared_ptr<CreateOrUpdateFormDataHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrUpdateFormDataResponse createOrUpdateFormData(shared_ptr<CreateOrUpdateFormDataRequest> request);
  CreateOrgHonorTemplateResponse createOrgHonorTemplateWithOptions(shared_ptr<CreateOrgHonorTemplateRequest> tmpReq, shared_ptr<CreateOrgHonorTemplateHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrgHonorTemplateResponse createOrgHonorTemplate(shared_ptr<CreateOrgHonorTemplateRequest> request);
  CreatePersonalTodoTaskResponse createPersonalTodoTaskWithOptions(shared_ptr<CreatePersonalTodoTaskRequest> tmpReq, shared_ptr<CreatePersonalTodoTaskHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePersonalTodoTaskResponse createPersonalTodoTask(shared_ptr<CreatePersonalTodoTaskRequest> request);
  CreateReportResponse createReportWithOptions(shared_ptr<CreateReportRequest> tmpReq, shared_ptr<CreateReportHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateReportResponse createReport(shared_ptr<CreateReportRequest> request);
  CreateRunResponse createRunWithOptions(shared_ptr<CreateRunRequest> request, shared_ptr<CreateRunHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRunResponse createRun(shared_ptr<CreateRunRequest> request);
  CreateScenegroupResponse createScenegroupWithOptions(shared_ptr<CreateScenegroupRequest> request, shared_ptr<CreateScenegroupHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateScenegroupResponse createScenegroup(shared_ptr<CreateScenegroupRequest> request);
  CreateScheduleConferenceResponse createScheduleConferenceWithOptions(shared_ptr<CreateScheduleConferenceRequest> tmpReq, shared_ptr<CreateScheduleConferenceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateScheduleConferenceResponse createScheduleConference(shared_ptr<CreateScheduleConferenceRequest> request);
  CreateSearchDomeResponse createSearchDomeWithOptions(shared_ptr<CreateSearchDomeRequest> tmpReq, shared_ptr<CreateSearchDomeHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSearchDomeResponse createSearchDome(shared_ptr<CreateSearchDomeRequest> request);
  CreateSearchKeywordResponse createSearchKeywordWithOptions(shared_ptr<CreateSearchKeywordRequest> tmpReq, shared_ptr<CreateSearchKeywordHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSearchKeywordResponse createSearchKeyword(shared_ptr<CreateSearchKeywordRequest> request);
  CreateSheetResponse createSheetWithOptions(shared_ptr<CreateSheetRequest> tmpReq, shared_ptr<CreateSheetHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSheetResponse createSheet(shared_ptr<CreateSheetRequest> request);
  CreateSubscribedCalendarResponse createSubscribedCalendarWithOptions(shared_ptr<CreateSubscribedCalendarRequest> tmpReq, shared_ptr<CreateSubscribedCalendarHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSubscribedCalendarResponse createSubscribedCalendar(shared_ptr<CreateSubscribedCalendarRequest> request);
  CreateThreadResponse createThreadWithOptions(shared_ptr<CreateThreadRequest> request, shared_ptr<CreateThreadHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateThreadResponse createThread(shared_ptr<CreateThreadRequest> request);
  CreateTicketResponse createTicketWithOptions(shared_ptr<CreateTicketRequest> tmpReq, shared_ptr<CreateTicketHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTicketResponse createTicket(shared_ptr<CreateTicketRequest> request);
  CreateTodoTaskResponse createTodoTaskWithOptions(shared_ptr<CreateTodoTaskRequest> tmpReq, shared_ptr<CreateTodoTaskHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTodoTaskResponse createTodoTask(shared_ptr<CreateTodoTaskRequest> request);
  CreateVideoConferenceResponse createVideoConferenceWithOptions(shared_ptr<CreateVideoConferenceRequest> tmpReq, shared_ptr<CreateVideoConferenceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVideoConferenceResponse createVideoConference(shared_ptr<CreateVideoConferenceRequest> request);
  CreateWorkspaceResponse createWorkspaceWithOptions(shared_ptr<CreateWorkspaceRequest> tmpReq, shared_ptr<CreateWorkspaceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWorkspaceResponse createWorkspace(shared_ptr<CreateWorkspaceRequest> request);
  CreateWorkspaceDocResponse createWorkspaceDocWithOptions(shared_ptr<CreateWorkspaceDocRequest> tmpReq, shared_ptr<CreateWorkspaceDocHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWorkspaceDocResponse createWorkspaceDoc(shared_ptr<CreateWorkspaceDocRequest> request);
  DeleteColumnsResponse deleteColumnsWithOptions(shared_ptr<DeleteColumnsRequest> tmpReq, shared_ptr<DeleteColumnsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteColumnsResponse deleteColumns(shared_ptr<DeleteColumnsRequest> request);
  DeleteDentryResponse deleteDentryWithOptions(shared_ptr<DeleteDentryRequest> tmpReq, shared_ptr<DeleteDentryHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDentryResponse deleteDentry(shared_ptr<DeleteDentryRequest> request);
  DeleteDriveSpaceResponse deleteDriveSpaceWithOptions(shared_ptr<DeleteDriveSpaceRequest> tmpReq, shared_ptr<DeleteDriveSpaceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDriveSpaceResponse deleteDriveSpace(shared_ptr<DeleteDriveSpaceRequest> request);
  DeleteEventResponse deleteEventWithOptions(shared_ptr<DeleteEventRequest> request, shared_ptr<DeleteEventHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEventResponse deleteEvent(shared_ptr<DeleteEventRequest> request);
  DeleteFormDataResponse deleteFormDataWithOptions(shared_ptr<DeleteFormDataRequest> request, shared_ptr<DeleteFormDataHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFormDataResponse deleteFormData(shared_ptr<DeleteFormDataRequest> request);
  DeleteInstanceResponse deleteInstanceWithOptions(shared_ptr<DeleteInstanceRequest> request, shared_ptr<DeleteInstanceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteInstanceResponse deleteInstance(shared_ptr<DeleteInstanceRequest> request);
  DeleteLiveResponse deleteLiveWithOptions(shared_ptr<DeleteLiveRequest> tmpReq, shared_ptr<DeleteLiveHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveResponse deleteLive(shared_ptr<DeleteLiveRequest> request);
  DeleteMeetingRoomResponse deleteMeetingRoomWithOptions(shared_ptr<DeleteMeetingRoomRequest> tmpReq, shared_ptr<DeleteMeetingRoomHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMeetingRoomResponse deleteMeetingRoom(shared_ptr<DeleteMeetingRoomRequest> request);
  DeleteMeetingRoomGroupResponse deleteMeetingRoomGroupWithOptions(shared_ptr<DeleteMeetingRoomGroupRequest> tmpReq, shared_ptr<DeleteMeetingRoomGroupHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMeetingRoomGroupResponse deleteMeetingRoomGroup(shared_ptr<DeleteMeetingRoomGroupRequest> request);
  DeleteMultiDimTableFieldResponse deleteMultiDimTableFieldWithOptions(shared_ptr<DeleteMultiDimTableFieldRequest> tmpReq, shared_ptr<DeleteMultiDimTableFieldHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMultiDimTableFieldResponse deleteMultiDimTableField(shared_ptr<DeleteMultiDimTableFieldRequest> request);
  DeleteMultiDimTableRecordsResponse deleteMultiDimTableRecordsWithOptions(shared_ptr<DeleteMultiDimTableRecordsRequest> tmpReq, shared_ptr<DeleteMultiDimTableRecordsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMultiDimTableRecordsResponse deleteMultiDimTableRecords(shared_ptr<DeleteMultiDimTableRecordsRequest> request);
  DeletePermissionResponse deletePermissionWithOptions(shared_ptr<DeletePermissionRequest> tmpReq, shared_ptr<DeletePermissionHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePermissionResponse deletePermission(shared_ptr<DeletePermissionRequest> request);
  DeleteRowsResponse deleteRowsWithOptions(shared_ptr<DeleteRowsRequest> tmpReq, shared_ptr<DeleteRowsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRowsResponse deleteRows(shared_ptr<DeleteRowsRequest> request);
  DeleteScenegroupMemberResponse deleteScenegroupMemberWithOptions(shared_ptr<DeleteScenegroupMemberRequest> request, shared_ptr<DeleteScenegroupMemberHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteScenegroupMemberResponse deleteScenegroupMember(shared_ptr<DeleteScenegroupMemberRequest> request);
  DeleteSheetResponse deleteSheetWithOptions(shared_ptr<DeleteSheetRequest> tmpReq, shared_ptr<DeleteSheetHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSheetResponse deleteSheet(shared_ptr<DeleteSheetRequest> request);
  DeleteSubscribedCalendarResponse deleteSubscribedCalendarWithOptions(shared_ptr<DeleteSubscribedCalendarRequest> request, shared_ptr<DeleteSubscribedCalendarHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSubscribedCalendarResponse deleteSubscribedCalendar(shared_ptr<DeleteSubscribedCalendarRequest> request);
  DeleteTodoTaskResponse deleteTodoTaskWithOptions(shared_ptr<DeleteTodoTaskRequest> tmpReq, shared_ptr<DeleteTodoTaskHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTodoTaskResponse deleteTodoTask(shared_ptr<DeleteTodoTaskRequest> request);
  DeleteWorkspaceDocMembersResponse deleteWorkspaceDocMembersWithOptions(shared_ptr<DeleteWorkspaceDocMembersRequest> tmpReq, shared_ptr<DeleteWorkspaceDocMembersHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWorkspaceDocMembersResponse deleteWorkspaceDocMembers(shared_ptr<DeleteWorkspaceDocMembersRequest> request);
  DeleteWorkspaceMembersResponse deleteWorkspaceMembersWithOptions(shared_ptr<DeleteWorkspaceMembersRequest> tmpReq, shared_ptr<DeleteWorkspaceMembersHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWorkspaceMembersResponse deleteWorkspaceMembers(shared_ptr<DeleteWorkspaceMembersRequest> request);
  DocBlocksQueryResponse docBlocksQueryWithOptions(shared_ptr<DocBlocksQueryRequest> tmpReq, shared_ptr<DocBlocksQueryHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DocBlocksQueryResponse docBlocksQuery(shared_ptr<DocBlocksQueryRequest> request);
  DocUpdateContentResponse docUpdateContentWithOptions(shared_ptr<DocUpdateContentRequest> tmpReq, shared_ptr<DocUpdateContentHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DocUpdateContentResponse docUpdateContent(shared_ptr<DocUpdateContentRequest> request);
  ExecuteBatchTaskResponse executeBatchTaskWithOptions(shared_ptr<ExecuteBatchTaskRequest> request, shared_ptr<ExecuteBatchTaskHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecuteBatchTaskResponse executeBatchTask(shared_ptr<ExecuteBatchTaskRequest> request);
  ExecutePlatformTaskResponse executePlatformTaskWithOptions(shared_ptr<ExecutePlatformTaskRequest> request, shared_ptr<ExecutePlatformTaskHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecutePlatformTaskResponse executePlatformTask(shared_ptr<ExecutePlatformTaskRequest> request);
  ExecuteTaskResponse executeTaskWithOptions(shared_ptr<ExecuteTaskRequest> request, shared_ptr<ExecuteTaskHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecuteTaskResponse executeTask(shared_ptr<ExecuteTaskRequest> request);
  ExpandGroupCapacityResponse expandGroupCapacityWithOptions(shared_ptr<ExpandGroupCapacityRequest> tmpReq, shared_ptr<ExpandGroupCapacityHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExpandGroupCapacityResponse expandGroupCapacity(shared_ptr<ExpandGroupCapacityRequest> request);
  FinishTicketResponse finishTicketWithOptions(shared_ptr<FinishTicketRequest> tmpReq, shared_ptr<FinishTicketHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FinishTicketResponse finishTicket(shared_ptr<FinishTicketRequest> request);
  GetActivityListResponse getActivityListWithOptions(shared_ptr<GetActivityListRequest> request, shared_ptr<GetActivityListHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetActivityListResponse getActivityList(shared_ptr<GetActivityListRequest> request);
  GetAllSheetsResponse getAllSheetsWithOptions(shared_ptr<GetAllSheetsRequest> tmpReq, shared_ptr<GetAllSheetsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAllSheetsResponse getAllSheets(shared_ptr<GetAllSheetsRequest> request);
  GetAssistantCapabilityResponse getAssistantCapabilityWithOptions(shared_ptr<GetAssistantCapabilityRequest> request, shared_ptr<GetAssistantCapabilityHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAssistantCapabilityResponse getAssistantCapability(shared_ptr<GetAssistantCapabilityRequest> request);
  GetConversaionSpaceResponse getConversaionSpaceWithOptions(shared_ptr<GetConversaionSpaceRequest> tmpReq, shared_ptr<GetConversaionSpaceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetConversaionSpaceResponse getConversaionSpace(shared_ptr<GetConversaionSpaceRequest> request);
  GetCorpAccomplishmentTasksResponse getCorpAccomplishmentTasksWithOptions(shared_ptr<GetCorpAccomplishmentTasksRequest> request, shared_ptr<GetCorpAccomplishmentTasksHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCorpAccomplishmentTasksResponse getCorpAccomplishmentTasks(shared_ptr<GetCorpAccomplishmentTasksRequest> request);
  GetCorpTasksResponse getCorpTasksWithOptions(shared_ptr<GetCorpTasksRequest> request, shared_ptr<GetCorpTasksHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCorpTasksResponse getCorpTasks(shared_ptr<GetCorpTasksRequest> request);
  GetDeptNoResponse getDeptNoWithOptions(shared_ptr<GetDeptNoRequest> tmpReq, shared_ptr<GetDeptNoHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeptNoResponse getDeptNo(shared_ptr<GetDeptNoRequest> request);
  GetDocContentResponse getDocContentWithOptions(shared_ptr<GetDocContentRequest> tmpReq, shared_ptr<GetDocContentHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDocContentResponse getDocContent(shared_ptr<GetDocContentRequest> request);
  GetDocContentTakIdResponse getDocContentTakIdWithOptions(shared_ptr<GetDocContentTakIdRequest> tmpReq, shared_ptr<GetDocContentTakIdHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDocContentTakIdResponse getDocContentTakId(shared_ptr<GetDocContentTakIdRequest> request);
  GetEventResponse getEventWithOptions(shared_ptr<GetEventRequest> request, shared_ptr<GetEventHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEventResponse getEvent(shared_ptr<GetEventRequest> request);
  GetFieldDefByUuidResponse getFieldDefByUuidWithOptions(shared_ptr<GetFieldDefByUuidRequest> request, shared_ptr<GetFieldDefByUuidHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFieldDefByUuidResponse getFieldDefByUuid(shared_ptr<GetFieldDefByUuidRequest> request);
  GetFileDownloadInfoResponse getFileDownloadInfoWithOptions(shared_ptr<GetFileDownloadInfoRequest> tmpReq, shared_ptr<GetFileDownloadInfoHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFileDownloadInfoResponse getFileDownloadInfo(shared_ptr<GetFileDownloadInfoRequest> request);
  GetFileUploadInfoResponse getFileUploadInfoWithOptions(shared_ptr<GetFileUploadInfoRequest> tmpReq, shared_ptr<GetFileUploadInfoHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFileUploadInfoResponse getFileUploadInfo(shared_ptr<GetFileUploadInfoRequest> request);
  GetFormComponentDefinitionListResponse getFormComponentDefinitionListWithOptions(shared_ptr<GetFormComponentDefinitionListRequest> request, shared_ptr<GetFormComponentDefinitionListHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFormComponentDefinitionListResponse getFormComponentDefinitionList(shared_ptr<GetFormComponentDefinitionListRequest> request);
  GetFormDataByIDResponse getFormDataByIDWithOptions(shared_ptr<GetFormDataByIDRequest> request, shared_ptr<GetFormDataByIDHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFormDataByIDResponse getFormDataByID(shared_ptr<GetFormDataByIDRequest> request);
  GetFormListInAppResponse getFormListInAppWithOptions(shared_ptr<GetFormListInAppRequest> request, shared_ptr<GetFormListInAppHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFormListInAppResponse getFormListInApp(shared_ptr<GetFormListInAppRequest> request);
  GetGroupLiveListResponse getGroupLiveListWithOptions(shared_ptr<GetGroupLiveListRequest> tmpReq, shared_ptr<GetGroupLiveListHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetGroupLiveListResponse getGroupLiveList(shared_ptr<GetGroupLiveListRequest> request);
  GetInnerGroupMembersResponse getInnerGroupMembersWithOptions(shared_ptr<GetInnerGroupMembersRequest> request, shared_ptr<GetInnerGroupMembersHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInnerGroupMembersResponse getInnerGroupMembers(shared_ptr<GetInnerGroupMembersRequest> request);
  GetInstanceByIdResponse getInstanceByIdWithOptions(shared_ptr<GetInstanceByIdRequest> request, shared_ptr<GetInstanceByIdHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceByIdResponse getInstanceById(shared_ptr<GetInstanceByIdRequest> request);
  GetInstanceIdListResponse getInstanceIdListWithOptions(shared_ptr<GetInstanceIdListRequest> request, shared_ptr<GetInstanceIdListHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceIdListResponse getInstanceIdList(shared_ptr<GetInstanceIdListRequest> request);
  GetInstancesResponse getInstancesWithOptions(shared_ptr<GetInstancesRequest> request, shared_ptr<GetInstancesHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstancesResponse getInstances(shared_ptr<GetInstancesRequest> request);
  GetInstancesByIdListResponse getInstancesByIdListWithOptions(shared_ptr<GetInstancesByIdListRequest> request, shared_ptr<GetInstancesByIdListHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstancesByIdListResponse getInstancesByIdList(shared_ptr<GetInstancesByIdListRequest> request);
  GetLiveReplayUrlResponse getLiveReplayUrlWithOptions(shared_ptr<GetLiveReplayUrlRequest> tmpReq, shared_ptr<GetLiveReplayUrlHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLiveReplayUrlResponse getLiveReplayUrl(shared_ptr<GetLiveReplayUrlRequest> request);
  GetMeCorpSubmissionResponse getMeCorpSubmissionWithOptions(shared_ptr<GetMeCorpSubmissionRequest> request, shared_ptr<GetMeCorpSubmissionHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMeCorpSubmissionResponse getMeCorpSubmission(shared_ptr<GetMeCorpSubmissionRequest> request);
  GetMeetingRoomsScheduleResponse getMeetingRoomsScheduleWithOptions(shared_ptr<GetMeetingRoomsScheduleRequest> tmpReq, shared_ptr<GetMeetingRoomsScheduleHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMeetingRoomsScheduleResponse getMeetingRoomsSchedule(shared_ptr<GetMeetingRoomsScheduleRequest> request);
  GetMineWorkspaceResponse getMineWorkspaceWithOptions(shared_ptr<GetMineWorkspaceRequest> tmpReq, shared_ptr<GetMineWorkspaceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMineWorkspaceResponse getMineWorkspace(shared_ptr<GetMineWorkspaceRequest> request);
  GetMultiDimTableAllFieldsResponse getMultiDimTableAllFieldsWithOptions(shared_ptr<GetMultiDimTableAllFieldsRequest> tmpReq, shared_ptr<GetMultiDimTableAllFieldsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMultiDimTableAllFieldsResponse getMultiDimTableAllFields(shared_ptr<GetMultiDimTableAllFieldsRequest> request);
  GetMultiDimTableAllSheetsResponse getMultiDimTableAllSheetsWithOptions(shared_ptr<GetMultiDimTableAllSheetsRequest> tmpReq, shared_ptr<GetMultiDimTableAllSheetsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMultiDimTableAllSheetsResponse getMultiDimTableAllSheets(shared_ptr<GetMultiDimTableAllSheetsRequest> request);
  GetMultiDimTableRecordResponse getMultiDimTableRecordWithOptions(shared_ptr<GetMultiDimTableRecordRequest> tmpReq, shared_ptr<GetMultiDimTableRecordHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMultiDimTableRecordResponse getMultiDimTableRecord(shared_ptr<GetMultiDimTableRecordRequest> request);
  GetMultiDimTableSheetResponse getMultiDimTableSheetWithOptions(shared_ptr<GetMultiDimTableSheetRequest> tmpReq, shared_ptr<GetMultiDimTableSheetHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMultiDimTableSheetResponse getMultiDimTableSheet(shared_ptr<GetMultiDimTableSheetRequest> request);
  GetMultipartFileUploadInfosResponse getMultipartFileUploadInfosWithOptions(shared_ptr<GetMultipartFileUploadInfosRequest> tmpReq, shared_ptr<GetMultipartFileUploadInfosHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMultipartFileUploadInfosResponse getMultipartFileUploadInfos(shared_ptr<GetMultipartFileUploadInfosRequest> request);
  GetNewestInnerGroupsResponse getNewestInnerGroupsWithOptions(shared_ptr<GetNewestInnerGroupsRequest> tmpReq, shared_ptr<GetNewestInnerGroupsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNewestInnerGroupsResponse getNewestInnerGroups(shared_ptr<GetNewestInnerGroupsRequest> request);
  GetNodeResponse getNodeWithOptions(shared_ptr<GetNodeRequest> tmpReq, shared_ptr<GetNodeHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodeResponse getNode(shared_ptr<GetNodeRequest> request);
  GetNodeByUrlResponse getNodeByUrlWithOptions(shared_ptr<GetNodeByUrlRequest> tmpReq, shared_ptr<GetNodeByUrlHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodeByUrlResponse getNodeByUrl(shared_ptr<GetNodeByUrlRequest> request);
  GetNodesResponse getNodesWithOptions(shared_ptr<GetNodesRequest> tmpReq, shared_ptr<GetNodesHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodesResponse getNodes(shared_ptr<GetNodesRequest> request);
  GetNotifyMeResponse getNotifyMeWithOptions(shared_ptr<GetNotifyMeRequest> request, shared_ptr<GetNotifyMeHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNotifyMeResponse getNotifyMe(shared_ptr<GetNotifyMeRequest> request);
  GetOpenUrlResponse getOpenUrlWithOptions(shared_ptr<GetOpenUrlRequest> request, shared_ptr<GetOpenUrlHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOpenUrlResponse getOpenUrl(shared_ptr<GetOpenUrlRequest> request);
  GetOperationRecordsResponse getOperationRecordsWithOptions(shared_ptr<GetOperationRecordsRequest> request, shared_ptr<GetOperationRecordsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOperationRecordsResponse getOperationRecords(shared_ptr<GetOperationRecordsRequest> request);
  GetOrgLiveListResponse getOrgLiveListWithOptions(shared_ptr<GetOrgLiveListRequest> tmpReq, shared_ptr<GetOrgLiveListHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOrgLiveListResponse getOrgLiveList(shared_ptr<GetOrgLiveListRequest> request);
  GetOrgOrWebOpenDocContentTaskIdResponse getOrgOrWebOpenDocContentTaskIdWithOptions(shared_ptr<GetOrgOrWebOpenDocContentTaskIdRequest> tmpReq, shared_ptr<GetOrgOrWebOpenDocContentTaskIdHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOrgOrWebOpenDocContentTaskIdResponse getOrgOrWebOpenDocContentTaskId(shared_ptr<GetOrgOrWebOpenDocContentTaskIdRequest> request);
  GetProcessDefinitionResponse getProcessDefinitionWithOptions(shared_ptr<GetProcessDefinitionRequest> request, shared_ptr<GetProcessDefinitionHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetProcessDefinitionResponse getProcessDefinition(shared_ptr<GetProcessDefinitionRequest> request);
  GetRangeResponse getRangeWithOptions(shared_ptr<GetRangeRequest> tmpReq, shared_ptr<GetRangeHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRangeResponse getRange(shared_ptr<GetRangeRequest> request);
  GetRelatedWorkspacesResponse getRelatedWorkspacesWithOptions(shared_ptr<GetRelatedWorkspacesRequest> tmpReq, shared_ptr<GetRelatedWorkspacesHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRelatedWorkspacesResponse getRelatedWorkspaces(shared_ptr<GetRelatedWorkspacesRequest> request);
  GetReportTemplateByNameResponse getReportTemplateByNameWithOptions(shared_ptr<GetReportTemplateByNameRequest> tmpReq, shared_ptr<GetReportTemplateByNameHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetReportTemplateByNameResponse getReportTemplateByName(shared_ptr<GetReportTemplateByNameRequest> request);
  GetReportUnReadCountResponse getReportUnReadCountWithOptions(shared_ptr<GetReportUnReadCountRequest> tmpReq, shared_ptr<GetReportUnReadCountHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetReportUnReadCountResponse getReportUnReadCount(shared_ptr<GetReportUnReadCountRequest> request);
  GetRunningTasksResponse getRunningTasksWithOptions(shared_ptr<GetRunningTasksRequest> request, shared_ptr<GetRunningTasksHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRunningTasksResponse getRunningTasks(shared_ptr<GetRunningTasksRequest> request);
  GetScheduleResponse getScheduleWithOptions(shared_ptr<GetScheduleRequest> tmpReq, shared_ptr<GetScheduleHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetScheduleResponse getSchedule(shared_ptr<GetScheduleRequest> request);
  GetSheetResponse getSheetWithOptions(shared_ptr<GetSheetRequest> tmpReq, shared_ptr<GetSheetHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSheetResponse getSheet(shared_ptr<GetSheetRequest> request);
  GetSheetContentJobIdResponse getSheetContentJobIdWithOptions(shared_ptr<GetSheetContentJobIdRequest> tmpReq, shared_ptr<GetSheetContentJobIdHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSheetContentJobIdResponse getSheetContentJobId(shared_ptr<GetSheetContentJobIdRequest> request);
  GetSpaceDirectoriesResponse getSpaceDirectoriesWithOptions(shared_ptr<GetSpaceDirectoriesRequest> tmpReq, shared_ptr<GetSpaceDirectoriesHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSpaceDirectoriesResponse getSpaceDirectories(shared_ptr<GetSpaceDirectoriesRequest> request);
  GetSubscribedCalendarResponse getSubscribedCalendarWithOptions(shared_ptr<GetSubscribedCalendarRequest> request, shared_ptr<GetSubscribedCalendarHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSubscribedCalendarResponse getSubscribedCalendar(shared_ptr<GetSubscribedCalendarRequest> request);
  GetTaskCopiesResponse getTaskCopiesWithOptions(shared_ptr<GetTaskCopiesRequest> request, shared_ptr<GetTaskCopiesHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTaskCopiesResponse getTaskCopies(shared_ptr<GetTaskCopiesRequest> request);
  GetTemplateListByUserIdResponse getTemplateListByUserIdWithOptions(shared_ptr<GetTemplateListByUserIdRequest> tmpReq, shared_ptr<GetTemplateListByUserIdHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTemplateListByUserIdResponse getTemplateListByUserId(shared_ptr<GetTemplateListByUserIdRequest> request);
  GetTicketResponse getTicketWithOptions(shared_ptr<GetTicketRequest> tmpReq, shared_ptr<GetTicketHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTicketResponse getTicket(shared_ptr<GetTicketRequest> request);
  GetTodoTaskResponse getTodoTaskWithOptions(shared_ptr<GetTodoTaskRequest> tmpReq, shared_ptr<GetTodoTaskHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTodoTaskResponse getTodoTask(shared_ptr<GetTodoTaskRequest> request);
  GetUserResponse getUserWithOptions(shared_ptr<GetUserRequest> tmpReq, shared_ptr<GetUserHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserResponse getUser(shared_ptr<GetUserRequest> request);
  GetUserIdResponse getUserIdWithOptions(shared_ptr<GetUserIdRequest> tmpReq, shared_ptr<GetUserIdHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserIdResponse getUserId(shared_ptr<GetUserIdRequest> request);
  GetUserIdByOrgIdAndStaffIdResponse getUserIdByOrgIdAndStaffIdWithOptions(shared_ptr<GetUserIdByOrgIdAndStaffIdRequest> tmpReq, shared_ptr<GetUserIdByOrgIdAndStaffIdHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserIdByOrgIdAndStaffIdResponse getUserIdByOrgIdAndStaffId(shared_ptr<GetUserIdByOrgIdAndStaffIdRequest> request);
  GetUserLatestPlanResponse getUserLatestPlanWithOptions(shared_ptr<GetUserLatestPlanRequest> tmpReq, shared_ptr<GetUserLatestPlanHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserLatestPlanResponse getUserLatestPlan(shared_ptr<GetUserLatestPlanRequest> request);
  GetWorkspaceResponse getWorkspaceWithOptions(shared_ptr<GetWorkspaceRequest> tmpReq, shared_ptr<GetWorkspaceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWorkspaceResponse getWorkspace(shared_ptr<GetWorkspaceRequest> request);
  GetWorkspacesResponse getWorkspacesWithOptions(shared_ptr<GetWorkspacesRequest> tmpReq, shared_ptr<GetWorkspacesHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWorkspacesResponse getWorkspaces(shared_ptr<GetWorkspacesRequest> request);
  GrantHonorResponse grantHonorWithOptions(shared_ptr<GrantHonorRequest> tmpReq, shared_ptr<GrantHonorHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GrantHonorResponse grantHonor(shared_ptr<GrantHonorRequest> request);
  InitMultipartFileUploadResponse initMultipartFileUploadWithOptions(shared_ptr<InitMultipartFileUploadRequest> tmpReq, shared_ptr<InitMultipartFileUploadHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InitMultipartFileUploadResponse initMultipartFileUpload(shared_ptr<InitMultipartFileUploadRequest> request);
  InsertColumnsBeforeResponse insertColumnsBeforeWithOptions(shared_ptr<InsertColumnsBeforeRequest> tmpReq, shared_ptr<InsertColumnsBeforeHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertColumnsBeforeResponse insertColumnsBefore(shared_ptr<InsertColumnsBeforeRequest> request);
  InsertContentWithOptionsResponse insertContentWithOptionsWithOptions(shared_ptr<InsertContentWithOptionsRequest> tmpReq, shared_ptr<InsertContentWithOptionsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertContentWithOptionsResponse insertContentWithOptions(shared_ptr<InsertContentWithOptionsRequest> request);
  InsertMultiDimTableRecordResponse insertMultiDimTableRecordWithOptions(shared_ptr<InsertMultiDimTableRecordRequest> tmpReq, shared_ptr<InsertMultiDimTableRecordHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertMultiDimTableRecordResponse insertMultiDimTableRecord(shared_ptr<InsertMultiDimTableRecordRequest> request);
  InsertRowsBeforeResponse insertRowsBeforeWithOptions(shared_ptr<InsertRowsBeforeRequest> tmpReq, shared_ptr<InsertRowsBeforeHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertRowsBeforeResponse insertRowsBefore(shared_ptr<InsertRowsBeforeRequest> request);
  InviteUsersResponse inviteUsersWithOptions(shared_ptr<InviteUsersRequest> tmpReq, shared_ptr<InviteUsersHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InviteUsersResponse inviteUsers(shared_ptr<InviteUsersRequest> request);
  InvokeAssistantResponse invokeAssistantWithOptions(shared_ptr<InvokeAssistantRequest> request, shared_ptr<InvokeAssistantHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvokeAssistantResponse invokeAssistant(shared_ptr<InvokeAssistantRequest> request);
  InvokeSkillResponse invokeSkillWithOptions(shared_ptr<InvokeSkillRequest> tmpReq, shared_ptr<InvokeSkillHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvokeSkillResponse invokeSkill(shared_ptr<InvokeSkillRequest> request);
  ListApplicationResponse listApplicationWithOptions(shared_ptr<ListApplicationRequest> request, shared_ptr<ListApplicationHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApplicationResponse listApplication(shared_ptr<ListApplicationRequest> request);
  ListCalendarsResponse listCalendarsWithOptions(shared_ptr<ListCalendarsRequest> tmpReq, shared_ptr<ListCalendarsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCalendarsResponse listCalendars(shared_ptr<ListCalendarsRequest> request);
  ListDentriesResponse listDentriesWithOptions(shared_ptr<ListDentriesRequest> tmpReq, shared_ptr<ListDentriesHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDentriesResponse listDentries(shared_ptr<ListDentriesRequest> request);
  ListDriveSpacesResponse listDriveSpacesWithOptions(shared_ptr<ListDriveSpacesRequest> tmpReq, shared_ptr<ListDriveSpacesHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDriveSpacesResponse listDriveSpaces(shared_ptr<ListDriveSpacesRequest> request);
  ListEventsResponse listEventsWithOptions(shared_ptr<ListEventsRequest> request, shared_ptr<ListEventsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEventsResponse listEvents(shared_ptr<ListEventsRequest> request);
  ListEventsViewResponse listEventsViewWithOptions(shared_ptr<ListEventsViewRequest> request, shared_ptr<ListEventsViewHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEventsViewResponse listEventsView(shared_ptr<ListEventsViewRequest> request);
  ListFormRemarksResponse listFormRemarksWithOptions(shared_ptr<ListFormRemarksRequest> tmpReq, shared_ptr<ListFormRemarksHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFormRemarksResponse listFormRemarks(shared_ptr<ListFormRemarksRequest> request);
  ListMessageResponse listMessageWithOptions(shared_ptr<ListMessageRequest> request, shared_ptr<ListMessageHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMessageResponse listMessage(shared_ptr<ListMessageRequest> request);
  ListMultiDimTableRecordsResponse listMultiDimTableRecordsWithOptions(shared_ptr<ListMultiDimTableRecordsRequest> tmpReq, shared_ptr<ListMultiDimTableRecordsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMultiDimTableRecordsResponse listMultiDimTableRecords(shared_ptr<ListMultiDimTableRecordsRequest> request);
  ListNavigationByFormTypeResponse listNavigationByFormTypeWithOptions(shared_ptr<ListNavigationByFormTypeRequest> request, shared_ptr<ListNavigationByFormTypeHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNavigationByFormTypeResponse listNavigationByFormType(shared_ptr<ListNavigationByFormTypeRequest> request);
  ListNodesResponse listNodesWithOptions(shared_ptr<ListNodesRequest> tmpReq, shared_ptr<ListNodesHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNodesResponse listNodes(shared_ptr<ListNodesRequest> request);
  ListPermissionsResponse listPermissionsWithOptions(shared_ptr<ListPermissionsRequest> tmpReq, shared_ptr<ListPermissionsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPermissionsResponse listPermissions(shared_ptr<ListPermissionsRequest> request);
  ListReportResponse listReportWithOptions(shared_ptr<ListReportRequest> tmpReq, shared_ptr<ListReportHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListReportResponse listReport(shared_ptr<ListReportRequest> request);
  ListSkillResponse listSkillWithOptions(shared_ptr<ListSkillRequest> request, shared_ptr<ListSkillHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSkillResponse listSkill(shared_ptr<ListSkillRequest> request);
  ListTableDataByFormInstanceIdTableIdResponse listTableDataByFormInstanceIdTableIdWithOptions(shared_ptr<ListTableDataByFormInstanceIdTableIdRequest> request, shared_ptr<ListTableDataByFormInstanceIdTableIdHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTableDataByFormInstanceIdTableIdResponse listTableDataByFormInstanceIdTableId(shared_ptr<ListTableDataByFormInstanceIdTableIdRequest> request);
  ListTeamsResponse listTeamsWithOptions(shared_ptr<ListTeamsRequest> tmpReq, shared_ptr<ListTeamsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTeamsResponse listTeams(shared_ptr<ListTeamsRequest> request);
  ListTemplateResponse listTemplateWithOptions(shared_ptr<ListTemplateRequest> tmpReq, shared_ptr<ListTemplateHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTemplateResponse listTemplate(shared_ptr<ListTemplateRequest> request);
  ListTicketOperateRecordResponse listTicketOperateRecordWithOptions(shared_ptr<ListTicketOperateRecordRequest> tmpReq, shared_ptr<ListTicketOperateRecordHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTicketOperateRecordResponse listTicketOperateRecord(shared_ptr<ListTicketOperateRecordRequest> request);
  ListWorkspacesResponse listWorkspacesWithOptions(shared_ptr<ListWorkspacesRequest> tmpReq, shared_ptr<ListWorkspacesHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWorkspacesResponse listWorkspaces(shared_ptr<ListWorkspacesRequest> request);
  PatchEventResponse patchEventWithOptions(shared_ptr<PatchEventRequest> tmpReq, shared_ptr<PatchEventHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PatchEventResponse patchEvent(shared_ptr<PatchEventRequest> request);
  QueryCloudRecordTextResponse queryCloudRecordTextWithOptions(shared_ptr<QueryCloudRecordTextRequest> tmpReq, shared_ptr<QueryCloudRecordTextHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCloudRecordTextResponse queryCloudRecordText(shared_ptr<QueryCloudRecordTextRequest> request);
  QueryCloudRecordVideoResponse queryCloudRecordVideoWithOptions(shared_ptr<QueryCloudRecordVideoRequest> tmpReq, shared_ptr<QueryCloudRecordVideoHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCloudRecordVideoResponse queryCloudRecordVideo(shared_ptr<QueryCloudRecordVideoRequest> request);
  QueryCloudRecordVideoPlayInfoResponse queryCloudRecordVideoPlayInfoWithOptions(shared_ptr<QueryCloudRecordVideoPlayInfoRequest> tmpReq, shared_ptr<QueryCloudRecordVideoPlayInfoHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCloudRecordVideoPlayInfoResponse queryCloudRecordVideoPlayInfo(shared_ptr<QueryCloudRecordVideoPlayInfoRequest> request);
  QueryConferenceInfoResponse queryConferenceInfoWithOptions(shared_ptr<QueryConferenceInfoRequest> request, shared_ptr<QueryConferenceInfoHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryConferenceInfoResponse queryConferenceInfo(shared_ptr<QueryConferenceInfoRequest> request);
  QueryConferenceInfoByRoomCodeResponse queryConferenceInfoByRoomCodeWithOptions(shared_ptr<QueryConferenceInfoByRoomCodeRequest> tmpReq, shared_ptr<QueryConferenceInfoByRoomCodeHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryConferenceInfoByRoomCodeResponse queryConferenceInfoByRoomCode(shared_ptr<QueryConferenceInfoByRoomCodeRequest> request);
  QueryConferenceMembersResponse queryConferenceMembersWithOptions(shared_ptr<QueryConferenceMembersRequest> tmpReq, shared_ptr<QueryConferenceMembersHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryConferenceMembersResponse queryConferenceMembers(shared_ptr<QueryConferenceMembersRequest> request);
  QueryDentriesInfoResponse queryDentriesInfoWithOptions(shared_ptr<QueryDentriesInfoRequest> tmpReq, shared_ptr<QueryDentriesInfoHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDentriesInfoResponse queryDentriesInfo(shared_ptr<QueryDentriesInfoRequest> request);
  QueryDentryResponse queryDentryWithOptions(shared_ptr<QueryDentryRequest> tmpReq, shared_ptr<QueryDentryHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDentryResponse queryDentry(shared_ptr<QueryDentryRequest> request);
  QueryGroupLiveInfoResponse queryGroupLiveInfoWithOptions(shared_ptr<QueryGroupLiveInfoRequest> tmpReq, shared_ptr<QueryGroupLiveInfoHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryGroupLiveInfoResponse queryGroupLiveInfo(shared_ptr<QueryGroupLiveInfoRequest> request);
  QueryLiveInfoResponse queryLiveInfoWithOptions(shared_ptr<QueryLiveInfoRequest> tmpReq, shared_ptr<QueryLiveInfoHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryLiveInfoResponse queryLiveInfo(shared_ptr<QueryLiveInfoRequest> request);
  QueryLiveWatchDetailResponse queryLiveWatchDetailWithOptions(shared_ptr<QueryLiveWatchDetailRequest> tmpReq, shared_ptr<QueryLiveWatchDetailHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryLiveWatchDetailResponse queryLiveWatchDetail(shared_ptr<QueryLiveWatchDetailRequest> request);
  QueryLiveWatchUserListResponse queryLiveWatchUserListWithOptions(shared_ptr<QueryLiveWatchUserListRequest> tmpReq, shared_ptr<QueryLiveWatchUserListHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryLiveWatchUserListResponse queryLiveWatchUserList(shared_ptr<QueryLiveWatchUserListRequest> request);
  QueryMeetingRoomResponse queryMeetingRoomWithOptions(shared_ptr<QueryMeetingRoomRequest> tmpReq, shared_ptr<QueryMeetingRoomHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMeetingRoomResponse queryMeetingRoom(shared_ptr<QueryMeetingRoomRequest> request);
  QueryMeetingRoomGroupResponse queryMeetingRoomGroupWithOptions(shared_ptr<QueryMeetingRoomGroupRequest> tmpReq, shared_ptr<QueryMeetingRoomGroupHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMeetingRoomGroupResponse queryMeetingRoomGroup(shared_ptr<QueryMeetingRoomGroupRequest> request);
  QueryMeetingRoomGroupListResponse queryMeetingRoomGroupListWithOptions(shared_ptr<QueryMeetingRoomGroupListRequest> tmpReq, shared_ptr<QueryMeetingRoomGroupListHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMeetingRoomGroupListResponse queryMeetingRoomGroupList(shared_ptr<QueryMeetingRoomGroupListRequest> request);
  QueryMeetingRoomListResponse queryMeetingRoomListWithOptions(shared_ptr<QueryMeetingRoomListRequest> tmpReq, shared_ptr<QueryMeetingRoomListHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMeetingRoomListResponse queryMeetingRoomList(shared_ptr<QueryMeetingRoomListRequest> request);
  QueryMinutesResponse queryMinutesWithOptions(shared_ptr<QueryMinutesRequest> tmpReq, shared_ptr<QueryMinutesHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMinutesResponse queryMinutes(shared_ptr<QueryMinutesRequest> request);
  QueryMinutesSummaryResponse queryMinutesSummaryWithOptions(shared_ptr<QueryMinutesSummaryRequest> tmpReq, shared_ptr<QueryMinutesSummaryHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMinutesSummaryResponse queryMinutesSummary(shared_ptr<QueryMinutesSummaryRequest> request);
  QueryMinutesTextResponse queryMinutesTextWithOptions(shared_ptr<QueryMinutesTextRequest> tmpReq, shared_ptr<QueryMinutesTextHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMinutesTextResponse queryMinutesText(shared_ptr<QueryMinutesTextRequest> request);
  QueryOrgHonorsResponse queryOrgHonorsWithOptions(shared_ptr<QueryOrgHonorsRequest> tmpReq, shared_ptr<QueryOrgHonorsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOrgHonorsResponse queryOrgHonors(shared_ptr<QueryOrgHonorsRequest> request);
  QueryOrgTodoTasksResponse queryOrgTodoTasksWithOptions(shared_ptr<QueryOrgTodoTasksRequest> tmpReq, shared_ptr<QueryOrgTodoTasksHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOrgTodoTasksResponse queryOrgTodoTasks(shared_ptr<QueryOrgTodoTasksRequest> request);
  QueryRecordMinutesUrlResponse queryRecordMinutesUrlWithOptions(shared_ptr<QueryRecordMinutesUrlRequest> tmpReq, shared_ptr<QueryRecordMinutesUrlHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryRecordMinutesUrlResponse queryRecordMinutesUrl(shared_ptr<QueryRecordMinutesUrlRequest> request);
  QueryReportDetailResponse queryReportDetailWithOptions(shared_ptr<QueryReportDetailRequest> tmpReq, shared_ptr<QueryReportDetailHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryReportDetailResponse queryReportDetail(shared_ptr<QueryReportDetailRequest> request);
  QueryScheduleConferenceResponse queryScheduleConferenceWithOptions(shared_ptr<QueryScheduleConferenceRequest> tmpReq, shared_ptr<QueryScheduleConferenceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryScheduleConferenceResponse queryScheduleConference(shared_ptr<QueryScheduleConferenceRequest> request);
  QueryScheduleConferenceInfoResponse queryScheduleConferenceInfoWithOptions(shared_ptr<QueryScheduleConferenceInfoRequest> tmpReq, shared_ptr<QueryScheduleConferenceInfoHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryScheduleConferenceInfoResponse queryScheduleConferenceInfo(shared_ptr<QueryScheduleConferenceInfoRequest> request);
  QueryUserHonorsResponse queryUserHonorsWithOptions(shared_ptr<QueryUserHonorsRequest> tmpReq, shared_ptr<QueryUserHonorsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryUserHonorsResponse queryUserHonors(shared_ptr<QueryUserHonorsRequest> request);
  RecallHonorResponse recallHonorWithOptions(shared_ptr<RecallHonorRequest> tmpReq, shared_ptr<RecallHonorHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RecallHonorResponse recallHonor(shared_ptr<RecallHonorRequest> request);
  ReceiverListReportResponse receiverListReportWithOptions(shared_ptr<ReceiverListReportRequest> tmpReq, shared_ptr<ReceiverListReportHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReceiverListReportResponse receiverListReport(shared_ptr<ReceiverListReportRequest> request);
  RedirectTaskResponse redirectTaskWithOptions(shared_ptr<RedirectTaskRequest> request, shared_ptr<RedirectTaskHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RedirectTaskResponse redirectTask(shared_ptr<RedirectTaskRequest> request);
  RemoveAttendeeResponse removeAttendeeWithOptions(shared_ptr<RemoveAttendeeRequest> tmpReq, shared_ptr<RemoveAttendeeHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveAttendeeResponse removeAttendee(shared_ptr<RemoveAttendeeRequest> request);
  RemoveMeetingRoomsResponse removeMeetingRoomsWithOptions(shared_ptr<RemoveMeetingRoomsRequest> tmpReq, shared_ptr<RemoveMeetingRoomsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveMeetingRoomsResponse removeMeetingRooms(shared_ptr<RemoveMeetingRoomsRequest> request);
  RespondEventResponse respondEventWithOptions(shared_ptr<RespondEventRequest> tmpReq, shared_ptr<RespondEventHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RespondEventResponse respondEvent(shared_ptr<RespondEventRequest> request);
  RetrieveRunResponse retrieveRunWithOptions(shared_ptr<RetrieveRunRequest> request, shared_ptr<RetrieveRunHeaders> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RetrieveRunResponse retrieveRun(shared_ptr<RetrieveRunRequest> request);
  SaveContentResponse saveContentWithOptions(shared_ptr<SaveContentRequest> tmpReq, shared_ptr<SaveContentHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveContentResponse saveContent(shared_ptr<SaveContentRequest> request);
  SaveFormDataResponse saveFormDataWithOptions(shared_ptr<SaveFormDataRequest> request, shared_ptr<SaveFormDataHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveFormDataResponse saveFormData(shared_ptr<SaveFormDataRequest> request);
  SaveFormRemarkResponse saveFormRemarkWithOptions(shared_ptr<SaveFormRemarkRequest> request, shared_ptr<SaveFormRemarkHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveFormRemarkResponse saveFormRemark(shared_ptr<SaveFormRemarkRequest> request);
  SearchEmployeeFieldValuesResponse searchEmployeeFieldValuesWithOptions(shared_ptr<SearchEmployeeFieldValuesRequest> request, shared_ptr<SearchEmployeeFieldValuesHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchEmployeeFieldValuesResponse searchEmployeeFieldValues(shared_ptr<SearchEmployeeFieldValuesRequest> request);
  SearchFormDataIdListResponse searchFormDataIdListWithOptions(shared_ptr<SearchFormDataIdListRequest> request, shared_ptr<SearchFormDataIdListHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchFormDataIdListResponse searchFormDataIdList(shared_ptr<SearchFormDataIdListRequest> request);
  SearchFormDataSecondGenerationResponse searchFormDataSecondGenerationWithOptions(shared_ptr<SearchFormDataSecondGenerationRequest> request, shared_ptr<SearchFormDataSecondGenerationHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchFormDataSecondGenerationResponse searchFormDataSecondGeneration(shared_ptr<SearchFormDataSecondGenerationRequest> request);
  SearchFormDataSecondGenerationNoTableFieldResponse searchFormDataSecondGenerationNoTableFieldWithOptions(shared_ptr<SearchFormDataSecondGenerationNoTableFieldRequest> request, shared_ptr<SearchFormDataSecondGenerationNoTableFieldHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchFormDataSecondGenerationNoTableFieldResponse searchFormDataSecondGenerationNoTableField(shared_ptr<SearchFormDataSecondGenerationNoTableFieldRequest> request);
  SearchFormDatasResponse searchFormDatasWithOptions(shared_ptr<SearchFormDatasRequest> request, shared_ptr<SearchFormDatasHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchFormDatasResponse searchFormDatas(shared_ptr<SearchFormDatasRequest> request);
  SearchInnerGroupsResponse searchInnerGroupsWithOptions(shared_ptr<SearchInnerGroupsRequest> request, shared_ptr<SearchInnerGroupsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchInnerGroupsResponse searchInnerGroups(shared_ptr<SearchInnerGroupsRequest> request);
  SendBannerResponse sendBannerWithOptions(shared_ptr<SendBannerRequest> tmpReq, shared_ptr<SendBannerHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendBannerResponse sendBanner(shared_ptr<SendBannerRequest> request);
  SendPopupResponse sendPopupWithOptions(shared_ptr<SendPopupRequest> tmpReq, shared_ptr<SendPopupHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendPopupResponse sendPopup(shared_ptr<SendPopupRequest> request);
  SendSearchShadeResponse sendSearchShadeWithOptions(shared_ptr<SendSearchShadeRequest> tmpReq, shared_ptr<SendSearchShadeHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendSearchShadeResponse sendSearchShade(shared_ptr<SendSearchShadeRequest> request);
  SetColumnsVisibilityResponse setColumnsVisibilityWithOptions(shared_ptr<SetColumnsVisibilityRequest> tmpReq, shared_ptr<SetColumnsVisibilityHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetColumnsVisibilityResponse setColumnsVisibility(shared_ptr<SetColumnsVisibilityRequest> request);
  SetConferenceHostsResponse setConferenceHostsWithOptions(shared_ptr<SetConferenceHostsRequest> tmpReq, shared_ptr<SetConferenceHostsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetConferenceHostsResponse setConferenceHosts(shared_ptr<SetConferenceHostsRequest> request);
  SetRowsVisibilityResponse setRowsVisibilityWithOptions(shared_ptr<SetRowsVisibilityRequest> tmpReq, shared_ptr<SetRowsVisibilityHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetRowsVisibilityResponse setRowsVisibility(shared_ptr<SetRowsVisibilityRequest> request);
  SimpleListReportResponse simpleListReportWithOptions(shared_ptr<SimpleListReportRequest> tmpReq, shared_ptr<SimpleListReportHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SimpleListReportResponse simpleListReport(shared_ptr<SimpleListReportRequest> request);
  StartCloudRecordResponse startCloudRecordWithOptions(shared_ptr<StartCloudRecordRequest> tmpReq, shared_ptr<StartCloudRecordHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartCloudRecordResponse startCloudRecord(shared_ptr<StartCloudRecordRequest> request);
  StartInstanceResponse startInstanceWithOptions(shared_ptr<StartInstanceRequest> request, shared_ptr<StartInstanceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartInstanceResponse startInstance(shared_ptr<StartInstanceRequest> request);
  StartMinutesResponse startMinutesWithOptions(shared_ptr<StartMinutesRequest> tmpReq, shared_ptr<StartMinutesHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartMinutesResponse startMinutes(shared_ptr<StartMinutesRequest> request);
  StatisticsListByTypeReportResponse statisticsListByTypeReportWithOptions(shared_ptr<StatisticsListByTypeReportRequest> tmpReq, shared_ptr<StatisticsListByTypeReportHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StatisticsListByTypeReportResponse statisticsListByTypeReport(shared_ptr<StatisticsListByTypeReportRequest> request);
  StatisticsReportResponse statisticsReportWithOptions(shared_ptr<StatisticsReportRequest> tmpReq, shared_ptr<StatisticsReportHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StatisticsReportResponse statisticsReport(shared_ptr<StatisticsReportRequest> request);
  StopCloudRecordResponse stopCloudRecordWithOptions(shared_ptr<StopCloudRecordRequest> tmpReq, shared_ptr<StopCloudRecordHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopCloudRecordResponse stopCloudRecord(shared_ptr<StopCloudRecordRequest> request);
  StopMinutesResponse stopMinutesWithOptions(shared_ptr<StopMinutesRequest> tmpReq, shared_ptr<StopMinutesHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopMinutesResponse stopMinutes(shared_ptr<StopMinutesRequest> request);
  SubscribeCalendarResponse subscribeCalendarWithOptions(shared_ptr<SubscribeCalendarRequest> request, shared_ptr<SubscribeCalendarHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubscribeCalendarResponse subscribeCalendar(shared_ptr<SubscribeCalendarRequest> request);
  SubscribeEventResponse subscribeEventWithOptions(shared_ptr<SubscribeEventRequest> tmpReq, shared_ptr<SubscribeEventHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubscribeEventResponse subscribeEvent(shared_ptr<SubscribeEventRequest> request);
  SwitchMainOrgResponse switchMainOrgWithOptions(shared_ptr<SwitchMainOrgRequest> tmpReq, shared_ptr<SwitchMainOrgHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SwitchMainOrgResponse switchMainOrg(shared_ptr<SwitchMainOrgRequest> request);
  SyncDingTypeResponse syncDingTypeWithOptions(shared_ptr<SyncDingTypeRequest> tmpReq, shared_ptr<SyncDingTypeHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SyncDingTypeResponse syncDingType(shared_ptr<SyncDingTypeRequest> request);
  TerminateInstanceResponse terminateInstanceWithOptions(shared_ptr<TerminateInstanceRequest> request, shared_ptr<TerminateInstanceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TerminateInstanceResponse terminateInstance(shared_ptr<TerminateInstanceRequest> request);
  TransferTicketResponse transferTicketWithOptions(shared_ptr<TransferTicketRequest> tmpReq, shared_ptr<TransferTicketHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TransferTicketResponse transferTicket(shared_ptr<TransferTicketRequest> request);
  UnsubscribeCalendarResponse unsubscribeCalendarWithOptions(shared_ptr<UnsubscribeCalendarRequest> request, shared_ptr<UnsubscribeCalendarHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnsubscribeCalendarResponse unsubscribeCalendar(shared_ptr<UnsubscribeCalendarRequest> request);
  UnsubscribeEventResponse unsubscribeEventWithOptions(shared_ptr<UnsubscribeEventRequest> tmpReq, shared_ptr<UnsubscribeEventHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnsubscribeEventResponse unsubscribeEvent(shared_ptr<UnsubscribeEventRequest> request);
  UpdateConvExtensionResponse updateConvExtensionWithOptions(shared_ptr<UpdateConvExtensionRequest> tmpReq, shared_ptr<UpdateConvExtensionHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateConvExtensionResponse updateConvExtension(shared_ptr<UpdateConvExtensionRequest> request);
  UpdateFormDataResponse updateFormDataWithOptions(shared_ptr<UpdateFormDataRequest> request, shared_ptr<UpdateFormDataHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateFormDataResponse updateFormData(shared_ptr<UpdateFormDataRequest> request);
  UpdateInstanceResponse updateInstanceWithOptions(shared_ptr<UpdateInstanceRequest> request, shared_ptr<UpdateInstanceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateInstanceResponse updateInstance(shared_ptr<UpdateInstanceRequest> request);
  UpdateLiveResponse updateLiveWithOptions(shared_ptr<UpdateLiveRequest> tmpReq, shared_ptr<UpdateLiveHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveResponse updateLive(shared_ptr<UpdateLiveRequest> request);
  UpdateMeetingRoomResponse updateMeetingRoomWithOptions(shared_ptr<UpdateMeetingRoomRequest> tmpReq, shared_ptr<UpdateMeetingRoomHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMeetingRoomResponse updateMeetingRoom(shared_ptr<UpdateMeetingRoomRequest> request);
  UpdateMeetingRoomGroupResponse updateMeetingRoomGroupWithOptions(shared_ptr<UpdateMeetingRoomGroupRequest> tmpReq, shared_ptr<UpdateMeetingRoomGroupHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMeetingRoomGroupResponse updateMeetingRoomGroup(shared_ptr<UpdateMeetingRoomGroupRequest> request);
  UpdateMultiDimTableResponse updateMultiDimTableWithOptions(shared_ptr<UpdateMultiDimTableRequest> tmpReq, shared_ptr<UpdateMultiDimTableHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMultiDimTableResponse updateMultiDimTable(shared_ptr<UpdateMultiDimTableRequest> request);
  UpdateMultiDimTableFieldResponse updateMultiDimTableFieldWithOptions(shared_ptr<UpdateMultiDimTableFieldRequest> tmpReq, shared_ptr<UpdateMultiDimTableFieldHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMultiDimTableFieldResponse updateMultiDimTableField(shared_ptr<UpdateMultiDimTableFieldRequest> request);
  UpdateMultiDimTableRecordsResponse updateMultiDimTableRecordsWithOptions(shared_ptr<UpdateMultiDimTableRecordsRequest> tmpReq, shared_ptr<UpdateMultiDimTableRecordsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMultiDimTableRecordsResponse updateMultiDimTableRecords(shared_ptr<UpdateMultiDimTableRecordsRequest> request);
  UpdatePermissionResponse updatePermissionWithOptions(shared_ptr<UpdatePermissionRequest> tmpReq, shared_ptr<UpdatePermissionHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePermissionResponse updatePermission(shared_ptr<UpdatePermissionRequest> request);
  UpdateRangeResponse updateRangeWithOptions(shared_ptr<UpdateRangeRequest> tmpReq, shared_ptr<UpdateRangeHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRangeResponse updateRange(shared_ptr<UpdateRangeRequest> request);
  UpdateScheduleConfSettingsResponse updateScheduleConfSettingsWithOptions(shared_ptr<UpdateScheduleConfSettingsRequest> tmpReq, shared_ptr<UpdateScheduleConfSettingsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateScheduleConfSettingsResponse updateScheduleConfSettings(shared_ptr<UpdateScheduleConfSettingsRequest> request);
  UpdateScheduleConferenceResponse updateScheduleConferenceWithOptions(shared_ptr<UpdateScheduleConferenceRequest> tmpReq, shared_ptr<UpdateScheduleConferenceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateScheduleConferenceResponse updateScheduleConference(shared_ptr<UpdateScheduleConferenceRequest> request);
  UpdateStatusResponse updateStatusWithOptions(shared_ptr<UpdateStatusRequest> tmpReq, shared_ptr<UpdateStatusHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateStatusResponse updateStatus(shared_ptr<UpdateStatusRequest> request);
  UpdateSubscribedCalendarsResponse updateSubscribedCalendarsWithOptions(shared_ptr<UpdateSubscribedCalendarsRequest> tmpReq, shared_ptr<UpdateSubscribedCalendarsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSubscribedCalendarsResponse updateSubscribedCalendars(shared_ptr<UpdateSubscribedCalendarsRequest> request);
  UpdateTodoTaskResponse updateTodoTaskWithOptions(shared_ptr<UpdateTodoTaskRequest> tmpReq, shared_ptr<UpdateTodoTaskHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTodoTaskResponse updateTodoTask(shared_ptr<UpdateTodoTaskRequest> request);
  UpdateTodoTaskExecutorStatusResponse updateTodoTaskExecutorStatusWithOptions(shared_ptr<UpdateTodoTaskExecutorStatusRequest> tmpReq, shared_ptr<UpdateTodoTaskExecutorStatusHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTodoTaskExecutorStatusResponse updateTodoTaskExecutorStatus(shared_ptr<UpdateTodoTaskExecutorStatusRequest> request);
  UpdateUserAvatarResponse updateUserAvatarWithOptions(shared_ptr<UpdateUserAvatarRequest> request, shared_ptr<UpdateUserAvatarHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateUserAvatarResponse updateUserAvatar(shared_ptr<UpdateUserAvatarRequest> request);
  UpdateVideoConferenceSettingResponse updateVideoConferenceSettingWithOptions(shared_ptr<UpdateVideoConferenceSettingRequest> tmpReq, shared_ptr<UpdateVideoConferenceSettingHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateVideoConferenceSettingResponse updateVideoConferenceSetting(shared_ptr<UpdateVideoConferenceSettingRequest> request);
  UpdateWorkspaceDocMembersResponse updateWorkspaceDocMembersWithOptions(shared_ptr<UpdateWorkspaceDocMembersRequest> tmpReq, shared_ptr<UpdateWorkspaceDocMembersHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWorkspaceDocMembersResponse updateWorkspaceDocMembers(shared_ptr<UpdateWorkspaceDocMembersRequest> request);
  UpdateWorkspaceMembersResponse updateWorkspaceMembersWithOptions(shared_ptr<UpdateWorkspaceMembersRequest> tmpReq, shared_ptr<UpdateWorkspaceMembersHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWorkspaceMembersResponse updateWorkspaceMembers(shared_ptr<UpdateWorkspaceMembersRequest> request);
  UploadMediaResponse uploadMediaWithOptions(shared_ptr<UploadMediaRequest> tmpReq, shared_ptr<UploadMediaHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadMediaResponse uploadMedia(shared_ptr<UploadMediaRequest> request);
  WearOrgHonorResponse wearOrgHonorWithOptions(shared_ptr<WearOrgHonorRequest> tmpReq, shared_ptr<WearOrgHonorHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  WearOrgHonorResponse wearOrgHonor(shared_ptr<WearOrgHonorRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Aliding20230426

#endif
