// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_ALIDING20230426_H_
#define ALIBABACLOUD_ALIDING20230426_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Aliding20230426 {
class AddAttendeeHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  AddAttendeeHeadersAccountContext() {}

  explicit AddAttendeeHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~AddAttendeeHeadersAccountContext() = default;
};
class AddAttendeeHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<AddAttendeeHeadersAccountContext> accountContext{};

  AddAttendeeHeaders() {}

  explicit AddAttendeeHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        AddAttendeeHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<AddAttendeeHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~AddAttendeeHeaders() = default;
};
class AddAttendeeShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  AddAttendeeShrinkHeaders() {}

  explicit AddAttendeeShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~AddAttendeeShrinkHeaders() = default;
};
class AddAttendeeRequestAttendeesToAdd : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<bool> isOptional{};

  AddAttendeeRequestAttendeesToAdd() {}

  explicit AddAttendeeRequestAttendeesToAdd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isOptional) {
      res["isOptional"] = boost::any(*isOptional);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("isOptional") != m.end() && !m["isOptional"].empty()) {
      isOptional = make_shared<bool>(boost::any_cast<bool>(m["isOptional"]));
    }
  }


  virtual ~AddAttendeeRequestAttendeesToAdd() = default;
};
class AddAttendeeRequest : public Darabonba::Model {
public:
  shared_ptr<vector<AddAttendeeRequestAttendeesToAdd>> attendeesToAdd{};
  shared_ptr<string> calendarId{};
  shared_ptr<string> eventId{};

  AddAttendeeRequest() {}

  explicit AddAttendeeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendeesToAdd) {
      vector<boost::any> temp1;
      for(auto item1:*attendeesToAdd){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AttendeesToAdd"] = boost::any(temp1);
    }
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttendeesToAdd") != m.end() && !m["AttendeesToAdd"].empty()) {
      if (typeid(vector<boost::any>) == m["AttendeesToAdd"].type()) {
        vector<AddAttendeeRequestAttendeesToAdd> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AttendeesToAdd"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddAttendeeRequestAttendeesToAdd model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attendeesToAdd = make_shared<vector<AddAttendeeRequestAttendeesToAdd>>(expect1);
      }
    }
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
  }


  virtual ~AddAttendeeRequest() = default;
};
class AddAttendeeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> attendeesToAddShrink{};
  shared_ptr<string> calendarId{};
  shared_ptr<string> eventId{};

  AddAttendeeShrinkRequest() {}

  explicit AddAttendeeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendeesToAddShrink) {
      res["AttendeesToAdd"] = boost::any(*attendeesToAddShrink);
    }
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttendeesToAdd") != m.end() && !m["AttendeesToAdd"].empty()) {
      attendeesToAddShrink = make_shared<string>(boost::any_cast<string>(m["AttendeesToAdd"]));
    }
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
  }


  virtual ~AddAttendeeShrinkRequest() = default;
};
class AddAttendeeResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};

  AddAttendeeResponseBodyContent() {}

  explicit AddAttendeeResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
  }


  virtual ~AddAttendeeResponseBodyContent() = default;
};
class AddAttendeeResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddAttendeeResponseBodyContent> content{};
  shared_ptr<string> errorCode{};
  shared_ptr<map<string, boost::any>> errorCtx{};
  shared_ptr<string> errorMsg{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddAttendeeResponseBody() {}

  explicit AddAttendeeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorCtx) {
      res["ErrorCtx"] = boost::any(*errorCtx);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        AddAttendeeResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<AddAttendeeResponseBodyContent>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorCtx") != m.end() && !m["ErrorCtx"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ErrorCtx"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      errorCtx = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddAttendeeResponseBody() = default;
};
class AddAttendeeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddAttendeeResponseBody> body{};

  AddAttendeeResponse() {}

  explicit AddAttendeeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddAttendeeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddAttendeeResponseBody>(model1);
      }
    }
  }


  virtual ~AddAttendeeResponse() = default;
};
class AddWorkspaceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  AddWorkspaceHeadersAccountContext() {}

  explicit AddWorkspaceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~AddWorkspaceHeadersAccountContext() = default;
};
class AddWorkspaceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<AddWorkspaceHeadersAccountContext> accountContext{};

  AddWorkspaceHeaders() {}

  explicit AddWorkspaceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        AddWorkspaceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<AddWorkspaceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~AddWorkspaceHeaders() = default;
};
class AddWorkspaceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  AddWorkspaceShrinkHeaders() {}

  explicit AddWorkspaceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~AddWorkspaceShrinkHeaders() = default;
};
class AddWorkspaceRequestOption : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> teamId{};

  AddWorkspaceRequestOption() {}

  explicit AddWorkspaceRequestOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (teamId) {
      res["TeamId"] = boost::any(*teamId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("TeamId") != m.end() && !m["TeamId"].empty()) {
      teamId = make_shared<string>(boost::any_cast<string>(m["TeamId"]));
    }
  }


  virtual ~AddWorkspaceRequestOption() = default;
};
class AddWorkspaceRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  AddWorkspaceRequestTenantContext() {}

  explicit AddWorkspaceRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~AddWorkspaceRequestTenantContext() = default;
};
class AddWorkspaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<AddWorkspaceRequestOption> option{};
  shared_ptr<AddWorkspaceRequestTenantContext> tenantContext{};

  AddWorkspaceRequest() {}

  explicit AddWorkspaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (option) {
      res["Option"] = option ? boost::any(option->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      if (typeid(map<string, boost::any>) == m["Option"].type()) {
        AddWorkspaceRequestOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Option"]));
        option = make_shared<AddWorkspaceRequestOption>(model1);
      }
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        AddWorkspaceRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<AddWorkspaceRequestTenantContext>(model1);
      }
    }
  }


  virtual ~AddWorkspaceRequest() = default;
};
class AddWorkspaceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> optionShrink{};
  shared_ptr<string> tenantContextShrink{};

  AddWorkspaceShrinkRequest() {}

  explicit AddWorkspaceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (optionShrink) {
      res["Option"] = boost::any(*optionShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      optionShrink = make_shared<string>(boost::any_cast<string>(m["Option"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~AddWorkspaceShrinkRequest() = default;
};
class AddWorkspaceResponseBodyWorkspaceIcon : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  AddWorkspaceResponseBodyWorkspaceIcon() {}

  explicit AddWorkspaceResponseBodyWorkspaceIcon(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~AddWorkspaceResponseBodyWorkspaceIcon() = default;
};
class AddWorkspaceResponseBodyWorkspace : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<string> cover{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<AddWorkspaceResponseBodyWorkspaceIcon> icon{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> name{};
  shared_ptr<string> permissionRole{};
  shared_ptr<string> rootNodeId{};
  shared_ptr<string> teamId{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  AddWorkspaceResponseBodyWorkspace() {}

  explicit AddWorkspaceResponseBodyWorkspace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (cover) {
      res["Cover"] = boost::any(*cover);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (icon) {
      res["Icon"] = icon ? boost::any(icon->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (permissionRole) {
      res["PermissionRole"] = boost::any(*permissionRole);
    }
    if (rootNodeId) {
      res["RootNodeId"] = boost::any(*rootNodeId);
    }
    if (teamId) {
      res["TeamId"] = boost::any(*teamId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      cover = make_shared<string>(boost::any_cast<string>(m["Cover"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      if (typeid(map<string, boost::any>) == m["Icon"].type()) {
        AddWorkspaceResponseBodyWorkspaceIcon model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Icon"]));
        icon = make_shared<AddWorkspaceResponseBodyWorkspaceIcon>(model1);
      }
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["ModifierId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PermissionRole") != m.end() && !m["PermissionRole"].empty()) {
      permissionRole = make_shared<string>(boost::any_cast<string>(m["PermissionRole"]));
    }
    if (m.find("RootNodeId") != m.end() && !m["RootNodeId"].empty()) {
      rootNodeId = make_shared<string>(boost::any_cast<string>(m["RootNodeId"]));
    }
    if (m.find("TeamId") != m.end() && !m["TeamId"].empty()) {
      teamId = make_shared<string>(boost::any_cast<string>(m["TeamId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~AddWorkspaceResponseBodyWorkspace() = default;
};
class AddWorkspaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<AddWorkspaceResponseBodyWorkspace> workspace{};

  AddWorkspaceResponseBody() {}

  explicit AddWorkspaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (workspace) {
      res["workspace"] = workspace ? boost::any(workspace->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("workspace") != m.end() && !m["workspace"].empty()) {
      if (typeid(map<string, boost::any>) == m["workspace"].type()) {
        AddWorkspaceResponseBodyWorkspace model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["workspace"]));
        workspace = make_shared<AddWorkspaceResponseBodyWorkspace>(model1);
      }
    }
  }


  virtual ~AddWorkspaceResponseBody() = default;
};
class AddWorkspaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddWorkspaceResponseBody> body{};

  AddWorkspaceResponse() {}

  explicit AddWorkspaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddWorkspaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddWorkspaceResponseBody>(model1);
      }
    }
  }


  virtual ~AddWorkspaceResponse() = default;
};
class AddWorkspaceDocMembersHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  AddWorkspaceDocMembersHeadersAccountContext() {}

  explicit AddWorkspaceDocMembersHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~AddWorkspaceDocMembersHeadersAccountContext() = default;
};
class AddWorkspaceDocMembersHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<AddWorkspaceDocMembersHeadersAccountContext> accountContext{};

  AddWorkspaceDocMembersHeaders() {}

  explicit AddWorkspaceDocMembersHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        AddWorkspaceDocMembersHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<AddWorkspaceDocMembersHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~AddWorkspaceDocMembersHeaders() = default;
};
class AddWorkspaceDocMembersShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  AddWorkspaceDocMembersShrinkHeaders() {}

  explicit AddWorkspaceDocMembersShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~AddWorkspaceDocMembersShrinkHeaders() = default;
};
class AddWorkspaceDocMembersRequestMembers : public Darabonba::Model {
public:
  shared_ptr<string> memberId{};
  shared_ptr<string> memberType{};
  shared_ptr<string> roleType{};

  AddWorkspaceDocMembersRequestMembers() {}

  explicit AddWorkspaceDocMembersRequestMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberId) {
      res["MemberId"] = boost::any(*memberId);
    }
    if (memberType) {
      res["MemberType"] = boost::any(*memberType);
    }
    if (roleType) {
      res["RoleType"] = boost::any(*roleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemberId") != m.end() && !m["MemberId"].empty()) {
      memberId = make_shared<string>(boost::any_cast<string>(m["MemberId"]));
    }
    if (m.find("MemberType") != m.end() && !m["MemberType"].empty()) {
      memberType = make_shared<string>(boost::any_cast<string>(m["MemberType"]));
    }
    if (m.find("RoleType") != m.end() && !m["RoleType"].empty()) {
      roleType = make_shared<string>(boost::any_cast<string>(m["RoleType"]));
    }
  }


  virtual ~AddWorkspaceDocMembersRequestMembers() = default;
};
class AddWorkspaceDocMembersRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  AddWorkspaceDocMembersRequestTenantContext() {}

  explicit AddWorkspaceDocMembersRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~AddWorkspaceDocMembersRequestTenantContext() = default;
};
class AddWorkspaceDocMembersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<AddWorkspaceDocMembersRequestMembers>> members{};
  shared_ptr<string> nodeId{};
  shared_ptr<AddWorkspaceDocMembersRequestTenantContext> tenantContext{};
  shared_ptr<string> workspaceId{};

  AddWorkspaceDocMembersRequest() {}

  explicit AddWorkspaceDocMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (members) {
      vector<boost::any> temp1;
      for(auto item1:*members){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Members"] = boost::any(temp1);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      if (typeid(vector<boost::any>) == m["Members"].type()) {
        vector<AddWorkspaceDocMembersRequestMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Members"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddWorkspaceDocMembersRequestMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        members = make_shared<vector<AddWorkspaceDocMembersRequestMembers>>(expect1);
      }
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        AddWorkspaceDocMembersRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<AddWorkspaceDocMembersRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~AddWorkspaceDocMembersRequest() = default;
};
class AddWorkspaceDocMembersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> membersShrink{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workspaceId{};

  AddWorkspaceDocMembersShrinkRequest() {}

  explicit AddWorkspaceDocMembersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (membersShrink) {
      res["Members"] = boost::any(*membersShrink);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      membersShrink = make_shared<string>(boost::any_cast<string>(m["Members"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~AddWorkspaceDocMembersShrinkRequest() = default;
};
class AddWorkspaceDocMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddWorkspaceDocMembersResponseBody() {}

  explicit AddWorkspaceDocMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~AddWorkspaceDocMembersResponseBody() = default;
};
class AddWorkspaceDocMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddWorkspaceDocMembersResponseBody> body{};

  AddWorkspaceDocMembersResponse() {}

  explicit AddWorkspaceDocMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddWorkspaceDocMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddWorkspaceDocMembersResponseBody>(model1);
      }
    }
  }


  virtual ~AddWorkspaceDocMembersResponse() = default;
};
class AddWorkspaceMembersHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  AddWorkspaceMembersHeadersAccountContext() {}

  explicit AddWorkspaceMembersHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~AddWorkspaceMembersHeadersAccountContext() = default;
};
class AddWorkspaceMembersHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<AddWorkspaceMembersHeadersAccountContext> accountContext{};

  AddWorkspaceMembersHeaders() {}

  explicit AddWorkspaceMembersHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        AddWorkspaceMembersHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<AddWorkspaceMembersHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~AddWorkspaceMembersHeaders() = default;
};
class AddWorkspaceMembersShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  AddWorkspaceMembersShrinkHeaders() {}

  explicit AddWorkspaceMembersShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~AddWorkspaceMembersShrinkHeaders() = default;
};
class AddWorkspaceMembersRequestMembers : public Darabonba::Model {
public:
  shared_ptr<string> memberId{};
  shared_ptr<string> memberType{};
  shared_ptr<string> roleType{};

  AddWorkspaceMembersRequestMembers() {}

  explicit AddWorkspaceMembersRequestMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberId) {
      res["MemberId"] = boost::any(*memberId);
    }
    if (memberType) {
      res["MemberType"] = boost::any(*memberType);
    }
    if (roleType) {
      res["RoleType"] = boost::any(*roleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemberId") != m.end() && !m["MemberId"].empty()) {
      memberId = make_shared<string>(boost::any_cast<string>(m["MemberId"]));
    }
    if (m.find("MemberType") != m.end() && !m["MemberType"].empty()) {
      memberType = make_shared<string>(boost::any_cast<string>(m["MemberType"]));
    }
    if (m.find("RoleType") != m.end() && !m["RoleType"].empty()) {
      roleType = make_shared<string>(boost::any_cast<string>(m["RoleType"]));
    }
  }


  virtual ~AddWorkspaceMembersRequestMembers() = default;
};
class AddWorkspaceMembersRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  AddWorkspaceMembersRequestTenantContext() {}

  explicit AddWorkspaceMembersRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~AddWorkspaceMembersRequestTenantContext() = default;
};
class AddWorkspaceMembersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<AddWorkspaceMembersRequestMembers>> members{};
  shared_ptr<AddWorkspaceMembersRequestTenantContext> tenantContext{};
  shared_ptr<string> workspaceId{};

  AddWorkspaceMembersRequest() {}

  explicit AddWorkspaceMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (members) {
      vector<boost::any> temp1;
      for(auto item1:*members){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Members"] = boost::any(temp1);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      if (typeid(vector<boost::any>) == m["Members"].type()) {
        vector<AddWorkspaceMembersRequestMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Members"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddWorkspaceMembersRequestMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        members = make_shared<vector<AddWorkspaceMembersRequestMembers>>(expect1);
      }
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        AddWorkspaceMembersRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<AddWorkspaceMembersRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~AddWorkspaceMembersRequest() = default;
};
class AddWorkspaceMembersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> membersShrink{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workspaceId{};

  AddWorkspaceMembersShrinkRequest() {}

  explicit AddWorkspaceMembersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (membersShrink) {
      res["Members"] = boost::any(*membersShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      membersShrink = make_shared<string>(boost::any_cast<string>(m["Members"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~AddWorkspaceMembersShrinkRequest() = default;
};
class AddWorkspaceMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> notInOrgList{};
  shared_ptr<string> requestId{};

  AddWorkspaceMembersResponseBody() {}

  explicit AddWorkspaceMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notInOrgList) {
      res["NotInOrgList"] = boost::any(*notInOrgList);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotInOrgList") != m.end() && !m["NotInOrgList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NotInOrgList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NotInOrgList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      notInOrgList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~AddWorkspaceMembersResponseBody() = default;
};
class AddWorkspaceMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddWorkspaceMembersResponseBody> body{};

  AddWorkspaceMembersResponse() {}

  explicit AddWorkspaceMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddWorkspaceMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddWorkspaceMembersResponseBody>(model1);
      }
    }
  }


  virtual ~AddWorkspaceMembersResponse() = default;
};
class CancelScheduleConferenceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CancelScheduleConferenceHeadersAccountContext() {}

  explicit CancelScheduleConferenceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CancelScheduleConferenceHeadersAccountContext() = default;
};
class CancelScheduleConferenceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CancelScheduleConferenceHeadersAccountContext> accountContext{};

  CancelScheduleConferenceHeaders() {}

  explicit CancelScheduleConferenceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CancelScheduleConferenceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CancelScheduleConferenceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CancelScheduleConferenceHeaders() = default;
};
class CancelScheduleConferenceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CancelScheduleConferenceShrinkHeaders() {}

  explicit CancelScheduleConferenceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CancelScheduleConferenceShrinkHeaders() = default;
};
class CancelScheduleConferenceRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CancelScheduleConferenceRequestTenantContext() {}

  explicit CancelScheduleConferenceRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CancelScheduleConferenceRequestTenantContext() = default;
};
class CancelScheduleConferenceRequest : public Darabonba::Model {
public:
  shared_ptr<string> scheduleConferenceId{};
  shared_ptr<CancelScheduleConferenceRequestTenantContext> tenantContext{};

  CancelScheduleConferenceRequest() {}

  explicit CancelScheduleConferenceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scheduleConferenceId) {
      res["ScheduleConferenceId"] = boost::any(*scheduleConferenceId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScheduleConferenceId") != m.end() && !m["ScheduleConferenceId"].empty()) {
      scheduleConferenceId = make_shared<string>(boost::any_cast<string>(m["ScheduleConferenceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CancelScheduleConferenceRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CancelScheduleConferenceRequestTenantContext>(model1);
      }
    }
  }


  virtual ~CancelScheduleConferenceRequest() = default;
};
class CancelScheduleConferenceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> scheduleConferenceId{};
  shared_ptr<string> tenantContextShrink{};

  CancelScheduleConferenceShrinkRequest() {}

  explicit CancelScheduleConferenceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scheduleConferenceId) {
      res["ScheduleConferenceId"] = boost::any(*scheduleConferenceId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScheduleConferenceId") != m.end() && !m["ScheduleConferenceId"].empty()) {
      scheduleConferenceId = make_shared<string>(boost::any_cast<string>(m["ScheduleConferenceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~CancelScheduleConferenceShrinkRequest() = default;
};
class CancelScheduleConferenceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CancelScheduleConferenceResponseBody() {}

  explicit CancelScheduleConferenceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CancelScheduleConferenceResponseBody() = default;
};
class CancelScheduleConferenceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelScheduleConferenceResponseBody> body{};

  CancelScheduleConferenceResponse() {}

  explicit CancelScheduleConferenceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelScheduleConferenceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelScheduleConferenceResponseBody>(model1);
      }
    }
  }


  virtual ~CancelScheduleConferenceResponse() = default;
};
class ClearHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ClearHeadersAccountContext() {}

  explicit ClearHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ClearHeadersAccountContext() = default;
};
class ClearHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ClearHeadersAccountContext> accountContext{};

  ClearHeaders() {}

  explicit ClearHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ClearHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ClearHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ClearHeaders() = default;
};
class ClearShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ClearShrinkHeaders() {}

  explicit ClearShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ClearShrinkHeaders() = default;
};
class ClearRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  ClearRequestTenantContext() {}

  explicit ClearRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~ClearRequestTenantContext() = default;
};
class ClearRequest : public Darabonba::Model {
public:
  shared_ptr<string> rangeAddress{};
  shared_ptr<string> sheetId{};
  shared_ptr<ClearRequestTenantContext> tenantContext{};
  shared_ptr<string> workbookId{};

  ClearRequest() {}

  explicit ClearRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rangeAddress) {
      res["RangeAddress"] = boost::any(*rangeAddress);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RangeAddress") != m.end() && !m["RangeAddress"].empty()) {
      rangeAddress = make_shared<string>(boost::any_cast<string>(m["RangeAddress"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        ClearRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<ClearRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~ClearRequest() = default;
};
class ClearShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> rangeAddress{};
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workbookId{};

  ClearShrinkRequest() {}

  explicit ClearShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rangeAddress) {
      res["RangeAddress"] = boost::any(*rangeAddress);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RangeAddress") != m.end() && !m["RangeAddress"].empty()) {
      rangeAddress = make_shared<string>(boost::any_cast<string>(m["RangeAddress"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~ClearShrinkRequest() = default;
};
class ClearResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> a1Notation{};
  shared_ptr<string> requestId{};

  ClearResponseBody() {}

  explicit ClearResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (a1Notation) {
      res["a1Notation"] = boost::any(*a1Notation);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("a1Notation") != m.end() && !m["a1Notation"].empty()) {
      a1Notation = make_shared<string>(boost::any_cast<string>(m["a1Notation"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ClearResponseBody() = default;
};
class ClearResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ClearResponseBody> body{};

  ClearResponse() {}

  explicit ClearResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ClearResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ClearResponseBody>(model1);
      }
    }
  }


  virtual ~ClearResponse() = default;
};
class ClearDataHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ClearDataHeadersAccountContext() {}

  explicit ClearDataHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ClearDataHeadersAccountContext() = default;
};
class ClearDataHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ClearDataHeadersAccountContext> accountContext{};

  ClearDataHeaders() {}

  explicit ClearDataHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ClearDataHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ClearDataHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ClearDataHeaders() = default;
};
class ClearDataShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ClearDataShrinkHeaders() {}

  explicit ClearDataShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ClearDataShrinkHeaders() = default;
};
class ClearDataRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  ClearDataRequestTenantContext() {}

  explicit ClearDataRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~ClearDataRequestTenantContext() = default;
};
class ClearDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> rangeAddress{};
  shared_ptr<string> sheetId{};
  shared_ptr<ClearDataRequestTenantContext> tenantContext{};
  shared_ptr<string> workbookId{};

  ClearDataRequest() {}

  explicit ClearDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rangeAddress) {
      res["RangeAddress"] = boost::any(*rangeAddress);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RangeAddress") != m.end() && !m["RangeAddress"].empty()) {
      rangeAddress = make_shared<string>(boost::any_cast<string>(m["RangeAddress"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        ClearDataRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<ClearDataRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~ClearDataRequest() = default;
};
class ClearDataShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> rangeAddress{};
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workbookId{};

  ClearDataShrinkRequest() {}

  explicit ClearDataShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rangeAddress) {
      res["RangeAddress"] = boost::any(*rangeAddress);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RangeAddress") != m.end() && !m["RangeAddress"].empty()) {
      rangeAddress = make_shared<string>(boost::any_cast<string>(m["RangeAddress"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~ClearDataShrinkRequest() = default;
};
class ClearDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> a1Notation{};
  shared_ptr<string> requestId{};

  ClearDataResponseBody() {}

  explicit ClearDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (a1Notation) {
      res["a1Notation"] = boost::any(*a1Notation);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("a1Notation") != m.end() && !m["a1Notation"].empty()) {
      a1Notation = make_shared<string>(boost::any_cast<string>(m["a1Notation"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ClearDataResponseBody() = default;
};
class ClearDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ClearDataResponseBody> body{};

  ClearDataResponse() {}

  explicit ClearDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ClearDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ClearDataResponseBody>(model1);
      }
    }
  }


  virtual ~ClearDataResponse() = default;
};
class CommentListReportHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CommentListReportHeadersAccountContext() {}

  explicit CommentListReportHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CommentListReportHeadersAccountContext() = default;
};
class CommentListReportHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CommentListReportHeadersAccountContext> accountContext{};

  CommentListReportHeaders() {}

  explicit CommentListReportHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CommentListReportHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CommentListReportHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CommentListReportHeaders() = default;
};
class CommentListReportShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CommentListReportShrinkHeaders() {}

  explicit CommentListReportShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CommentListReportShrinkHeaders() = default;
};
class CommentListReportRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CommentListReportRequestTenantContext() {}

  explicit CommentListReportRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CommentListReportRequestTenantContext() = default;
};
class CommentListReportRequest : public Darabonba::Model {
public:
  shared_ptr<long> offset{};
  shared_ptr<string> reportId{};
  shared_ptr<long> size{};
  shared_ptr<CommentListReportRequestTenantContext> tenantContext{};

  CommentListReportRequest() {}

  explicit CommentListReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CommentListReportRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CommentListReportRequestTenantContext>(model1);
      }
    }
  }


  virtual ~CommentListReportRequest() = default;
};
class CommentListReportShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> offset{};
  shared_ptr<string> reportId{};
  shared_ptr<long> size{};
  shared_ptr<string> tenantContextShrink{};

  CommentListReportShrinkRequest() {}

  explicit CommentListReportShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~CommentListReportShrinkRequest() = default;
};
class CommentListReportResponseBodyComments : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> createTime{};
  shared_ptr<string> userid{};

  CommentListReportResponseBodyComments() {}

  explicit CommentListReportResponseBodyComments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (userid) {
      res["Userid"] = boost::any(*userid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Userid") != m.end() && !m["Userid"].empty()) {
      userid = make_shared<string>(boost::any_cast<string>(m["Userid"]));
    }
  }


  virtual ~CommentListReportResponseBodyComments() = default;
};
class CommentListReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<CommentListReportResponseBodyComments>> comments{};
  shared_ptr<bool> hasMore{};
  shared_ptr<long> nextCursor{};
  shared_ptr<string> requestId{};

  CommentListReportResponseBody() {}

  explicit CommentListReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comments) {
      vector<boost::any> temp1;
      for(auto item1:*comments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["comments"] = boost::any(temp1);
    }
    if (hasMore) {
      res["hasMore"] = boost::any(*hasMore);
    }
    if (nextCursor) {
      res["nextCursor"] = boost::any(*nextCursor);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("comments") != m.end() && !m["comments"].empty()) {
      if (typeid(vector<boost::any>) == m["comments"].type()) {
        vector<CommentListReportResponseBodyComments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["comments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CommentListReportResponseBodyComments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        comments = make_shared<vector<CommentListReportResponseBodyComments>>(expect1);
      }
    }
    if (m.find("hasMore") != m.end() && !m["hasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["hasMore"]));
    }
    if (m.find("nextCursor") != m.end() && !m["nextCursor"].empty()) {
      nextCursor = make_shared<long>(boost::any_cast<long>(m["nextCursor"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CommentListReportResponseBody() = default;
};
class CommentListReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CommentListReportResponseBody> body{};

  CommentListReportResponse() {}

  explicit CommentListReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CommentListReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CommentListReportResponseBody>(model1);
      }
    }
  }


  virtual ~CommentListReportResponse() = default;
};
class CreateEventHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateEventHeadersAccountContext() {}

  explicit CreateEventHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateEventHeadersAccountContext() = default;
};
class CreateEventHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateEventHeadersAccountContext> accountContext{};

  CreateEventHeaders() {}

  explicit CreateEventHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateEventHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateEventHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateEventHeaders() = default;
};
class CreateEventShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateEventShrinkHeaders() {}

  explicit CreateEventShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateEventShrinkHeaders() = default;
};
class CreateEventRequestAttendees : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<bool> isOptional{};

  CreateEventRequestAttendees() {}

  explicit CreateEventRequestAttendees(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isOptional) {
      res["isOptional"] = boost::any(*isOptional);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("isOptional") != m.end() && !m["isOptional"].empty()) {
      isOptional = make_shared<bool>(boost::any_cast<bool>(m["isOptional"]));
    }
  }


  virtual ~CreateEventRequestAttendees() = default;
};
class CreateEventRequestEnd : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  CreateEventRequestEnd() {}

  explicit CreateEventRequestEnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["date"] = boost::any(*date);
    }
    if (dateTime) {
      res["dateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["timeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("date") != m.end() && !m["date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["date"]));
    }
    if (m.find("dateTime") != m.end() && !m["dateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["dateTime"]));
    }
    if (m.find("timeZone") != m.end() && !m["timeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["timeZone"]));
    }
  }


  virtual ~CreateEventRequestEnd() = default;
};
class CreateEventRequestLocation : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};

  CreateEventRequestLocation() {}

  explicit CreateEventRequestLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["displayName"] = boost::any(*displayName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("displayName") != m.end() && !m["displayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["displayName"]));
    }
  }


  virtual ~CreateEventRequestLocation() = default;
};
class CreateEventRequestOnlineMeetingInfo : public Darabonba::Model {
public:
  shared_ptr<string> type{};

  CreateEventRequestOnlineMeetingInfo() {}

  explicit CreateEventRequestOnlineMeetingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateEventRequestOnlineMeetingInfo() = default;
};
class CreateEventRequestRecurrencePattern : public Darabonba::Model {
public:
  shared_ptr<long> dayOfMonth{};
  shared_ptr<string> daysOfWeek{};
  shared_ptr<string> index{};
  shared_ptr<long> interval{};
  shared_ptr<string> type{};

  CreateEventRequestRecurrencePattern() {}

  explicit CreateEventRequestRecurrencePattern(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dayOfMonth) {
      res["dayOfMonth"] = boost::any(*dayOfMonth);
    }
    if (daysOfWeek) {
      res["daysOfWeek"] = boost::any(*daysOfWeek);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (interval) {
      res["interval"] = boost::any(*interval);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dayOfMonth") != m.end() && !m["dayOfMonth"].empty()) {
      dayOfMonth = make_shared<long>(boost::any_cast<long>(m["dayOfMonth"]));
    }
    if (m.find("daysOfWeek") != m.end() && !m["daysOfWeek"].empty()) {
      daysOfWeek = make_shared<string>(boost::any_cast<string>(m["daysOfWeek"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("interval") != m.end() && !m["interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["interval"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateEventRequestRecurrencePattern() = default;
};
class CreateEventRequestRecurrenceRange : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<long> numberOfOccurrences{};
  shared_ptr<string> type{};

  CreateEventRequestRecurrenceRange() {}

  explicit CreateEventRequestRecurrenceRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["endDate"] = boost::any(*endDate);
    }
    if (numberOfOccurrences) {
      res["numberOfOccurrences"] = boost::any(*numberOfOccurrences);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endDate") != m.end() && !m["endDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["endDate"]));
    }
    if (m.find("numberOfOccurrences") != m.end() && !m["numberOfOccurrences"].empty()) {
      numberOfOccurrences = make_shared<long>(boost::any_cast<long>(m["numberOfOccurrences"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CreateEventRequestRecurrenceRange() = default;
};
class CreateEventRequestRecurrence : public Darabonba::Model {
public:
  shared_ptr<CreateEventRequestRecurrencePattern> pattern{};
  shared_ptr<CreateEventRequestRecurrenceRange> range{};

  CreateEventRequestRecurrence() {}

  explicit CreateEventRequestRecurrence(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pattern) {
      res["pattern"] = pattern ? boost::any(pattern->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (range) {
      res["range"] = range ? boost::any(range->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("pattern") != m.end() && !m["pattern"].empty()) {
      if (typeid(map<string, boost::any>) == m["pattern"].type()) {
        CreateEventRequestRecurrencePattern model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["pattern"]));
        pattern = make_shared<CreateEventRequestRecurrencePattern>(model1);
      }
    }
    if (m.find("range") != m.end() && !m["range"].empty()) {
      if (typeid(map<string, boost::any>) == m["range"].type()) {
        CreateEventRequestRecurrenceRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["range"]));
        range = make_shared<CreateEventRequestRecurrenceRange>(model1);
      }
    }
  }


  virtual ~CreateEventRequestRecurrence() = default;
};
class CreateEventRequestReminders : public Darabonba::Model {
public:
  shared_ptr<string> method{};
  shared_ptr<long> minutes{};

  CreateEventRequestReminders() {}

  explicit CreateEventRequestReminders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["method"] = boost::any(*method);
    }
    if (minutes) {
      res["minutes"] = boost::any(*minutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("method") != m.end() && !m["method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["method"]));
    }
    if (m.find("minutes") != m.end() && !m["minutes"].empty()) {
      minutes = make_shared<long>(boost::any_cast<long>(m["minutes"]));
    }
  }


  virtual ~CreateEventRequestReminders() = default;
};
class CreateEventRequestUiConfigs : public Darabonba::Model {
public:
  shared_ptr<string> uiName{};
  shared_ptr<string> uiStatus{};

  CreateEventRequestUiConfigs() {}

  explicit CreateEventRequestUiConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uiName) {
      res["uiName"] = boost::any(*uiName);
    }
    if (uiStatus) {
      res["uiStatus"] = boost::any(*uiStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("uiName") != m.end() && !m["uiName"].empty()) {
      uiName = make_shared<string>(boost::any_cast<string>(m["uiName"]));
    }
    if (m.find("uiStatus") != m.end() && !m["uiStatus"].empty()) {
      uiStatus = make_shared<string>(boost::any_cast<string>(m["uiStatus"]));
    }
  }


  virtual ~CreateEventRequestUiConfigs() = default;
};
class CreateEventRequestStart : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  CreateEventRequestStart() {}

  explicit CreateEventRequestStart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["date"] = boost::any(*date);
    }
    if (dateTime) {
      res["dateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["timeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("date") != m.end() && !m["date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["date"]));
    }
    if (m.find("dateTime") != m.end() && !m["dateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["dateTime"]));
    }
    if (m.find("timeZone") != m.end() && !m["timeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["timeZone"]));
    }
  }


  virtual ~CreateEventRequestStart() = default;
};
class CreateEventRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateEventRequestAttendees>> attendees{};
  shared_ptr<string> description{};
  shared_ptr<CreateEventRequestEnd> end{};
  shared_ptr<map<string, string>> extra{};
  shared_ptr<bool> isAllDay{};
  shared_ptr<CreateEventRequestLocation> location{};
  shared_ptr<CreateEventRequestOnlineMeetingInfo> onlineMeetingInfo{};
  shared_ptr<CreateEventRequestRecurrence> recurrence{};
  shared_ptr<vector<CreateEventRequestReminders>> reminders{};
  shared_ptr<string> summary{};
  shared_ptr<vector<CreateEventRequestUiConfigs>> uiConfigs{};
  shared_ptr<string> calendarId{};
  shared_ptr<CreateEventRequestStart> start{};

  CreateEventRequest() {}

  explicit CreateEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendees) {
      vector<boost::any> temp1;
      for(auto item1:*attendees){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attendees"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (end) {
      res["End"] = end ? boost::any(end->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (isAllDay) {
      res["IsAllDay"] = boost::any(*isAllDay);
    }
    if (location) {
      res["Location"] = location ? boost::any(location->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (onlineMeetingInfo) {
      res["OnlineMeetingInfo"] = onlineMeetingInfo ? boost::any(onlineMeetingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recurrence) {
      res["Recurrence"] = recurrence ? boost::any(recurrence->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reminders) {
      vector<boost::any> temp1;
      for(auto item1:*reminders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Reminders"] = boost::any(temp1);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (uiConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*uiConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UiConfigs"] = boost::any(temp1);
    }
    if (calendarId) {
      res["calendarId"] = boost::any(*calendarId);
    }
    if (start) {
      res["start"] = start ? boost::any(start->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attendees") != m.end() && !m["Attendees"].empty()) {
      if (typeid(vector<boost::any>) == m["Attendees"].type()) {
        vector<CreateEventRequestAttendees> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attendees"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEventRequestAttendees model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attendees = make_shared<vector<CreateEventRequestAttendees>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      if (typeid(map<string, boost::any>) == m["End"].type()) {
        CreateEventRequestEnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["End"]));
        end = make_shared<CreateEventRequestEnd>(model1);
      }
    }
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Extra"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extra = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("IsAllDay") != m.end() && !m["IsAllDay"].empty()) {
      isAllDay = make_shared<bool>(boost::any_cast<bool>(m["IsAllDay"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      if (typeid(map<string, boost::any>) == m["Location"].type()) {
        CreateEventRequestLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Location"]));
        location = make_shared<CreateEventRequestLocation>(model1);
      }
    }
    if (m.find("OnlineMeetingInfo") != m.end() && !m["OnlineMeetingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["OnlineMeetingInfo"].type()) {
        CreateEventRequestOnlineMeetingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OnlineMeetingInfo"]));
        onlineMeetingInfo = make_shared<CreateEventRequestOnlineMeetingInfo>(model1);
      }
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      if (typeid(map<string, boost::any>) == m["Recurrence"].type()) {
        CreateEventRequestRecurrence model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Recurrence"]));
        recurrence = make_shared<CreateEventRequestRecurrence>(model1);
      }
    }
    if (m.find("Reminders") != m.end() && !m["Reminders"].empty()) {
      if (typeid(vector<boost::any>) == m["Reminders"].type()) {
        vector<CreateEventRequestReminders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Reminders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEventRequestReminders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reminders = make_shared<vector<CreateEventRequestReminders>>(expect1);
      }
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("UiConfigs") != m.end() && !m["UiConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["UiConfigs"].type()) {
        vector<CreateEventRequestUiConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UiConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEventRequestUiConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        uiConfigs = make_shared<vector<CreateEventRequestUiConfigs>>(expect1);
      }
    }
    if (m.find("calendarId") != m.end() && !m["calendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["calendarId"]));
    }
    if (m.find("start") != m.end() && !m["start"].empty()) {
      if (typeid(map<string, boost::any>) == m["start"].type()) {
        CreateEventRequestStart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["start"]));
        start = make_shared<CreateEventRequestStart>(model1);
      }
    }
  }


  virtual ~CreateEventRequest() = default;
};
class CreateEventShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> attendeesShrink{};
  shared_ptr<string> description{};
  shared_ptr<string> endShrink{};
  shared_ptr<string> extraShrink{};
  shared_ptr<bool> isAllDay{};
  shared_ptr<string> locationShrink{};
  shared_ptr<string> onlineMeetingInfoShrink{};
  shared_ptr<string> recurrenceShrink{};
  shared_ptr<string> remindersShrink{};
  shared_ptr<string> summary{};
  shared_ptr<string> uiConfigsShrink{};
  shared_ptr<string> calendarId{};
  shared_ptr<string> startShrink{};

  CreateEventShrinkRequest() {}

  explicit CreateEventShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendeesShrink) {
      res["Attendees"] = boost::any(*attendeesShrink);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endShrink) {
      res["End"] = boost::any(*endShrink);
    }
    if (extraShrink) {
      res["Extra"] = boost::any(*extraShrink);
    }
    if (isAllDay) {
      res["IsAllDay"] = boost::any(*isAllDay);
    }
    if (locationShrink) {
      res["Location"] = boost::any(*locationShrink);
    }
    if (onlineMeetingInfoShrink) {
      res["OnlineMeetingInfo"] = boost::any(*onlineMeetingInfoShrink);
    }
    if (recurrenceShrink) {
      res["Recurrence"] = boost::any(*recurrenceShrink);
    }
    if (remindersShrink) {
      res["Reminders"] = boost::any(*remindersShrink);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (uiConfigsShrink) {
      res["UiConfigs"] = boost::any(*uiConfigsShrink);
    }
    if (calendarId) {
      res["calendarId"] = boost::any(*calendarId);
    }
    if (startShrink) {
      res["start"] = boost::any(*startShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attendees") != m.end() && !m["Attendees"].empty()) {
      attendeesShrink = make_shared<string>(boost::any_cast<string>(m["Attendees"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      endShrink = make_shared<string>(boost::any_cast<string>(m["End"]));
    }
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extraShrink = make_shared<string>(boost::any_cast<string>(m["Extra"]));
    }
    if (m.find("IsAllDay") != m.end() && !m["IsAllDay"].empty()) {
      isAllDay = make_shared<bool>(boost::any_cast<bool>(m["IsAllDay"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      locationShrink = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OnlineMeetingInfo") != m.end() && !m["OnlineMeetingInfo"].empty()) {
      onlineMeetingInfoShrink = make_shared<string>(boost::any_cast<string>(m["OnlineMeetingInfo"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrenceShrink = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("Reminders") != m.end() && !m["Reminders"].empty()) {
      remindersShrink = make_shared<string>(boost::any_cast<string>(m["Reminders"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("UiConfigs") != m.end() && !m["UiConfigs"].empty()) {
      uiConfigsShrink = make_shared<string>(boost::any_cast<string>(m["UiConfigs"]));
    }
    if (m.find("calendarId") != m.end() && !m["calendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["calendarId"]));
    }
    if (m.find("start") != m.end() && !m["start"].empty()) {
      startShrink = make_shared<string>(boost::any_cast<string>(m["start"]));
    }
  }


  virtual ~CreateEventShrinkRequest() = default;
};
class CreateEventResponseBodyAttendees : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<bool> isOptional{};
  shared_ptr<string> responseStatus{};
  shared_ptr<bool> self{};

  CreateEventResponseBodyAttendees() {}

  explicit CreateEventResponseBodyAttendees(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (isOptional) {
      res["IsOptional"] = boost::any(*isOptional);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (self) {
      res["Self"] = boost::any(*self);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("IsOptional") != m.end() && !m["IsOptional"].empty()) {
      isOptional = make_shared<bool>(boost::any_cast<bool>(m["IsOptional"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("Self") != m.end() && !m["Self"].empty()) {
      self = make_shared<bool>(boost::any_cast<bool>(m["Self"]));
    }
  }


  virtual ~CreateEventResponseBodyAttendees() = default;
};
class CreateEventResponseBodyEnd : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  CreateEventResponseBodyEnd() {}

  explicit CreateEventResponseBodyEnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~CreateEventResponseBodyEnd() = default;
};
class CreateEventResponseBodyLocation : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};

  CreateEventResponseBodyLocation() {}

  explicit CreateEventResponseBodyLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
  }


  virtual ~CreateEventResponseBodyLocation() = default;
};
class CreateEventResponseBodyOnlineMeetingInfo : public Darabonba::Model {
public:
  shared_ptr<string> conferenceId{};
  shared_ptr<map<string, boost::any>> extraInfo{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  CreateEventResponseBodyOnlineMeetingInfo() {}

  explicit CreateEventResponseBodyOnlineMeetingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conferenceId) {
      res["ConferenceId"] = boost::any(*conferenceId);
    }
    if (extraInfo) {
      res["ExtraInfo"] = boost::any(*extraInfo);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConferenceId") != m.end() && !m["ConferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["ConferenceId"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~CreateEventResponseBodyOnlineMeetingInfo() = default;
};
class CreateEventResponseBodyOrganizer : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> id{};
  shared_ptr<string> responseStatus{};
  shared_ptr<bool> self{};

  CreateEventResponseBodyOrganizer() {}

  explicit CreateEventResponseBodyOrganizer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (self) {
      res["Self"] = boost::any(*self);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("Self") != m.end() && !m["Self"].empty()) {
      self = make_shared<bool>(boost::any_cast<bool>(m["Self"]));
    }
  }


  virtual ~CreateEventResponseBodyOrganizer() = default;
};
class CreateEventResponseBodyRecurrencePattern : public Darabonba::Model {
public:
  shared_ptr<long> dayOfMonth{};
  shared_ptr<string> daysOfWeek{};
  shared_ptr<string> index{};
  shared_ptr<long> interval{};
  shared_ptr<string> type{};

  CreateEventResponseBodyRecurrencePattern() {}

  explicit CreateEventResponseBodyRecurrencePattern(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dayOfMonth) {
      res["DayOfMonth"] = boost::any(*dayOfMonth);
    }
    if (daysOfWeek) {
      res["DaysOfWeek"] = boost::any(*daysOfWeek);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DayOfMonth") != m.end() && !m["DayOfMonth"].empty()) {
      dayOfMonth = make_shared<long>(boost::any_cast<long>(m["DayOfMonth"]));
    }
    if (m.find("DaysOfWeek") != m.end() && !m["DaysOfWeek"].empty()) {
      daysOfWeek = make_shared<string>(boost::any_cast<string>(m["DaysOfWeek"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateEventResponseBodyRecurrencePattern() = default;
};
class CreateEventResponseBodyRecurrenceRange : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<long> numberOfOccurrences{};
  shared_ptr<string> type{};

  CreateEventResponseBodyRecurrenceRange() {}

  explicit CreateEventResponseBodyRecurrenceRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (numberOfOccurrences) {
      res["NumberOfOccurrences"] = boost::any(*numberOfOccurrences);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("NumberOfOccurrences") != m.end() && !m["NumberOfOccurrences"].empty()) {
      numberOfOccurrences = make_shared<long>(boost::any_cast<long>(m["NumberOfOccurrences"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateEventResponseBodyRecurrenceRange() = default;
};
class CreateEventResponseBodyRecurrence : public Darabonba::Model {
public:
  shared_ptr<CreateEventResponseBodyRecurrencePattern> pattern{};
  shared_ptr<CreateEventResponseBodyRecurrenceRange> range{};

  CreateEventResponseBodyRecurrence() {}

  explicit CreateEventResponseBodyRecurrence(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pattern) {
      res["Pattern"] = pattern ? boost::any(pattern->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (range) {
      res["Range"] = range ? boost::any(range->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pattern"].type()) {
        CreateEventResponseBodyRecurrencePattern model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pattern"]));
        pattern = make_shared<CreateEventResponseBodyRecurrencePattern>(model1);
      }
    }
    if (m.find("Range") != m.end() && !m["Range"].empty()) {
      if (typeid(map<string, boost::any>) == m["Range"].type()) {
        CreateEventResponseBodyRecurrenceRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Range"]));
        range = make_shared<CreateEventResponseBodyRecurrenceRange>(model1);
      }
    }
  }


  virtual ~CreateEventResponseBodyRecurrence() = default;
};
class CreateEventResponseBodyReminders : public Darabonba::Model {
public:
  shared_ptr<string> method{};
  shared_ptr<string> minutes{};

  CreateEventResponseBodyReminders() {}

  explicit CreateEventResponseBodyReminders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (minutes) {
      res["Minutes"] = boost::any(*minutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Minutes") != m.end() && !m["Minutes"].empty()) {
      minutes = make_shared<string>(boost::any_cast<string>(m["Minutes"]));
    }
  }


  virtual ~CreateEventResponseBodyReminders() = default;
};
class CreateEventResponseBodyStart : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  CreateEventResponseBodyStart() {}

  explicit CreateEventResponseBodyStart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~CreateEventResponseBodyStart() = default;
};
class CreateEventResponseBodyUiConfigs : public Darabonba::Model {
public:
  shared_ptr<string> uiName{};
  shared_ptr<string> uiStatus{};

  CreateEventResponseBodyUiConfigs() {}

  explicit CreateEventResponseBodyUiConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uiName) {
      res["UiName"] = boost::any(*uiName);
    }
    if (uiStatus) {
      res["UiStatus"] = boost::any(*uiStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UiName") != m.end() && !m["UiName"].empty()) {
      uiName = make_shared<string>(boost::any_cast<string>(m["UiName"]));
    }
    if (m.find("UiStatus") != m.end() && !m["UiStatus"].empty()) {
      uiStatus = make_shared<string>(boost::any_cast<string>(m["UiStatus"]));
    }
  }


  virtual ~CreateEventResponseBodyUiConfigs() = default;
};
class CreateEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<CreateEventResponseBodyAttendees>> attendees{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<CreateEventResponseBodyEnd> end{};
  shared_ptr<string> id{};
  shared_ptr<bool> isAllDay{};
  shared_ptr<CreateEventResponseBodyLocation> location{};
  shared_ptr<CreateEventResponseBodyOnlineMeetingInfo> onlineMeetingInfo{};
  shared_ptr<CreateEventResponseBodyOrganizer> organizer{};
  shared_ptr<CreateEventResponseBodyRecurrence> recurrence{};
  shared_ptr<vector<CreateEventResponseBodyReminders>> reminders{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateEventResponseBodyStart> start{};
  shared_ptr<string> summary{};
  shared_ptr<vector<CreateEventResponseBodyUiConfigs>> uiConfigs{};
  shared_ptr<string> updateTime{};

  CreateEventResponseBody() {}

  explicit CreateEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendees) {
      vector<boost::any> temp1;
      for(auto item1:*attendees){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["attendees"] = boost::any(temp1);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (end) {
      res["end"] = end ? boost::any(end->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isAllDay) {
      res["isAllDay"] = boost::any(*isAllDay);
    }
    if (location) {
      res["location"] = location ? boost::any(location->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (onlineMeetingInfo) {
      res["onlineMeetingInfo"] = onlineMeetingInfo ? boost::any(onlineMeetingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (organizer) {
      res["organizer"] = organizer ? boost::any(organizer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recurrence) {
      res["recurrence"] = recurrence ? boost::any(recurrence->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reminders) {
      vector<boost::any> temp1;
      for(auto item1:*reminders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["reminders"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (start) {
      res["start"] = start ? boost::any(start->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (summary) {
      res["summary"] = boost::any(*summary);
    }
    if (uiConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*uiConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["uiConfigs"] = boost::any(temp1);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("attendees") != m.end() && !m["attendees"].empty()) {
      if (typeid(vector<boost::any>) == m["attendees"].type()) {
        vector<CreateEventResponseBodyAttendees> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["attendees"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEventResponseBodyAttendees model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attendees = make_shared<vector<CreateEventResponseBodyAttendees>>(expect1);
      }
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("end") != m.end() && !m["end"].empty()) {
      if (typeid(map<string, boost::any>) == m["end"].type()) {
        CreateEventResponseBodyEnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["end"]));
        end = make_shared<CreateEventResponseBodyEnd>(model1);
      }
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("isAllDay") != m.end() && !m["isAllDay"].empty()) {
      isAllDay = make_shared<bool>(boost::any_cast<bool>(m["isAllDay"]));
    }
    if (m.find("location") != m.end() && !m["location"].empty()) {
      if (typeid(map<string, boost::any>) == m["location"].type()) {
        CreateEventResponseBodyLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["location"]));
        location = make_shared<CreateEventResponseBodyLocation>(model1);
      }
    }
    if (m.find("onlineMeetingInfo") != m.end() && !m["onlineMeetingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["onlineMeetingInfo"].type()) {
        CreateEventResponseBodyOnlineMeetingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["onlineMeetingInfo"]));
        onlineMeetingInfo = make_shared<CreateEventResponseBodyOnlineMeetingInfo>(model1);
      }
    }
    if (m.find("organizer") != m.end() && !m["organizer"].empty()) {
      if (typeid(map<string, boost::any>) == m["organizer"].type()) {
        CreateEventResponseBodyOrganizer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["organizer"]));
        organizer = make_shared<CreateEventResponseBodyOrganizer>(model1);
      }
    }
    if (m.find("recurrence") != m.end() && !m["recurrence"].empty()) {
      if (typeid(map<string, boost::any>) == m["recurrence"].type()) {
        CreateEventResponseBodyRecurrence model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["recurrence"]));
        recurrence = make_shared<CreateEventResponseBodyRecurrence>(model1);
      }
    }
    if (m.find("reminders") != m.end() && !m["reminders"].empty()) {
      if (typeid(vector<boost::any>) == m["reminders"].type()) {
        vector<CreateEventResponseBodyReminders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["reminders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEventResponseBodyReminders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reminders = make_shared<vector<CreateEventResponseBodyReminders>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("start") != m.end() && !m["start"].empty()) {
      if (typeid(map<string, boost::any>) == m["start"].type()) {
        CreateEventResponseBodyStart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["start"]));
        start = make_shared<CreateEventResponseBodyStart>(model1);
      }
    }
    if (m.find("summary") != m.end() && !m["summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["summary"]));
    }
    if (m.find("uiConfigs") != m.end() && !m["uiConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["uiConfigs"].type()) {
        vector<CreateEventResponseBodyUiConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["uiConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEventResponseBodyUiConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        uiConfigs = make_shared<vector<CreateEventResponseBodyUiConfigs>>(expect1);
      }
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["updateTime"]));
    }
  }


  virtual ~CreateEventResponseBody() = default;
};
class CreateEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEventResponseBody> body{};

  CreateEventResponse() {}

  explicit CreateEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEventResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEventResponse() = default;
};
class CreateLiveHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateLiveHeadersAccountContext() {}

  explicit CreateLiveHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateLiveHeadersAccountContext() = default;
};
class CreateLiveHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateLiveHeadersAccountContext> accountContext{};

  CreateLiveHeaders() {}

  explicit CreateLiveHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateLiveHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateLiveHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateLiveHeaders() = default;
};
class CreateLiveShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateLiveShrinkHeaders() {}

  explicit CreateLiveShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateLiveShrinkHeaders() = default;
};
class CreateLiveRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateLiveRequestTenantContext() {}

  explicit CreateLiveRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateLiveRequestTenantContext() = default;
};
class CreateLiveRequest : public Darabonba::Model {
public:
  shared_ptr<string> coverUrl{};
  shared_ptr<string> introduction{};
  shared_ptr<long> preEndTime{};
  shared_ptr<long> preStartTime{};
  shared_ptr<long> publicType{};
  shared_ptr<CreateLiveRequestTenantContext> tenantContext{};
  shared_ptr<string> title{};

  CreateLiveRequest() {}

  explicit CreateLiveRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverUrl) {
      res["CoverUrl"] = boost::any(*coverUrl);
    }
    if (introduction) {
      res["Introduction"] = boost::any(*introduction);
    }
    if (preEndTime) {
      res["PreEndTime"] = boost::any(*preEndTime);
    }
    if (preStartTime) {
      res["PreStartTime"] = boost::any(*preStartTime);
    }
    if (publicType) {
      res["PublicType"] = boost::any(*publicType);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverUrl") != m.end() && !m["CoverUrl"].empty()) {
      coverUrl = make_shared<string>(boost::any_cast<string>(m["CoverUrl"]));
    }
    if (m.find("Introduction") != m.end() && !m["Introduction"].empty()) {
      introduction = make_shared<string>(boost::any_cast<string>(m["Introduction"]));
    }
    if (m.find("PreEndTime") != m.end() && !m["PreEndTime"].empty()) {
      preEndTime = make_shared<long>(boost::any_cast<long>(m["PreEndTime"]));
    }
    if (m.find("PreStartTime") != m.end() && !m["PreStartTime"].empty()) {
      preStartTime = make_shared<long>(boost::any_cast<long>(m["PreStartTime"]));
    }
    if (m.find("PublicType") != m.end() && !m["PublicType"].empty()) {
      publicType = make_shared<long>(boost::any_cast<long>(m["PublicType"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateLiveRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateLiveRequestTenantContext>(model1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~CreateLiveRequest() = default;
};
class CreateLiveShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> coverUrl{};
  shared_ptr<string> introduction{};
  shared_ptr<long> preEndTime{};
  shared_ptr<long> preStartTime{};
  shared_ptr<long> publicType{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> title{};

  CreateLiveShrinkRequest() {}

  explicit CreateLiveShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverUrl) {
      res["CoverUrl"] = boost::any(*coverUrl);
    }
    if (introduction) {
      res["Introduction"] = boost::any(*introduction);
    }
    if (preEndTime) {
      res["PreEndTime"] = boost::any(*preEndTime);
    }
    if (preStartTime) {
      res["PreStartTime"] = boost::any(*preStartTime);
    }
    if (publicType) {
      res["PublicType"] = boost::any(*publicType);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverUrl") != m.end() && !m["CoverUrl"].empty()) {
      coverUrl = make_shared<string>(boost::any_cast<string>(m["CoverUrl"]));
    }
    if (m.find("Introduction") != m.end() && !m["Introduction"].empty()) {
      introduction = make_shared<string>(boost::any_cast<string>(m["Introduction"]));
    }
    if (m.find("PreEndTime") != m.end() && !m["PreEndTime"].empty()) {
      preEndTime = make_shared<long>(boost::any_cast<long>(m["PreEndTime"]));
    }
    if (m.find("PreStartTime") != m.end() && !m["PreStartTime"].empty()) {
      preStartTime = make_shared<long>(boost::any_cast<long>(m["PreStartTime"]));
    }
    if (m.find("PublicType") != m.end() && !m["PublicType"].empty()) {
      publicType = make_shared<long>(boost::any_cast<long>(m["PublicType"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~CreateLiveShrinkRequest() = default;
};
class CreateLiveResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> liveId{};
  shared_ptr<string> requestId{};

  CreateLiveResponseBody() {}

  explicit CreateLiveResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveId) {
      res["liveId"] = boost::any(*liveId);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("liveId") != m.end() && !m["liveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["liveId"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateLiveResponseBody() = default;
};
class CreateLiveResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLiveResponseBody> body{};

  CreateLiveResponse() {}

  explicit CreateLiveResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLiveResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLiveResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLiveResponse() = default;
};
class CreateMeetingRoomHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateMeetingRoomHeadersAccountContext() {}

  explicit CreateMeetingRoomHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateMeetingRoomHeadersAccountContext() = default;
};
class CreateMeetingRoomHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateMeetingRoomHeadersAccountContext> accountContext{};

  CreateMeetingRoomHeaders() {}

  explicit CreateMeetingRoomHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateMeetingRoomHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateMeetingRoomHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateMeetingRoomHeaders() = default;
};
class CreateMeetingRoomShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateMeetingRoomShrinkHeaders() {}

  explicit CreateMeetingRoomShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateMeetingRoomShrinkHeaders() = default;
};
class CreateMeetingRoomRequestRoomLocation : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> title{};

  CreateMeetingRoomRequestRoomLocation() {}

  explicit CreateMeetingRoomRequestRoomLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~CreateMeetingRoomRequestRoomLocation() = default;
};
class CreateMeetingRoomRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateMeetingRoomRequestTenantContext() {}

  explicit CreateMeetingRoomRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateMeetingRoomRequestTenantContext() = default;
};
class CreateMeetingRoomRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> isvRoomId{};
  shared_ptr<long> roomCapacity{};
  shared_ptr<vector<long>> roomLabelIds{};
  shared_ptr<CreateMeetingRoomRequestRoomLocation> roomLocation{};
  shared_ptr<string> roomName{};
  shared_ptr<string> roomPicture{};
  shared_ptr<long> roomStatus{};
  shared_ptr<CreateMeetingRoomRequestTenantContext> tenantContext{};

  CreateMeetingRoomRequest() {}

  explicit CreateMeetingRoomRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (isvRoomId) {
      res["IsvRoomId"] = boost::any(*isvRoomId);
    }
    if (roomCapacity) {
      res["RoomCapacity"] = boost::any(*roomCapacity);
    }
    if (roomLabelIds) {
      res["RoomLabelIds"] = boost::any(*roomLabelIds);
    }
    if (roomLocation) {
      res["RoomLocation"] = roomLocation ? boost::any(roomLocation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (roomName) {
      res["RoomName"] = boost::any(*roomName);
    }
    if (roomPicture) {
      res["RoomPicture"] = boost::any(*roomPicture);
    }
    if (roomStatus) {
      res["RoomStatus"] = boost::any(*roomStatus);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("IsvRoomId") != m.end() && !m["IsvRoomId"].empty()) {
      isvRoomId = make_shared<string>(boost::any_cast<string>(m["IsvRoomId"]));
    }
    if (m.find("RoomCapacity") != m.end() && !m["RoomCapacity"].empty()) {
      roomCapacity = make_shared<long>(boost::any_cast<long>(m["RoomCapacity"]));
    }
    if (m.find("RoomLabelIds") != m.end() && !m["RoomLabelIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RoomLabelIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoomLabelIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      roomLabelIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RoomLocation") != m.end() && !m["RoomLocation"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoomLocation"].type()) {
        CreateMeetingRoomRequestRoomLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoomLocation"]));
        roomLocation = make_shared<CreateMeetingRoomRequestRoomLocation>(model1);
      }
    }
    if (m.find("RoomName") != m.end() && !m["RoomName"].empty()) {
      roomName = make_shared<string>(boost::any_cast<string>(m["RoomName"]));
    }
    if (m.find("RoomPicture") != m.end() && !m["RoomPicture"].empty()) {
      roomPicture = make_shared<string>(boost::any_cast<string>(m["RoomPicture"]));
    }
    if (m.find("RoomStatus") != m.end() && !m["RoomStatus"].empty()) {
      roomStatus = make_shared<long>(boost::any_cast<long>(m["RoomStatus"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateMeetingRoomRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateMeetingRoomRequestTenantContext>(model1);
      }
    }
  }


  virtual ~CreateMeetingRoomRequest() = default;
};
class CreateMeetingRoomShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> isvRoomId{};
  shared_ptr<long> roomCapacity{};
  shared_ptr<string> roomLabelIdsShrink{};
  shared_ptr<string> roomLocationShrink{};
  shared_ptr<string> roomName{};
  shared_ptr<string> roomPicture{};
  shared_ptr<long> roomStatus{};
  shared_ptr<string> tenantContextShrink{};

  CreateMeetingRoomShrinkRequest() {}

  explicit CreateMeetingRoomShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (isvRoomId) {
      res["IsvRoomId"] = boost::any(*isvRoomId);
    }
    if (roomCapacity) {
      res["RoomCapacity"] = boost::any(*roomCapacity);
    }
    if (roomLabelIdsShrink) {
      res["RoomLabelIds"] = boost::any(*roomLabelIdsShrink);
    }
    if (roomLocationShrink) {
      res["RoomLocation"] = boost::any(*roomLocationShrink);
    }
    if (roomName) {
      res["RoomName"] = boost::any(*roomName);
    }
    if (roomPicture) {
      res["RoomPicture"] = boost::any(*roomPicture);
    }
    if (roomStatus) {
      res["RoomStatus"] = boost::any(*roomStatus);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("IsvRoomId") != m.end() && !m["IsvRoomId"].empty()) {
      isvRoomId = make_shared<string>(boost::any_cast<string>(m["IsvRoomId"]));
    }
    if (m.find("RoomCapacity") != m.end() && !m["RoomCapacity"].empty()) {
      roomCapacity = make_shared<long>(boost::any_cast<long>(m["RoomCapacity"]));
    }
    if (m.find("RoomLabelIds") != m.end() && !m["RoomLabelIds"].empty()) {
      roomLabelIdsShrink = make_shared<string>(boost::any_cast<string>(m["RoomLabelIds"]));
    }
    if (m.find("RoomLocation") != m.end() && !m["RoomLocation"].empty()) {
      roomLocationShrink = make_shared<string>(boost::any_cast<string>(m["RoomLocation"]));
    }
    if (m.find("RoomName") != m.end() && !m["RoomName"].empty()) {
      roomName = make_shared<string>(boost::any_cast<string>(m["RoomName"]));
    }
    if (m.find("RoomPicture") != m.end() && !m["RoomPicture"].empty()) {
      roomPicture = make_shared<string>(boost::any_cast<string>(m["RoomPicture"]));
    }
    if (m.find("RoomStatus") != m.end() && !m["RoomStatus"].empty()) {
      roomStatus = make_shared<long>(boost::any_cast<long>(m["RoomStatus"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~CreateMeetingRoomShrinkRequest() = default;
};
class CreateMeetingRoomResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  CreateMeetingRoomResponseBody() {}

  explicit CreateMeetingRoomResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["result"]));
    }
  }


  virtual ~CreateMeetingRoomResponseBody() = default;
};
class CreateMeetingRoomResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMeetingRoomResponseBody> body{};

  CreateMeetingRoomResponse() {}

  explicit CreateMeetingRoomResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMeetingRoomResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMeetingRoomResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMeetingRoomResponse() = default;
};
class CreateMeetingRoomGroupHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateMeetingRoomGroupHeadersAccountContext() {}

  explicit CreateMeetingRoomGroupHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateMeetingRoomGroupHeadersAccountContext() = default;
};
class CreateMeetingRoomGroupHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateMeetingRoomGroupHeadersAccountContext> accountContext{};

  CreateMeetingRoomGroupHeaders() {}

  explicit CreateMeetingRoomGroupHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateMeetingRoomGroupHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateMeetingRoomGroupHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateMeetingRoomGroupHeaders() = default;
};
class CreateMeetingRoomGroupShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateMeetingRoomGroupShrinkHeaders() {}

  explicit CreateMeetingRoomGroupShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateMeetingRoomGroupShrinkHeaders() = default;
};
class CreateMeetingRoomGroupRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateMeetingRoomGroupRequestTenantContext() {}

  explicit CreateMeetingRoomGroupRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateMeetingRoomGroupRequestTenantContext() = default;
};
class CreateMeetingRoomGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<long> parentGroupId{};
  shared_ptr<CreateMeetingRoomGroupRequestTenantContext> tenantContext{};

  CreateMeetingRoomGroupRequest() {}

  explicit CreateMeetingRoomGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (parentGroupId) {
      res["ParentGroupId"] = boost::any(*parentGroupId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ParentGroupId") != m.end() && !m["ParentGroupId"].empty()) {
      parentGroupId = make_shared<long>(boost::any_cast<long>(m["ParentGroupId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateMeetingRoomGroupRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateMeetingRoomGroupRequestTenantContext>(model1);
      }
    }
  }


  virtual ~CreateMeetingRoomGroupRequest() = default;
};
class CreateMeetingRoomGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<long> parentGroupId{};
  shared_ptr<string> tenantContextShrink{};

  CreateMeetingRoomGroupShrinkRequest() {}

  explicit CreateMeetingRoomGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (parentGroupId) {
      res["ParentGroupId"] = boost::any(*parentGroupId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ParentGroupId") != m.end() && !m["ParentGroupId"].empty()) {
      parentGroupId = make_shared<long>(boost::any_cast<long>(m["ParentGroupId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~CreateMeetingRoomGroupShrinkRequest() = default;
};
class CreateMeetingRoomGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> result{};

  CreateMeetingRoomGroupResponseBody() {}

  explicit CreateMeetingRoomGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<long>(boost::any_cast<long>(m["result"]));
    }
  }


  virtual ~CreateMeetingRoomGroupResponseBody() = default;
};
class CreateMeetingRoomGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMeetingRoomGroupResponseBody> body{};

  CreateMeetingRoomGroupResponse() {}

  explicit CreateMeetingRoomGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMeetingRoomGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMeetingRoomGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMeetingRoomGroupResponse() = default;
};
class CreateReportHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateReportHeadersAccountContext() {}

  explicit CreateReportHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateReportHeadersAccountContext() = default;
};
class CreateReportHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateReportHeadersAccountContext> accountContext{};

  CreateReportHeaders() {}

  explicit CreateReportHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateReportHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateReportHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateReportHeaders() = default;
};
class CreateReportShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateReportShrinkHeaders() {}

  explicit CreateReportShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateReportShrinkHeaders() = default;
};
class CreateReportRequestContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentType{};
  shared_ptr<string> key{};
  shared_ptr<long> sort{};
  shared_ptr<long> type{};

  CreateReportRequestContents() {}

  explicit CreateReportRequestContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<long>(boost::any_cast<long>(m["Sort"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~CreateReportRequestContents() = default;
};
class CreateReportRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateReportRequestTenantContext() {}

  explicit CreateReportRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateReportRequestTenantContext() = default;
};
class CreateReportRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateReportRequestContents>> contents{};
  shared_ptr<string> ddFrom{};
  shared_ptr<string> templateId{};
  shared_ptr<CreateReportRequestTenantContext> tenantContext{};
  shared_ptr<bool> toChat{};
  shared_ptr<vector<string>> toCids{};
  shared_ptr<vector<string>> toUserids{};

  CreateReportRequest() {}

  explicit CreateReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contents) {
      vector<boost::any> temp1;
      for(auto item1:*contents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contents"] = boost::any(temp1);
    }
    if (ddFrom) {
      res["DdFrom"] = boost::any(*ddFrom);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (toChat) {
      res["ToChat"] = boost::any(*toChat);
    }
    if (toCids) {
      res["ToCids"] = boost::any(*toCids);
    }
    if (toUserids) {
      res["ToUserids"] = boost::any(*toUserids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      if (typeid(vector<boost::any>) == m["Contents"].type()) {
        vector<CreateReportRequestContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateReportRequestContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contents = make_shared<vector<CreateReportRequestContents>>(expect1);
      }
    }
    if (m.find("DdFrom") != m.end() && !m["DdFrom"].empty()) {
      ddFrom = make_shared<string>(boost::any_cast<string>(m["DdFrom"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateReportRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateReportRequestTenantContext>(model1);
      }
    }
    if (m.find("ToChat") != m.end() && !m["ToChat"].empty()) {
      toChat = make_shared<bool>(boost::any_cast<bool>(m["ToChat"]));
    }
    if (m.find("ToCids") != m.end() && !m["ToCids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ToCids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ToCids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      toCids = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ToUserids") != m.end() && !m["ToUserids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ToUserids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ToUserids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      toUserids = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateReportRequest() = default;
};
class CreateReportShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> contentsShrink{};
  shared_ptr<string> ddFrom{};
  shared_ptr<string> templateId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<bool> toChat{};
  shared_ptr<string> toCidsShrink{};
  shared_ptr<string> toUseridsShrink{};

  CreateReportShrinkRequest() {}

  explicit CreateReportShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentsShrink) {
      res["Contents"] = boost::any(*contentsShrink);
    }
    if (ddFrom) {
      res["DdFrom"] = boost::any(*ddFrom);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (toChat) {
      res["ToChat"] = boost::any(*toChat);
    }
    if (toCidsShrink) {
      res["ToCids"] = boost::any(*toCidsShrink);
    }
    if (toUseridsShrink) {
      res["ToUserids"] = boost::any(*toUseridsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      contentsShrink = make_shared<string>(boost::any_cast<string>(m["Contents"]));
    }
    if (m.find("DdFrom") != m.end() && !m["DdFrom"].empty()) {
      ddFrom = make_shared<string>(boost::any_cast<string>(m["DdFrom"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("ToChat") != m.end() && !m["ToChat"].empty()) {
      toChat = make_shared<bool>(boost::any_cast<bool>(m["ToChat"]));
    }
    if (m.find("ToCids") != m.end() && !m["ToCids"].empty()) {
      toCidsShrink = make_shared<string>(boost::any_cast<string>(m["ToCids"]));
    }
    if (m.find("ToUserids") != m.end() && !m["ToUserids"].empty()) {
      toUseridsShrink = make_shared<string>(boost::any_cast<string>(m["ToUserids"]));
    }
  }


  virtual ~CreateReportShrinkRequest() = default;
};
class CreateReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateReportResponseBody() {}

  explicit CreateReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~CreateReportResponseBody() = default;
};
class CreateReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateReportResponseBody> body{};

  CreateReportResponse() {}

  explicit CreateReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateReportResponseBody>(model1);
      }
    }
  }


  virtual ~CreateReportResponse() = default;
};
class CreateScheduleConferenceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateScheduleConferenceHeadersAccountContext() {}

  explicit CreateScheduleConferenceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateScheduleConferenceHeadersAccountContext() = default;
};
class CreateScheduleConferenceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateScheduleConferenceHeadersAccountContext> accountContext{};

  CreateScheduleConferenceHeaders() {}

  explicit CreateScheduleConferenceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateScheduleConferenceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateScheduleConferenceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateScheduleConferenceHeaders() = default;
};
class CreateScheduleConferenceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateScheduleConferenceShrinkHeaders() {}

  explicit CreateScheduleConferenceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateScheduleConferenceShrinkHeaders() = default;
};
class CreateScheduleConferenceRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateScheduleConferenceRequestTenantContext() {}

  explicit CreateScheduleConferenceRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateScheduleConferenceRequestTenantContext() = default;
};
class CreateScheduleConferenceRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<CreateScheduleConferenceRequestTenantContext> tenantContext{};
  shared_ptr<string> title{};

  CreateScheduleConferenceRequest() {}

  explicit CreateScheduleConferenceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateScheduleConferenceRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateScheduleConferenceRequestTenantContext>(model1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~CreateScheduleConferenceRequest() = default;
};
class CreateScheduleConferenceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> title{};

  CreateScheduleConferenceShrinkRequest() {}

  explicit CreateScheduleConferenceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~CreateScheduleConferenceShrinkRequest() = default;
};
class CreateScheduleConferenceResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> phones{};
  shared_ptr<string> requestId{};
  shared_ptr<string> roomCode{};
  shared_ptr<string> scheduleConferenceId{};
  shared_ptr<string> url{};

  CreateScheduleConferenceResponseBody() {}

  explicit CreateScheduleConferenceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phones) {
      res["phones"] = boost::any(*phones);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (roomCode) {
      res["roomCode"] = boost::any(*roomCode);
    }
    if (scheduleConferenceId) {
      res["scheduleConferenceId"] = boost::any(*scheduleConferenceId);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("phones") != m.end() && !m["phones"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["phones"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["phones"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      phones = make_shared<vector<string>>(toVec1);
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("roomCode") != m.end() && !m["roomCode"].empty()) {
      roomCode = make_shared<string>(boost::any_cast<string>(m["roomCode"]));
    }
    if (m.find("scheduleConferenceId") != m.end() && !m["scheduleConferenceId"].empty()) {
      scheduleConferenceId = make_shared<string>(boost::any_cast<string>(m["scheduleConferenceId"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~CreateScheduleConferenceResponseBody() = default;
};
class CreateScheduleConferenceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateScheduleConferenceResponseBody> body{};

  CreateScheduleConferenceResponse() {}

  explicit CreateScheduleConferenceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateScheduleConferenceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateScheduleConferenceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateScheduleConferenceResponse() = default;
};
class CreateSheetHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateSheetHeadersAccountContext() {}

  explicit CreateSheetHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateSheetHeadersAccountContext() = default;
};
class CreateSheetHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateSheetHeadersAccountContext> accountContext{};

  CreateSheetHeaders() {}

  explicit CreateSheetHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateSheetHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateSheetHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateSheetHeaders() = default;
};
class CreateSheetShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateSheetShrinkHeaders() {}

  explicit CreateSheetShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateSheetShrinkHeaders() = default;
};
class CreateSheetRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateSheetRequestTenantContext() {}

  explicit CreateSheetRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateSheetRequestTenantContext() = default;
};
class CreateSheetRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<CreateSheetRequestTenantContext> tenantContext{};
  shared_ptr<string> workbookId{};

  CreateSheetRequest() {}

  explicit CreateSheetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateSheetRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateSheetRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~CreateSheetRequest() = default;
};
class CreateSheetShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workbookId{};

  CreateSheetShrinkRequest() {}

  explicit CreateSheetShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~CreateSheetShrinkRequest() = default;
};
class CreateSheetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> visibility{};

  CreateSheetResponseBody() {}

  explicit CreateSheetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (visibility) {
      res["visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("visibility") != m.end() && !m["visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["visibility"]));
    }
  }


  virtual ~CreateSheetResponseBody() = default;
};
class CreateSheetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSheetResponseBody> body{};

  CreateSheetResponse() {}

  explicit CreateSheetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSheetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSheetResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSheetResponse() = default;
};
class CreateTodoTaskHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateTodoTaskHeadersAccountContext() {}

  explicit CreateTodoTaskHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateTodoTaskHeadersAccountContext() = default;
};
class CreateTodoTaskHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateTodoTaskHeadersAccountContext> accountContext{};

  CreateTodoTaskHeaders() {}

  explicit CreateTodoTaskHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateTodoTaskHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateTodoTaskHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateTodoTaskHeaders() = default;
};
class CreateTodoTaskShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateTodoTaskShrinkHeaders() {}

  explicit CreateTodoTaskShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateTodoTaskShrinkHeaders() = default;
};
class CreateTodoTaskRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateTodoTaskRequestTenantContext() {}

  explicit CreateTodoTaskRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateTodoTaskRequestTenantContext() = default;
};
class CreateTodoTaskRequestContentFieldList : public Darabonba::Model {
public:
  shared_ptr<string> fieldKey{};
  shared_ptr<string> fieldValue{};

  CreateTodoTaskRequestContentFieldList() {}

  explicit CreateTodoTaskRequestContentFieldList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldKey) {
      res["fieldKey"] = boost::any(*fieldKey);
    }
    if (fieldValue) {
      res["fieldValue"] = boost::any(*fieldValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldKey") != m.end() && !m["fieldKey"].empty()) {
      fieldKey = make_shared<string>(boost::any_cast<string>(m["fieldKey"]));
    }
    if (m.find("fieldValue") != m.end() && !m["fieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["fieldValue"]));
    }
  }


  virtual ~CreateTodoTaskRequestContentFieldList() = default;
};
class CreateTodoTaskRequestDetailUrl : public Darabonba::Model {
public:
  shared_ptr<string> appUrl{};
  shared_ptr<string> pcUrl{};

  CreateTodoTaskRequestDetailUrl() {}

  explicit CreateTodoTaskRequestDetailUrl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appUrl) {
      res["appUrl"] = boost::any(*appUrl);
    }
    if (pcUrl) {
      res["pcUrl"] = boost::any(*pcUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("appUrl") != m.end() && !m["appUrl"].empty()) {
      appUrl = make_shared<string>(boost::any_cast<string>(m["appUrl"]));
    }
    if (m.find("pcUrl") != m.end() && !m["pcUrl"].empty()) {
      pcUrl = make_shared<string>(boost::any_cast<string>(m["pcUrl"]));
    }
  }


  virtual ~CreateTodoTaskRequestDetailUrl() = default;
};
class CreateTodoTaskRequestNotifyConfigs : public Darabonba::Model {
public:
  shared_ptr<string> dingNotify{};

  CreateTodoTaskRequestNotifyConfigs() {}

  explicit CreateTodoTaskRequestNotifyConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dingNotify) {
      res["dingNotify"] = boost::any(*dingNotify);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dingNotify") != m.end() && !m["dingNotify"].empty()) {
      dingNotify = make_shared<string>(boost::any_cast<string>(m["dingNotify"]));
    }
  }


  virtual ~CreateTodoTaskRequestNotifyConfigs() = default;
};
class CreateTodoTaskRequest : public Darabonba::Model {
public:
  shared_ptr<CreateTodoTaskRequestTenantContext> tenantContext{};
  shared_ptr<vector<CreateTodoTaskRequestContentFieldList>> contentFieldList{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<CreateTodoTaskRequestDetailUrl> detailUrl{};
  shared_ptr<long> dueTime{};
  shared_ptr<vector<string>> executorIds{};
  shared_ptr<bool> isOnlyShowExecutor{};
  shared_ptr<CreateTodoTaskRequestNotifyConfigs> notifyConfigs{};
  shared_ptr<string> operatorId{};
  shared_ptr<vector<string>> participantIds{};
  shared_ptr<long> priority{};
  shared_ptr<string> sourceId{};
  shared_ptr<string> subject{};

  CreateTodoTaskRequest() {}

  explicit CreateTodoTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contentFieldList) {
      vector<boost::any> temp1;
      for(auto item1:*contentFieldList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["contentFieldList"] = boost::any(temp1);
    }
    if (creatorId) {
      res["creatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (detailUrl) {
      res["detailUrl"] = detailUrl ? boost::any(detailUrl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dueTime) {
      res["dueTime"] = boost::any(*dueTime);
    }
    if (executorIds) {
      res["executorIds"] = boost::any(*executorIds);
    }
    if (isOnlyShowExecutor) {
      res["isOnlyShowExecutor"] = boost::any(*isOnlyShowExecutor);
    }
    if (notifyConfigs) {
      res["notifyConfigs"] = notifyConfigs ? boost::any(notifyConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (operatorId) {
      res["operatorId"] = boost::any(*operatorId);
    }
    if (participantIds) {
      res["participantIds"] = boost::any(*participantIds);
    }
    if (priority) {
      res["priority"] = boost::any(*priority);
    }
    if (sourceId) {
      res["sourceId"] = boost::any(*sourceId);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateTodoTaskRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateTodoTaskRequestTenantContext>(model1);
      }
    }
    if (m.find("contentFieldList") != m.end() && !m["contentFieldList"].empty()) {
      if (typeid(vector<boost::any>) == m["contentFieldList"].type()) {
        vector<CreateTodoTaskRequestContentFieldList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["contentFieldList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTodoTaskRequestContentFieldList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contentFieldList = make_shared<vector<CreateTodoTaskRequestContentFieldList>>(expect1);
      }
    }
    if (m.find("creatorId") != m.end() && !m["creatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["creatorId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("detailUrl") != m.end() && !m["detailUrl"].empty()) {
      if (typeid(map<string, boost::any>) == m["detailUrl"].type()) {
        CreateTodoTaskRequestDetailUrl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["detailUrl"]));
        detailUrl = make_shared<CreateTodoTaskRequestDetailUrl>(model1);
      }
    }
    if (m.find("dueTime") != m.end() && !m["dueTime"].empty()) {
      dueTime = make_shared<long>(boost::any_cast<long>(m["dueTime"]));
    }
    if (m.find("executorIds") != m.end() && !m["executorIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["executorIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["executorIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      executorIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("isOnlyShowExecutor") != m.end() && !m["isOnlyShowExecutor"].empty()) {
      isOnlyShowExecutor = make_shared<bool>(boost::any_cast<bool>(m["isOnlyShowExecutor"]));
    }
    if (m.find("notifyConfigs") != m.end() && !m["notifyConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["notifyConfigs"].type()) {
        CreateTodoTaskRequestNotifyConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["notifyConfigs"]));
        notifyConfigs = make_shared<CreateTodoTaskRequestNotifyConfigs>(model1);
      }
    }
    if (m.find("operatorId") != m.end() && !m["operatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["operatorId"]));
    }
    if (m.find("participantIds") != m.end() && !m["participantIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["participantIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["participantIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      participantIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("priority") != m.end() && !m["priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["priority"]));
    }
    if (m.find("sourceId") != m.end() && !m["sourceId"].empty()) {
      sourceId = make_shared<string>(boost::any_cast<string>(m["sourceId"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
  }


  virtual ~CreateTodoTaskRequest() = default;
};
class CreateTodoTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> contentFieldListShrink{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<string> detailUrlShrink{};
  shared_ptr<long> dueTime{};
  shared_ptr<string> executorIdsShrink{};
  shared_ptr<bool> isOnlyShowExecutor{};
  shared_ptr<string> notifyConfigsShrink{};
  shared_ptr<string> operatorId{};
  shared_ptr<string> participantIdsShrink{};
  shared_ptr<long> priority{};
  shared_ptr<string> sourceId{};
  shared_ptr<string> subject{};

  CreateTodoTaskShrinkRequest() {}

  explicit CreateTodoTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (contentFieldListShrink) {
      res["contentFieldList"] = boost::any(*contentFieldListShrink);
    }
    if (creatorId) {
      res["creatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (detailUrlShrink) {
      res["detailUrl"] = boost::any(*detailUrlShrink);
    }
    if (dueTime) {
      res["dueTime"] = boost::any(*dueTime);
    }
    if (executorIdsShrink) {
      res["executorIds"] = boost::any(*executorIdsShrink);
    }
    if (isOnlyShowExecutor) {
      res["isOnlyShowExecutor"] = boost::any(*isOnlyShowExecutor);
    }
    if (notifyConfigsShrink) {
      res["notifyConfigs"] = boost::any(*notifyConfigsShrink);
    }
    if (operatorId) {
      res["operatorId"] = boost::any(*operatorId);
    }
    if (participantIdsShrink) {
      res["participantIds"] = boost::any(*participantIdsShrink);
    }
    if (priority) {
      res["priority"] = boost::any(*priority);
    }
    if (sourceId) {
      res["sourceId"] = boost::any(*sourceId);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("contentFieldList") != m.end() && !m["contentFieldList"].empty()) {
      contentFieldListShrink = make_shared<string>(boost::any_cast<string>(m["contentFieldList"]));
    }
    if (m.find("creatorId") != m.end() && !m["creatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["creatorId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("detailUrl") != m.end() && !m["detailUrl"].empty()) {
      detailUrlShrink = make_shared<string>(boost::any_cast<string>(m["detailUrl"]));
    }
    if (m.find("dueTime") != m.end() && !m["dueTime"].empty()) {
      dueTime = make_shared<long>(boost::any_cast<long>(m["dueTime"]));
    }
    if (m.find("executorIds") != m.end() && !m["executorIds"].empty()) {
      executorIdsShrink = make_shared<string>(boost::any_cast<string>(m["executorIds"]));
    }
    if (m.find("isOnlyShowExecutor") != m.end() && !m["isOnlyShowExecutor"].empty()) {
      isOnlyShowExecutor = make_shared<bool>(boost::any_cast<bool>(m["isOnlyShowExecutor"]));
    }
    if (m.find("notifyConfigs") != m.end() && !m["notifyConfigs"].empty()) {
      notifyConfigsShrink = make_shared<string>(boost::any_cast<string>(m["notifyConfigs"]));
    }
    if (m.find("operatorId") != m.end() && !m["operatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["operatorId"]));
    }
    if (m.find("participantIds") != m.end() && !m["participantIds"].empty()) {
      participantIdsShrink = make_shared<string>(boost::any_cast<string>(m["participantIds"]));
    }
    if (m.find("priority") != m.end() && !m["priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["priority"]));
    }
    if (m.find("sourceId") != m.end() && !m["sourceId"].empty()) {
      sourceId = make_shared<string>(boost::any_cast<string>(m["sourceId"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
  }


  virtual ~CreateTodoTaskShrinkRequest() = default;
};
class CreateTodoTaskResponseBodyContentFieldList : public Darabonba::Model {
public:
  shared_ptr<string> fieldKey{};
  shared_ptr<string> fieldValue{};

  CreateTodoTaskResponseBodyContentFieldList() {}

  explicit CreateTodoTaskResponseBodyContentFieldList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldKey) {
      res["fieldKey"] = boost::any(*fieldKey);
    }
    if (fieldValue) {
      res["fieldValue"] = boost::any(*fieldValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldKey") != m.end() && !m["fieldKey"].empty()) {
      fieldKey = make_shared<string>(boost::any_cast<string>(m["fieldKey"]));
    }
    if (m.find("fieldValue") != m.end() && !m["fieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["fieldValue"]));
    }
  }


  virtual ~CreateTodoTaskResponseBodyContentFieldList() = default;
};
class CreateTodoTaskResponseBodyDetailUrl : public Darabonba::Model {
public:
  shared_ptr<string> appUrl{};
  shared_ptr<string> pcUrl{};

  CreateTodoTaskResponseBodyDetailUrl() {}

  explicit CreateTodoTaskResponseBodyDetailUrl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appUrl) {
      res["appUrl"] = boost::any(*appUrl);
    }
    if (pcUrl) {
      res["pcUrl"] = boost::any(*pcUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("appUrl") != m.end() && !m["appUrl"].empty()) {
      appUrl = make_shared<string>(boost::any_cast<string>(m["appUrl"]));
    }
    if (m.find("pcUrl") != m.end() && !m["pcUrl"].empty()) {
      pcUrl = make_shared<string>(boost::any_cast<string>(m["pcUrl"]));
    }
  }


  virtual ~CreateTodoTaskResponseBodyDetailUrl() = default;
};
class CreateTodoTaskResponseBodyNotifyConfigs : public Darabonba::Model {
public:
  shared_ptr<string> dingNotify{};

  CreateTodoTaskResponseBodyNotifyConfigs() {}

  explicit CreateTodoTaskResponseBodyNotifyConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dingNotify) {
      res["dingNotify"] = boost::any(*dingNotify);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dingNotify") != m.end() && !m["dingNotify"].empty()) {
      dingNotify = make_shared<string>(boost::any_cast<string>(m["dingNotify"]));
    }
  }


  virtual ~CreateTodoTaskResponseBodyNotifyConfigs() = default;
};
class CreateTodoTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bizTag{};
  shared_ptr<vector<CreateTodoTaskResponseBodyContentFieldList>> contentFieldList{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<CreateTodoTaskResponseBodyDetailUrl> detailUrl{};
  shared_ptr<bool> done{};
  shared_ptr<long> dueTime{};
  shared_ptr<vector<string>> executorIds{};
  shared_ptr<long> finishTime{};
  shared_ptr<string> id{};
  shared_ptr<bool> isOnlyShowExecutor{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<CreateTodoTaskResponseBodyNotifyConfigs> notifyConfigs{};
  shared_ptr<vector<string>> participantIds{};
  shared_ptr<long> priority{};
  shared_ptr<string> requestId{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> subject{};

  CreateTodoTaskResponseBody() {}

  explicit CreateTodoTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizTag) {
      res["bizTag"] = boost::any(*bizTag);
    }
    if (contentFieldList) {
      vector<boost::any> temp1;
      for(auto item1:*contentFieldList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["contentFieldList"] = boost::any(temp1);
    }
    if (createdTime) {
      res["createdTime"] = boost::any(*createdTime);
    }
    if (creatorId) {
      res["creatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (detailUrl) {
      res["detailUrl"] = detailUrl ? boost::any(detailUrl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (done) {
      res["done"] = boost::any(*done);
    }
    if (dueTime) {
      res["dueTime"] = boost::any(*dueTime);
    }
    if (executorIds) {
      res["executorIds"] = boost::any(*executorIds);
    }
    if (finishTime) {
      res["finishTime"] = boost::any(*finishTime);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isOnlyShowExecutor) {
      res["isOnlyShowExecutor"] = boost::any(*isOnlyShowExecutor);
    }
    if (modifiedTime) {
      res["modifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["modifierId"] = boost::any(*modifierId);
    }
    if (notifyConfigs) {
      res["notifyConfigs"] = notifyConfigs ? boost::any(notifyConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (participantIds) {
      res["participantIds"] = boost::any(*participantIds);
    }
    if (priority) {
      res["priority"] = boost::any(*priority);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (sourceId) {
      res["sourceId"] = boost::any(*sourceId);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bizTag") != m.end() && !m["bizTag"].empty()) {
      bizTag = make_shared<string>(boost::any_cast<string>(m["bizTag"]));
    }
    if (m.find("contentFieldList") != m.end() && !m["contentFieldList"].empty()) {
      if (typeid(vector<boost::any>) == m["contentFieldList"].type()) {
        vector<CreateTodoTaskResponseBodyContentFieldList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["contentFieldList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTodoTaskResponseBodyContentFieldList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contentFieldList = make_shared<vector<CreateTodoTaskResponseBodyContentFieldList>>(expect1);
      }
    }
    if (m.find("createdTime") != m.end() && !m["createdTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["createdTime"]));
    }
    if (m.find("creatorId") != m.end() && !m["creatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["creatorId"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("detailUrl") != m.end() && !m["detailUrl"].empty()) {
      if (typeid(map<string, boost::any>) == m["detailUrl"].type()) {
        CreateTodoTaskResponseBodyDetailUrl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["detailUrl"]));
        detailUrl = make_shared<CreateTodoTaskResponseBodyDetailUrl>(model1);
      }
    }
    if (m.find("done") != m.end() && !m["done"].empty()) {
      done = make_shared<bool>(boost::any_cast<bool>(m["done"]));
    }
    if (m.find("dueTime") != m.end() && !m["dueTime"].empty()) {
      dueTime = make_shared<long>(boost::any_cast<long>(m["dueTime"]));
    }
    if (m.find("executorIds") != m.end() && !m["executorIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["executorIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["executorIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      executorIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("finishTime") != m.end() && !m["finishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["finishTime"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("isOnlyShowExecutor") != m.end() && !m["isOnlyShowExecutor"].empty()) {
      isOnlyShowExecutor = make_shared<bool>(boost::any_cast<bool>(m["isOnlyShowExecutor"]));
    }
    if (m.find("modifiedTime") != m.end() && !m["modifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["modifiedTime"]));
    }
    if (m.find("modifierId") != m.end() && !m["modifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["modifierId"]));
    }
    if (m.find("notifyConfigs") != m.end() && !m["notifyConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["notifyConfigs"].type()) {
        CreateTodoTaskResponseBodyNotifyConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["notifyConfigs"]));
        notifyConfigs = make_shared<CreateTodoTaskResponseBodyNotifyConfigs>(model1);
      }
    }
    if (m.find("participantIds") != m.end() && !m["participantIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["participantIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["participantIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      participantIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("priority") != m.end() && !m["priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["priority"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("sourceId") != m.end() && !m["sourceId"].empty()) {
      sourceId = make_shared<string>(boost::any_cast<string>(m["sourceId"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
  }


  virtual ~CreateTodoTaskResponseBody() = default;
};
class CreateTodoTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTodoTaskResponseBody> body{};

  CreateTodoTaskResponse() {}

  explicit CreateTodoTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTodoTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTodoTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTodoTaskResponse() = default;
};
class CreateVideoConferenceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateVideoConferenceHeadersAccountContext() {}

  explicit CreateVideoConferenceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateVideoConferenceHeadersAccountContext() = default;
};
class CreateVideoConferenceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateVideoConferenceHeadersAccountContext> accountContext{};

  CreateVideoConferenceHeaders() {}

  explicit CreateVideoConferenceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateVideoConferenceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateVideoConferenceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateVideoConferenceHeaders() = default;
};
class CreateVideoConferenceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateVideoConferenceShrinkHeaders() {}

  explicit CreateVideoConferenceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateVideoConferenceShrinkHeaders() = default;
};
class CreateVideoConferenceRequest : public Darabonba::Model {
public:
  shared_ptr<string> confTitle{};
  shared_ptr<bool> inviteCaller{};
  shared_ptr<vector<string>> inviteUserIds{};

  CreateVideoConferenceRequest() {}

  explicit CreateVideoConferenceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (confTitle) {
      res["ConfTitle"] = boost::any(*confTitle);
    }
    if (inviteCaller) {
      res["InviteCaller"] = boost::any(*inviteCaller);
    }
    if (inviteUserIds) {
      res["InviteUserIds"] = boost::any(*inviteUserIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfTitle") != m.end() && !m["ConfTitle"].empty()) {
      confTitle = make_shared<string>(boost::any_cast<string>(m["ConfTitle"]));
    }
    if (m.find("InviteCaller") != m.end() && !m["InviteCaller"].empty()) {
      inviteCaller = make_shared<bool>(boost::any_cast<bool>(m["InviteCaller"]));
    }
    if (m.find("InviteUserIds") != m.end() && !m["InviteUserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InviteUserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InviteUserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      inviteUserIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateVideoConferenceRequest() = default;
};
class CreateVideoConferenceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> confTitle{};
  shared_ptr<bool> inviteCaller{};
  shared_ptr<string> inviteUserIdsShrink{};

  CreateVideoConferenceShrinkRequest() {}

  explicit CreateVideoConferenceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (confTitle) {
      res["ConfTitle"] = boost::any(*confTitle);
    }
    if (inviteCaller) {
      res["InviteCaller"] = boost::any(*inviteCaller);
    }
    if (inviteUserIdsShrink) {
      res["InviteUserIds"] = boost::any(*inviteUserIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfTitle") != m.end() && !m["ConfTitle"].empty()) {
      confTitle = make_shared<string>(boost::any_cast<string>(m["ConfTitle"]));
    }
    if (m.find("InviteCaller") != m.end() && !m["InviteCaller"].empty()) {
      inviteCaller = make_shared<bool>(boost::any_cast<bool>(m["InviteCaller"]));
    }
    if (m.find("InviteUserIds") != m.end() && !m["InviteUserIds"].empty()) {
      inviteUserIdsShrink = make_shared<string>(boost::any_cast<string>(m["InviteUserIds"]));
    }
  }


  virtual ~CreateVideoConferenceShrinkRequest() = default;
};
class CreateVideoConferenceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> conferenceId{};
  shared_ptr<string> conferencePassword{};
  shared_ptr<string> externalLinkUrl{};
  shared_ptr<string> hostPassword{};
  shared_ptr<vector<string>> phoneNumbers{};
  shared_ptr<string> requestId{};
  shared_ptr<string> roomCode{};

  CreateVideoConferenceResponseBody() {}

  explicit CreateVideoConferenceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    if (conferencePassword) {
      res["conferencePassword"] = boost::any(*conferencePassword);
    }
    if (externalLinkUrl) {
      res["externalLinkUrl"] = boost::any(*externalLinkUrl);
    }
    if (hostPassword) {
      res["hostPassword"] = boost::any(*hostPassword);
    }
    if (phoneNumbers) {
      res["phoneNumbers"] = boost::any(*phoneNumbers);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (roomCode) {
      res["roomCode"] = boost::any(*roomCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
    if (m.find("conferencePassword") != m.end() && !m["conferencePassword"].empty()) {
      conferencePassword = make_shared<string>(boost::any_cast<string>(m["conferencePassword"]));
    }
    if (m.find("externalLinkUrl") != m.end() && !m["externalLinkUrl"].empty()) {
      externalLinkUrl = make_shared<string>(boost::any_cast<string>(m["externalLinkUrl"]));
    }
    if (m.find("hostPassword") != m.end() && !m["hostPassword"].empty()) {
      hostPassword = make_shared<string>(boost::any_cast<string>(m["hostPassword"]));
    }
    if (m.find("phoneNumbers") != m.end() && !m["phoneNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["phoneNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["phoneNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      phoneNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("roomCode") != m.end() && !m["roomCode"].empty()) {
      roomCode = make_shared<string>(boost::any_cast<string>(m["roomCode"]));
    }
  }


  virtual ~CreateVideoConferenceResponseBody() = default;
};
class CreateVideoConferenceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVideoConferenceResponseBody> body{};

  CreateVideoConferenceResponse() {}

  explicit CreateVideoConferenceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVideoConferenceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVideoConferenceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVideoConferenceResponse() = default;
};
class CreateWorkspaceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateWorkspaceHeadersAccountContext() {}

  explicit CreateWorkspaceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateWorkspaceHeadersAccountContext() = default;
};
class CreateWorkspaceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateWorkspaceHeadersAccountContext> accountContext{};

  CreateWorkspaceHeaders() {}

  explicit CreateWorkspaceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateWorkspaceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateWorkspaceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateWorkspaceHeaders() = default;
};
class CreateWorkspaceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateWorkspaceShrinkHeaders() {}

  explicit CreateWorkspaceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateWorkspaceShrinkHeaders() = default;
};
class CreateWorkspaceRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateWorkspaceRequestTenantContext() {}

  explicit CreateWorkspaceRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateWorkspaceRequestTenantContext() = default;
};
class CreateWorkspaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<CreateWorkspaceRequestTenantContext> tenantContext{};

  CreateWorkspaceRequest() {}

  explicit CreateWorkspaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateWorkspaceRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateWorkspaceRequestTenantContext>(model1);
      }
    }
  }


  virtual ~CreateWorkspaceRequest() = default;
};
class CreateWorkspaceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> tenantContextShrink{};

  CreateWorkspaceShrinkRequest() {}

  explicit CreateWorkspaceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~CreateWorkspaceShrinkRequest() = default;
};
class CreateWorkspaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  CreateWorkspaceResponseBody() {}

  explicit CreateWorkspaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["workspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
    if (m.find("workspaceId") != m.end() && !m["workspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["workspaceId"]));
    }
  }


  virtual ~CreateWorkspaceResponseBody() = default;
};
class CreateWorkspaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWorkspaceResponseBody> body{};

  CreateWorkspaceResponse() {}

  explicit CreateWorkspaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWorkspaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWorkspaceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWorkspaceResponse() = default;
};
class CreateWorkspaceDocHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateWorkspaceDocHeadersAccountContext() {}

  explicit CreateWorkspaceDocHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~CreateWorkspaceDocHeadersAccountContext() = default;
};
class CreateWorkspaceDocHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<CreateWorkspaceDocHeadersAccountContext> accountContext{};

  CreateWorkspaceDocHeaders() {}

  explicit CreateWorkspaceDocHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        CreateWorkspaceDocHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<CreateWorkspaceDocHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~CreateWorkspaceDocHeaders() = default;
};
class CreateWorkspaceDocShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  CreateWorkspaceDocShrinkHeaders() {}

  explicit CreateWorkspaceDocShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~CreateWorkspaceDocShrinkHeaders() = default;
};
class CreateWorkspaceDocRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  CreateWorkspaceDocRequestTenantContext() {}

  explicit CreateWorkspaceDocRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~CreateWorkspaceDocRequestTenantContext() = default;
};
class CreateWorkspaceDocRequest : public Darabonba::Model {
public:
  shared_ptr<string> docType{};
  shared_ptr<string> name{};
  shared_ptr<string> parentNodeId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateType{};
  shared_ptr<CreateWorkspaceDocRequestTenantContext> tenantContext{};
  shared_ptr<string> workspaceId{};

  CreateWorkspaceDocRequest() {}

  explicit CreateWorkspaceDocRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentNodeId) {
      res["ParentNodeId"] = boost::any(*parentNodeId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentNodeId") != m.end() && !m["ParentNodeId"].empty()) {
      parentNodeId = make_shared<string>(boost::any_cast<string>(m["ParentNodeId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        CreateWorkspaceDocRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<CreateWorkspaceDocRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateWorkspaceDocRequest() = default;
};
class CreateWorkspaceDocShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> docType{};
  shared_ptr<string> name{};
  shared_ptr<string> parentNodeId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateType{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workspaceId{};

  CreateWorkspaceDocShrinkRequest() {}

  explicit CreateWorkspaceDocShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentNodeId) {
      res["ParentNodeId"] = boost::any(*parentNodeId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentNodeId") != m.end() && !m["ParentNodeId"].empty()) {
      parentNodeId = make_shared<string>(boost::any_cast<string>(m["ParentNodeId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateWorkspaceDocShrinkRequest() = default;
};
class CreateWorkspaceDocResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> docKey{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  CreateWorkspaceDocResponseBody() {}

  explicit CreateWorkspaceDocResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docKey) {
      res["docKey"] = boost::any(*docKey);
    }
    if (nodeId) {
      res["nodeId"] = boost::any(*nodeId);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["workspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("docKey") != m.end() && !m["docKey"].empty()) {
      docKey = make_shared<string>(boost::any_cast<string>(m["docKey"]));
    }
    if (m.find("nodeId") != m.end() && !m["nodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["nodeId"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
    if (m.find("workspaceId") != m.end() && !m["workspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["workspaceId"]));
    }
  }


  virtual ~CreateWorkspaceDocResponseBody() = default;
};
class CreateWorkspaceDocResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWorkspaceDocResponseBody> body{};

  CreateWorkspaceDocResponse() {}

  explicit CreateWorkspaceDocResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWorkspaceDocResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWorkspaceDocResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWorkspaceDocResponse() = default;
};
class DeleteColumnsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteColumnsHeadersAccountContext() {}

  explicit DeleteColumnsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteColumnsHeadersAccountContext() = default;
};
class DeleteColumnsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteColumnsHeadersAccountContext> accountContext{};

  DeleteColumnsHeaders() {}

  explicit DeleteColumnsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteColumnsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteColumnsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteColumnsHeaders() = default;
};
class DeleteColumnsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteColumnsShrinkHeaders() {}

  explicit DeleteColumnsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteColumnsShrinkHeaders() = default;
};
class DeleteColumnsRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DeleteColumnsRequestTenantContext() {}

  explicit DeleteColumnsRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DeleteColumnsRequestTenantContext() = default;
};
class DeleteColumnsRequest : public Darabonba::Model {
public:
  shared_ptr<long> column{};
  shared_ptr<long> columnCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<DeleteColumnsRequestTenantContext> tenantContext{};
  shared_ptr<string> workbookId{};

  DeleteColumnsRequest() {}

  explicit DeleteColumnsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (column) {
      res["Column"] = boost::any(*column);
    }
    if (columnCount) {
      res["ColumnCount"] = boost::any(*columnCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Column") != m.end() && !m["Column"].empty()) {
      column = make_shared<long>(boost::any_cast<long>(m["Column"]));
    }
    if (m.find("ColumnCount") != m.end() && !m["ColumnCount"].empty()) {
      columnCount = make_shared<long>(boost::any_cast<long>(m["ColumnCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DeleteColumnsRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DeleteColumnsRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~DeleteColumnsRequest() = default;
};
class DeleteColumnsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> column{};
  shared_ptr<long> columnCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workbookId{};

  DeleteColumnsShrinkRequest() {}

  explicit DeleteColumnsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (column) {
      res["Column"] = boost::any(*column);
    }
    if (columnCount) {
      res["ColumnCount"] = boost::any(*columnCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Column") != m.end() && !m["Column"].empty()) {
      column = make_shared<long>(boost::any_cast<long>(m["Column"]));
    }
    if (m.find("ColumnCount") != m.end() && !m["ColumnCount"].empty()) {
      columnCount = make_shared<long>(boost::any_cast<long>(m["ColumnCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~DeleteColumnsShrinkRequest() = default;
};
class DeleteColumnsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  DeleteColumnsResponseBody() {}

  explicit DeleteColumnsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeleteColumnsResponseBody() = default;
};
class DeleteColumnsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteColumnsResponseBody> body{};

  DeleteColumnsResponse() {}

  explicit DeleteColumnsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteColumnsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteColumnsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteColumnsResponse() = default;
};
class DeleteEventHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteEventHeadersAccountContext() {}

  explicit DeleteEventHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteEventHeadersAccountContext() = default;
};
class DeleteEventHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteEventHeadersAccountContext> accountContext{};

  DeleteEventHeaders() {}

  explicit DeleteEventHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteEventHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteEventHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteEventHeaders() = default;
};
class DeleteEventShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteEventShrinkHeaders() {}

  explicit DeleteEventShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteEventShrinkHeaders() = default;
};
class DeleteEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> calendarId{};
  shared_ptr<string> eventId{};

  DeleteEventRequest() {}

  explicit DeleteEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
  }


  virtual ~DeleteEventRequest() = default;
};
class DeleteEventResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};

  DeleteEventResponseBodyContent() {}

  explicit DeleteEventResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["data"]));
    }
  }


  virtual ~DeleteEventResponseBodyContent() = default;
};
class DeleteEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeleteEventResponseBodyContent> content{};
  shared_ptr<string> errorCode{};
  shared_ptr<map<string, boost::any>> errorCtx{};
  shared_ptr<string> errorMsg{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteEventResponseBody() {}

  explicit DeleteEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorCtx) {
      res["errorCtx"] = boost::any(*errorCtx);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (httpStatusCode) {
      res["httpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      if (typeid(map<string, boost::any>) == m["content"].type()) {
        DeleteEventResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["content"]));
        content = make_shared<DeleteEventResponseBodyContent>(model1);
      }
    }
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorCtx") != m.end() && !m["errorCtx"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["errorCtx"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      errorCtx = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("httpStatusCode") != m.end() && !m["httpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["httpStatusCode"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteEventResponseBody() = default;
};
class DeleteEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEventResponseBody> body{};

  DeleteEventResponse() {}

  explicit DeleteEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEventResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEventResponse() = default;
};
class DeleteLiveHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteLiveHeadersAccountContext() {}

  explicit DeleteLiveHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteLiveHeadersAccountContext() = default;
};
class DeleteLiveHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteLiveHeadersAccountContext> accountContext{};

  DeleteLiveHeaders() {}

  explicit DeleteLiveHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteLiveHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteLiveHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteLiveHeaders() = default;
};
class DeleteLiveShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteLiveShrinkHeaders() {}

  explicit DeleteLiveShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteLiveShrinkHeaders() = default;
};
class DeleteLiveRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DeleteLiveRequestTenantContext() {}

  explicit DeleteLiveRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DeleteLiveRequestTenantContext() = default;
};
class DeleteLiveRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveId{};
  shared_ptr<DeleteLiveRequestTenantContext> tenantContext{};

  DeleteLiveRequest() {}

  explicit DeleteLiveRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveId) {
      res["LiveId"] = boost::any(*liveId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveId") != m.end() && !m["LiveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["LiveId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DeleteLiveRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DeleteLiveRequestTenantContext>(model1);
      }
    }
  }


  virtual ~DeleteLiveRequest() = default;
};
class DeleteLiveShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveId{};
  shared_ptr<string> tenantContextShrink{};

  DeleteLiveShrinkRequest() {}

  explicit DeleteLiveShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveId) {
      res["LiveId"] = boost::any(*liveId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveId") != m.end() && !m["LiveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["LiveId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~DeleteLiveShrinkRequest() = default;
};
class DeleteLiveResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteLiveResponseBody() {}

  explicit DeleteLiveResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteLiveResponseBody() = default;
};
class DeleteLiveResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveResponseBody> body{};

  DeleteLiveResponse() {}

  explicit DeleteLiveResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveResponse() = default;
};
class DeleteMeetingRoomHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteMeetingRoomHeadersAccountContext() {}

  explicit DeleteMeetingRoomHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteMeetingRoomHeadersAccountContext() = default;
};
class DeleteMeetingRoomHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteMeetingRoomHeadersAccountContext> accountContext{};

  DeleteMeetingRoomHeaders() {}

  explicit DeleteMeetingRoomHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteMeetingRoomHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteMeetingRoomHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteMeetingRoomHeaders() = default;
};
class DeleteMeetingRoomShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteMeetingRoomShrinkHeaders() {}

  explicit DeleteMeetingRoomShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteMeetingRoomShrinkHeaders() = default;
};
class DeleteMeetingRoomRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DeleteMeetingRoomRequestTenantContext() {}

  explicit DeleteMeetingRoomRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DeleteMeetingRoomRequestTenantContext() = default;
};
class DeleteMeetingRoomRequest : public Darabonba::Model {
public:
  shared_ptr<string> roomId{};
  shared_ptr<DeleteMeetingRoomRequestTenantContext> tenantContext{};

  DeleteMeetingRoomRequest() {}

  explicit DeleteMeetingRoomRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DeleteMeetingRoomRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DeleteMeetingRoomRequestTenantContext>(model1);
      }
    }
  }


  virtual ~DeleteMeetingRoomRequest() = default;
};
class DeleteMeetingRoomShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> roomId{};
  shared_ptr<string> tenantContextShrink{};

  DeleteMeetingRoomShrinkRequest() {}

  explicit DeleteMeetingRoomShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~DeleteMeetingRoomShrinkRequest() = default;
};
class DeleteMeetingRoomResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteMeetingRoomResponseBody() {}

  explicit DeleteMeetingRoomResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~DeleteMeetingRoomResponseBody() = default;
};
class DeleteMeetingRoomResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMeetingRoomResponseBody> body{};

  DeleteMeetingRoomResponse() {}

  explicit DeleteMeetingRoomResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMeetingRoomResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMeetingRoomResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMeetingRoomResponse() = default;
};
class DeleteMeetingRoomGroupHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteMeetingRoomGroupHeadersAccountContext() {}

  explicit DeleteMeetingRoomGroupHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteMeetingRoomGroupHeadersAccountContext() = default;
};
class DeleteMeetingRoomGroupHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteMeetingRoomGroupHeadersAccountContext> accountContext{};

  DeleteMeetingRoomGroupHeaders() {}

  explicit DeleteMeetingRoomGroupHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteMeetingRoomGroupHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteMeetingRoomGroupHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteMeetingRoomGroupHeaders() = default;
};
class DeleteMeetingRoomGroupShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteMeetingRoomGroupShrinkHeaders() {}

  explicit DeleteMeetingRoomGroupShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteMeetingRoomGroupShrinkHeaders() = default;
};
class DeleteMeetingRoomGroupRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DeleteMeetingRoomGroupRequestTenantContext() {}

  explicit DeleteMeetingRoomGroupRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DeleteMeetingRoomGroupRequestTenantContext() = default;
};
class DeleteMeetingRoomGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<DeleteMeetingRoomGroupRequestTenantContext> tenantContext{};

  DeleteMeetingRoomGroupRequest() {}

  explicit DeleteMeetingRoomGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DeleteMeetingRoomGroupRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DeleteMeetingRoomGroupRequestTenantContext>(model1);
      }
    }
  }


  virtual ~DeleteMeetingRoomGroupRequest() = default;
};
class DeleteMeetingRoomGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> tenantContextShrink{};

  DeleteMeetingRoomGroupShrinkRequest() {}

  explicit DeleteMeetingRoomGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~DeleteMeetingRoomGroupShrinkRequest() = default;
};
class DeleteMeetingRoomGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteMeetingRoomGroupResponseBody() {}

  explicit DeleteMeetingRoomGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~DeleteMeetingRoomGroupResponseBody() = default;
};
class DeleteMeetingRoomGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMeetingRoomGroupResponseBody> body{};

  DeleteMeetingRoomGroupResponse() {}

  explicit DeleteMeetingRoomGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMeetingRoomGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMeetingRoomGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMeetingRoomGroupResponse() = default;
};
class DeleteRowsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteRowsHeadersAccountContext() {}

  explicit DeleteRowsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteRowsHeadersAccountContext() = default;
};
class DeleteRowsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteRowsHeadersAccountContext> accountContext{};

  DeleteRowsHeaders() {}

  explicit DeleteRowsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteRowsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteRowsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteRowsHeaders() = default;
};
class DeleteRowsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteRowsShrinkHeaders() {}

  explicit DeleteRowsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteRowsShrinkHeaders() = default;
};
class DeleteRowsRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DeleteRowsRequestTenantContext() {}

  explicit DeleteRowsRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DeleteRowsRequestTenantContext() = default;
};
class DeleteRowsRequest : public Darabonba::Model {
public:
  shared_ptr<long> row{};
  shared_ptr<long> rowCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<DeleteRowsRequestTenantContext> tenantContext{};
  shared_ptr<string> workbookId{};

  DeleteRowsRequest() {}

  explicit DeleteRowsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (row) {
      res["Row"] = boost::any(*row);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Row") != m.end() && !m["Row"].empty()) {
      row = make_shared<long>(boost::any_cast<long>(m["Row"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["RowCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DeleteRowsRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DeleteRowsRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~DeleteRowsRequest() = default;
};
class DeleteRowsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> row{};
  shared_ptr<long> rowCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workbookId{};

  DeleteRowsShrinkRequest() {}

  explicit DeleteRowsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (row) {
      res["Row"] = boost::any(*row);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Row") != m.end() && !m["Row"].empty()) {
      row = make_shared<long>(boost::any_cast<long>(m["Row"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["RowCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~DeleteRowsShrinkRequest() = default;
};
class DeleteRowsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  DeleteRowsResponseBody() {}

  explicit DeleteRowsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeleteRowsResponseBody() = default;
};
class DeleteRowsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRowsResponseBody> body{};

  DeleteRowsResponse() {}

  explicit DeleteRowsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRowsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRowsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRowsResponse() = default;
};
class DeleteSheetHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteSheetHeadersAccountContext() {}

  explicit DeleteSheetHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteSheetHeadersAccountContext() = default;
};
class DeleteSheetHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteSheetHeadersAccountContext> accountContext{};

  DeleteSheetHeaders() {}

  explicit DeleteSheetHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteSheetHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteSheetHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteSheetHeaders() = default;
};
class DeleteSheetShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteSheetShrinkHeaders() {}

  explicit DeleteSheetShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteSheetShrinkHeaders() = default;
};
class DeleteSheetRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DeleteSheetRequestTenantContext() {}

  explicit DeleteSheetRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DeleteSheetRequestTenantContext() = default;
};
class DeleteSheetRequest : public Darabonba::Model {
public:
  shared_ptr<string> sheetId{};
  shared_ptr<DeleteSheetRequestTenantContext> tenantContext{};
  shared_ptr<string> workbookId{};

  DeleteSheetRequest() {}

  explicit DeleteSheetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DeleteSheetRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DeleteSheetRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~DeleteSheetRequest() = default;
};
class DeleteSheetShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workbookId{};

  DeleteSheetShrinkRequest() {}

  explicit DeleteSheetShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~DeleteSheetShrinkRequest() = default;
};
class DeleteSheetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteSheetResponseBody() {}

  explicit DeleteSheetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~DeleteSheetResponseBody() = default;
};
class DeleteSheetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSheetResponseBody> body{};

  DeleteSheetResponse() {}

  explicit DeleteSheetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSheetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSheetResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSheetResponse() = default;
};
class DeleteTodoTaskHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteTodoTaskHeadersAccountContext() {}

  explicit DeleteTodoTaskHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteTodoTaskHeadersAccountContext() = default;
};
class DeleteTodoTaskHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteTodoTaskHeadersAccountContext> accountContext{};

  DeleteTodoTaskHeaders() {}

  explicit DeleteTodoTaskHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteTodoTaskHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteTodoTaskHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteTodoTaskHeaders() = default;
};
class DeleteTodoTaskShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteTodoTaskShrinkHeaders() {}

  explicit DeleteTodoTaskShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteTodoTaskShrinkHeaders() = default;
};
class DeleteTodoTaskRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DeleteTodoTaskRequestTenantContext() {}

  explicit DeleteTodoTaskRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DeleteTodoTaskRequestTenantContext() = default;
};
class DeleteTodoTaskRequest : public Darabonba::Model {
public:
  shared_ptr<DeleteTodoTaskRequestTenantContext> tenantContext{};
  shared_ptr<string> operatorId{};
  shared_ptr<string> taskId{};

  DeleteTodoTaskRequest() {}

  explicit DeleteTodoTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (operatorId) {
      res["operatorId"] = boost::any(*operatorId);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DeleteTodoTaskRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DeleteTodoTaskRequestTenantContext>(model1);
      }
    }
    if (m.find("operatorId") != m.end() && !m["operatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["operatorId"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
  }


  virtual ~DeleteTodoTaskRequest() = default;
};
class DeleteTodoTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> operatorId{};
  shared_ptr<string> taskId{};

  DeleteTodoTaskShrinkRequest() {}

  explicit DeleteTodoTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (operatorId) {
      res["operatorId"] = boost::any(*operatorId);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("operatorId") != m.end() && !m["operatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["operatorId"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
  }


  virtual ~DeleteTodoTaskShrinkRequest() = default;
};
class DeleteTodoTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteTodoTaskResponseBody() {}

  explicit DeleteTodoTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~DeleteTodoTaskResponseBody() = default;
};
class DeleteTodoTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTodoTaskResponseBody> body{};

  DeleteTodoTaskResponse() {}

  explicit DeleteTodoTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTodoTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTodoTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTodoTaskResponse() = default;
};
class DeleteWorkspaceDocMembersHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteWorkspaceDocMembersHeadersAccountContext() {}

  explicit DeleteWorkspaceDocMembersHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteWorkspaceDocMembersHeadersAccountContext() = default;
};
class DeleteWorkspaceDocMembersHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteWorkspaceDocMembersHeadersAccountContext> accountContext{};

  DeleteWorkspaceDocMembersHeaders() {}

  explicit DeleteWorkspaceDocMembersHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteWorkspaceDocMembersHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteWorkspaceDocMembersHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteWorkspaceDocMembersHeaders() = default;
};
class DeleteWorkspaceDocMembersShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteWorkspaceDocMembersShrinkHeaders() {}

  explicit DeleteWorkspaceDocMembersShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteWorkspaceDocMembersShrinkHeaders() = default;
};
class DeleteWorkspaceDocMembersRequestMembers : public Darabonba::Model {
public:
  shared_ptr<string> memberId{};
  shared_ptr<string> memberType{};

  DeleteWorkspaceDocMembersRequestMembers() {}

  explicit DeleteWorkspaceDocMembersRequestMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberId) {
      res["MemberId"] = boost::any(*memberId);
    }
    if (memberType) {
      res["MemberType"] = boost::any(*memberType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemberId") != m.end() && !m["MemberId"].empty()) {
      memberId = make_shared<string>(boost::any_cast<string>(m["MemberId"]));
    }
    if (m.find("MemberType") != m.end() && !m["MemberType"].empty()) {
      memberType = make_shared<string>(boost::any_cast<string>(m["MemberType"]));
    }
  }


  virtual ~DeleteWorkspaceDocMembersRequestMembers() = default;
};
class DeleteWorkspaceDocMembersRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DeleteWorkspaceDocMembersRequestTenantContext() {}

  explicit DeleteWorkspaceDocMembersRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DeleteWorkspaceDocMembersRequestTenantContext() = default;
};
class DeleteWorkspaceDocMembersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteWorkspaceDocMembersRequestMembers>> members{};
  shared_ptr<string> nodeId{};
  shared_ptr<DeleteWorkspaceDocMembersRequestTenantContext> tenantContext{};
  shared_ptr<string> workspaceId{};

  DeleteWorkspaceDocMembersRequest() {}

  explicit DeleteWorkspaceDocMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (members) {
      vector<boost::any> temp1;
      for(auto item1:*members){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Members"] = boost::any(temp1);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      if (typeid(vector<boost::any>) == m["Members"].type()) {
        vector<DeleteWorkspaceDocMembersRequestMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Members"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteWorkspaceDocMembersRequestMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        members = make_shared<vector<DeleteWorkspaceDocMembersRequestMembers>>(expect1);
      }
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DeleteWorkspaceDocMembersRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DeleteWorkspaceDocMembersRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteWorkspaceDocMembersRequest() = default;
};
class DeleteWorkspaceDocMembersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> membersShrink{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workspaceId{};

  DeleteWorkspaceDocMembersShrinkRequest() {}

  explicit DeleteWorkspaceDocMembersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (membersShrink) {
      res["Members"] = boost::any(*membersShrink);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      membersShrink = make_shared<string>(boost::any_cast<string>(m["Members"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteWorkspaceDocMembersShrinkRequest() = default;
};
class DeleteWorkspaceDocMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteWorkspaceDocMembersResponseBody() {}

  explicit DeleteWorkspaceDocMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeleteWorkspaceDocMembersResponseBody() = default;
};
class DeleteWorkspaceDocMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWorkspaceDocMembersResponseBody> body{};

  DeleteWorkspaceDocMembersResponse() {}

  explicit DeleteWorkspaceDocMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWorkspaceDocMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWorkspaceDocMembersResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWorkspaceDocMembersResponse() = default;
};
class DeleteWorkspaceMembersHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  DeleteWorkspaceMembersHeadersAccountContext() {}

  explicit DeleteWorkspaceMembersHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~DeleteWorkspaceMembersHeadersAccountContext() = default;
};
class DeleteWorkspaceMembersHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<DeleteWorkspaceMembersHeadersAccountContext> accountContext{};

  DeleteWorkspaceMembersHeaders() {}

  explicit DeleteWorkspaceMembersHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        DeleteWorkspaceMembersHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<DeleteWorkspaceMembersHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~DeleteWorkspaceMembersHeaders() = default;
};
class DeleteWorkspaceMembersShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  DeleteWorkspaceMembersShrinkHeaders() {}

  explicit DeleteWorkspaceMembersShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~DeleteWorkspaceMembersShrinkHeaders() = default;
};
class DeleteWorkspaceMembersRequestMembers : public Darabonba::Model {
public:
  shared_ptr<string> memberId{};
  shared_ptr<string> memberType{};

  DeleteWorkspaceMembersRequestMembers() {}

  explicit DeleteWorkspaceMembersRequestMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberId) {
      res["MemberId"] = boost::any(*memberId);
    }
    if (memberType) {
      res["MemberType"] = boost::any(*memberType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemberId") != m.end() && !m["MemberId"].empty()) {
      memberId = make_shared<string>(boost::any_cast<string>(m["MemberId"]));
    }
    if (m.find("MemberType") != m.end() && !m["MemberType"].empty()) {
      memberType = make_shared<string>(boost::any_cast<string>(m["MemberType"]));
    }
  }


  virtual ~DeleteWorkspaceMembersRequestMembers() = default;
};
class DeleteWorkspaceMembersRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DeleteWorkspaceMembersRequestTenantContext() {}

  explicit DeleteWorkspaceMembersRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~DeleteWorkspaceMembersRequestTenantContext() = default;
};
class DeleteWorkspaceMembersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteWorkspaceMembersRequestMembers>> members{};
  shared_ptr<DeleteWorkspaceMembersRequestTenantContext> tenantContext{};
  shared_ptr<string> workspaceId{};

  DeleteWorkspaceMembersRequest() {}

  explicit DeleteWorkspaceMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (members) {
      vector<boost::any> temp1;
      for(auto item1:*members){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Members"] = boost::any(temp1);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      if (typeid(vector<boost::any>) == m["Members"].type()) {
        vector<DeleteWorkspaceMembersRequestMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Members"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteWorkspaceMembersRequestMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        members = make_shared<vector<DeleteWorkspaceMembersRequestMembers>>(expect1);
      }
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        DeleteWorkspaceMembersRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<DeleteWorkspaceMembersRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteWorkspaceMembersRequest() = default;
};
class DeleteWorkspaceMembersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> membersShrink{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workspaceId{};

  DeleteWorkspaceMembersShrinkRequest() {}

  explicit DeleteWorkspaceMembersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (membersShrink) {
      res["Members"] = boost::any(*membersShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      membersShrink = make_shared<string>(boost::any_cast<string>(m["Members"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteWorkspaceMembersShrinkRequest() = default;
};
class DeleteWorkspaceMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteWorkspaceMembersResponseBody() {}

  explicit DeleteWorkspaceMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeleteWorkspaceMembersResponseBody() = default;
};
class DeleteWorkspaceMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWorkspaceMembersResponseBody> body{};

  DeleteWorkspaceMembersResponse() {}

  explicit DeleteWorkspaceMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWorkspaceMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWorkspaceMembersResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWorkspaceMembersResponse() = default;
};
class GetAllSheetsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetAllSheetsHeadersAccountContext() {}

  explicit GetAllSheetsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetAllSheetsHeadersAccountContext() = default;
};
class GetAllSheetsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetAllSheetsHeadersAccountContext> accountContext{};

  GetAllSheetsHeaders() {}

  explicit GetAllSheetsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetAllSheetsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetAllSheetsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetAllSheetsHeaders() = default;
};
class GetAllSheetsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetAllSheetsShrinkHeaders() {}

  explicit GetAllSheetsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetAllSheetsShrinkHeaders() = default;
};
class GetAllSheetsRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetAllSheetsRequestTenantContext() {}

  explicit GetAllSheetsRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetAllSheetsRequestTenantContext() = default;
};
class GetAllSheetsRequest : public Darabonba::Model {
public:
  shared_ptr<GetAllSheetsRequestTenantContext> tenantContext{};
  shared_ptr<string> workbookId{};

  GetAllSheetsRequest() {}

  explicit GetAllSheetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetAllSheetsRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetAllSheetsRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~GetAllSheetsRequest() = default;
};
class GetAllSheetsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workbookId{};

  GetAllSheetsShrinkRequest() {}

  explicit GetAllSheetsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~GetAllSheetsShrinkRequest() = default;
};
class GetAllSheetsResponseBodyValue : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  GetAllSheetsResponseBodyValue() {}

  explicit GetAllSheetsResponseBodyValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetAllSheetsResponseBodyValue() = default;
};
class GetAllSheetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetAllSheetsResponseBodyValue>> value{};

  GetAllSheetsResponseBody() {}

  explicit GetAllSheetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (value) {
      vector<boost::any> temp1;
      for(auto item1:*value){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["value"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      if (typeid(vector<boost::any>) == m["value"].type()) {
        vector<GetAllSheetsResponseBodyValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["value"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAllSheetsResponseBodyValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        value = make_shared<vector<GetAllSheetsResponseBodyValue>>(expect1);
      }
    }
  }


  virtual ~GetAllSheetsResponseBody() = default;
};
class GetAllSheetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAllSheetsResponseBody> body{};

  GetAllSheetsResponse() {}

  explicit GetAllSheetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAllSheetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAllSheetsResponseBody>(model1);
      }
    }
  }


  virtual ~GetAllSheetsResponse() = default;
};
class GetEventHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetEventHeadersAccountContext() {}

  explicit GetEventHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetEventHeadersAccountContext() = default;
};
class GetEventHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetEventHeadersAccountContext> accountContext{};

  GetEventHeaders() {}

  explicit GetEventHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetEventHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetEventHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetEventHeaders() = default;
};
class GetEventShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetEventShrinkHeaders() {}

  explicit GetEventShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetEventShrinkHeaders() = default;
};
class GetEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> calendarId{};
  shared_ptr<string> eventId{};
  shared_ptr<long> maxAttendees{};

  GetEventRequest() {}

  explicit GetEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (maxAttendees) {
      res["MaxAttendees"] = boost::any(*maxAttendees);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("MaxAttendees") != m.end() && !m["MaxAttendees"].empty()) {
      maxAttendees = make_shared<long>(boost::any_cast<long>(m["MaxAttendees"]));
    }
  }


  virtual ~GetEventRequest() = default;
};
class GetEventResponseBodyAttendees : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> id{};
  shared_ptr<bool> isOptional{};
  shared_ptr<string> responseStatus{};
  shared_ptr<bool> self{};

  GetEventResponseBodyAttendees() {}

  explicit GetEventResponseBodyAttendees(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isOptional) {
      res["IsOptional"] = boost::any(*isOptional);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (self) {
      res["Self"] = boost::any(*self);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IsOptional") != m.end() && !m["IsOptional"].empty()) {
      isOptional = make_shared<bool>(boost::any_cast<bool>(m["IsOptional"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("Self") != m.end() && !m["Self"].empty()) {
      self = make_shared<bool>(boost::any_cast<bool>(m["Self"]));
    }
  }


  virtual ~GetEventResponseBodyAttendees() = default;
};
class GetEventResponseBodyCategories : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};

  GetEventResponseBodyCategories() {}

  explicit GetEventResponseBodyCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
  }


  virtual ~GetEventResponseBodyCategories() = default;
};
class GetEventResponseBodyEnd : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  GetEventResponseBodyEnd() {}

  explicit GetEventResponseBodyEnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~GetEventResponseBodyEnd() = default;
};
class GetEventResponseBodyExtendedPropertiesSharedProperties : public Darabonba::Model {
public:
  shared_ptr<string> belongCorpId{};
  shared_ptr<string> sourceOpenCid{};

  GetEventResponseBodyExtendedPropertiesSharedProperties() {}

  explicit GetEventResponseBodyExtendedPropertiesSharedProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (belongCorpId) {
      res["BelongCorpId"] = boost::any(*belongCorpId);
    }
    if (sourceOpenCid) {
      res["SourceOpenCid"] = boost::any(*sourceOpenCid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BelongCorpId") != m.end() && !m["BelongCorpId"].empty()) {
      belongCorpId = make_shared<string>(boost::any_cast<string>(m["BelongCorpId"]));
    }
    if (m.find("SourceOpenCid") != m.end() && !m["SourceOpenCid"].empty()) {
      sourceOpenCid = make_shared<string>(boost::any_cast<string>(m["SourceOpenCid"]));
    }
  }


  virtual ~GetEventResponseBodyExtendedPropertiesSharedProperties() = default;
};
class GetEventResponseBodyExtendedProperties : public Darabonba::Model {
public:
  shared_ptr<GetEventResponseBodyExtendedPropertiesSharedProperties> sharedProperties{};

  GetEventResponseBodyExtendedProperties() {}

  explicit GetEventResponseBodyExtendedProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sharedProperties) {
      res["SharedProperties"] = sharedProperties ? boost::any(sharedProperties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SharedProperties") != m.end() && !m["SharedProperties"].empty()) {
      if (typeid(map<string, boost::any>) == m["SharedProperties"].type()) {
        GetEventResponseBodyExtendedPropertiesSharedProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SharedProperties"]));
        sharedProperties = make_shared<GetEventResponseBodyExtendedPropertiesSharedProperties>(model1);
      }
    }
  }


  virtual ~GetEventResponseBodyExtendedProperties() = default;
};
class GetEventResponseBodyLocation : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<vector<string>> meetingRooms{};

  GetEventResponseBodyLocation() {}

  explicit GetEventResponseBodyLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (meetingRooms) {
      res["MeetingRooms"] = boost::any(*meetingRooms);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("MeetingRooms") != m.end() && !m["MeetingRooms"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MeetingRooms"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MeetingRooms"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      meetingRooms = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetEventResponseBodyLocation() = default;
};
class GetEventResponseBodyMeetingRooms : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> responseStatus{};
  shared_ptr<string> roomId{};

  GetEventResponseBodyMeetingRooms() {}

  explicit GetEventResponseBodyMeetingRooms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
  }


  virtual ~GetEventResponseBodyMeetingRooms() = default;
};
class GetEventResponseBodyOnlineMeetingInfo : public Darabonba::Model {
public:
  shared_ptr<string> conferenceId{};
  shared_ptr<map<string, boost::any>> extraInfo{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  GetEventResponseBodyOnlineMeetingInfo() {}

  explicit GetEventResponseBodyOnlineMeetingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conferenceId) {
      res["ConferenceId"] = boost::any(*conferenceId);
    }
    if (extraInfo) {
      res["ExtraInfo"] = boost::any(*extraInfo);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConferenceId") != m.end() && !m["ConferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["ConferenceId"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetEventResponseBodyOnlineMeetingInfo() = default;
};
class GetEventResponseBodyOrganizer : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> id{};
  shared_ptr<string> responseStatus{};
  shared_ptr<bool> self{};

  GetEventResponseBodyOrganizer() {}

  explicit GetEventResponseBodyOrganizer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (self) {
      res["Self"] = boost::any(*self);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("Self") != m.end() && !m["Self"].empty()) {
      self = make_shared<bool>(boost::any_cast<bool>(m["Self"]));
    }
  }


  virtual ~GetEventResponseBodyOrganizer() = default;
};
class GetEventResponseBodyOriginStart : public Darabonba::Model {
public:
  shared_ptr<string> dateTime{};

  GetEventResponseBodyOriginStart() {}

  explicit GetEventResponseBodyOriginStart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
  }


  virtual ~GetEventResponseBodyOriginStart() = default;
};
class GetEventResponseBodyRecurrencePattern : public Darabonba::Model {
public:
  shared_ptr<long> dayOfMonth{};
  shared_ptr<string> daysOfWeek{};
  shared_ptr<string> index{};
  shared_ptr<long> interval{};
  shared_ptr<string> type{};

  GetEventResponseBodyRecurrencePattern() {}

  explicit GetEventResponseBodyRecurrencePattern(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dayOfMonth) {
      res["DayOfMonth"] = boost::any(*dayOfMonth);
    }
    if (daysOfWeek) {
      res["DaysOfWeek"] = boost::any(*daysOfWeek);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DayOfMonth") != m.end() && !m["DayOfMonth"].empty()) {
      dayOfMonth = make_shared<long>(boost::any_cast<long>(m["DayOfMonth"]));
    }
    if (m.find("DaysOfWeek") != m.end() && !m["DaysOfWeek"].empty()) {
      daysOfWeek = make_shared<string>(boost::any_cast<string>(m["DaysOfWeek"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetEventResponseBodyRecurrencePattern() = default;
};
class GetEventResponseBodyRecurrenceRange : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<long> numberOfOccurrences{};
  shared_ptr<string> type{};

  GetEventResponseBodyRecurrenceRange() {}

  explicit GetEventResponseBodyRecurrenceRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (numberOfOccurrences) {
      res["NumberOfOccurrences"] = boost::any(*numberOfOccurrences);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("NumberOfOccurrences") != m.end() && !m["NumberOfOccurrences"].empty()) {
      numberOfOccurrences = make_shared<long>(boost::any_cast<long>(m["NumberOfOccurrences"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetEventResponseBodyRecurrenceRange() = default;
};
class GetEventResponseBodyRecurrence : public Darabonba::Model {
public:
  shared_ptr<GetEventResponseBodyRecurrencePattern> pattern{};
  shared_ptr<GetEventResponseBodyRecurrenceRange> range{};

  GetEventResponseBodyRecurrence() {}

  explicit GetEventResponseBodyRecurrence(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pattern) {
      res["Pattern"] = pattern ? boost::any(pattern->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (range) {
      res["Range"] = range ? boost::any(range->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pattern"].type()) {
        GetEventResponseBodyRecurrencePattern model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pattern"]));
        pattern = make_shared<GetEventResponseBodyRecurrencePattern>(model1);
      }
    }
    if (m.find("Range") != m.end() && !m["Range"].empty()) {
      if (typeid(map<string, boost::any>) == m["Range"].type()) {
        GetEventResponseBodyRecurrenceRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Range"]));
        range = make_shared<GetEventResponseBodyRecurrenceRange>(model1);
      }
    }
  }


  virtual ~GetEventResponseBodyRecurrence() = default;
};
class GetEventResponseBodyReminders : public Darabonba::Model {
public:
  shared_ptr<string> method{};
  shared_ptr<string> minutes{};

  GetEventResponseBodyReminders() {}

  explicit GetEventResponseBodyReminders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (minutes) {
      res["Minutes"] = boost::any(*minutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Minutes") != m.end() && !m["Minutes"].empty()) {
      minutes = make_shared<string>(boost::any_cast<string>(m["Minutes"]));
    }
  }


  virtual ~GetEventResponseBodyReminders() = default;
};
class GetEventResponseBodyRichTextDescription : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  GetEventResponseBodyRichTextDescription() {}

  explicit GetEventResponseBodyRichTextDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~GetEventResponseBodyRichTextDescription() = default;
};
class GetEventResponseBodyStart : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  GetEventResponseBodyStart() {}

  explicit GetEventResponseBodyStart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~GetEventResponseBodyStart() = default;
};
class GetEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetEventResponseBodyAttendees>> attendees{};
  shared_ptr<vector<GetEventResponseBodyCategories>> categories{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<GetEventResponseBodyEnd> end{};
  shared_ptr<GetEventResponseBodyExtendedProperties> extendedProperties{};
  shared_ptr<string> id{};
  shared_ptr<bool> isAllDay{};
  shared_ptr<GetEventResponseBodyLocation> location{};
  shared_ptr<vector<GetEventResponseBodyMeetingRooms>> meetingRooms{};
  shared_ptr<GetEventResponseBodyOnlineMeetingInfo> onlineMeetingInfo{};
  shared_ptr<GetEventResponseBodyOrganizer> organizer{};
  shared_ptr<GetEventResponseBodyOriginStart> originStart{};
  shared_ptr<GetEventResponseBodyRecurrence> recurrence{};
  shared_ptr<vector<GetEventResponseBodyReminders>> reminders{};
  shared_ptr<string> requestId{};
  shared_ptr<GetEventResponseBodyRichTextDescription> richTextDescription{};
  shared_ptr<string> seriesMasterId{};
  shared_ptr<GetEventResponseBodyStart> start{};
  shared_ptr<string> status{};
  shared_ptr<string> summary{};
  shared_ptr<string> updateTime{};

  GetEventResponseBody() {}

  explicit GetEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendees) {
      vector<boost::any> temp1;
      for(auto item1:*attendees){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["attendees"] = boost::any(temp1);
    }
    if (categories) {
      vector<boost::any> temp1;
      for(auto item1:*categories){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["categories"] = boost::any(temp1);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (end) {
      res["end"] = end ? boost::any(end->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extendedProperties) {
      res["extendedProperties"] = extendedProperties ? boost::any(extendedProperties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isAllDay) {
      res["isAllDay"] = boost::any(*isAllDay);
    }
    if (location) {
      res["location"] = location ? boost::any(location->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (meetingRooms) {
      vector<boost::any> temp1;
      for(auto item1:*meetingRooms){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["meetingRooms"] = boost::any(temp1);
    }
    if (onlineMeetingInfo) {
      res["onlineMeetingInfo"] = onlineMeetingInfo ? boost::any(onlineMeetingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (organizer) {
      res["organizer"] = organizer ? boost::any(organizer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (originStart) {
      res["originStart"] = originStart ? boost::any(originStart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recurrence) {
      res["recurrence"] = recurrence ? boost::any(recurrence->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reminders) {
      vector<boost::any> temp1;
      for(auto item1:*reminders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["reminders"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (richTextDescription) {
      res["richTextDescription"] = richTextDescription ? boost::any(richTextDescription->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (seriesMasterId) {
      res["seriesMasterId"] = boost::any(*seriesMasterId);
    }
    if (start) {
      res["start"] = start ? boost::any(start->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (summary) {
      res["summary"] = boost::any(*summary);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("attendees") != m.end() && !m["attendees"].empty()) {
      if (typeid(vector<boost::any>) == m["attendees"].type()) {
        vector<GetEventResponseBodyAttendees> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["attendees"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEventResponseBodyAttendees model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attendees = make_shared<vector<GetEventResponseBodyAttendees>>(expect1);
      }
    }
    if (m.find("categories") != m.end() && !m["categories"].empty()) {
      if (typeid(vector<boost::any>) == m["categories"].type()) {
        vector<GetEventResponseBodyCategories> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["categories"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEventResponseBodyCategories model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        categories = make_shared<vector<GetEventResponseBodyCategories>>(expect1);
      }
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("end") != m.end() && !m["end"].empty()) {
      if (typeid(map<string, boost::any>) == m["end"].type()) {
        GetEventResponseBodyEnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["end"]));
        end = make_shared<GetEventResponseBodyEnd>(model1);
      }
    }
    if (m.find("extendedProperties") != m.end() && !m["extendedProperties"].empty()) {
      if (typeid(map<string, boost::any>) == m["extendedProperties"].type()) {
        GetEventResponseBodyExtendedProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["extendedProperties"]));
        extendedProperties = make_shared<GetEventResponseBodyExtendedProperties>(model1);
      }
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("isAllDay") != m.end() && !m["isAllDay"].empty()) {
      isAllDay = make_shared<bool>(boost::any_cast<bool>(m["isAllDay"]));
    }
    if (m.find("location") != m.end() && !m["location"].empty()) {
      if (typeid(map<string, boost::any>) == m["location"].type()) {
        GetEventResponseBodyLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["location"]));
        location = make_shared<GetEventResponseBodyLocation>(model1);
      }
    }
    if (m.find("meetingRooms") != m.end() && !m["meetingRooms"].empty()) {
      if (typeid(vector<boost::any>) == m["meetingRooms"].type()) {
        vector<GetEventResponseBodyMeetingRooms> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["meetingRooms"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEventResponseBodyMeetingRooms model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        meetingRooms = make_shared<vector<GetEventResponseBodyMeetingRooms>>(expect1);
      }
    }
    if (m.find("onlineMeetingInfo") != m.end() && !m["onlineMeetingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["onlineMeetingInfo"].type()) {
        GetEventResponseBodyOnlineMeetingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["onlineMeetingInfo"]));
        onlineMeetingInfo = make_shared<GetEventResponseBodyOnlineMeetingInfo>(model1);
      }
    }
    if (m.find("organizer") != m.end() && !m["organizer"].empty()) {
      if (typeid(map<string, boost::any>) == m["organizer"].type()) {
        GetEventResponseBodyOrganizer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["organizer"]));
        organizer = make_shared<GetEventResponseBodyOrganizer>(model1);
      }
    }
    if (m.find("originStart") != m.end() && !m["originStart"].empty()) {
      if (typeid(map<string, boost::any>) == m["originStart"].type()) {
        GetEventResponseBodyOriginStart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["originStart"]));
        originStart = make_shared<GetEventResponseBodyOriginStart>(model1);
      }
    }
    if (m.find("recurrence") != m.end() && !m["recurrence"].empty()) {
      if (typeid(map<string, boost::any>) == m["recurrence"].type()) {
        GetEventResponseBodyRecurrence model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["recurrence"]));
        recurrence = make_shared<GetEventResponseBodyRecurrence>(model1);
      }
    }
    if (m.find("reminders") != m.end() && !m["reminders"].empty()) {
      if (typeid(vector<boost::any>) == m["reminders"].type()) {
        vector<GetEventResponseBodyReminders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["reminders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEventResponseBodyReminders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reminders = make_shared<vector<GetEventResponseBodyReminders>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("richTextDescription") != m.end() && !m["richTextDescription"].empty()) {
      if (typeid(map<string, boost::any>) == m["richTextDescription"].type()) {
        GetEventResponseBodyRichTextDescription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["richTextDescription"]));
        richTextDescription = make_shared<GetEventResponseBodyRichTextDescription>(model1);
      }
    }
    if (m.find("seriesMasterId") != m.end() && !m["seriesMasterId"].empty()) {
      seriesMasterId = make_shared<string>(boost::any_cast<string>(m["seriesMasterId"]));
    }
    if (m.find("start") != m.end() && !m["start"].empty()) {
      if (typeid(map<string, boost::any>) == m["start"].type()) {
        GetEventResponseBodyStart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["start"]));
        start = make_shared<GetEventResponseBodyStart>(model1);
      }
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("summary") != m.end() && !m["summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["summary"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["updateTime"]));
    }
  }


  virtual ~GetEventResponseBody() = default;
};
class GetEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEventResponseBody> body{};

  GetEventResponse() {}

  explicit GetEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEventResponseBody>(model1);
      }
    }
  }


  virtual ~GetEventResponse() = default;
};
class GetMineWorkspaceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetMineWorkspaceHeadersAccountContext() {}

  explicit GetMineWorkspaceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetMineWorkspaceHeadersAccountContext() = default;
};
class GetMineWorkspaceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetMineWorkspaceHeadersAccountContext> accountContext{};

  GetMineWorkspaceHeaders() {}

  explicit GetMineWorkspaceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetMineWorkspaceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetMineWorkspaceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetMineWorkspaceHeaders() = default;
};
class GetMineWorkspaceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetMineWorkspaceShrinkHeaders() {}

  explicit GetMineWorkspaceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetMineWorkspaceShrinkHeaders() = default;
};
class GetMineWorkspaceRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetMineWorkspaceRequestTenantContext() {}

  explicit GetMineWorkspaceRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetMineWorkspaceRequestTenantContext() = default;
};
class GetMineWorkspaceRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> request{};
  shared_ptr<GetMineWorkspaceRequestTenantContext> tenantContext{};

  GetMineWorkspaceRequest() {}

  explicit GetMineWorkspaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (request) {
      res["Request"] = boost::any(*request);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Request") != m.end() && !m["Request"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Request"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      request = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetMineWorkspaceRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetMineWorkspaceRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetMineWorkspaceRequest() = default;
};
class GetMineWorkspaceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> requestShrink{};
  shared_ptr<string> tenantContextShrink{};

  GetMineWorkspaceShrinkRequest() {}

  explicit GetMineWorkspaceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestShrink) {
      res["Request"] = boost::any(*requestShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Request") != m.end() && !m["Request"].empty()) {
      requestShrink = make_shared<string>(boost::any_cast<string>(m["Request"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetMineWorkspaceShrinkRequest() = default;
};
class GetMineWorkspaceResponseBodyWorkspaceIcon : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  GetMineWorkspaceResponseBodyWorkspaceIcon() {}

  explicit GetMineWorkspaceResponseBodyWorkspaceIcon(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetMineWorkspaceResponseBodyWorkspaceIcon() = default;
};
class GetMineWorkspaceResponseBodyWorkspace : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<string> cover{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<GetMineWorkspaceResponseBodyWorkspaceIcon> icon{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> name{};
  shared_ptr<string> permissionRole{};
  shared_ptr<string> rootNodeId{};
  shared_ptr<string> teamId{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  GetMineWorkspaceResponseBodyWorkspace() {}

  explicit GetMineWorkspaceResponseBodyWorkspace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (cover) {
      res["Cover"] = boost::any(*cover);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (icon) {
      res["Icon"] = icon ? boost::any(icon->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (permissionRole) {
      res["PermissionRole"] = boost::any(*permissionRole);
    }
    if (rootNodeId) {
      res["RootNodeId"] = boost::any(*rootNodeId);
    }
    if (teamId) {
      res["TeamId"] = boost::any(*teamId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      cover = make_shared<string>(boost::any_cast<string>(m["Cover"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      if (typeid(map<string, boost::any>) == m["Icon"].type()) {
        GetMineWorkspaceResponseBodyWorkspaceIcon model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Icon"]));
        icon = make_shared<GetMineWorkspaceResponseBodyWorkspaceIcon>(model1);
      }
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["ModifierId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PermissionRole") != m.end() && !m["PermissionRole"].empty()) {
      permissionRole = make_shared<string>(boost::any_cast<string>(m["PermissionRole"]));
    }
    if (m.find("RootNodeId") != m.end() && !m["RootNodeId"].empty()) {
      rootNodeId = make_shared<string>(boost::any_cast<string>(m["RootNodeId"]));
    }
    if (m.find("TeamId") != m.end() && !m["TeamId"].empty()) {
      teamId = make_shared<string>(boost::any_cast<string>(m["TeamId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetMineWorkspaceResponseBodyWorkspace() = default;
};
class GetMineWorkspaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetMineWorkspaceResponseBodyWorkspace> workspace{};

  GetMineWorkspaceResponseBody() {}

  explicit GetMineWorkspaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (workspace) {
      res["workspace"] = workspace ? boost::any(workspace->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("workspace") != m.end() && !m["workspace"].empty()) {
      if (typeid(map<string, boost::any>) == m["workspace"].type()) {
        GetMineWorkspaceResponseBodyWorkspace model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["workspace"]));
        workspace = make_shared<GetMineWorkspaceResponseBodyWorkspace>(model1);
      }
    }
  }


  virtual ~GetMineWorkspaceResponseBody() = default;
};
class GetMineWorkspaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMineWorkspaceResponseBody> body{};

  GetMineWorkspaceResponse() {}

  explicit GetMineWorkspaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMineWorkspaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMineWorkspaceResponseBody>(model1);
      }
    }
  }


  virtual ~GetMineWorkspaceResponse() = default;
};
class GetNodeHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetNodeHeadersAccountContext() {}

  explicit GetNodeHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetNodeHeadersAccountContext() = default;
};
class GetNodeHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetNodeHeadersAccountContext> accountContext{};

  GetNodeHeaders() {}

  explicit GetNodeHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetNodeHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetNodeHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetNodeHeaders() = default;
};
class GetNodeShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetNodeShrinkHeaders() {}

  explicit GetNodeShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetNodeShrinkHeaders() = default;
};
class GetNodeRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetNodeRequestTenantContext() {}

  explicit GetNodeRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetNodeRequestTenantContext() = default;
};
class GetNodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};
  shared_ptr<GetNodeRequestTenantContext> tenantContext{};
  shared_ptr<bool> withPermissionRole{};
  shared_ptr<bool> withStatisticalInfo{};

  GetNodeRequest() {}

  explicit GetNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (withPermissionRole) {
      res["WithPermissionRole"] = boost::any(*withPermissionRole);
    }
    if (withStatisticalInfo) {
      res["WithStatisticalInfo"] = boost::any(*withStatisticalInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetNodeRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetNodeRequestTenantContext>(model1);
      }
    }
    if (m.find("WithPermissionRole") != m.end() && !m["WithPermissionRole"].empty()) {
      withPermissionRole = make_shared<bool>(boost::any_cast<bool>(m["WithPermissionRole"]));
    }
    if (m.find("WithStatisticalInfo") != m.end() && !m["WithStatisticalInfo"].empty()) {
      withStatisticalInfo = make_shared<bool>(boost::any_cast<bool>(m["WithStatisticalInfo"]));
    }
  }


  virtual ~GetNodeRequest() = default;
};
class GetNodeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<bool> withPermissionRole{};
  shared_ptr<bool> withStatisticalInfo{};

  GetNodeShrinkRequest() {}

  explicit GetNodeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (withPermissionRole) {
      res["WithPermissionRole"] = boost::any(*withPermissionRole);
    }
    if (withStatisticalInfo) {
      res["WithStatisticalInfo"] = boost::any(*withStatisticalInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WithPermissionRole") != m.end() && !m["WithPermissionRole"].empty()) {
      withPermissionRole = make_shared<bool>(boost::any_cast<bool>(m["WithPermissionRole"]));
    }
    if (m.find("WithStatisticalInfo") != m.end() && !m["WithStatisticalInfo"].empty()) {
      withStatisticalInfo = make_shared<bool>(boost::any_cast<bool>(m["WithStatisticalInfo"]));
    }
  }


  virtual ~GetNodeShrinkRequest() = default;
};
class GetNodeResponseBodyNodeStatisticalInfo : public Darabonba::Model {
public:
  shared_ptr<long> wordCount{};

  GetNodeResponseBodyNodeStatisticalInfo() {}

  explicit GetNodeResponseBodyNodeStatisticalInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (wordCount) {
      res["WordCount"] = boost::any(*wordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WordCount") != m.end() && !m["WordCount"].empty()) {
      wordCount = make_shared<long>(boost::any_cast<long>(m["WordCount"]));
    }
  }


  virtual ~GetNodeResponseBodyNodeStatisticalInfo() = default;
};
class GetNodeResponseBodyNode : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> extension{};
  shared_ptr<bool> hasChildren{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> name{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> permissionRole{};
  shared_ptr<long> size{};
  shared_ptr<GetNodeResponseBodyNodeStatisticalInfo> statisticalInfo{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  GetNodeResponseBodyNode() {}

  explicit GetNodeResponseBodyNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (hasChildren) {
      res["HasChildren"] = boost::any(*hasChildren);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (permissionRole) {
      res["PermissionRole"] = boost::any(*permissionRole);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (statisticalInfo) {
      res["StatisticalInfo"] = statisticalInfo ? boost::any(statisticalInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("HasChildren") != m.end() && !m["HasChildren"].empty()) {
      hasChildren = make_shared<bool>(boost::any_cast<bool>(m["HasChildren"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["ModifierId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("PermissionRole") != m.end() && !m["PermissionRole"].empty()) {
      permissionRole = make_shared<string>(boost::any_cast<string>(m["PermissionRole"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StatisticalInfo") != m.end() && !m["StatisticalInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatisticalInfo"].type()) {
        GetNodeResponseBodyNodeStatisticalInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatisticalInfo"]));
        statisticalInfo = make_shared<GetNodeResponseBodyNodeStatisticalInfo>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetNodeResponseBodyNode() = default;
};
class GetNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetNodeResponseBodyNode> node{};
  shared_ptr<string> requestId{};

  GetNodeResponseBody() {}

  explicit GetNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (node) {
      res["node"] = node ? boost::any(node->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("node") != m.end() && !m["node"].empty()) {
      if (typeid(map<string, boost::any>) == m["node"].type()) {
        GetNodeResponseBodyNode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["node"]));
        node = make_shared<GetNodeResponseBodyNode>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetNodeResponseBody() = default;
};
class GetNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetNodeResponseBody> body{};

  GetNodeResponse() {}

  explicit GetNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNodeResponseBody>(model1);
      }
    }
  }


  virtual ~GetNodeResponse() = default;
};
class GetNodeByUrlHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetNodeByUrlHeadersAccountContext() {}

  explicit GetNodeByUrlHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetNodeByUrlHeadersAccountContext() = default;
};
class GetNodeByUrlHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetNodeByUrlHeadersAccountContext> accountContext{};

  GetNodeByUrlHeaders() {}

  explicit GetNodeByUrlHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetNodeByUrlHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetNodeByUrlHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetNodeByUrlHeaders() = default;
};
class GetNodeByUrlShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetNodeByUrlShrinkHeaders() {}

  explicit GetNodeByUrlShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetNodeByUrlShrinkHeaders() = default;
};
class GetNodeByUrlRequestOption : public Darabonba::Model {
public:
  shared_ptr<bool> withPermissionRole{};
  shared_ptr<bool> withStatisticalInfo{};

  GetNodeByUrlRequestOption() {}

  explicit GetNodeByUrlRequestOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (withPermissionRole) {
      res["WithPermissionRole"] = boost::any(*withPermissionRole);
    }
    if (withStatisticalInfo) {
      res["WithStatisticalInfo"] = boost::any(*withStatisticalInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WithPermissionRole") != m.end() && !m["WithPermissionRole"].empty()) {
      withPermissionRole = make_shared<bool>(boost::any_cast<bool>(m["WithPermissionRole"]));
    }
    if (m.find("WithStatisticalInfo") != m.end() && !m["WithStatisticalInfo"].empty()) {
      withStatisticalInfo = make_shared<bool>(boost::any_cast<bool>(m["WithStatisticalInfo"]));
    }
  }


  virtual ~GetNodeByUrlRequestOption() = default;
};
class GetNodeByUrlRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetNodeByUrlRequestTenantContext() {}

  explicit GetNodeByUrlRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetNodeByUrlRequestTenantContext() = default;
};
class GetNodeByUrlRequest : public Darabonba::Model {
public:
  shared_ptr<GetNodeByUrlRequestOption> option{};
  shared_ptr<GetNodeByUrlRequestTenantContext> tenantContext{};
  shared_ptr<string> url{};

  GetNodeByUrlRequest() {}

  explicit GetNodeByUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (option) {
      res["Option"] = option ? boost::any(option->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      if (typeid(map<string, boost::any>) == m["Option"].type()) {
        GetNodeByUrlRequestOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Option"]));
        option = make_shared<GetNodeByUrlRequestOption>(model1);
      }
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetNodeByUrlRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetNodeByUrlRequestTenantContext>(model1);
      }
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetNodeByUrlRequest() = default;
};
class GetNodeByUrlShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> optionShrink{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> url{};

  GetNodeByUrlShrinkRequest() {}

  explicit GetNodeByUrlShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (optionShrink) {
      res["Option"] = boost::any(*optionShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      optionShrink = make_shared<string>(boost::any_cast<string>(m["Option"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetNodeByUrlShrinkRequest() = default;
};
class GetNodeByUrlResponseBodyNodeStatisticalInfo : public Darabonba::Model {
public:
  shared_ptr<long> wordCount{};

  GetNodeByUrlResponseBodyNodeStatisticalInfo() {}

  explicit GetNodeByUrlResponseBodyNodeStatisticalInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (wordCount) {
      res["WordCount"] = boost::any(*wordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WordCount") != m.end() && !m["WordCount"].empty()) {
      wordCount = make_shared<long>(boost::any_cast<long>(m["WordCount"]));
    }
  }


  virtual ~GetNodeByUrlResponseBodyNodeStatisticalInfo() = default;
};
class GetNodeByUrlResponseBodyNode : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> extension{};
  shared_ptr<bool> hasChildren{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> name{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> permissionRole{};
  shared_ptr<long> size{};
  shared_ptr<GetNodeByUrlResponseBodyNodeStatisticalInfo> statisticalInfo{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  GetNodeByUrlResponseBodyNode() {}

  explicit GetNodeByUrlResponseBodyNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (hasChildren) {
      res["HasChildren"] = boost::any(*hasChildren);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (permissionRole) {
      res["PermissionRole"] = boost::any(*permissionRole);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (statisticalInfo) {
      res["StatisticalInfo"] = statisticalInfo ? boost::any(statisticalInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("HasChildren") != m.end() && !m["HasChildren"].empty()) {
      hasChildren = make_shared<bool>(boost::any_cast<bool>(m["HasChildren"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["ModifierId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("PermissionRole") != m.end() && !m["PermissionRole"].empty()) {
      permissionRole = make_shared<string>(boost::any_cast<string>(m["PermissionRole"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StatisticalInfo") != m.end() && !m["StatisticalInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatisticalInfo"].type()) {
        GetNodeByUrlResponseBodyNodeStatisticalInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatisticalInfo"]));
        statisticalInfo = make_shared<GetNodeByUrlResponseBodyNodeStatisticalInfo>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetNodeByUrlResponseBodyNode() = default;
};
class GetNodeByUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetNodeByUrlResponseBodyNode> node{};
  shared_ptr<string> requestId{};

  GetNodeByUrlResponseBody() {}

  explicit GetNodeByUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (node) {
      res["node"] = node ? boost::any(node->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("node") != m.end() && !m["node"].empty()) {
      if (typeid(map<string, boost::any>) == m["node"].type()) {
        GetNodeByUrlResponseBodyNode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["node"]));
        node = make_shared<GetNodeByUrlResponseBodyNode>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetNodeByUrlResponseBody() = default;
};
class GetNodeByUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetNodeByUrlResponseBody> body{};

  GetNodeByUrlResponse() {}

  explicit GetNodeByUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNodeByUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNodeByUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetNodeByUrlResponse() = default;
};
class GetNodesHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetNodesHeadersAccountContext() {}

  explicit GetNodesHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetNodesHeadersAccountContext() = default;
};
class GetNodesHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetNodesHeadersAccountContext> accountContext{};

  GetNodesHeaders() {}

  explicit GetNodesHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetNodesHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetNodesHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetNodesHeaders() = default;
};
class GetNodesShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetNodesShrinkHeaders() {}

  explicit GetNodesShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetNodesShrinkHeaders() = default;
};
class GetNodesRequestOption : public Darabonba::Model {
public:
  shared_ptr<bool> withPermissionRole{};
  shared_ptr<bool> withStatisticalInfo{};

  GetNodesRequestOption() {}

  explicit GetNodesRequestOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (withPermissionRole) {
      res["WithPermissionRole"] = boost::any(*withPermissionRole);
    }
    if (withStatisticalInfo) {
      res["WithStatisticalInfo"] = boost::any(*withStatisticalInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WithPermissionRole") != m.end() && !m["WithPermissionRole"].empty()) {
      withPermissionRole = make_shared<bool>(boost::any_cast<bool>(m["WithPermissionRole"]));
    }
    if (m.find("WithStatisticalInfo") != m.end() && !m["WithStatisticalInfo"].empty()) {
      withStatisticalInfo = make_shared<bool>(boost::any_cast<bool>(m["WithStatisticalInfo"]));
    }
  }


  virtual ~GetNodesRequestOption() = default;
};
class GetNodesRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetNodesRequestTenantContext() {}

  explicit GetNodesRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetNodesRequestTenantContext() = default;
};
class GetNodesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> nodeIds{};
  shared_ptr<GetNodesRequestOption> option{};
  shared_ptr<GetNodesRequestTenantContext> tenantContext{};

  GetNodesRequest() {}

  explicit GetNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeIds) {
      res["NodeIds"] = boost::any(*nodeIds);
    }
    if (option) {
      res["Option"] = option ? boost::any(option->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeIds") != m.end() && !m["NodeIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      if (typeid(map<string, boost::any>) == m["Option"].type()) {
        GetNodesRequestOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Option"]));
        option = make_shared<GetNodesRequestOption>(model1);
      }
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetNodesRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetNodesRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetNodesRequest() = default;
};
class GetNodesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> nodeIdsShrink{};
  shared_ptr<string> optionShrink{};
  shared_ptr<string> tenantContextShrink{};

  GetNodesShrinkRequest() {}

  explicit GetNodesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeIdsShrink) {
      res["NodeIds"] = boost::any(*nodeIdsShrink);
    }
    if (optionShrink) {
      res["Option"] = boost::any(*optionShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeIds") != m.end() && !m["NodeIds"].empty()) {
      nodeIdsShrink = make_shared<string>(boost::any_cast<string>(m["NodeIds"]));
    }
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      optionShrink = make_shared<string>(boost::any_cast<string>(m["Option"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetNodesShrinkRequest() = default;
};
class GetNodesResponseBodyNodesStatisticalInfo : public Darabonba::Model {
public:
  shared_ptr<long> wordCount{};

  GetNodesResponseBodyNodesStatisticalInfo() {}

  explicit GetNodesResponseBodyNodesStatisticalInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (wordCount) {
      res["WordCount"] = boost::any(*wordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WordCount") != m.end() && !m["WordCount"].empty()) {
      wordCount = make_shared<long>(boost::any_cast<long>(m["WordCount"]));
    }
  }


  virtual ~GetNodesResponseBodyNodesStatisticalInfo() = default;
};
class GetNodesResponseBodyNodes : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> extension{};
  shared_ptr<bool> hasChildren{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> name{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> permissionRole{};
  shared_ptr<long> size{};
  shared_ptr<GetNodesResponseBodyNodesStatisticalInfo> statisticalInfo{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  GetNodesResponseBodyNodes() {}

  explicit GetNodesResponseBodyNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (hasChildren) {
      res["HasChildren"] = boost::any(*hasChildren);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (permissionRole) {
      res["PermissionRole"] = boost::any(*permissionRole);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (statisticalInfo) {
      res["StatisticalInfo"] = statisticalInfo ? boost::any(statisticalInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("HasChildren") != m.end() && !m["HasChildren"].empty()) {
      hasChildren = make_shared<bool>(boost::any_cast<bool>(m["HasChildren"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["ModifierId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("PermissionRole") != m.end() && !m["PermissionRole"].empty()) {
      permissionRole = make_shared<string>(boost::any_cast<string>(m["PermissionRole"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StatisticalInfo") != m.end() && !m["StatisticalInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatisticalInfo"].type()) {
        GetNodesResponseBodyNodesStatisticalInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatisticalInfo"]));
        statisticalInfo = make_shared<GetNodesResponseBodyNodesStatisticalInfo>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetNodesResponseBodyNodes() = default;
};
class GetNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetNodesResponseBodyNodes>> nodes{};
  shared_ptr<string> requestId{};

  GetNodesResponseBody() {}

  explicit GetNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["nodes"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nodes") != m.end() && !m["nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["nodes"].type()) {
        vector<GetNodesResponseBodyNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetNodesResponseBodyNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<GetNodesResponseBodyNodes>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetNodesResponseBody() = default;
};
class GetNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetNodesResponseBody> body{};

  GetNodesResponse() {}

  explicit GetNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNodesResponseBody>(model1);
      }
    }
  }


  virtual ~GetNodesResponse() = default;
};
class GetRangeHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetRangeHeadersAccountContext() {}

  explicit GetRangeHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetRangeHeadersAccountContext() = default;
};
class GetRangeHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetRangeHeadersAccountContext> accountContext{};

  GetRangeHeaders() {}

  explicit GetRangeHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetRangeHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetRangeHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetRangeHeaders() = default;
};
class GetRangeShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetRangeShrinkHeaders() {}

  explicit GetRangeShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetRangeShrinkHeaders() = default;
};
class GetRangeRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetRangeRequestTenantContext() {}

  explicit GetRangeRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetRangeRequestTenantContext() = default;
};
class GetRangeRequest : public Darabonba::Model {
public:
  shared_ptr<string> rangeAddress{};
  shared_ptr<string> select{};
  shared_ptr<string> sheetId{};
  shared_ptr<GetRangeRequestTenantContext> tenantContext{};
  shared_ptr<string> workbookId{};

  GetRangeRequest() {}

  explicit GetRangeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rangeAddress) {
      res["RangeAddress"] = boost::any(*rangeAddress);
    }
    if (select) {
      res["Select"] = boost::any(*select);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RangeAddress") != m.end() && !m["RangeAddress"].empty()) {
      rangeAddress = make_shared<string>(boost::any_cast<string>(m["RangeAddress"]));
    }
    if (m.find("Select") != m.end() && !m["Select"].empty()) {
      select = make_shared<string>(boost::any_cast<string>(m["Select"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetRangeRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetRangeRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~GetRangeRequest() = default;
};
class GetRangeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> rangeAddress{};
  shared_ptr<string> select{};
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workbookId{};

  GetRangeShrinkRequest() {}

  explicit GetRangeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rangeAddress) {
      res["RangeAddress"] = boost::any(*rangeAddress);
    }
    if (select) {
      res["Select"] = boost::any(*select);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RangeAddress") != m.end() && !m["RangeAddress"].empty()) {
      rangeAddress = make_shared<string>(boost::any_cast<string>(m["RangeAddress"]));
    }
    if (m.find("Select") != m.end() && !m["Select"].empty()) {
      select = make_shared<string>(boost::any_cast<string>(m["Select"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~GetRangeShrinkRequest() = default;
};
class GetRangeResponseBodyBackgroundColors : public Darabonba::Model {
public:
  shared_ptr<long> red{};
  shared_ptr<long> green{};
  shared_ptr<long> blue{};
  shared_ptr<string> hexString{};

  GetRangeResponseBodyBackgroundColors() {}

  explicit GetRangeResponseBodyBackgroundColors(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (red) {
      res["Red"] = boost::any(*red);
    }
    if (green) {
      res["Green"] = boost::any(*green);
    }
    if (blue) {
      res["Blue"] = boost::any(*blue);
    }
    if (hexString) {
      res["HexString"] = boost::any(*hexString);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Red") != m.end() && !m["Red"].empty()) {
      red = make_shared<long>(boost::any_cast<long>(m["Red"]));
    }
    if (m.find("Green") != m.end() && !m["Green"].empty()) {
      green = make_shared<long>(boost::any_cast<long>(m["Green"]));
    }
    if (m.find("Blue") != m.end() && !m["Blue"].empty()) {
      blue = make_shared<long>(boost::any_cast<long>(m["Blue"]));
    }
    if (m.find("HexString") != m.end() && !m["HexString"].empty()) {
      hexString = make_shared<string>(boost::any_cast<string>(m["HexString"]));
    }
  }


  virtual ~GetRangeResponseBodyBackgroundColors() = default;
};
class GetRangeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<vector<undefined>>> backgroundColors{};
  shared_ptr<vector<vector<string>>> displayValues{};
  shared_ptr<vector<vector<string>>> formulas{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<vector<boost::any>>> values{};

  GetRangeResponseBody() {}

  explicit GetRangeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backgroundColors) {
      vector<boost::any> temp1;
      for(auto item1:*backgroundColors){
        vector<boost::any> temp2;
        for(auto item2:item1){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1 = boost::any(temp2);
      }
      res["backgroundColors"] = boost::any(temp1);
    }
    if (displayValues) {
      res["displayValues"] = boost::any(*displayValues);
    }
    if (formulas) {
      res["formulas"] = boost::any(*formulas);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (values) {
      res["values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("backgroundColors") != m.end() && !m["backgroundColors"].empty()) {
      if (typeid(vector<boost::any>) == m["backgroundColors"].type()) {
        vector<vector<undefined>> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["backgroundColors"])){
          if (typeid(vector<boost::any>) == item1.type()) {
            vector<undefined> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                undefined model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1.push_back(expect2);
          }
        }
        backgroundColors = make_shared<vector<vector<undefined>>>(expect1);
      }
    }
    if (m.find("displayValues") != m.end() && !m["displayValues"].empty()) {
      vector<vector<string>> toVec1;
      if (typeid(vector<boost::any>) == m["displayValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["displayValues"]);
        for (auto item:vec1) {
          vector<string> toVec2;
          if (typeid(vector<boost::any>) == item.type()) {
            vector<boost::any> vec2 = boost::any_cast<vector<boost::any>>(item);
            for (auto item:vec2) {
               toVec2.push_back(boost::any_cast<string>(item));
            }
          }
           toVec1 = toVec2;
        }
      }
      displayValues = make_shared<vector<vector<string>>>(toVec1);
    }
    if (m.find("formulas") != m.end() && !m["formulas"].empty()) {
      vector<vector<string>> toVec1;
      if (typeid(vector<boost::any>) == m["formulas"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["formulas"]);
        for (auto item:vec1) {
          vector<string> toVec2;
          if (typeid(vector<boost::any>) == item.type()) {
            vector<boost::any> vec2 = boost::any_cast<vector<boost::any>>(item);
            for (auto item:vec2) {
               toVec2.push_back(boost::any_cast<string>(item));
            }
          }
           toVec1 = toVec2;
        }
      }
      formulas = make_shared<vector<vector<string>>>(toVec1);
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("values") != m.end() && !m["values"].empty()) {
      vector<vector<boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["values"]);
        for (auto item:vec1) {
          vector<boost::any> toVec2;
          if (typeid(vector<boost::any>) == item.type()) {
            vector<boost::any> vec2 = boost::any_cast<vector<boost::any>>(item);
            for (auto item:vec2) {
               toVec2.push_back(boost::any_cast<boost::any>(item));
            }
          }
           toVec1 = toVec2;
        }
      }
      values = make_shared<vector<vector<boost::any>>>(toVec1);
    }
  }


  virtual ~GetRangeResponseBody() = default;
};
class GetRangeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRangeResponseBody> body{};

  GetRangeResponse() {}

  explicit GetRangeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRangeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRangeResponseBody>(model1);
      }
    }
  }


  virtual ~GetRangeResponse() = default;
};
class GetReportTemplateByNameHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetReportTemplateByNameHeadersAccountContext() {}

  explicit GetReportTemplateByNameHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetReportTemplateByNameHeadersAccountContext() = default;
};
class GetReportTemplateByNameHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetReportTemplateByNameHeadersAccountContext> accountContext{};

  GetReportTemplateByNameHeaders() {}

  explicit GetReportTemplateByNameHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetReportTemplateByNameHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetReportTemplateByNameHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetReportTemplateByNameHeaders() = default;
};
class GetReportTemplateByNameShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetReportTemplateByNameShrinkHeaders() {}

  explicit GetReportTemplateByNameShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetReportTemplateByNameShrinkHeaders() = default;
};
class GetReportTemplateByNameRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetReportTemplateByNameRequestTenantContext() {}

  explicit GetReportTemplateByNameRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetReportTemplateByNameRequestTenantContext() = default;
};
class GetReportTemplateByNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateName{};
  shared_ptr<GetReportTemplateByNameRequestTenantContext> tenantContext{};

  GetReportTemplateByNameRequest() {}

  explicit GetReportTemplateByNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetReportTemplateByNameRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetReportTemplateByNameRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetReportTemplateByNameRequest() = default;
};
class GetReportTemplateByNameShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateName{};
  shared_ptr<string> tenantContextShrink{};

  GetReportTemplateByNameShrinkRequest() {}

  explicit GetReportTemplateByNameShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetReportTemplateByNameShrinkRequest() = default;
};
class GetReportTemplateByNameResponseBodyDefaultReceivedConvs : public Darabonba::Model {
public:
  shared_ptr<string> conversationId{};
  shared_ptr<string> title{};

  GetReportTemplateByNameResponseBodyDefaultReceivedConvs() {}

  explicit GetReportTemplateByNameResponseBodyDefaultReceivedConvs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conversationId) {
      res["ConversationId"] = boost::any(*conversationId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConversationId") != m.end() && !m["ConversationId"].empty()) {
      conversationId = make_shared<string>(boost::any_cast<string>(m["ConversationId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GetReportTemplateByNameResponseBodyDefaultReceivedConvs() = default;
};
class GetReportTemplateByNameResponseBodyDefaultReceivers : public Darabonba::Model {
public:
  shared_ptr<string> userName{};
  shared_ptr<string> userid{};

  GetReportTemplateByNameResponseBodyDefaultReceivers() {}

  explicit GetReportTemplateByNameResponseBodyDefaultReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (userid) {
      res["Userid"] = boost::any(*userid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("Userid") != m.end() && !m["Userid"].empty()) {
      userid = make_shared<string>(boost::any_cast<string>(m["Userid"]));
    }
  }


  virtual ~GetReportTemplateByNameResponseBodyDefaultReceivers() = default;
};
class GetReportTemplateByNameResponseBodyFields : public Darabonba::Model {
public:
  shared_ptr<string> fieldName{};
  shared_ptr<long> sort{};
  shared_ptr<long> type{};

  GetReportTemplateByNameResponseBodyFields() {}

  explicit GetReportTemplateByNameResponseBodyFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<long>(boost::any_cast<long>(m["Sort"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~GetReportTemplateByNameResponseBodyFields() = default;
};
class GetReportTemplateByNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetReportTemplateByNameResponseBodyDefaultReceivedConvs>> defaultReceivedConvs{};
  shared_ptr<vector<GetReportTemplateByNameResponseBodyDefaultReceivers>> defaultReceivers{};
  shared_ptr<vector<GetReportTemplateByNameResponseBodyFields>> fields{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> userName{};
  shared_ptr<string> userid{};

  GetReportTemplateByNameResponseBody() {}

  explicit GetReportTemplateByNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultReceivedConvs) {
      vector<boost::any> temp1;
      for(auto item1:*defaultReceivedConvs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["defaultReceivedConvs"] = boost::any(temp1);
    }
    if (defaultReceivers) {
      vector<boost::any> temp1;
      for(auto item1:*defaultReceivers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["defaultReceivers"] = boost::any(temp1);
    }
    if (fields) {
      vector<boost::any> temp1;
      for(auto item1:*fields){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["fields"] = boost::any(temp1);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (userName) {
      res["userName"] = boost::any(*userName);
    }
    if (userid) {
      res["userid"] = boost::any(*userid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("defaultReceivedConvs") != m.end() && !m["defaultReceivedConvs"].empty()) {
      if (typeid(vector<boost::any>) == m["defaultReceivedConvs"].type()) {
        vector<GetReportTemplateByNameResponseBodyDefaultReceivedConvs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["defaultReceivedConvs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetReportTemplateByNameResponseBodyDefaultReceivedConvs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        defaultReceivedConvs = make_shared<vector<GetReportTemplateByNameResponseBodyDefaultReceivedConvs>>(expect1);
      }
    }
    if (m.find("defaultReceivers") != m.end() && !m["defaultReceivers"].empty()) {
      if (typeid(vector<boost::any>) == m["defaultReceivers"].type()) {
        vector<GetReportTemplateByNameResponseBodyDefaultReceivers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["defaultReceivers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetReportTemplateByNameResponseBodyDefaultReceivers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        defaultReceivers = make_shared<vector<GetReportTemplateByNameResponseBodyDefaultReceivers>>(expect1);
      }
    }
    if (m.find("fields") != m.end() && !m["fields"].empty()) {
      if (typeid(vector<boost::any>) == m["fields"].type()) {
        vector<GetReportTemplateByNameResponseBodyFields> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["fields"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetReportTemplateByNameResponseBodyFields model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fields = make_shared<vector<GetReportTemplateByNameResponseBodyFields>>(expect1);
      }
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("userName") != m.end() && !m["userName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["userName"]));
    }
    if (m.find("userid") != m.end() && !m["userid"].empty()) {
      userid = make_shared<string>(boost::any_cast<string>(m["userid"]));
    }
  }


  virtual ~GetReportTemplateByNameResponseBody() = default;
};
class GetReportTemplateByNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetReportTemplateByNameResponseBody> body{};

  GetReportTemplateByNameResponse() {}

  explicit GetReportTemplateByNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetReportTemplateByNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetReportTemplateByNameResponseBody>(model1);
      }
    }
  }


  virtual ~GetReportTemplateByNameResponse() = default;
};
class GetReportUnReadCountHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetReportUnReadCountHeadersAccountContext() {}

  explicit GetReportUnReadCountHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetReportUnReadCountHeadersAccountContext() = default;
};
class GetReportUnReadCountHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetReportUnReadCountHeadersAccountContext> accountContext{};

  GetReportUnReadCountHeaders() {}

  explicit GetReportUnReadCountHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetReportUnReadCountHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetReportUnReadCountHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetReportUnReadCountHeaders() = default;
};
class GetReportUnReadCountShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetReportUnReadCountShrinkHeaders() {}

  explicit GetReportUnReadCountShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetReportUnReadCountShrinkHeaders() = default;
};
class GetReportUnReadCountRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetReportUnReadCountRequestTenantContext() {}

  explicit GetReportUnReadCountRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetReportUnReadCountRequestTenantContext() = default;
};
class GetReportUnReadCountRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> request{};
  shared_ptr<GetReportUnReadCountRequestTenantContext> tenantContext{};

  GetReportUnReadCountRequest() {}

  explicit GetReportUnReadCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (request) {
      res["Request"] = boost::any(*request);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Request") != m.end() && !m["Request"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Request"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      request = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetReportUnReadCountRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetReportUnReadCountRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetReportUnReadCountRequest() = default;
};
class GetReportUnReadCountShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> requestShrink{};
  shared_ptr<string> tenantContextShrink{};

  GetReportUnReadCountShrinkRequest() {}

  explicit GetReportUnReadCountShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestShrink) {
      res["Request"] = boost::any(*requestShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Request") != m.end() && !m["Request"].empty()) {
      requestShrink = make_shared<string>(boost::any_cast<string>(m["Request"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetReportUnReadCountShrinkRequest() = default;
};
class GetReportUnReadCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> requestId{};

  GetReportUnReadCountResponseBody() {}

  explicit GetReportUnReadCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["count"] = boost::any(*count);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetReportUnReadCountResponseBody() = default;
};
class GetReportUnReadCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetReportUnReadCountResponseBody> body{};

  GetReportUnReadCountResponse() {}

  explicit GetReportUnReadCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetReportUnReadCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetReportUnReadCountResponseBody>(model1);
      }
    }
  }


  virtual ~GetReportUnReadCountResponse() = default;
};
class GetSheetHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetSheetHeadersAccountContext() {}

  explicit GetSheetHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetSheetHeadersAccountContext() = default;
};
class GetSheetHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetSheetHeadersAccountContext> accountContext{};

  GetSheetHeaders() {}

  explicit GetSheetHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetSheetHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetSheetHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetSheetHeaders() = default;
};
class GetSheetShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetSheetShrinkHeaders() {}

  explicit GetSheetShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetSheetShrinkHeaders() = default;
};
class GetSheetRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetSheetRequestTenantContext() {}

  explicit GetSheetRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetSheetRequestTenantContext() = default;
};
class GetSheetRequest : public Darabonba::Model {
public:
  shared_ptr<string> sheetId{};
  shared_ptr<GetSheetRequestTenantContext> tenantContext{};
  shared_ptr<string> workbookId{};

  GetSheetRequest() {}

  explicit GetSheetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetSheetRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetSheetRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~GetSheetRequest() = default;
};
class GetSheetShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workbookId{};

  GetSheetShrinkRequest() {}

  explicit GetSheetShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~GetSheetShrinkRequest() = default;
};
class GetSheetResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> columnCount{};
  shared_ptr<string> id{};
  shared_ptr<long> lastNonEmptyColumn{};
  shared_ptr<long> lastNonEmptyRow{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<long> rowCount{};
  shared_ptr<string> visibility{};

  GetSheetResponseBody() {}

  explicit GetSheetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnCount) {
      res["columnCount"] = boost::any(*columnCount);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (lastNonEmptyColumn) {
      res["lastNonEmptyColumn"] = boost::any(*lastNonEmptyColumn);
    }
    if (lastNonEmptyRow) {
      res["lastNonEmptyRow"] = boost::any(*lastNonEmptyRow);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (rowCount) {
      res["rowCount"] = boost::any(*rowCount);
    }
    if (visibility) {
      res["visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("columnCount") != m.end() && !m["columnCount"].empty()) {
      columnCount = make_shared<long>(boost::any_cast<long>(m["columnCount"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("lastNonEmptyColumn") != m.end() && !m["lastNonEmptyColumn"].empty()) {
      lastNonEmptyColumn = make_shared<long>(boost::any_cast<long>(m["lastNonEmptyColumn"]));
    }
    if (m.find("lastNonEmptyRow") != m.end() && !m["lastNonEmptyRow"].empty()) {
      lastNonEmptyRow = make_shared<long>(boost::any_cast<long>(m["lastNonEmptyRow"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("rowCount") != m.end() && !m["rowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["rowCount"]));
    }
    if (m.find("visibility") != m.end() && !m["visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["visibility"]));
    }
  }


  virtual ~GetSheetResponseBody() = default;
};
class GetSheetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSheetResponseBody> body{};

  GetSheetResponse() {}

  explicit GetSheetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSheetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSheetResponseBody>(model1);
      }
    }
  }


  virtual ~GetSheetResponse() = default;
};
class GetSpaceDirectoriesHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetSpaceDirectoriesHeadersAccountContext() {}

  explicit GetSpaceDirectoriesHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetSpaceDirectoriesHeadersAccountContext() = default;
};
class GetSpaceDirectoriesHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetSpaceDirectoriesHeadersAccountContext> accountContext{};

  GetSpaceDirectoriesHeaders() {}

  explicit GetSpaceDirectoriesHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetSpaceDirectoriesHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetSpaceDirectoriesHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetSpaceDirectoriesHeaders() = default;
};
class GetSpaceDirectoriesShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetSpaceDirectoriesShrinkHeaders() {}

  explicit GetSpaceDirectoriesShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetSpaceDirectoriesShrinkHeaders() = default;
};
class GetSpaceDirectoriesRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetSpaceDirectoriesRequestTenantContext() {}

  explicit GetSpaceDirectoriesRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetSpaceDirectoriesRequestTenantContext() = default;
};
class GetSpaceDirectoriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> spaceId{};
  shared_ptr<GetSpaceDirectoriesRequestTenantContext> tenantContext{};

  GetSpaceDirectoriesRequest() {}

  explicit GetSpaceDirectoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryId) {
      res["DentryId"] = boost::any(*dentryId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryId") != m.end() && !m["DentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["DentryId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetSpaceDirectoriesRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetSpaceDirectoriesRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetSpaceDirectoriesRequest() = default;
};
class GetSpaceDirectoriesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> spaceId{};
  shared_ptr<string> tenantContextShrink{};

  GetSpaceDirectoriesShrinkRequest() {}

  explicit GetSpaceDirectoriesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryId) {
      res["DentryId"] = boost::any(*dentryId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryId") != m.end() && !m["DentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["DentryId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetSpaceDirectoriesShrinkRequest() = default;
};
class GetSpaceDirectoriesResponseBodyChildrenCreator : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> userId{};

  GetSpaceDirectoriesResponseBodyChildrenCreator() {}

  explicit GetSpaceDirectoriesResponseBodyChildrenCreator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildrenCreator() = default;
};
class GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfoIconUrl : public Darabonba::Model {
public:
  shared_ptr<string> line{};
  shared_ptr<string> small{};

  GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfoIconUrl() {}

  explicit GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfoIconUrl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (small) {
      res["Small"] = boost::any(*small);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("Small") != m.end() && !m["Small"].empty()) {
      small = make_shared<string>(boost::any_cast<string>(m["Small"]));
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfoIconUrl() = default;
};
class GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfo : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfoIconUrl> iconUrl{};
  shared_ptr<string> id{};
  shared_ptr<long> linkType{};
  shared_ptr<string> spaceId{};

  GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfo() {}

  explicit GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (iconUrl) {
      res["IconUrl"] = iconUrl ? boost::any(iconUrl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (linkType) {
      res["LinkType"] = boost::any(*linkType);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("IconUrl") != m.end() && !m["IconUrl"].empty()) {
      if (typeid(map<string, boost::any>) == m["IconUrl"].type()) {
        GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfoIconUrl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IconUrl"]));
        iconUrl = make_shared<GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfoIconUrl>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LinkType") != m.end() && !m["LinkType"].empty()) {
      linkType = make_shared<long>(boost::any_cast<long>(m["LinkType"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfo() = default;
};
class GetSpaceDirectoriesResponseBodyChildrenSpaceHdIconVO : public Darabonba::Model {
public:
  shared_ptr<string> icon{};
  shared_ptr<string> type{};

  GetSpaceDirectoriesResponseBodyChildrenSpaceHdIconVO() {}

  explicit GetSpaceDirectoriesResponseBodyChildrenSpaceHdIconVO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildrenSpaceHdIconVO() = default;
};
class GetSpaceDirectoriesResponseBodyChildrenSpaceIconVO : public Darabonba::Model {
public:
  shared_ptr<string> icon{};
  shared_ptr<string> type{};

  GetSpaceDirectoriesResponseBodyChildrenSpaceIconVO() {}

  explicit GetSpaceDirectoriesResponseBodyChildrenSpaceIconVO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildrenSpaceIconVO() = default;
};
class GetSpaceDirectoriesResponseBodyChildrenSpaceOwner : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> userId{};

  GetSpaceDirectoriesResponseBodyChildrenSpaceOwner() {}

  explicit GetSpaceDirectoriesResponseBodyChildrenSpaceOwner(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildrenSpaceOwner() = default;
};
class GetSpaceDirectoriesResponseBodyChildrenSpaceVisitorInfo : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dentryActions{};
  shared_ptr<string> roleCode{};
  shared_ptr<vector<string>> spaceActions{};

  GetSpaceDirectoriesResponseBodyChildrenSpaceVisitorInfo() {}

  explicit GetSpaceDirectoriesResponseBodyChildrenSpaceVisitorInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryActions) {
      res["DentryActions"] = boost::any(*dentryActions);
    }
    if (roleCode) {
      res["RoleCode"] = boost::any(*roleCode);
    }
    if (spaceActions) {
      res["SpaceActions"] = boost::any(*spaceActions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryActions") != m.end() && !m["DentryActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DentryActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DentryActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dentryActions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoleCode") != m.end() && !m["RoleCode"].empty()) {
      roleCode = make_shared<string>(boost::any_cast<string>(m["RoleCode"]));
    }
    if (m.find("SpaceActions") != m.end() && !m["SpaceActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SpaceActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SpaceActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      spaceActions = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildrenSpaceVisitorInfo() = default;
};
class GetSpaceDirectoriesResponseBodyChildrenSpace : public Darabonba::Model {
public:
  shared_ptr<string> cover{};
  shared_ptr<string> description{};
  shared_ptr<GetSpaceDirectoriesResponseBodyChildrenSpaceHdIconVO> hdIconVO{};
  shared_ptr<GetSpaceDirectoriesResponseBodyChildrenSpaceIconVO> iconVO{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<GetSpaceDirectoriesResponseBodyChildrenSpaceOwner> owner{};
  shared_ptr<vector<boost::any>> recentList{};
  shared_ptr<long> type{};
  shared_ptr<string> url{};
  shared_ptr<GetSpaceDirectoriesResponseBodyChildrenSpaceVisitorInfo> visitorInfo{};

  GetSpaceDirectoriesResponseBodyChildrenSpace() {}

  explicit GetSpaceDirectoriesResponseBodyChildrenSpace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cover) {
      res["Cover"] = boost::any(*cover);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hdIconVO) {
      res["HdIconVO"] = hdIconVO ? boost::any(hdIconVO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (iconVO) {
      res["IconVO"] = iconVO ? boost::any(iconVO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = owner ? boost::any(owner->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recentList) {
      res["RecentList"] = boost::any(*recentList);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (visitorInfo) {
      res["VisitorInfo"] = visitorInfo ? boost::any(visitorInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      cover = make_shared<string>(boost::any_cast<string>(m["Cover"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HdIconVO") != m.end() && !m["HdIconVO"].empty()) {
      if (typeid(map<string, boost::any>) == m["HdIconVO"].type()) {
        GetSpaceDirectoriesResponseBodyChildrenSpaceHdIconVO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HdIconVO"]));
        hdIconVO = make_shared<GetSpaceDirectoriesResponseBodyChildrenSpaceHdIconVO>(model1);
      }
    }
    if (m.find("IconVO") != m.end() && !m["IconVO"].empty()) {
      if (typeid(map<string, boost::any>) == m["IconVO"].type()) {
        GetSpaceDirectoriesResponseBodyChildrenSpaceIconVO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IconVO"]));
        iconVO = make_shared<GetSpaceDirectoriesResponseBodyChildrenSpaceIconVO>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      if (typeid(map<string, boost::any>) == m["Owner"].type()) {
        GetSpaceDirectoriesResponseBodyChildrenSpaceOwner model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Owner"]));
        owner = make_shared<GetSpaceDirectoriesResponseBodyChildrenSpaceOwner>(model1);
      }
    }
    if (m.find("RecentList") != m.end() && !m["RecentList"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["RecentList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecentList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      recentList = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("VisitorInfo") != m.end() && !m["VisitorInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["VisitorInfo"].type()) {
        GetSpaceDirectoriesResponseBodyChildrenSpaceVisitorInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VisitorInfo"]));
        visitorInfo = make_shared<GetSpaceDirectoriesResponseBodyChildrenSpaceVisitorInfo>(model1);
      }
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildrenSpace() = default;
};
class GetSpaceDirectoriesResponseBodyChildrenStatisticalInfo : public Darabonba::Model {
public:
  shared_ptr<long> wordCount{};

  GetSpaceDirectoriesResponseBodyChildrenStatisticalInfo() {}

  explicit GetSpaceDirectoriesResponseBodyChildrenStatisticalInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (wordCount) {
      res["WordCount"] = boost::any(*wordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WordCount") != m.end() && !m["WordCount"].empty()) {
      wordCount = make_shared<long>(boost::any_cast<long>(m["WordCount"]));
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildrenStatisticalInfo() = default;
};
class GetSpaceDirectoriesResponseBodyChildrenUpdater : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> userId{};

  GetSpaceDirectoriesResponseBodyChildrenUpdater() {}

  explicit GetSpaceDirectoriesResponseBodyChildrenUpdater(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildrenUpdater() = default;
};
class GetSpaceDirectoriesResponseBodyChildrenVisitorInfo : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dentryActions{};
  shared_ptr<string> roleCode{};
  shared_ptr<vector<string>> spaceActions{};

  GetSpaceDirectoriesResponseBodyChildrenVisitorInfo() {}

  explicit GetSpaceDirectoriesResponseBodyChildrenVisitorInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryActions) {
      res["DentryActions"] = boost::any(*dentryActions);
    }
    if (roleCode) {
      res["RoleCode"] = boost::any(*roleCode);
    }
    if (spaceActions) {
      res["SpaceActions"] = boost::any(*spaceActions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryActions") != m.end() && !m["DentryActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DentryActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DentryActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dentryActions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoleCode") != m.end() && !m["RoleCode"].empty()) {
      roleCode = make_shared<string>(boost::any_cast<string>(m["RoleCode"]));
    }
    if (m.find("SpaceActions") != m.end() && !m["SpaceActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SpaceActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SpaceActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      spaceActions = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildrenVisitorInfo() = default;
};
class GetSpaceDirectoriesResponseBodyChildren : public Darabonba::Model {
public:
  shared_ptr<string> contentType{};
  shared_ptr<long> createdTime{};
  shared_ptr<GetSpaceDirectoriesResponseBodyChildrenCreator> creator{};
  shared_ptr<string> dentryId{};
  shared_ptr<string> dentryType{};
  shared_ptr<string> dentryUuid{};
  shared_ptr<string> docKey{};
  shared_ptr<string> extension{};
  shared_ptr<bool> hasChildren{};
  shared_ptr<GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfo> linkSourceInfo{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<GetSpaceDirectoriesResponseBodyChildrenSpace> space{};
  shared_ptr<string> spaceId{};
  shared_ptr<GetSpaceDirectoriesResponseBodyChildrenStatisticalInfo> statisticalInfo{};
  shared_ptr<long> updatedTime{};
  shared_ptr<GetSpaceDirectoriesResponseBodyChildrenUpdater> updater{};
  shared_ptr<string> url{};
  shared_ptr<GetSpaceDirectoriesResponseBodyChildrenVisitorInfo> visitorInfo{};

  GetSpaceDirectoriesResponseBodyChildren() {}

  explicit GetSpaceDirectoriesResponseBodyChildren(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (creator) {
      res["Creator"] = creator ? boost::any(creator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dentryId) {
      res["DentryId"] = boost::any(*dentryId);
    }
    if (dentryType) {
      res["DentryType"] = boost::any(*dentryType);
    }
    if (dentryUuid) {
      res["DentryUuid"] = boost::any(*dentryUuid);
    }
    if (docKey) {
      res["DocKey"] = boost::any(*docKey);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (hasChildren) {
      res["HasChildren"] = boost::any(*hasChildren);
    }
    if (linkSourceInfo) {
      res["LinkSourceInfo"] = linkSourceInfo ? boost::any(linkSourceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (space) {
      res["Space"] = space ? boost::any(space->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (statisticalInfo) {
      res["StatisticalInfo"] = statisticalInfo ? boost::any(statisticalInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    if (updater) {
      res["Updater"] = updater ? boost::any(updater->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (visitorInfo) {
      res["VisitorInfo"] = visitorInfo ? boost::any(visitorInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      if (typeid(map<string, boost::any>) == m["Creator"].type()) {
        GetSpaceDirectoriesResponseBodyChildrenCreator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Creator"]));
        creator = make_shared<GetSpaceDirectoriesResponseBodyChildrenCreator>(model1);
      }
    }
    if (m.find("DentryId") != m.end() && !m["DentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["DentryId"]));
    }
    if (m.find("DentryType") != m.end() && !m["DentryType"].empty()) {
      dentryType = make_shared<string>(boost::any_cast<string>(m["DentryType"]));
    }
    if (m.find("DentryUuid") != m.end() && !m["DentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["DentryUuid"]));
    }
    if (m.find("DocKey") != m.end() && !m["DocKey"].empty()) {
      docKey = make_shared<string>(boost::any_cast<string>(m["DocKey"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("HasChildren") != m.end() && !m["HasChildren"].empty()) {
      hasChildren = make_shared<bool>(boost::any_cast<bool>(m["HasChildren"]));
    }
    if (m.find("LinkSourceInfo") != m.end() && !m["LinkSourceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["LinkSourceInfo"].type()) {
        GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LinkSourceInfo"]));
        linkSourceInfo = make_shared<GetSpaceDirectoriesResponseBodyChildrenLinkSourceInfo>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Space") != m.end() && !m["Space"].empty()) {
      if (typeid(map<string, boost::any>) == m["Space"].type()) {
        GetSpaceDirectoriesResponseBodyChildrenSpace model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Space"]));
        space = make_shared<GetSpaceDirectoriesResponseBodyChildrenSpace>(model1);
      }
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("StatisticalInfo") != m.end() && !m["StatisticalInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatisticalInfo"].type()) {
        GetSpaceDirectoriesResponseBodyChildrenStatisticalInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatisticalInfo"]));
        statisticalInfo = make_shared<GetSpaceDirectoriesResponseBodyChildrenStatisticalInfo>(model1);
      }
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["UpdatedTime"]));
    }
    if (m.find("Updater") != m.end() && !m["Updater"].empty()) {
      if (typeid(map<string, boost::any>) == m["Updater"].type()) {
        GetSpaceDirectoriesResponseBodyChildrenUpdater model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Updater"]));
        updater = make_shared<GetSpaceDirectoriesResponseBodyChildrenUpdater>(model1);
      }
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("VisitorInfo") != m.end() && !m["VisitorInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["VisitorInfo"].type()) {
        GetSpaceDirectoriesResponseBodyChildrenVisitorInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VisitorInfo"]));
        visitorInfo = make_shared<GetSpaceDirectoriesResponseBodyChildrenVisitorInfo>(model1);
      }
    }
  }


  virtual ~GetSpaceDirectoriesResponseBodyChildren() = default;
};
class GetSpaceDirectoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetSpaceDirectoriesResponseBodyChildren>> children{};
  shared_ptr<bool> hasMore{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  GetSpaceDirectoriesResponseBody() {}

  explicit GetSpaceDirectoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (children) {
      vector<boost::any> temp1;
      for(auto item1:*children){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["children"] = boost::any(temp1);
    }
    if (hasMore) {
      res["hasMore"] = boost::any(*hasMore);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("children") != m.end() && !m["children"].empty()) {
      if (typeid(vector<boost::any>) == m["children"].type()) {
        vector<GetSpaceDirectoriesResponseBodyChildren> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["children"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSpaceDirectoriesResponseBodyChildren model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        children = make_shared<vector<GetSpaceDirectoriesResponseBodyChildren>>(expect1);
      }
    }
    if (m.find("hasMore") != m.end() && !m["hasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["hasMore"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetSpaceDirectoriesResponseBody() = default;
};
class GetSpaceDirectoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSpaceDirectoriesResponseBody> body{};

  GetSpaceDirectoriesResponse() {}

  explicit GetSpaceDirectoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSpaceDirectoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSpaceDirectoriesResponseBody>(model1);
      }
    }
  }


  virtual ~GetSpaceDirectoriesResponse() = default;
};
class GetTemplateListByUserIdHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetTemplateListByUserIdHeadersAccountContext() {}

  explicit GetTemplateListByUserIdHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetTemplateListByUserIdHeadersAccountContext() = default;
};
class GetTemplateListByUserIdHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetTemplateListByUserIdHeadersAccountContext> accountContext{};

  GetTemplateListByUserIdHeaders() {}

  explicit GetTemplateListByUserIdHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetTemplateListByUserIdHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetTemplateListByUserIdHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetTemplateListByUserIdHeaders() = default;
};
class GetTemplateListByUserIdShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetTemplateListByUserIdShrinkHeaders() {}

  explicit GetTemplateListByUserIdShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetTemplateListByUserIdShrinkHeaders() = default;
};
class GetTemplateListByUserIdRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetTemplateListByUserIdRequestTenantContext() {}

  explicit GetTemplateListByUserIdRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetTemplateListByUserIdRequestTenantContext() = default;
};
class GetTemplateListByUserIdRequest : public Darabonba::Model {
public:
  shared_ptr<long> offset{};
  shared_ptr<long> size{};
  shared_ptr<GetTemplateListByUserIdRequestTenantContext> tenantContext{};

  GetTemplateListByUserIdRequest() {}

  explicit GetTemplateListByUserIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetTemplateListByUserIdRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetTemplateListByUserIdRequestTenantContext>(model1);
      }
    }
  }


  virtual ~GetTemplateListByUserIdRequest() = default;
};
class GetTemplateListByUserIdShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> offset{};
  shared_ptr<long> size{};
  shared_ptr<string> tenantContextShrink{};

  GetTemplateListByUserIdShrinkRequest() {}

  explicit GetTemplateListByUserIdShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~GetTemplateListByUserIdShrinkRequest() = default;
};
class GetTemplateListByUserIdResponseBodyTemplateList : public Darabonba::Model {
public:
  shared_ptr<string> iconUrl{};
  shared_ptr<string> name{};
  shared_ptr<string> reportCode{};
  shared_ptr<string> url{};

  GetTemplateListByUserIdResponseBodyTemplateList() {}

  explicit GetTemplateListByUserIdResponseBodyTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iconUrl) {
      res["IconUrl"] = boost::any(*iconUrl);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (reportCode) {
      res["ReportCode"] = boost::any(*reportCode);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IconUrl") != m.end() && !m["IconUrl"].empty()) {
      iconUrl = make_shared<string>(boost::any_cast<string>(m["IconUrl"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ReportCode") != m.end() && !m["ReportCode"].empty()) {
      reportCode = make_shared<string>(boost::any_cast<string>(m["ReportCode"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetTemplateListByUserIdResponseBodyTemplateList() = default;
};
class GetTemplateListByUserIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> nextCursor{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetTemplateListByUserIdResponseBodyTemplateList>> templateList{};

  GetTemplateListByUserIdResponseBody() {}

  explicit GetTemplateListByUserIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextCursor) {
      res["nextCursor"] = boost::any(*nextCursor);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (templateList) {
      vector<boost::any> temp1;
      for(auto item1:*templateList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["templateList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nextCursor") != m.end() && !m["nextCursor"].empty()) {
      nextCursor = make_shared<long>(boost::any_cast<long>(m["nextCursor"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("templateList") != m.end() && !m["templateList"].empty()) {
      if (typeid(vector<boost::any>) == m["templateList"].type()) {
        vector<GetTemplateListByUserIdResponseBodyTemplateList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["templateList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTemplateListByUserIdResponseBodyTemplateList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templateList = make_shared<vector<GetTemplateListByUserIdResponseBodyTemplateList>>(expect1);
      }
    }
  }


  virtual ~GetTemplateListByUserIdResponseBody() = default;
};
class GetTemplateListByUserIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTemplateListByUserIdResponseBody> body{};

  GetTemplateListByUserIdResponse() {}

  explicit GetTemplateListByUserIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTemplateListByUserIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTemplateListByUserIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetTemplateListByUserIdResponse() = default;
};
class GetUserHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetUserHeadersAccountContext() {}

  explicit GetUserHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetUserHeadersAccountContext() = default;
};
class GetUserHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetUserHeadersAccountContext> accountContext{};

  GetUserHeaders() {}

  explicit GetUserHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetUserHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetUserHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetUserHeaders() = default;
};
class GetUserShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetUserShrinkHeaders() {}

  explicit GetUserShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetUserShrinkHeaders() = default;
};
class GetUserRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetUserRequestTenantContext() {}

  explicit GetUserRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetUserRequestTenantContext() = default;
};
class GetUserRequest : public Darabonba::Model {
public:
  shared_ptr<GetUserRequestTenantContext> tenantContext{};
  shared_ptr<string> language{};

  GetUserRequest() {}

  explicit GetUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (language) {
      res["language"] = boost::any(*language);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetUserRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetUserRequestTenantContext>(model1);
      }
    }
    if (m.find("language") != m.end() && !m["language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["language"]));
    }
  }


  virtual ~GetUserRequest() = default;
};
class GetUserShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> language{};

  GetUserShrinkRequest() {}

  explicit GetUserShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (language) {
      res["language"] = boost::any(*language);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("language") != m.end() && !m["language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["language"]));
    }
  }


  virtual ~GetUserShrinkRequest() = default;
};
class GetUserResponseBodyDeptOrderList : public Darabonba::Model {
public:
  shared_ptr<long> deptId{};
  shared_ptr<long> order{};

  GetUserResponseBodyDeptOrderList() {}

  explicit GetUserResponseBodyDeptOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deptId) {
      res["deptId"] = boost::any(*deptId);
    }
    if (order) {
      res["order"] = boost::any(*order);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("deptId") != m.end() && !m["deptId"].empty()) {
      deptId = make_shared<long>(boost::any_cast<long>(m["deptId"]));
    }
    if (m.find("order") != m.end() && !m["order"].empty()) {
      order = make_shared<long>(boost::any_cast<long>(m["order"]));
    }
  }


  virtual ~GetUserResponseBodyDeptOrderList() = default;
};
class GetUserResponseBodyLeaderInDept : public Darabonba::Model {
public:
  shared_ptr<long> deptId{};
  shared_ptr<bool> leader{};

  GetUserResponseBodyLeaderInDept() {}

  explicit GetUserResponseBodyLeaderInDept(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deptId) {
      res["deptId"] = boost::any(*deptId);
    }
    if (leader) {
      res["leader"] = boost::any(*leader);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("deptId") != m.end() && !m["deptId"].empty()) {
      deptId = make_shared<long>(boost::any_cast<long>(m["deptId"]));
    }
    if (m.find("leader") != m.end() && !m["leader"].empty()) {
      leader = make_shared<bool>(boost::any_cast<bool>(m["leader"]));
    }
  }


  virtual ~GetUserResponseBodyLeaderInDept() = default;
};
class GetUserResponseBodyRoleList : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  GetUserResponseBodyRoleList() {}

  explicit GetUserResponseBodyRoleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["groupName"] = boost::any(*groupName);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("groupName") != m.end() && !m["groupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["groupName"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~GetUserResponseBodyRoleList() = default;
};
class GetUserResponseBodyUnionEmpExtUnionEmpMapList : public Darabonba::Model {
public:
  shared_ptr<string> cropId{};
  shared_ptr<string> userid{};

  GetUserResponseBodyUnionEmpExtUnionEmpMapList() {}

  explicit GetUserResponseBodyUnionEmpExtUnionEmpMapList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cropId) {
      res["cropId"] = boost::any(*cropId);
    }
    if (userid) {
      res["userid"] = boost::any(*userid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cropId") != m.end() && !m["cropId"].empty()) {
      cropId = make_shared<string>(boost::any_cast<string>(m["cropId"]));
    }
    if (m.find("userid") != m.end() && !m["userid"].empty()) {
      userid = make_shared<string>(boost::any_cast<string>(m["userid"]));
    }
  }


  virtual ~GetUserResponseBodyUnionEmpExtUnionEmpMapList() = default;
};
class GetUserResponseBodyUnionEmpExt : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<vector<GetUserResponseBodyUnionEmpExtUnionEmpMapList>> unionEmpMapList{};
  shared_ptr<string> userid{};

  GetUserResponseBodyUnionEmpExt() {}

  explicit GetUserResponseBodyUnionEmpExt(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["corpId"] = boost::any(*corpId);
    }
    if (unionEmpMapList) {
      vector<boost::any> temp1;
      for(auto item1:*unionEmpMapList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["unionEmpMapList"] = boost::any(temp1);
    }
    if (userid) {
      res["userid"] = boost::any(*userid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("corpId") != m.end() && !m["corpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["corpId"]));
    }
    if (m.find("unionEmpMapList") != m.end() && !m["unionEmpMapList"].empty()) {
      if (typeid(vector<boost::any>) == m["unionEmpMapList"].type()) {
        vector<GetUserResponseBodyUnionEmpExtUnionEmpMapList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["unionEmpMapList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetUserResponseBodyUnionEmpExtUnionEmpMapList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        unionEmpMapList = make_shared<vector<GetUserResponseBodyUnionEmpExtUnionEmpMapList>>(expect1);
      }
    }
    if (m.find("userid") != m.end() && !m["userid"].empty()) {
      userid = make_shared<string>(boost::any_cast<string>(m["userid"]));
    }
  }


  virtual ~GetUserResponseBodyUnionEmpExt() = default;
};
class GetUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<bool> admin{};
  shared_ptr<string> avatar{};
  shared_ptr<bool> boss{};
  shared_ptr<vector<long>> deptIdList{};
  shared_ptr<vector<GetUserResponseBodyDeptOrderList>> deptOrderList{};
  shared_ptr<string> email{};
  shared_ptr<bool> exclusiveAccount{};
  shared_ptr<string> exclusiveAccountCorpId{};
  shared_ptr<string> exclusiveAccountCorpName{};
  shared_ptr<string> exclusiveAccountType{};
  shared_ptr<string> extension{};
  shared_ptr<bool> hideMobile{};
  shared_ptr<long> hiredDate{};
  shared_ptr<string> jobNumber{};
  shared_ptr<vector<GetUserResponseBodyLeaderInDept>> leaderInDept{};
  shared_ptr<string> loginId{};
  shared_ptr<string> managerUserid{};
  shared_ptr<string> mobile{};
  shared_ptr<string> name{};
  shared_ptr<string> nickname{};
  shared_ptr<string> orgEmail{};
  shared_ptr<bool> realAuthed{};
  shared_ptr<string> remark{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetUserResponseBodyRoleList>> roleList{};
  shared_ptr<bool> senior{};
  shared_ptr<string> stateCode{};
  shared_ptr<string> telephone{};
  shared_ptr<string> title{};
  shared_ptr<GetUserResponseBodyUnionEmpExt> unionEmpExt{};
  shared_ptr<string> userid{};
  shared_ptr<string> workPlace{};

  GetUserResponseBody() {}

  explicit GetUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["active"] = boost::any(*active);
    }
    if (admin) {
      res["admin"] = boost::any(*admin);
    }
    if (avatar) {
      res["avatar"] = boost::any(*avatar);
    }
    if (boss) {
      res["boss"] = boost::any(*boss);
    }
    if (deptIdList) {
      res["deptIdList"] = boost::any(*deptIdList);
    }
    if (deptOrderList) {
      vector<boost::any> temp1;
      for(auto item1:*deptOrderList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["deptOrderList"] = boost::any(temp1);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (exclusiveAccount) {
      res["exclusiveAccount"] = boost::any(*exclusiveAccount);
    }
    if (exclusiveAccountCorpId) {
      res["exclusiveAccountCorpId"] = boost::any(*exclusiveAccountCorpId);
    }
    if (exclusiveAccountCorpName) {
      res["exclusiveAccountCorpName"] = boost::any(*exclusiveAccountCorpName);
    }
    if (exclusiveAccountType) {
      res["exclusiveAccountType"] = boost::any(*exclusiveAccountType);
    }
    if (extension) {
      res["extension"] = boost::any(*extension);
    }
    if (hideMobile) {
      res["hideMobile"] = boost::any(*hideMobile);
    }
    if (hiredDate) {
      res["hiredDate"] = boost::any(*hiredDate);
    }
    if (jobNumber) {
      res["jobNumber"] = boost::any(*jobNumber);
    }
    if (leaderInDept) {
      vector<boost::any> temp1;
      for(auto item1:*leaderInDept){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["leaderInDept"] = boost::any(temp1);
    }
    if (loginId) {
      res["loginId"] = boost::any(*loginId);
    }
    if (managerUserid) {
      res["managerUserid"] = boost::any(*managerUserid);
    }
    if (mobile) {
      res["mobile"] = boost::any(*mobile);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nickname) {
      res["nickname"] = boost::any(*nickname);
    }
    if (orgEmail) {
      res["orgEmail"] = boost::any(*orgEmail);
    }
    if (realAuthed) {
      res["realAuthed"] = boost::any(*realAuthed);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (roleList) {
      vector<boost::any> temp1;
      for(auto item1:*roleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["roleList"] = boost::any(temp1);
    }
    if (senior) {
      res["senior"] = boost::any(*senior);
    }
    if (stateCode) {
      res["stateCode"] = boost::any(*stateCode);
    }
    if (telephone) {
      res["telephone"] = boost::any(*telephone);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (unionEmpExt) {
      res["unionEmpExt"] = unionEmpExt ? boost::any(unionEmpExt->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userid) {
      res["userid"] = boost::any(*userid);
    }
    if (workPlace) {
      res["workPlace"] = boost::any(*workPlace);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("active") != m.end() && !m["active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["active"]));
    }
    if (m.find("admin") != m.end() && !m["admin"].empty()) {
      admin = make_shared<bool>(boost::any_cast<bool>(m["admin"]));
    }
    if (m.find("avatar") != m.end() && !m["avatar"].empty()) {
      avatar = make_shared<string>(boost::any_cast<string>(m["avatar"]));
    }
    if (m.find("boss") != m.end() && !m["boss"].empty()) {
      boss = make_shared<bool>(boost::any_cast<bool>(m["boss"]));
    }
    if (m.find("deptIdList") != m.end() && !m["deptIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["deptIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["deptIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      deptIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("deptOrderList") != m.end() && !m["deptOrderList"].empty()) {
      if (typeid(vector<boost::any>) == m["deptOrderList"].type()) {
        vector<GetUserResponseBodyDeptOrderList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["deptOrderList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetUserResponseBodyDeptOrderList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deptOrderList = make_shared<vector<GetUserResponseBodyDeptOrderList>>(expect1);
      }
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("exclusiveAccount") != m.end() && !m["exclusiveAccount"].empty()) {
      exclusiveAccount = make_shared<bool>(boost::any_cast<bool>(m["exclusiveAccount"]));
    }
    if (m.find("exclusiveAccountCorpId") != m.end() && !m["exclusiveAccountCorpId"].empty()) {
      exclusiveAccountCorpId = make_shared<string>(boost::any_cast<string>(m["exclusiveAccountCorpId"]));
    }
    if (m.find("exclusiveAccountCorpName") != m.end() && !m["exclusiveAccountCorpName"].empty()) {
      exclusiveAccountCorpName = make_shared<string>(boost::any_cast<string>(m["exclusiveAccountCorpName"]));
    }
    if (m.find("exclusiveAccountType") != m.end() && !m["exclusiveAccountType"].empty()) {
      exclusiveAccountType = make_shared<string>(boost::any_cast<string>(m["exclusiveAccountType"]));
    }
    if (m.find("extension") != m.end() && !m["extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["extension"]));
    }
    if (m.find("hideMobile") != m.end() && !m["hideMobile"].empty()) {
      hideMobile = make_shared<bool>(boost::any_cast<bool>(m["hideMobile"]));
    }
    if (m.find("hiredDate") != m.end() && !m["hiredDate"].empty()) {
      hiredDate = make_shared<long>(boost::any_cast<long>(m["hiredDate"]));
    }
    if (m.find("jobNumber") != m.end() && !m["jobNumber"].empty()) {
      jobNumber = make_shared<string>(boost::any_cast<string>(m["jobNumber"]));
    }
    if (m.find("leaderInDept") != m.end() && !m["leaderInDept"].empty()) {
      if (typeid(vector<boost::any>) == m["leaderInDept"].type()) {
        vector<GetUserResponseBodyLeaderInDept> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["leaderInDept"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetUserResponseBodyLeaderInDept model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        leaderInDept = make_shared<vector<GetUserResponseBodyLeaderInDept>>(expect1);
      }
    }
    if (m.find("loginId") != m.end() && !m["loginId"].empty()) {
      loginId = make_shared<string>(boost::any_cast<string>(m["loginId"]));
    }
    if (m.find("managerUserid") != m.end() && !m["managerUserid"].empty()) {
      managerUserid = make_shared<string>(boost::any_cast<string>(m["managerUserid"]));
    }
    if (m.find("mobile") != m.end() && !m["mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["mobile"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nickname") != m.end() && !m["nickname"].empty()) {
      nickname = make_shared<string>(boost::any_cast<string>(m["nickname"]));
    }
    if (m.find("orgEmail") != m.end() && !m["orgEmail"].empty()) {
      orgEmail = make_shared<string>(boost::any_cast<string>(m["orgEmail"]));
    }
    if (m.find("realAuthed") != m.end() && !m["realAuthed"].empty()) {
      realAuthed = make_shared<bool>(boost::any_cast<bool>(m["realAuthed"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("roleList") != m.end() && !m["roleList"].empty()) {
      if (typeid(vector<boost::any>) == m["roleList"].type()) {
        vector<GetUserResponseBodyRoleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["roleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetUserResponseBodyRoleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roleList = make_shared<vector<GetUserResponseBodyRoleList>>(expect1);
      }
    }
    if (m.find("senior") != m.end() && !m["senior"].empty()) {
      senior = make_shared<bool>(boost::any_cast<bool>(m["senior"]));
    }
    if (m.find("stateCode") != m.end() && !m["stateCode"].empty()) {
      stateCode = make_shared<string>(boost::any_cast<string>(m["stateCode"]));
    }
    if (m.find("telephone") != m.end() && !m["telephone"].empty()) {
      telephone = make_shared<string>(boost::any_cast<string>(m["telephone"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("unionEmpExt") != m.end() && !m["unionEmpExt"].empty()) {
      if (typeid(map<string, boost::any>) == m["unionEmpExt"].type()) {
        GetUserResponseBodyUnionEmpExt model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["unionEmpExt"]));
        unionEmpExt = make_shared<GetUserResponseBodyUnionEmpExt>(model1);
      }
    }
    if (m.find("userid") != m.end() && !m["userid"].empty()) {
      userid = make_shared<string>(boost::any_cast<string>(m["userid"]));
    }
    if (m.find("workPlace") != m.end() && !m["workPlace"].empty()) {
      workPlace = make_shared<string>(boost::any_cast<string>(m["workPlace"]));
    }
  }


  virtual ~GetUserResponseBody() = default;
};
class GetUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserResponseBody> body{};

  GetUserResponse() {}

  explicit GetUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserResponse() = default;
};
class GetWorkspaceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetWorkspaceHeadersAccountContext() {}

  explicit GetWorkspaceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetWorkspaceHeadersAccountContext() = default;
};
class GetWorkspaceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetWorkspaceHeadersAccountContext> accountContext{};

  GetWorkspaceHeaders() {}

  explicit GetWorkspaceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetWorkspaceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetWorkspaceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetWorkspaceHeaders() = default;
};
class GetWorkspaceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetWorkspaceShrinkHeaders() {}

  explicit GetWorkspaceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetWorkspaceShrinkHeaders() = default;
};
class GetWorkspaceRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetWorkspaceRequestTenantContext() {}

  explicit GetWorkspaceRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetWorkspaceRequestTenantContext() = default;
};
class GetWorkspaceRequest : public Darabonba::Model {
public:
  shared_ptr<GetWorkspaceRequestTenantContext> tenantContext{};
  shared_ptr<bool> withPermissionRole{};
  shared_ptr<string> workspaceId{};

  GetWorkspaceRequest() {}

  explicit GetWorkspaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (withPermissionRole) {
      res["WithPermissionRole"] = boost::any(*withPermissionRole);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetWorkspaceRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetWorkspaceRequestTenantContext>(model1);
      }
    }
    if (m.find("WithPermissionRole") != m.end() && !m["WithPermissionRole"].empty()) {
      withPermissionRole = make_shared<bool>(boost::any_cast<bool>(m["WithPermissionRole"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetWorkspaceRequest() = default;
};
class GetWorkspaceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<bool> withPermissionRole{};
  shared_ptr<string> workspaceId{};

  GetWorkspaceShrinkRequest() {}

  explicit GetWorkspaceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (withPermissionRole) {
      res["WithPermissionRole"] = boost::any(*withPermissionRole);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WithPermissionRole") != m.end() && !m["WithPermissionRole"].empty()) {
      withPermissionRole = make_shared<bool>(boost::any_cast<bool>(m["WithPermissionRole"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetWorkspaceShrinkRequest() = default;
};
class GetWorkspaceResponseBodyWorkspaceIcon : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  GetWorkspaceResponseBodyWorkspaceIcon() {}

  explicit GetWorkspaceResponseBodyWorkspaceIcon(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetWorkspaceResponseBodyWorkspaceIcon() = default;
};
class GetWorkspaceResponseBodyWorkspace : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<string> cover{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<GetWorkspaceResponseBodyWorkspaceIcon> icon{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> name{};
  shared_ptr<string> permissionRole{};
  shared_ptr<string> rootNodeId{};
  shared_ptr<string> teamId{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  GetWorkspaceResponseBodyWorkspace() {}

  explicit GetWorkspaceResponseBodyWorkspace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (cover) {
      res["Cover"] = boost::any(*cover);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (icon) {
      res["Icon"] = icon ? boost::any(icon->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (permissionRole) {
      res["PermissionRole"] = boost::any(*permissionRole);
    }
    if (rootNodeId) {
      res["RootNodeId"] = boost::any(*rootNodeId);
    }
    if (teamId) {
      res["TeamId"] = boost::any(*teamId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      cover = make_shared<string>(boost::any_cast<string>(m["Cover"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      if (typeid(map<string, boost::any>) == m["Icon"].type()) {
        GetWorkspaceResponseBodyWorkspaceIcon model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Icon"]));
        icon = make_shared<GetWorkspaceResponseBodyWorkspaceIcon>(model1);
      }
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["ModifierId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PermissionRole") != m.end() && !m["PermissionRole"].empty()) {
      permissionRole = make_shared<string>(boost::any_cast<string>(m["PermissionRole"]));
    }
    if (m.find("RootNodeId") != m.end() && !m["RootNodeId"].empty()) {
      rootNodeId = make_shared<string>(boost::any_cast<string>(m["RootNodeId"]));
    }
    if (m.find("TeamId") != m.end() && !m["TeamId"].empty()) {
      teamId = make_shared<string>(boost::any_cast<string>(m["TeamId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetWorkspaceResponseBodyWorkspace() = default;
};
class GetWorkspaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetWorkspaceResponseBodyWorkspace> workspace{};

  GetWorkspaceResponseBody() {}

  explicit GetWorkspaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (workspace) {
      res["workspace"] = workspace ? boost::any(workspace->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("workspace") != m.end() && !m["workspace"].empty()) {
      if (typeid(map<string, boost::any>) == m["workspace"].type()) {
        GetWorkspaceResponseBodyWorkspace model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["workspace"]));
        workspace = make_shared<GetWorkspaceResponseBodyWorkspace>(model1);
      }
    }
  }


  virtual ~GetWorkspaceResponseBody() = default;
};
class GetWorkspaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWorkspaceResponseBody> body{};

  GetWorkspaceResponse() {}

  explicit GetWorkspaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWorkspaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWorkspaceResponseBody>(model1);
      }
    }
  }


  virtual ~GetWorkspaceResponse() = default;
};
class GetWorkspacesHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  GetWorkspacesHeadersAccountContext() {}

  explicit GetWorkspacesHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~GetWorkspacesHeadersAccountContext() = default;
};
class GetWorkspacesHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<GetWorkspacesHeadersAccountContext> accountContext{};

  GetWorkspacesHeaders() {}

  explicit GetWorkspacesHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        GetWorkspacesHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<GetWorkspacesHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~GetWorkspacesHeaders() = default;
};
class GetWorkspacesShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  GetWorkspacesShrinkHeaders() {}

  explicit GetWorkspacesShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~GetWorkspacesShrinkHeaders() = default;
};
class GetWorkspacesRequestOption : public Darabonba::Model {
public:
  shared_ptr<bool> withPermissionRole{};

  GetWorkspacesRequestOption() {}

  explicit GetWorkspacesRequestOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (withPermissionRole) {
      res["WithPermissionRole"] = boost::any(*withPermissionRole);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WithPermissionRole") != m.end() && !m["WithPermissionRole"].empty()) {
      withPermissionRole = make_shared<bool>(boost::any_cast<bool>(m["WithPermissionRole"]));
    }
  }


  virtual ~GetWorkspacesRequestOption() = default;
};
class GetWorkspacesRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  GetWorkspacesRequestTenantContext() {}

  explicit GetWorkspacesRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~GetWorkspacesRequestTenantContext() = default;
};
class GetWorkspacesRequest : public Darabonba::Model {
public:
  shared_ptr<GetWorkspacesRequestOption> option{};
  shared_ptr<GetWorkspacesRequestTenantContext> tenantContext{};
  shared_ptr<vector<string>> workspaceIds{};

  GetWorkspacesRequest() {}

  explicit GetWorkspacesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (option) {
      res["Option"] = option ? boost::any(option->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workspaceIds) {
      res["WorkspaceIds"] = boost::any(*workspaceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      if (typeid(map<string, boost::any>) == m["Option"].type()) {
        GetWorkspacesRequestOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Option"]));
        option = make_shared<GetWorkspacesRequestOption>(model1);
      }
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        GetWorkspacesRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<GetWorkspacesRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkspaceIds") != m.end() && !m["WorkspaceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WorkspaceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WorkspaceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      workspaceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetWorkspacesRequest() = default;
};
class GetWorkspacesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> optionShrink{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workspaceIdsShrink{};

  GetWorkspacesShrinkRequest() {}

  explicit GetWorkspacesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (optionShrink) {
      res["Option"] = boost::any(*optionShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workspaceIdsShrink) {
      res["WorkspaceIds"] = boost::any(*workspaceIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      optionShrink = make_shared<string>(boost::any_cast<string>(m["Option"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkspaceIds") != m.end() && !m["WorkspaceIds"].empty()) {
      workspaceIdsShrink = make_shared<string>(boost::any_cast<string>(m["WorkspaceIds"]));
    }
  }


  virtual ~GetWorkspacesShrinkRequest() = default;
};
class GetWorkspacesResponseBodyWorkspaceIcon : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  GetWorkspacesResponseBodyWorkspaceIcon() {}

  explicit GetWorkspacesResponseBodyWorkspaceIcon(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetWorkspacesResponseBodyWorkspaceIcon() = default;
};
class GetWorkspacesResponseBodyWorkspace : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<string> cover{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<GetWorkspacesResponseBodyWorkspaceIcon> icon{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> name{};
  shared_ptr<string> permissionRole{};
  shared_ptr<string> rootNodeId{};
  shared_ptr<string> teamId{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  GetWorkspacesResponseBodyWorkspace() {}

  explicit GetWorkspacesResponseBodyWorkspace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (cover) {
      res["Cover"] = boost::any(*cover);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (icon) {
      res["Icon"] = icon ? boost::any(icon->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (permissionRole) {
      res["PermissionRole"] = boost::any(*permissionRole);
    }
    if (rootNodeId) {
      res["RootNodeId"] = boost::any(*rootNodeId);
    }
    if (teamId) {
      res["TeamId"] = boost::any(*teamId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      cover = make_shared<string>(boost::any_cast<string>(m["Cover"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      if (typeid(map<string, boost::any>) == m["Icon"].type()) {
        GetWorkspacesResponseBodyWorkspaceIcon model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Icon"]));
        icon = make_shared<GetWorkspacesResponseBodyWorkspaceIcon>(model1);
      }
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["ModifierId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PermissionRole") != m.end() && !m["PermissionRole"].empty()) {
      permissionRole = make_shared<string>(boost::any_cast<string>(m["PermissionRole"]));
    }
    if (m.find("RootNodeId") != m.end() && !m["RootNodeId"].empty()) {
      rootNodeId = make_shared<string>(boost::any_cast<string>(m["RootNodeId"]));
    }
    if (m.find("TeamId") != m.end() && !m["TeamId"].empty()) {
      teamId = make_shared<string>(boost::any_cast<string>(m["TeamId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetWorkspacesResponseBodyWorkspace() = default;
};
class GetWorkspacesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetWorkspacesResponseBodyWorkspace>> workspace{};

  GetWorkspacesResponseBody() {}

  explicit GetWorkspacesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (workspace) {
      vector<boost::any> temp1;
      for(auto item1:*workspace){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["workspace"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("workspace") != m.end() && !m["workspace"].empty()) {
      if (typeid(vector<boost::any>) == m["workspace"].type()) {
        vector<GetWorkspacesResponseBodyWorkspace> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["workspace"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetWorkspacesResponseBodyWorkspace model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workspace = make_shared<vector<GetWorkspacesResponseBodyWorkspace>>(expect1);
      }
    }
  }


  virtual ~GetWorkspacesResponseBody() = default;
};
class GetWorkspacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWorkspacesResponseBody> body{};

  GetWorkspacesResponse() {}

  explicit GetWorkspacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWorkspacesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWorkspacesResponseBody>(model1);
      }
    }
  }


  virtual ~GetWorkspacesResponse() = default;
};
class InsertColumnsBeforeHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  InsertColumnsBeforeHeadersAccountContext() {}

  explicit InsertColumnsBeforeHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~InsertColumnsBeforeHeadersAccountContext() = default;
};
class InsertColumnsBeforeHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<InsertColumnsBeforeHeadersAccountContext> accountContext{};

  InsertColumnsBeforeHeaders() {}

  explicit InsertColumnsBeforeHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        InsertColumnsBeforeHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<InsertColumnsBeforeHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~InsertColumnsBeforeHeaders() = default;
};
class InsertColumnsBeforeShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  InsertColumnsBeforeShrinkHeaders() {}

  explicit InsertColumnsBeforeShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~InsertColumnsBeforeShrinkHeaders() = default;
};
class InsertColumnsBeforeRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  InsertColumnsBeforeRequestTenantContext() {}

  explicit InsertColumnsBeforeRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~InsertColumnsBeforeRequestTenantContext() = default;
};
class InsertColumnsBeforeRequest : public Darabonba::Model {
public:
  shared_ptr<long> column{};
  shared_ptr<long> columnCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<InsertColumnsBeforeRequestTenantContext> tenantContext{};
  shared_ptr<string> workbookId{};

  InsertColumnsBeforeRequest() {}

  explicit InsertColumnsBeforeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (column) {
      res["Column"] = boost::any(*column);
    }
    if (columnCount) {
      res["ColumnCount"] = boost::any(*columnCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Column") != m.end() && !m["Column"].empty()) {
      column = make_shared<long>(boost::any_cast<long>(m["Column"]));
    }
    if (m.find("ColumnCount") != m.end() && !m["ColumnCount"].empty()) {
      columnCount = make_shared<long>(boost::any_cast<long>(m["ColumnCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        InsertColumnsBeforeRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<InsertColumnsBeforeRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~InsertColumnsBeforeRequest() = default;
};
class InsertColumnsBeforeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> column{};
  shared_ptr<long> columnCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workbookId{};

  InsertColumnsBeforeShrinkRequest() {}

  explicit InsertColumnsBeforeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (column) {
      res["Column"] = boost::any(*column);
    }
    if (columnCount) {
      res["ColumnCount"] = boost::any(*columnCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Column") != m.end() && !m["Column"].empty()) {
      column = make_shared<long>(boost::any_cast<long>(m["Column"]));
    }
    if (m.find("ColumnCount") != m.end() && !m["ColumnCount"].empty()) {
      columnCount = make_shared<long>(boost::any_cast<long>(m["ColumnCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~InsertColumnsBeforeShrinkRequest() = default;
};
class InsertColumnsBeforeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  InsertColumnsBeforeResponseBody() {}

  explicit InsertColumnsBeforeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~InsertColumnsBeforeResponseBody() = default;
};
class InsertColumnsBeforeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsertColumnsBeforeResponseBody> body{};

  InsertColumnsBeforeResponse() {}

  explicit InsertColumnsBeforeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertColumnsBeforeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertColumnsBeforeResponseBody>(model1);
      }
    }
  }


  virtual ~InsertColumnsBeforeResponse() = default;
};
class InsertRowsBeforeHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  InsertRowsBeforeHeadersAccountContext() {}

  explicit InsertRowsBeforeHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~InsertRowsBeforeHeadersAccountContext() = default;
};
class InsertRowsBeforeHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<InsertRowsBeforeHeadersAccountContext> accountContext{};

  InsertRowsBeforeHeaders() {}

  explicit InsertRowsBeforeHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        InsertRowsBeforeHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<InsertRowsBeforeHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~InsertRowsBeforeHeaders() = default;
};
class InsertRowsBeforeShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  InsertRowsBeforeShrinkHeaders() {}

  explicit InsertRowsBeforeShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~InsertRowsBeforeShrinkHeaders() = default;
};
class InsertRowsBeforeRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  InsertRowsBeforeRequestTenantContext() {}

  explicit InsertRowsBeforeRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~InsertRowsBeforeRequestTenantContext() = default;
};
class InsertRowsBeforeRequest : public Darabonba::Model {
public:
  shared_ptr<long> row{};
  shared_ptr<long> rowCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<InsertRowsBeforeRequestTenantContext> tenantContext{};
  shared_ptr<string> workbookId{};

  InsertRowsBeforeRequest() {}

  explicit InsertRowsBeforeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (row) {
      res["Row"] = boost::any(*row);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Row") != m.end() && !m["Row"].empty()) {
      row = make_shared<long>(boost::any_cast<long>(m["Row"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["RowCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        InsertRowsBeforeRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<InsertRowsBeforeRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~InsertRowsBeforeRequest() = default;
};
class InsertRowsBeforeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> row{};
  shared_ptr<long> rowCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workbookId{};

  InsertRowsBeforeShrinkRequest() {}

  explicit InsertRowsBeforeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (row) {
      res["Row"] = boost::any(*row);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Row") != m.end() && !m["Row"].empty()) {
      row = make_shared<long>(boost::any_cast<long>(m["Row"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["RowCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~InsertRowsBeforeShrinkRequest() = default;
};
class InsertRowsBeforeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  InsertRowsBeforeResponseBody() {}

  explicit InsertRowsBeforeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~InsertRowsBeforeResponseBody() = default;
};
class InsertRowsBeforeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsertRowsBeforeResponseBody> body{};

  InsertRowsBeforeResponse() {}

  explicit InsertRowsBeforeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertRowsBeforeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertRowsBeforeResponseBody>(model1);
      }
    }
  }


  virtual ~InsertRowsBeforeResponse() = default;
};
class InviteUsersHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  InviteUsersHeadersAccountContext() {}

  explicit InviteUsersHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~InviteUsersHeadersAccountContext() = default;
};
class InviteUsersHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<InviteUsersHeadersAccountContext> accountContext{};

  InviteUsersHeaders() {}

  explicit InviteUsersHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        InviteUsersHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<InviteUsersHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~InviteUsersHeaders() = default;
};
class InviteUsersShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  InviteUsersShrinkHeaders() {}

  explicit InviteUsersShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~InviteUsersShrinkHeaders() = default;
};
class InviteUsersRequestInviteeList : public Darabonba::Model {
public:
  shared_ptr<string> nick{};
  shared_ptr<string> userId{};

  InviteUsersRequestInviteeList() {}

  explicit InviteUsersRequestInviteeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nick) {
      res["Nick"] = boost::any(*nick);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Nick") != m.end() && !m["Nick"].empty()) {
      nick = make_shared<string>(boost::any_cast<string>(m["Nick"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~InviteUsersRequestInviteeList() = default;
};
class InviteUsersRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  InviteUsersRequestTenantContext() {}

  explicit InviteUsersRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~InviteUsersRequestTenantContext() = default;
};
class InviteUsersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<InviteUsersRequestInviteeList>> inviteeList{};
  shared_ptr<InviteUsersRequestTenantContext> tenantContext{};
  shared_ptr<string> conferenceId{};

  InviteUsersRequest() {}

  explicit InviteUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inviteeList) {
      vector<boost::any> temp1;
      for(auto item1:*inviteeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InviteeList"] = boost::any(temp1);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InviteeList") != m.end() && !m["InviteeList"].empty()) {
      if (typeid(vector<boost::any>) == m["InviteeList"].type()) {
        vector<InviteUsersRequestInviteeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InviteeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InviteUsersRequestInviteeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inviteeList = make_shared<vector<InviteUsersRequestInviteeList>>(expect1);
      }
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        InviteUsersRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<InviteUsersRequestTenantContext>(model1);
      }
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~InviteUsersRequest() = default;
};
class InviteUsersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> inviteeListShrink{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> conferenceId{};

  InviteUsersShrinkRequest() {}

  explicit InviteUsersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inviteeListShrink) {
      res["InviteeList"] = boost::any(*inviteeListShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InviteeList") != m.end() && !m["InviteeList"].empty()) {
      inviteeListShrink = make_shared<string>(boost::any_cast<string>(m["InviteeList"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~InviteUsersShrinkRequest() = default;
};
class InviteUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  InviteUsersResponseBody() {}

  explicit InviteUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~InviteUsersResponseBody() = default;
};
class InviteUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InviteUsersResponseBody> body{};

  InviteUsersResponse() {}

  explicit InviteUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InviteUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InviteUsersResponseBody>(model1);
      }
    }
  }


  virtual ~InviteUsersResponse() = default;
};
class ListCalendarsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListCalendarsHeadersAccountContext() {}

  explicit ListCalendarsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListCalendarsHeadersAccountContext() = default;
};
class ListCalendarsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ListCalendarsHeadersAccountContext> accountContext{};

  ListCalendarsHeaders() {}

  explicit ListCalendarsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ListCalendarsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ListCalendarsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ListCalendarsHeaders() = default;
};
class ListCalendarsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ListCalendarsShrinkHeaders() {}

  explicit ListCalendarsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ListCalendarsShrinkHeaders() = default;
};
class ListCalendarsRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> request{};

  ListCalendarsRequest() {}

  explicit ListCalendarsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (request) {
      res["Request"] = boost::any(*request);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Request") != m.end() && !m["Request"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Request"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      request = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~ListCalendarsRequest() = default;
};
class ListCalendarsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> requestShrink{};

  ListCalendarsShrinkRequest() {}

  explicit ListCalendarsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestShrink) {
      res["Request"] = boost::any(*requestShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Request") != m.end() && !m["Request"].empty()) {
      requestShrink = make_shared<string>(boost::any_cast<string>(m["Request"]));
    }
  }


  virtual ~ListCalendarsShrinkRequest() = default;
};
class ListCalendarsResponseBodyResponseCalendars : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> ETag{};
  shared_ptr<string> id{};
  shared_ptr<string> privilege{};
  shared_ptr<string> summary{};
  shared_ptr<string> timeZone{};
  shared_ptr<string> type{};

  ListCalendarsResponseBodyResponseCalendars() {}

  explicit ListCalendarsResponseBodyResponseCalendars(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ETag) {
      res["ETag"] = boost::any(*ETag);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (privilege) {
      res["Privilege"] = boost::any(*privilege);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ETag") != m.end() && !m["ETag"].empty()) {
      ETag = make_shared<string>(boost::any_cast<string>(m["ETag"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Privilege") != m.end() && !m["Privilege"].empty()) {
      privilege = make_shared<string>(boost::any_cast<string>(m["Privilege"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListCalendarsResponseBodyResponseCalendars() = default;
};
class ListCalendarsResponseBodyResponse : public Darabonba::Model {
public:
  shared_ptr<vector<ListCalendarsResponseBodyResponseCalendars>> calendars{};

  ListCalendarsResponseBodyResponse() {}

  explicit ListCalendarsResponseBodyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calendars) {
      vector<boost::any> temp1;
      for(auto item1:*calendars){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Calendars"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Calendars") != m.end() && !m["Calendars"].empty()) {
      if (typeid(vector<boost::any>) == m["Calendars"].type()) {
        vector<ListCalendarsResponseBodyResponseCalendars> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Calendars"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCalendarsResponseBodyResponseCalendars model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        calendars = make_shared<vector<ListCalendarsResponseBodyResponseCalendars>>(expect1);
      }
    }
  }


  virtual ~ListCalendarsResponseBodyResponse() = default;
};
class ListCalendarsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListCalendarsResponseBodyResponse> response{};

  ListCalendarsResponseBody() {}

  explicit ListCalendarsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (response) {
      res["response"] = response ? boost::any(response->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("response") != m.end() && !m["response"].empty()) {
      if (typeid(map<string, boost::any>) == m["response"].type()) {
        ListCalendarsResponseBodyResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["response"]));
        response = make_shared<ListCalendarsResponseBodyResponse>(model1);
      }
    }
  }


  virtual ~ListCalendarsResponseBody() = default;
};
class ListCalendarsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCalendarsResponseBody> body{};

  ListCalendarsResponse() {}

  explicit ListCalendarsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCalendarsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCalendarsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCalendarsResponse() = default;
};
class ListEventsHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListEventsHeadersAccountContext() {}

  explicit ListEventsHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListEventsHeadersAccountContext() = default;
};
class ListEventsHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ListEventsHeadersAccountContext> accountContext{};

  ListEventsHeaders() {}

  explicit ListEventsHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ListEventsHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ListEventsHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ListEventsHeaders() = default;
};
class ListEventsShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ListEventsShrinkHeaders() {}

  explicit ListEventsShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ListEventsShrinkHeaders() = default;
};
class ListEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> calendarId{};
  shared_ptr<long> maxAttendees{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> seriesMasterId{};
  shared_ptr<bool> showDeleted{};
  shared_ptr<string> syncToken{};
  shared_ptr<string> timeMax{};
  shared_ptr<string> timeMin{};

  ListEventsRequest() {}

  explicit ListEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (maxAttendees) {
      res["MaxAttendees"] = boost::any(*maxAttendees);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (seriesMasterId) {
      res["SeriesMasterId"] = boost::any(*seriesMasterId);
    }
    if (showDeleted) {
      res["ShowDeleted"] = boost::any(*showDeleted);
    }
    if (syncToken) {
      res["SyncToken"] = boost::any(*syncToken);
    }
    if (timeMax) {
      res["TimeMax"] = boost::any(*timeMax);
    }
    if (timeMin) {
      res["TimeMin"] = boost::any(*timeMin);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("MaxAttendees") != m.end() && !m["MaxAttendees"].empty()) {
      maxAttendees = make_shared<long>(boost::any_cast<long>(m["MaxAttendees"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("SeriesMasterId") != m.end() && !m["SeriesMasterId"].empty()) {
      seriesMasterId = make_shared<string>(boost::any_cast<string>(m["SeriesMasterId"]));
    }
    if (m.find("ShowDeleted") != m.end() && !m["ShowDeleted"].empty()) {
      showDeleted = make_shared<bool>(boost::any_cast<bool>(m["ShowDeleted"]));
    }
    if (m.find("SyncToken") != m.end() && !m["SyncToken"].empty()) {
      syncToken = make_shared<string>(boost::any_cast<string>(m["SyncToken"]));
    }
    if (m.find("TimeMax") != m.end() && !m["TimeMax"].empty()) {
      timeMax = make_shared<string>(boost::any_cast<string>(m["TimeMax"]));
    }
    if (m.find("TimeMin") != m.end() && !m["TimeMin"].empty()) {
      timeMin = make_shared<string>(boost::any_cast<string>(m["TimeMin"]));
    }
  }


  virtual ~ListEventsRequest() = default;
};
class ListEventsResponseBodyEventsAttendees : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<bool> isOptional{};
  shared_ptr<string> responseStatus{};
  shared_ptr<bool> self{};

  ListEventsResponseBodyEventsAttendees() {}

  explicit ListEventsResponseBodyEventsAttendees(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (isOptional) {
      res["IsOptional"] = boost::any(*isOptional);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (self) {
      res["Self"] = boost::any(*self);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("IsOptional") != m.end() && !m["IsOptional"].empty()) {
      isOptional = make_shared<bool>(boost::any_cast<bool>(m["IsOptional"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("Self") != m.end() && !m["Self"].empty()) {
      self = make_shared<bool>(boost::any_cast<bool>(m["Self"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsAttendees() = default;
};
class ListEventsResponseBodyEventsCategories : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};

  ListEventsResponseBodyEventsCategories() {}

  explicit ListEventsResponseBodyEventsCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsCategories() = default;
};
class ListEventsResponseBodyEventsEnd : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  ListEventsResponseBodyEventsEnd() {}

  explicit ListEventsResponseBodyEventsEnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsEnd() = default;
};
class ListEventsResponseBodyEventsExtendedPropertiesSharedProperties : public Darabonba::Model {
public:
  shared_ptr<string> belongCorpId{};
  shared_ptr<string> sourceOpenCid{};

  ListEventsResponseBodyEventsExtendedPropertiesSharedProperties() {}

  explicit ListEventsResponseBodyEventsExtendedPropertiesSharedProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (belongCorpId) {
      res["BelongCorpId"] = boost::any(*belongCorpId);
    }
    if (sourceOpenCid) {
      res["SourceOpenCid"] = boost::any(*sourceOpenCid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BelongCorpId") != m.end() && !m["BelongCorpId"].empty()) {
      belongCorpId = make_shared<string>(boost::any_cast<string>(m["BelongCorpId"]));
    }
    if (m.find("SourceOpenCid") != m.end() && !m["SourceOpenCid"].empty()) {
      sourceOpenCid = make_shared<string>(boost::any_cast<string>(m["SourceOpenCid"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsExtendedPropertiesSharedProperties() = default;
};
class ListEventsResponseBodyEventsExtendedProperties : public Darabonba::Model {
public:
  shared_ptr<ListEventsResponseBodyEventsExtendedPropertiesSharedProperties> sharedProperties{};

  ListEventsResponseBodyEventsExtendedProperties() {}

  explicit ListEventsResponseBodyEventsExtendedProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sharedProperties) {
      res["SharedProperties"] = sharedProperties ? boost::any(sharedProperties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SharedProperties") != m.end() && !m["SharedProperties"].empty()) {
      if (typeid(map<string, boost::any>) == m["SharedProperties"].type()) {
        ListEventsResponseBodyEventsExtendedPropertiesSharedProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SharedProperties"]));
        sharedProperties = make_shared<ListEventsResponseBodyEventsExtendedPropertiesSharedProperties>(model1);
      }
    }
  }


  virtual ~ListEventsResponseBodyEventsExtendedProperties() = default;
};
class ListEventsResponseBodyEventsLocation : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<vector<string>> meetingRooms{};

  ListEventsResponseBodyEventsLocation() {}

  explicit ListEventsResponseBodyEventsLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (meetingRooms) {
      res["MeetingRooms"] = boost::any(*meetingRooms);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("MeetingRooms") != m.end() && !m["MeetingRooms"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MeetingRooms"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MeetingRooms"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      meetingRooms = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListEventsResponseBodyEventsLocation() = default;
};
class ListEventsResponseBodyEventsMeetingRooms : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> responseStatus{};
  shared_ptr<string> roomId{};

  ListEventsResponseBodyEventsMeetingRooms() {}

  explicit ListEventsResponseBodyEventsMeetingRooms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsMeetingRooms() = default;
};
class ListEventsResponseBodyEventsOnlineMeetingInfo : public Darabonba::Model {
public:
  shared_ptr<string> conferenceId{};
  shared_ptr<map<string, boost::any>> extraInfo{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  ListEventsResponseBodyEventsOnlineMeetingInfo() {}

  explicit ListEventsResponseBodyEventsOnlineMeetingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conferenceId) {
      res["ConferenceId"] = boost::any(*conferenceId);
    }
    if (extraInfo) {
      res["ExtraInfo"] = boost::any(*extraInfo);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConferenceId") != m.end() && !m["ConferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["ConferenceId"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsOnlineMeetingInfo() = default;
};
class ListEventsResponseBodyEventsOrganizer : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> responseStatus{};
  shared_ptr<bool> self{};

  ListEventsResponseBodyEventsOrganizer() {}

  explicit ListEventsResponseBodyEventsOrganizer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (self) {
      res["Self"] = boost::any(*self);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("Self") != m.end() && !m["Self"].empty()) {
      self = make_shared<bool>(boost::any_cast<bool>(m["Self"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsOrganizer() = default;
};
class ListEventsResponseBodyEventsOriginStart : public Darabonba::Model {
public:
  shared_ptr<string> dateTime{};

  ListEventsResponseBodyEventsOriginStart() {}

  explicit ListEventsResponseBodyEventsOriginStart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsOriginStart() = default;
};
class ListEventsResponseBodyEventsRecurrencePattern : public Darabonba::Model {
public:
  shared_ptr<long> dayOfMonth{};
  shared_ptr<string> daysOfWeek{};
  shared_ptr<string> index{};
  shared_ptr<long> interval{};
  shared_ptr<string> type{};

  ListEventsResponseBodyEventsRecurrencePattern() {}

  explicit ListEventsResponseBodyEventsRecurrencePattern(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dayOfMonth) {
      res["DayOfMonth"] = boost::any(*dayOfMonth);
    }
    if (daysOfWeek) {
      res["DaysOfWeek"] = boost::any(*daysOfWeek);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DayOfMonth") != m.end() && !m["DayOfMonth"].empty()) {
      dayOfMonth = make_shared<long>(boost::any_cast<long>(m["DayOfMonth"]));
    }
    if (m.find("DaysOfWeek") != m.end() && !m["DaysOfWeek"].empty()) {
      daysOfWeek = make_shared<string>(boost::any_cast<string>(m["DaysOfWeek"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsRecurrencePattern() = default;
};
class ListEventsResponseBodyEventsRecurrenceRange : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<long> numberOfOccurrences{};
  shared_ptr<string> type{};

  ListEventsResponseBodyEventsRecurrenceRange() {}

  explicit ListEventsResponseBodyEventsRecurrenceRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (numberOfOccurrences) {
      res["NumberOfOccurrences"] = boost::any(*numberOfOccurrences);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("NumberOfOccurrences") != m.end() && !m["NumberOfOccurrences"].empty()) {
      numberOfOccurrences = make_shared<long>(boost::any_cast<long>(m["NumberOfOccurrences"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsRecurrenceRange() = default;
};
class ListEventsResponseBodyEventsRecurrence : public Darabonba::Model {
public:
  shared_ptr<ListEventsResponseBodyEventsRecurrencePattern> pattern{};
  shared_ptr<ListEventsResponseBodyEventsRecurrenceRange> range{};

  ListEventsResponseBodyEventsRecurrence() {}

  explicit ListEventsResponseBodyEventsRecurrence(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pattern) {
      res["Pattern"] = pattern ? boost::any(pattern->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (range) {
      res["Range"] = range ? boost::any(range->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pattern"].type()) {
        ListEventsResponseBodyEventsRecurrencePattern model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pattern"]));
        pattern = make_shared<ListEventsResponseBodyEventsRecurrencePattern>(model1);
      }
    }
    if (m.find("Range") != m.end() && !m["Range"].empty()) {
      if (typeid(map<string, boost::any>) == m["Range"].type()) {
        ListEventsResponseBodyEventsRecurrenceRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Range"]));
        range = make_shared<ListEventsResponseBodyEventsRecurrenceRange>(model1);
      }
    }
  }


  virtual ~ListEventsResponseBodyEventsRecurrence() = default;
};
class ListEventsResponseBodyEventsReminders : public Darabonba::Model {
public:
  shared_ptr<string> method{};
  shared_ptr<string> minutes{};

  ListEventsResponseBodyEventsReminders() {}

  explicit ListEventsResponseBodyEventsReminders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (minutes) {
      res["Minutes"] = boost::any(*minutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Minutes") != m.end() && !m["Minutes"].empty()) {
      minutes = make_shared<string>(boost::any_cast<string>(m["Minutes"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsReminders() = default;
};
class ListEventsResponseBodyEventsRichTextDescription : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  ListEventsResponseBodyEventsRichTextDescription() {}

  explicit ListEventsResponseBodyEventsRichTextDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsRichTextDescription() = default;
};
class ListEventsResponseBodyEventsStart : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  ListEventsResponseBodyEventsStart() {}

  explicit ListEventsResponseBodyEventsStart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~ListEventsResponseBodyEventsStart() = default;
};
class ListEventsResponseBodyEvents : public Darabonba::Model {
public:
  shared_ptr<vector<ListEventsResponseBodyEventsAttendees>> attendees{};
  shared_ptr<vector<ListEventsResponseBodyEventsCategories>> categories{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<ListEventsResponseBodyEventsEnd> end{};
  shared_ptr<ListEventsResponseBodyEventsExtendedProperties> extendedProperties{};
  shared_ptr<string> id{};
  shared_ptr<bool> isAllDay{};
  shared_ptr<ListEventsResponseBodyEventsLocation> location{};
  shared_ptr<vector<ListEventsResponseBodyEventsMeetingRooms>> meetingRooms{};
  shared_ptr<ListEventsResponseBodyEventsOnlineMeetingInfo> onlineMeetingInfo{};
  shared_ptr<ListEventsResponseBodyEventsOrganizer> organizer{};
  shared_ptr<ListEventsResponseBodyEventsOriginStart> originStart{};
  shared_ptr<ListEventsResponseBodyEventsRecurrence> recurrence{};
  shared_ptr<vector<ListEventsResponseBodyEventsReminders>> reminders{};
  shared_ptr<ListEventsResponseBodyEventsRichTextDescription> richTextDescription{};
  shared_ptr<string> seriesMasterId{};
  shared_ptr<ListEventsResponseBodyEventsStart> start{};
  shared_ptr<string> status{};
  shared_ptr<string> summary{};
  shared_ptr<string> updateTime{};

  ListEventsResponseBodyEvents() {}

  explicit ListEventsResponseBodyEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendees) {
      vector<boost::any> temp1;
      for(auto item1:*attendees){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attendees"] = boost::any(temp1);
    }
    if (categories) {
      vector<boost::any> temp1;
      for(auto item1:*categories){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Categories"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (end) {
      res["End"] = end ? boost::any(end->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extendedProperties) {
      res["ExtendedProperties"] = extendedProperties ? boost::any(extendedProperties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isAllDay) {
      res["IsAllDay"] = boost::any(*isAllDay);
    }
    if (location) {
      res["Location"] = location ? boost::any(location->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (meetingRooms) {
      vector<boost::any> temp1;
      for(auto item1:*meetingRooms){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MeetingRooms"] = boost::any(temp1);
    }
    if (onlineMeetingInfo) {
      res["OnlineMeetingInfo"] = onlineMeetingInfo ? boost::any(onlineMeetingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (organizer) {
      res["Organizer"] = organizer ? boost::any(organizer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (originStart) {
      res["OriginStart"] = originStart ? boost::any(originStart->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recurrence) {
      res["Recurrence"] = recurrence ? boost::any(recurrence->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reminders) {
      vector<boost::any> temp1;
      for(auto item1:*reminders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Reminders"] = boost::any(temp1);
    }
    if (richTextDescription) {
      res["RichTextDescription"] = richTextDescription ? boost::any(richTextDescription->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (seriesMasterId) {
      res["SeriesMasterId"] = boost::any(*seriesMasterId);
    }
    if (start) {
      res["Start"] = start ? boost::any(start->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attendees") != m.end() && !m["Attendees"].empty()) {
      if (typeid(vector<boost::any>) == m["Attendees"].type()) {
        vector<ListEventsResponseBodyEventsAttendees> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attendees"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEventsResponseBodyEventsAttendees model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attendees = make_shared<vector<ListEventsResponseBodyEventsAttendees>>(expect1);
      }
    }
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<ListEventsResponseBodyEventsCategories> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Categories"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEventsResponseBodyEventsCategories model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        categories = make_shared<vector<ListEventsResponseBodyEventsCategories>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      if (typeid(map<string, boost::any>) == m["End"].type()) {
        ListEventsResponseBodyEventsEnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["End"]));
        end = make_shared<ListEventsResponseBodyEventsEnd>(model1);
      }
    }
    if (m.find("ExtendedProperties") != m.end() && !m["ExtendedProperties"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtendedProperties"].type()) {
        ListEventsResponseBodyEventsExtendedProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtendedProperties"]));
        extendedProperties = make_shared<ListEventsResponseBodyEventsExtendedProperties>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IsAllDay") != m.end() && !m["IsAllDay"].empty()) {
      isAllDay = make_shared<bool>(boost::any_cast<bool>(m["IsAllDay"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      if (typeid(map<string, boost::any>) == m["Location"].type()) {
        ListEventsResponseBodyEventsLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Location"]));
        location = make_shared<ListEventsResponseBodyEventsLocation>(model1);
      }
    }
    if (m.find("MeetingRooms") != m.end() && !m["MeetingRooms"].empty()) {
      if (typeid(vector<boost::any>) == m["MeetingRooms"].type()) {
        vector<ListEventsResponseBodyEventsMeetingRooms> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MeetingRooms"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEventsResponseBodyEventsMeetingRooms model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        meetingRooms = make_shared<vector<ListEventsResponseBodyEventsMeetingRooms>>(expect1);
      }
    }
    if (m.find("OnlineMeetingInfo") != m.end() && !m["OnlineMeetingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["OnlineMeetingInfo"].type()) {
        ListEventsResponseBodyEventsOnlineMeetingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OnlineMeetingInfo"]));
        onlineMeetingInfo = make_shared<ListEventsResponseBodyEventsOnlineMeetingInfo>(model1);
      }
    }
    if (m.find("Organizer") != m.end() && !m["Organizer"].empty()) {
      if (typeid(map<string, boost::any>) == m["Organizer"].type()) {
        ListEventsResponseBodyEventsOrganizer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Organizer"]));
        organizer = make_shared<ListEventsResponseBodyEventsOrganizer>(model1);
      }
    }
    if (m.find("OriginStart") != m.end() && !m["OriginStart"].empty()) {
      if (typeid(map<string, boost::any>) == m["OriginStart"].type()) {
        ListEventsResponseBodyEventsOriginStart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OriginStart"]));
        originStart = make_shared<ListEventsResponseBodyEventsOriginStart>(model1);
      }
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      if (typeid(map<string, boost::any>) == m["Recurrence"].type()) {
        ListEventsResponseBodyEventsRecurrence model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Recurrence"]));
        recurrence = make_shared<ListEventsResponseBodyEventsRecurrence>(model1);
      }
    }
    if (m.find("Reminders") != m.end() && !m["Reminders"].empty()) {
      if (typeid(vector<boost::any>) == m["Reminders"].type()) {
        vector<ListEventsResponseBodyEventsReminders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Reminders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEventsResponseBodyEventsReminders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reminders = make_shared<vector<ListEventsResponseBodyEventsReminders>>(expect1);
      }
    }
    if (m.find("RichTextDescription") != m.end() && !m["RichTextDescription"].empty()) {
      if (typeid(map<string, boost::any>) == m["RichTextDescription"].type()) {
        ListEventsResponseBodyEventsRichTextDescription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RichTextDescription"]));
        richTextDescription = make_shared<ListEventsResponseBodyEventsRichTextDescription>(model1);
      }
    }
    if (m.find("SeriesMasterId") != m.end() && !m["SeriesMasterId"].empty()) {
      seriesMasterId = make_shared<string>(boost::any_cast<string>(m["SeriesMasterId"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      if (typeid(map<string, boost::any>) == m["Start"].type()) {
        ListEventsResponseBodyEventsStart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Start"]));
        start = make_shared<ListEventsResponseBodyEventsStart>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~ListEventsResponseBodyEvents() = default;
};
class ListEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListEventsResponseBodyEvents>> events{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<string> syncToken{};

  ListEventsResponseBody() {}

  explicit ListEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (events) {
      vector<boost::any> temp1;
      for(auto item1:*events){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["events"] = boost::any(temp1);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (syncToken) {
      res["syncToken"] = boost::any(*syncToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("events") != m.end() && !m["events"].empty()) {
      if (typeid(vector<boost::any>) == m["events"].type()) {
        vector<ListEventsResponseBodyEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["events"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEventsResponseBodyEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        events = make_shared<vector<ListEventsResponseBodyEvents>>(expect1);
      }
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("syncToken") != m.end() && !m["syncToken"].empty()) {
      syncToken = make_shared<string>(boost::any_cast<string>(m["syncToken"]));
    }
  }


  virtual ~ListEventsResponseBody() = default;
};
class ListEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEventsResponseBody> body{};

  ListEventsResponse() {}

  explicit ListEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEventsResponseBody>(model1);
      }
    }
  }


  virtual ~ListEventsResponse() = default;
};
class ListNodesHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListNodesHeadersAccountContext() {}

  explicit ListNodesHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListNodesHeadersAccountContext() = default;
};
class ListNodesHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ListNodesHeadersAccountContext> accountContext{};

  ListNodesHeaders() {}

  explicit ListNodesHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ListNodesHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ListNodesHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ListNodesHeaders() = default;
};
class ListNodesShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ListNodesShrinkHeaders() {}

  explicit ListNodesShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ListNodesShrinkHeaders() = default;
};
class ListNodesRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  ListNodesRequestTenantContext() {}

  explicit ListNodesRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~ListNodesRequestTenantContext() = default;
};
class ListNodesRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> parentNodeId{};
  shared_ptr<ListNodesRequestTenantContext> tenantContext{};
  shared_ptr<bool> withPermissionRole{};

  ListNodesRequest() {}

  explicit ListNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (parentNodeId) {
      res["ParentNodeId"] = boost::any(*parentNodeId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (withPermissionRole) {
      res["WithPermissionRole"] = boost::any(*withPermissionRole);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ParentNodeId") != m.end() && !m["ParentNodeId"].empty()) {
      parentNodeId = make_shared<string>(boost::any_cast<string>(m["ParentNodeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        ListNodesRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<ListNodesRequestTenantContext>(model1);
      }
    }
    if (m.find("WithPermissionRole") != m.end() && !m["WithPermissionRole"].empty()) {
      withPermissionRole = make_shared<bool>(boost::any_cast<bool>(m["WithPermissionRole"]));
    }
  }


  virtual ~ListNodesRequest() = default;
};
class ListNodesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> parentNodeId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<bool> withPermissionRole{};

  ListNodesShrinkRequest() {}

  explicit ListNodesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (parentNodeId) {
      res["ParentNodeId"] = boost::any(*parentNodeId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (withPermissionRole) {
      res["WithPermissionRole"] = boost::any(*withPermissionRole);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ParentNodeId") != m.end() && !m["ParentNodeId"].empty()) {
      parentNodeId = make_shared<string>(boost::any_cast<string>(m["ParentNodeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WithPermissionRole") != m.end() && !m["WithPermissionRole"].empty()) {
      withPermissionRole = make_shared<bool>(boost::any_cast<bool>(m["WithPermissionRole"]));
    }
  }


  virtual ~ListNodesShrinkRequest() = default;
};
class ListNodesResponseBodyNodesStatisticalInfo : public Darabonba::Model {
public:
  shared_ptr<long> wordCount{};

  ListNodesResponseBodyNodesStatisticalInfo() {}

  explicit ListNodesResponseBodyNodesStatisticalInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (wordCount) {
      res["WordCount"] = boost::any(*wordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WordCount") != m.end() && !m["WordCount"].empty()) {
      wordCount = make_shared<long>(boost::any_cast<long>(m["WordCount"]));
    }
  }


  virtual ~ListNodesResponseBodyNodesStatisticalInfo() = default;
};
class ListNodesResponseBodyNodes : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> extension{};
  shared_ptr<bool> hasChildren{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> name{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> permissionRole{};
  shared_ptr<long> size{};
  shared_ptr<ListNodesResponseBodyNodesStatisticalInfo> statisticalInfo{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  ListNodesResponseBodyNodes() {}

  explicit ListNodesResponseBodyNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (hasChildren) {
      res["HasChildren"] = boost::any(*hasChildren);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (permissionRole) {
      res["PermissionRole"] = boost::any(*permissionRole);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (statisticalInfo) {
      res["StatisticalInfo"] = statisticalInfo ? boost::any(statisticalInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("HasChildren") != m.end() && !m["HasChildren"].empty()) {
      hasChildren = make_shared<bool>(boost::any_cast<bool>(m["HasChildren"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["ModifierId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("PermissionRole") != m.end() && !m["PermissionRole"].empty()) {
      permissionRole = make_shared<string>(boost::any_cast<string>(m["PermissionRole"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StatisticalInfo") != m.end() && !m["StatisticalInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatisticalInfo"].type()) {
        ListNodesResponseBodyNodesStatisticalInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatisticalInfo"]));
        statisticalInfo = make_shared<ListNodesResponseBodyNodesStatisticalInfo>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListNodesResponseBodyNodes() = default;
};
class ListNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListNodesResponseBodyNodes>> nodes{};
  shared_ptr<string> requestId{};

  ListNodesResponseBody() {}

  explicit ListNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["nodes"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("nodes") != m.end() && !m["nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["nodes"].type()) {
        vector<ListNodesResponseBodyNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<ListNodesResponseBodyNodes>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListNodesResponseBody() = default;
};
class ListNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNodesResponseBody> body{};

  ListNodesResponse() {}

  explicit ListNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNodesResponseBody>(model1);
      }
    }
  }


  virtual ~ListNodesResponse() = default;
};
class ListReportHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListReportHeadersAccountContext() {}

  explicit ListReportHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListReportHeadersAccountContext() = default;
};
class ListReportHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ListReportHeadersAccountContext> accountContext{};

  ListReportHeaders() {}

  explicit ListReportHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ListReportHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ListReportHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ListReportHeaders() = default;
};
class ListReportShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ListReportShrinkHeaders() {}

  explicit ListReportShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ListReportShrinkHeaders() = default;
};
class ListReportRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  ListReportRequestTenantContext() {}

  explicit ListReportRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~ListReportRequestTenantContext() = default;
};
class ListReportRequest : public Darabonba::Model {
public:
  shared_ptr<long> cursor{};
  shared_ptr<long> endTime{};
  shared_ptr<long> modifiedEndTime{};
  shared_ptr<long> modifiedStartTime{};
  shared_ptr<long> size{};
  shared_ptr<long> startTime{};
  shared_ptr<string> templateName{};
  shared_ptr<ListReportRequestTenantContext> tenantContext{};

  ListReportRequest() {}

  explicit ListReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cursor) {
      res["Cursor"] = boost::any(*cursor);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (modifiedEndTime) {
      res["ModifiedEndTime"] = boost::any(*modifiedEndTime);
    }
    if (modifiedStartTime) {
      res["ModifiedStartTime"] = boost::any(*modifiedStartTime);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cursor") != m.end() && !m["Cursor"].empty()) {
      cursor = make_shared<long>(boost::any_cast<long>(m["Cursor"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ModifiedEndTime") != m.end() && !m["ModifiedEndTime"].empty()) {
      modifiedEndTime = make_shared<long>(boost::any_cast<long>(m["ModifiedEndTime"]));
    }
    if (m.find("ModifiedStartTime") != m.end() && !m["ModifiedStartTime"].empty()) {
      modifiedStartTime = make_shared<long>(boost::any_cast<long>(m["ModifiedStartTime"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        ListReportRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<ListReportRequestTenantContext>(model1);
      }
    }
  }


  virtual ~ListReportRequest() = default;
};
class ListReportShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> cursor{};
  shared_ptr<long> endTime{};
  shared_ptr<long> modifiedEndTime{};
  shared_ptr<long> modifiedStartTime{};
  shared_ptr<long> size{};
  shared_ptr<long> startTime{};
  shared_ptr<string> templateName{};
  shared_ptr<string> tenantContextShrink{};

  ListReportShrinkRequest() {}

  explicit ListReportShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cursor) {
      res["Cursor"] = boost::any(*cursor);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (modifiedEndTime) {
      res["ModifiedEndTime"] = boost::any(*modifiedEndTime);
    }
    if (modifiedStartTime) {
      res["ModifiedStartTime"] = boost::any(*modifiedStartTime);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cursor") != m.end() && !m["Cursor"].empty()) {
      cursor = make_shared<long>(boost::any_cast<long>(m["Cursor"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ModifiedEndTime") != m.end() && !m["ModifiedEndTime"].empty()) {
      modifiedEndTime = make_shared<long>(boost::any_cast<long>(m["ModifiedEndTime"]));
    }
    if (m.find("ModifiedStartTime") != m.end() && !m["ModifiedStartTime"].empty()) {
      modifiedStartTime = make_shared<long>(boost::any_cast<long>(m["ModifiedStartTime"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~ListReportShrinkRequest() = default;
};
class ListReportResponseBodyDataListContents : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> sort{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ListReportResponseBodyDataListContents() {}

  explicit ListReportResponseBodyDataListContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListReportResponseBodyDataListContents() = default;
};
class ListReportResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<ListReportResponseBodyDataListContents>> contents{};
  shared_ptr<long> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> creatorName{};
  shared_ptr<string> deptName{};
  shared_ptr<vector<string>> images{};
  shared_ptr<string> latitude{};
  shared_ptr<string> longitude{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<string> remark{};
  shared_ptr<string> reportId{};
  shared_ptr<string> templateName{};

  ListReportResponseBodyDataList() {}

  explicit ListReportResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contents) {
      vector<boost::any> temp1;
      for(auto item1:*contents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contents"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (deptName) {
      res["DeptName"] = boost::any(*deptName);
    }
    if (images) {
      res["Images"] = boost::any(*images);
    }
    if (latitude) {
      res["Latitude"] = boost::any(*latitude);
    }
    if (longitude) {
      res["Longitude"] = boost::any(*longitude);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      if (typeid(vector<boost::any>) == m["Contents"].type()) {
        vector<ListReportResponseBodyDataListContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListReportResponseBodyDataListContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contents = make_shared<vector<ListReportResponseBodyDataListContents>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("DeptName") != m.end() && !m["DeptName"].empty()) {
      deptName = make_shared<string>(boost::any_cast<string>(m["DeptName"]));
    }
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Images"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Images"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      images = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Latitude") != m.end() && !m["Latitude"].empty()) {
      latitude = make_shared<string>(boost::any_cast<string>(m["Latitude"]));
    }
    if (m.find("Longitude") != m.end() && !m["Longitude"].empty()) {
      longitude = make_shared<string>(boost::any_cast<string>(m["Longitude"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~ListReportResponseBodyDataList() = default;
};
class ListReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListReportResponseBodyDataList>> dataList{};
  shared_ptr<bool> hasMore{};
  shared_ptr<long> nextCursor{};
  shared_ptr<string> requestId{};
  shared_ptr<long> size{};

  ListReportResponseBody() {}

  explicit ListReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataList) {
      vector<boost::any> temp1;
      for(auto item1:*dataList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dataList"] = boost::any(temp1);
    }
    if (hasMore) {
      res["hasMore"] = boost::any(*hasMore);
    }
    if (nextCursor) {
      res["nextCursor"] = boost::any(*nextCursor);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dataList") != m.end() && !m["dataList"].empty()) {
      if (typeid(vector<boost::any>) == m["dataList"].type()) {
        vector<ListReportResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dataList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListReportResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataList = make_shared<vector<ListReportResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("hasMore") != m.end() && !m["hasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["hasMore"]));
    }
    if (m.find("nextCursor") != m.end() && !m["nextCursor"].empty()) {
      nextCursor = make_shared<long>(boost::any_cast<long>(m["nextCursor"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
  }


  virtual ~ListReportResponseBody() = default;
};
class ListReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListReportResponseBody> body{};

  ListReportResponse() {}

  explicit ListReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListReportResponseBody>(model1);
      }
    }
  }


  virtual ~ListReportResponse() = default;
};
class ListWorkspacesHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListWorkspacesHeadersAccountContext() {}

  explicit ListWorkspacesHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ListWorkspacesHeadersAccountContext() = default;
};
class ListWorkspacesHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ListWorkspacesHeadersAccountContext> accountContext{};

  ListWorkspacesHeaders() {}

  explicit ListWorkspacesHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ListWorkspacesHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ListWorkspacesHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ListWorkspacesHeaders() = default;
};
class ListWorkspacesShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ListWorkspacesShrinkHeaders() {}

  explicit ListWorkspacesShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ListWorkspacesShrinkHeaders() = default;
};
class ListWorkspacesRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  ListWorkspacesRequestTenantContext() {}

  explicit ListWorkspacesRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~ListWorkspacesRequestTenantContext() = default;
};
class ListWorkspacesRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> teamId{};
  shared_ptr<ListWorkspacesRequestTenantContext> tenantContext{};
  shared_ptr<bool> withPermissionRole{};

  ListWorkspacesRequest() {}

  explicit ListWorkspacesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (teamId) {
      res["TeamId"] = boost::any(*teamId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (withPermissionRole) {
      res["WithPermissionRole"] = boost::any(*withPermissionRole);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("TeamId") != m.end() && !m["TeamId"].empty()) {
      teamId = make_shared<string>(boost::any_cast<string>(m["TeamId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        ListWorkspacesRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<ListWorkspacesRequestTenantContext>(model1);
      }
    }
    if (m.find("WithPermissionRole") != m.end() && !m["WithPermissionRole"].empty()) {
      withPermissionRole = make_shared<bool>(boost::any_cast<bool>(m["WithPermissionRole"]));
    }
  }


  virtual ~ListWorkspacesRequest() = default;
};
class ListWorkspacesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> teamId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<bool> withPermissionRole{};

  ListWorkspacesShrinkRequest() {}

  explicit ListWorkspacesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (teamId) {
      res["TeamId"] = boost::any(*teamId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (withPermissionRole) {
      res["WithPermissionRole"] = boost::any(*withPermissionRole);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("TeamId") != m.end() && !m["TeamId"].empty()) {
      teamId = make_shared<string>(boost::any_cast<string>(m["TeamId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WithPermissionRole") != m.end() && !m["WithPermissionRole"].empty()) {
      withPermissionRole = make_shared<bool>(boost::any_cast<bool>(m["WithPermissionRole"]));
    }
  }


  virtual ~ListWorkspacesShrinkRequest() = default;
};
class ListWorkspacesResponseBodyWorkspacesIcon : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ListWorkspacesResponseBodyWorkspacesIcon() {}

  explicit ListWorkspacesResponseBodyWorkspacesIcon(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListWorkspacesResponseBodyWorkspacesIcon() = default;
};
class ListWorkspacesResponseBodyWorkspaces : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<string> cover{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> description{};
  shared_ptr<ListWorkspacesResponseBodyWorkspacesIcon> icon{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> modifierId{};
  shared_ptr<string> name{};
  shared_ptr<string> permissionRole{};
  shared_ptr<string> rootNodeId{};
  shared_ptr<string> teamId{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  ListWorkspacesResponseBodyWorkspaces() {}

  explicit ListWorkspacesResponseBodyWorkspaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (cover) {
      res["Cover"] = boost::any(*cover);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (icon) {
      res["Icon"] = icon ? boost::any(icon->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (modifierId) {
      res["ModifierId"] = boost::any(*modifierId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (permissionRole) {
      res["PermissionRole"] = boost::any(*permissionRole);
    }
    if (rootNodeId) {
      res["RootNodeId"] = boost::any(*rootNodeId);
    }
    if (teamId) {
      res["TeamId"] = boost::any(*teamId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      cover = make_shared<string>(boost::any_cast<string>(m["Cover"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      if (typeid(map<string, boost::any>) == m["Icon"].type()) {
        ListWorkspacesResponseBodyWorkspacesIcon model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Icon"]));
        icon = make_shared<ListWorkspacesResponseBodyWorkspacesIcon>(model1);
      }
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ModifierId") != m.end() && !m["ModifierId"].empty()) {
      modifierId = make_shared<string>(boost::any_cast<string>(m["ModifierId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PermissionRole") != m.end() && !m["PermissionRole"].empty()) {
      permissionRole = make_shared<string>(boost::any_cast<string>(m["PermissionRole"]));
    }
    if (m.find("RootNodeId") != m.end() && !m["RootNodeId"].empty()) {
      rootNodeId = make_shared<string>(boost::any_cast<string>(m["RootNodeId"]));
    }
    if (m.find("TeamId") != m.end() && !m["TeamId"].empty()) {
      teamId = make_shared<string>(boost::any_cast<string>(m["TeamId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListWorkspacesResponseBodyWorkspaces() = default;
};
class ListWorkspacesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListWorkspacesResponseBodyWorkspaces>> workspaces{};

  ListWorkspacesResponseBody() {}

  explicit ListWorkspacesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (workspaces) {
      vector<boost::any> temp1;
      for(auto item1:*workspaces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["workspaces"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("workspaces") != m.end() && !m["workspaces"].empty()) {
      if (typeid(vector<boost::any>) == m["workspaces"].type()) {
        vector<ListWorkspacesResponseBodyWorkspaces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["workspaces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWorkspacesResponseBodyWorkspaces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workspaces = make_shared<vector<ListWorkspacesResponseBodyWorkspaces>>(expect1);
      }
    }
  }


  virtual ~ListWorkspacesResponseBody() = default;
};
class ListWorkspacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWorkspacesResponseBody> body{};

  ListWorkspacesResponse() {}

  explicit ListWorkspacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWorkspacesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWorkspacesResponseBody>(model1);
      }
    }
  }


  virtual ~ListWorkspacesResponse() = default;
};
class PatchEventHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  PatchEventHeadersAccountContext() {}

  explicit PatchEventHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~PatchEventHeadersAccountContext() = default;
};
class PatchEventHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<PatchEventHeadersAccountContext> accountContext{};

  PatchEventHeaders() {}

  explicit PatchEventHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        PatchEventHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<PatchEventHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~PatchEventHeaders() = default;
};
class PatchEventShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  PatchEventShrinkHeaders() {}

  explicit PatchEventShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~PatchEventShrinkHeaders() = default;
};
class PatchEventRequestAttendees : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<bool> isOptional{};

  PatchEventRequestAttendees() {}

  explicit PatchEventRequestAttendees(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isOptional) {
      res["isOptional"] = boost::any(*isOptional);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("isOptional") != m.end() && !m["isOptional"].empty()) {
      isOptional = make_shared<bool>(boost::any_cast<bool>(m["isOptional"]));
    }
  }


  virtual ~PatchEventRequestAttendees() = default;
};
class PatchEventRequestEnd : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  PatchEventRequestEnd() {}

  explicit PatchEventRequestEnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["date"] = boost::any(*date);
    }
    if (dateTime) {
      res["dateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["timeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("date") != m.end() && !m["date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["date"]));
    }
    if (m.find("dateTime") != m.end() && !m["dateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["dateTime"]));
    }
    if (m.find("timeZone") != m.end() && !m["timeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["timeZone"]));
    }
  }


  virtual ~PatchEventRequestEnd() = default;
};
class PatchEventRequestLocation : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};

  PatchEventRequestLocation() {}

  explicit PatchEventRequestLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["displayName"] = boost::any(*displayName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("displayName") != m.end() && !m["displayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["displayName"]));
    }
  }


  virtual ~PatchEventRequestLocation() = default;
};
class PatchEventRequestRecurrencePattern : public Darabonba::Model {
public:
  shared_ptr<long> dayOfMonth{};
  shared_ptr<string> daysOfWeek{};
  shared_ptr<string> index{};
  shared_ptr<long> interval{};
  shared_ptr<string> type{};

  PatchEventRequestRecurrencePattern() {}

  explicit PatchEventRequestRecurrencePattern(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dayOfMonth) {
      res["dayOfMonth"] = boost::any(*dayOfMonth);
    }
    if (daysOfWeek) {
      res["daysOfWeek"] = boost::any(*daysOfWeek);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (interval) {
      res["interval"] = boost::any(*interval);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dayOfMonth") != m.end() && !m["dayOfMonth"].empty()) {
      dayOfMonth = make_shared<long>(boost::any_cast<long>(m["dayOfMonth"]));
    }
    if (m.find("daysOfWeek") != m.end() && !m["daysOfWeek"].empty()) {
      daysOfWeek = make_shared<string>(boost::any_cast<string>(m["daysOfWeek"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("interval") != m.end() && !m["interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["interval"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~PatchEventRequestRecurrencePattern() = default;
};
class PatchEventRequestRecurrenceRange : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<long> numberOfOccurrences{};
  shared_ptr<string> type{};

  PatchEventRequestRecurrenceRange() {}

  explicit PatchEventRequestRecurrenceRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["endDate"] = boost::any(*endDate);
    }
    if (numberOfOccurrences) {
      res["numberOfOccurrences"] = boost::any(*numberOfOccurrences);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endDate") != m.end() && !m["endDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["endDate"]));
    }
    if (m.find("numberOfOccurrences") != m.end() && !m["numberOfOccurrences"].empty()) {
      numberOfOccurrences = make_shared<long>(boost::any_cast<long>(m["numberOfOccurrences"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~PatchEventRequestRecurrenceRange() = default;
};
class PatchEventRequestRecurrence : public Darabonba::Model {
public:
  shared_ptr<PatchEventRequestRecurrencePattern> pattern{};
  shared_ptr<PatchEventRequestRecurrenceRange> range{};

  PatchEventRequestRecurrence() {}

  explicit PatchEventRequestRecurrence(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pattern) {
      res["pattern"] = pattern ? boost::any(pattern->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (range) {
      res["range"] = range ? boost::any(range->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("pattern") != m.end() && !m["pattern"].empty()) {
      if (typeid(map<string, boost::any>) == m["pattern"].type()) {
        PatchEventRequestRecurrencePattern model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["pattern"]));
        pattern = make_shared<PatchEventRequestRecurrencePattern>(model1);
      }
    }
    if (m.find("range") != m.end() && !m["range"].empty()) {
      if (typeid(map<string, boost::any>) == m["range"].type()) {
        PatchEventRequestRecurrenceRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["range"]));
        range = make_shared<PatchEventRequestRecurrenceRange>(model1);
      }
    }
  }


  virtual ~PatchEventRequestRecurrence() = default;
};
class PatchEventRequestReminders : public Darabonba::Model {
public:
  shared_ptr<string> method{};
  shared_ptr<long> minutes{};

  PatchEventRequestReminders() {}

  explicit PatchEventRequestReminders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["method"] = boost::any(*method);
    }
    if (minutes) {
      res["minutes"] = boost::any(*minutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("method") != m.end() && !m["method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["method"]));
    }
    if (m.find("minutes") != m.end() && !m["minutes"].empty()) {
      minutes = make_shared<long>(boost::any_cast<long>(m["minutes"]));
    }
  }


  virtual ~PatchEventRequestReminders() = default;
};
class PatchEventRequestStart : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  PatchEventRequestStart() {}

  explicit PatchEventRequestStart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["date"] = boost::any(*date);
    }
    if (dateTime) {
      res["dateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["timeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("date") != m.end() && !m["date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["date"]));
    }
    if (m.find("dateTime") != m.end() && !m["dateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["dateTime"]));
    }
    if (m.find("timeZone") != m.end() && !m["timeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["timeZone"]));
    }
  }


  virtual ~PatchEventRequestStart() = default;
};
class PatchEventRequest : public Darabonba::Model {
public:
  shared_ptr<vector<PatchEventRequestAttendees>> attendees{};
  shared_ptr<string> calendarId{};
  shared_ptr<string> description{};
  shared_ptr<PatchEventRequestEnd> end{};
  shared_ptr<string> eventId{};
  shared_ptr<map<string, string>> extra{};
  shared_ptr<bool> isAllDay{};
  shared_ptr<PatchEventRequestLocation> location{};
  shared_ptr<PatchEventRequestRecurrence> recurrence{};
  shared_ptr<vector<PatchEventRequestReminders>> reminders{};
  shared_ptr<PatchEventRequestStart> start{};
  shared_ptr<string> summary{};

  PatchEventRequest() {}

  explicit PatchEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendees) {
      vector<boost::any> temp1;
      for(auto item1:*attendees){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attendees"] = boost::any(temp1);
    }
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (end) {
      res["End"] = end ? boost::any(end->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (isAllDay) {
      res["IsAllDay"] = boost::any(*isAllDay);
    }
    if (location) {
      res["Location"] = location ? boost::any(location->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recurrence) {
      res["Recurrence"] = recurrence ? boost::any(recurrence->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reminders) {
      vector<boost::any> temp1;
      for(auto item1:*reminders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Reminders"] = boost::any(temp1);
    }
    if (start) {
      res["Start"] = start ? boost::any(start->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attendees") != m.end() && !m["Attendees"].empty()) {
      if (typeid(vector<boost::any>) == m["Attendees"].type()) {
        vector<PatchEventRequestAttendees> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attendees"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PatchEventRequestAttendees model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attendees = make_shared<vector<PatchEventRequestAttendees>>(expect1);
      }
    }
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      if (typeid(map<string, boost::any>) == m["End"].type()) {
        PatchEventRequestEnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["End"]));
        end = make_shared<PatchEventRequestEnd>(model1);
      }
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Extra"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extra = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("IsAllDay") != m.end() && !m["IsAllDay"].empty()) {
      isAllDay = make_shared<bool>(boost::any_cast<bool>(m["IsAllDay"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      if (typeid(map<string, boost::any>) == m["Location"].type()) {
        PatchEventRequestLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Location"]));
        location = make_shared<PatchEventRequestLocation>(model1);
      }
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      if (typeid(map<string, boost::any>) == m["Recurrence"].type()) {
        PatchEventRequestRecurrence model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Recurrence"]));
        recurrence = make_shared<PatchEventRequestRecurrence>(model1);
      }
    }
    if (m.find("Reminders") != m.end() && !m["Reminders"].empty()) {
      if (typeid(vector<boost::any>) == m["Reminders"].type()) {
        vector<PatchEventRequestReminders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Reminders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PatchEventRequestReminders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reminders = make_shared<vector<PatchEventRequestReminders>>(expect1);
      }
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      if (typeid(map<string, boost::any>) == m["Start"].type()) {
        PatchEventRequestStart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Start"]));
        start = make_shared<PatchEventRequestStart>(model1);
      }
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~PatchEventRequest() = default;
};
class PatchEventShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> attendeesShrink{};
  shared_ptr<string> calendarId{};
  shared_ptr<string> description{};
  shared_ptr<string> endShrink{};
  shared_ptr<string> eventId{};
  shared_ptr<string> extraShrink{};
  shared_ptr<bool> isAllDay{};
  shared_ptr<string> locationShrink{};
  shared_ptr<string> recurrenceShrink{};
  shared_ptr<string> remindersShrink{};
  shared_ptr<string> startShrink{};
  shared_ptr<string> summary{};

  PatchEventShrinkRequest() {}

  explicit PatchEventShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendeesShrink) {
      res["Attendees"] = boost::any(*attendeesShrink);
    }
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endShrink) {
      res["End"] = boost::any(*endShrink);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (extraShrink) {
      res["Extra"] = boost::any(*extraShrink);
    }
    if (isAllDay) {
      res["IsAllDay"] = boost::any(*isAllDay);
    }
    if (locationShrink) {
      res["Location"] = boost::any(*locationShrink);
    }
    if (recurrenceShrink) {
      res["Recurrence"] = boost::any(*recurrenceShrink);
    }
    if (remindersShrink) {
      res["Reminders"] = boost::any(*remindersShrink);
    }
    if (startShrink) {
      res["Start"] = boost::any(*startShrink);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attendees") != m.end() && !m["Attendees"].empty()) {
      attendeesShrink = make_shared<string>(boost::any_cast<string>(m["Attendees"]));
    }
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      endShrink = make_shared<string>(boost::any_cast<string>(m["End"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extraShrink = make_shared<string>(boost::any_cast<string>(m["Extra"]));
    }
    if (m.find("IsAllDay") != m.end() && !m["IsAllDay"].empty()) {
      isAllDay = make_shared<bool>(boost::any_cast<bool>(m["IsAllDay"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      locationShrink = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Recurrence") != m.end() && !m["Recurrence"].empty()) {
      recurrenceShrink = make_shared<string>(boost::any_cast<string>(m["Recurrence"]));
    }
    if (m.find("Reminders") != m.end() && !m["Reminders"].empty()) {
      remindersShrink = make_shared<string>(boost::any_cast<string>(m["Reminders"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      startShrink = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~PatchEventShrinkRequest() = default;
};
class PatchEventResponseBodyAttendees : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> id{};
  shared_ptr<bool> isOptional{};
  shared_ptr<string> responseStatus{};
  shared_ptr<bool> self{};

  PatchEventResponseBodyAttendees() {}

  explicit PatchEventResponseBodyAttendees(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isOptional) {
      res["IsOptional"] = boost::any(*isOptional);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (self) {
      res["Self"] = boost::any(*self);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IsOptional") != m.end() && !m["IsOptional"].empty()) {
      isOptional = make_shared<bool>(boost::any_cast<bool>(m["IsOptional"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("Self") != m.end() && !m["Self"].empty()) {
      self = make_shared<bool>(boost::any_cast<bool>(m["Self"]));
    }
  }


  virtual ~PatchEventResponseBodyAttendees() = default;
};
class PatchEventResponseBodyEnd : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  PatchEventResponseBodyEnd() {}

  explicit PatchEventResponseBodyEnd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~PatchEventResponseBodyEnd() = default;
};
class PatchEventResponseBodyLocation : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<vector<string>> meetingRooms{};

  PatchEventResponseBodyLocation() {}

  explicit PatchEventResponseBodyLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (meetingRooms) {
      res["MeetingRooms"] = boost::any(*meetingRooms);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("MeetingRooms") != m.end() && !m["MeetingRooms"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MeetingRooms"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MeetingRooms"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      meetingRooms = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~PatchEventResponseBodyLocation() = default;
};
class PatchEventResponseBodyOrganizer : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> id{};
  shared_ptr<string> responseStatus{};
  shared_ptr<bool> self{};

  PatchEventResponseBodyOrganizer() {}

  explicit PatchEventResponseBodyOrganizer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (responseStatus) {
      res["ResponseStatus"] = boost::any(*responseStatus);
    }
    if (self) {
      res["Self"] = boost::any(*self);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ResponseStatus") != m.end() && !m["ResponseStatus"].empty()) {
      responseStatus = make_shared<string>(boost::any_cast<string>(m["ResponseStatus"]));
    }
    if (m.find("Self") != m.end() && !m["Self"].empty()) {
      self = make_shared<bool>(boost::any_cast<bool>(m["Self"]));
    }
  }


  virtual ~PatchEventResponseBodyOrganizer() = default;
};
class PatchEventResponseBodyRecurrencePattern : public Darabonba::Model {
public:
  shared_ptr<long> dayOfMonth{};
  shared_ptr<string> daysOfWeek{};
  shared_ptr<string> index{};
  shared_ptr<long> interval{};
  shared_ptr<string> type{};

  PatchEventResponseBodyRecurrencePattern() {}

  explicit PatchEventResponseBodyRecurrencePattern(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dayOfMonth) {
      res["DayOfMonth"] = boost::any(*dayOfMonth);
    }
    if (daysOfWeek) {
      res["DaysOfWeek"] = boost::any(*daysOfWeek);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DayOfMonth") != m.end() && !m["DayOfMonth"].empty()) {
      dayOfMonth = make_shared<long>(boost::any_cast<long>(m["DayOfMonth"]));
    }
    if (m.find("DaysOfWeek") != m.end() && !m["DaysOfWeek"].empty()) {
      daysOfWeek = make_shared<string>(boost::any_cast<string>(m["DaysOfWeek"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~PatchEventResponseBodyRecurrencePattern() = default;
};
class PatchEventResponseBodyRecurrenceRange : public Darabonba::Model {
public:
  shared_ptr<string> endDate{};
  shared_ptr<long> numberOfOccurrences{};
  shared_ptr<string> type{};

  PatchEventResponseBodyRecurrenceRange() {}

  explicit PatchEventResponseBodyRecurrenceRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (numberOfOccurrences) {
      res["NumberOfOccurrences"] = boost::any(*numberOfOccurrences);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("NumberOfOccurrences") != m.end() && !m["NumberOfOccurrences"].empty()) {
      numberOfOccurrences = make_shared<long>(boost::any_cast<long>(m["NumberOfOccurrences"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~PatchEventResponseBodyRecurrenceRange() = default;
};
class PatchEventResponseBodyRecurrence : public Darabonba::Model {
public:
  shared_ptr<PatchEventResponseBodyRecurrencePattern> pattern{};
  shared_ptr<PatchEventResponseBodyRecurrenceRange> range{};

  PatchEventResponseBodyRecurrence() {}

  explicit PatchEventResponseBodyRecurrence(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pattern) {
      res["Pattern"] = pattern ? boost::any(pattern->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (range) {
      res["Range"] = range ? boost::any(range->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pattern"].type()) {
        PatchEventResponseBodyRecurrencePattern model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pattern"]));
        pattern = make_shared<PatchEventResponseBodyRecurrencePattern>(model1);
      }
    }
    if (m.find("Range") != m.end() && !m["Range"].empty()) {
      if (typeid(map<string, boost::any>) == m["Range"].type()) {
        PatchEventResponseBodyRecurrenceRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Range"]));
        range = make_shared<PatchEventResponseBodyRecurrenceRange>(model1);
      }
    }
  }


  virtual ~PatchEventResponseBodyRecurrence() = default;
};
class PatchEventResponseBodyReminders : public Darabonba::Model {
public:
  shared_ptr<string> method{};
  shared_ptr<string> minutes{};

  PatchEventResponseBodyReminders() {}

  explicit PatchEventResponseBodyReminders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (minutes) {
      res["Minutes"] = boost::any(*minutes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Minutes") != m.end() && !m["Minutes"].empty()) {
      minutes = make_shared<string>(boost::any_cast<string>(m["Minutes"]));
    }
  }


  virtual ~PatchEventResponseBodyReminders() = default;
};
class PatchEventResponseBodyStart : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> dateTime{};
  shared_ptr<string> timeZone{};

  PatchEventResponseBodyStart() {}

  explicit PatchEventResponseBodyStart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (dateTime) {
      res["DateTime"] = boost::any(*dateTime);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("DateTime") != m.end() && !m["DateTime"].empty()) {
      dateTime = make_shared<string>(boost::any_cast<string>(m["DateTime"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~PatchEventResponseBodyStart() = default;
};
class PatchEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<PatchEventResponseBodyAttendees>> attendees{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<PatchEventResponseBodyEnd> end{};
  shared_ptr<string> id{};
  shared_ptr<bool> isAllDay{};
  shared_ptr<PatchEventResponseBodyLocation> location{};
  shared_ptr<PatchEventResponseBodyOrganizer> organizer{};
  shared_ptr<PatchEventResponseBodyRecurrence> recurrence{};
  shared_ptr<vector<PatchEventResponseBodyReminders>> reminders{};
  shared_ptr<string> requestId{};
  shared_ptr<PatchEventResponseBodyStart> start{};
  shared_ptr<string> summary{};
  shared_ptr<string> updateTime{};

  PatchEventResponseBody() {}

  explicit PatchEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendees) {
      vector<boost::any> temp1;
      for(auto item1:*attendees){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["attendees"] = boost::any(temp1);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (end) {
      res["end"] = end ? boost::any(end->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isAllDay) {
      res["isAllDay"] = boost::any(*isAllDay);
    }
    if (location) {
      res["location"] = location ? boost::any(location->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (organizer) {
      res["organizer"] = organizer ? boost::any(organizer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recurrence) {
      res["recurrence"] = recurrence ? boost::any(recurrence->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reminders) {
      vector<boost::any> temp1;
      for(auto item1:*reminders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["reminders"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (start) {
      res["start"] = start ? boost::any(start->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (summary) {
      res["summary"] = boost::any(*summary);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("attendees") != m.end() && !m["attendees"].empty()) {
      if (typeid(vector<boost::any>) == m["attendees"].type()) {
        vector<PatchEventResponseBodyAttendees> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["attendees"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PatchEventResponseBodyAttendees model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attendees = make_shared<vector<PatchEventResponseBodyAttendees>>(expect1);
      }
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("end") != m.end() && !m["end"].empty()) {
      if (typeid(map<string, boost::any>) == m["end"].type()) {
        PatchEventResponseBodyEnd model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["end"]));
        end = make_shared<PatchEventResponseBodyEnd>(model1);
      }
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("isAllDay") != m.end() && !m["isAllDay"].empty()) {
      isAllDay = make_shared<bool>(boost::any_cast<bool>(m["isAllDay"]));
    }
    if (m.find("location") != m.end() && !m["location"].empty()) {
      if (typeid(map<string, boost::any>) == m["location"].type()) {
        PatchEventResponseBodyLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["location"]));
        location = make_shared<PatchEventResponseBodyLocation>(model1);
      }
    }
    if (m.find("organizer") != m.end() && !m["organizer"].empty()) {
      if (typeid(map<string, boost::any>) == m["organizer"].type()) {
        PatchEventResponseBodyOrganizer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["organizer"]));
        organizer = make_shared<PatchEventResponseBodyOrganizer>(model1);
      }
    }
    if (m.find("recurrence") != m.end() && !m["recurrence"].empty()) {
      if (typeid(map<string, boost::any>) == m["recurrence"].type()) {
        PatchEventResponseBodyRecurrence model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["recurrence"]));
        recurrence = make_shared<PatchEventResponseBodyRecurrence>(model1);
      }
    }
    if (m.find("reminders") != m.end() && !m["reminders"].empty()) {
      if (typeid(vector<boost::any>) == m["reminders"].type()) {
        vector<PatchEventResponseBodyReminders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["reminders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PatchEventResponseBodyReminders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reminders = make_shared<vector<PatchEventResponseBodyReminders>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("start") != m.end() && !m["start"].empty()) {
      if (typeid(map<string, boost::any>) == m["start"].type()) {
        PatchEventResponseBodyStart model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["start"]));
        start = make_shared<PatchEventResponseBodyStart>(model1);
      }
    }
    if (m.find("summary") != m.end() && !m["summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["summary"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["updateTime"]));
    }
  }


  virtual ~PatchEventResponseBody() = default;
};
class PatchEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PatchEventResponseBody> body{};

  PatchEventResponse() {}

  explicit PatchEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PatchEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PatchEventResponseBody>(model1);
      }
    }
  }


  virtual ~PatchEventResponse() = default;
};
class QueryCloudRecordTextHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryCloudRecordTextHeadersAccountContext() {}

  explicit QueryCloudRecordTextHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryCloudRecordTextHeadersAccountContext() = default;
};
class QueryCloudRecordTextHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryCloudRecordTextHeadersAccountContext> accountContext{};

  QueryCloudRecordTextHeaders() {}

  explicit QueryCloudRecordTextHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryCloudRecordTextHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryCloudRecordTextHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryCloudRecordTextHeaders() = default;
};
class QueryCloudRecordTextShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryCloudRecordTextShrinkHeaders() {}

  explicit QueryCloudRecordTextShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryCloudRecordTextShrinkHeaders() = default;
};
class QueryCloudRecordTextRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryCloudRecordTextRequestTenantContext() {}

  explicit QueryCloudRecordTextRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryCloudRecordTextRequestTenantContext() = default;
};
class QueryCloudRecordTextRequest : public Darabonba::Model {
public:
  shared_ptr<string> direction{};
  shared_ptr<long> maxResults{};
  shared_ptr<long> nextToken{};
  shared_ptr<long> startTime{};
  shared_ptr<QueryCloudRecordTextRequestTenantContext> tenantContext{};
  shared_ptr<string> conferenceId{};

  QueryCloudRecordTextRequest() {}

  explicit QueryCloudRecordTextRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryCloudRecordTextRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryCloudRecordTextRequestTenantContext>(model1);
      }
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~QueryCloudRecordTextRequest() = default;
};
class QueryCloudRecordTextShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> direction{};
  shared_ptr<long> maxResults{};
  shared_ptr<long> nextToken{};
  shared_ptr<long> startTime{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> conferenceId{};

  QueryCloudRecordTextShrinkRequest() {}

  explicit QueryCloudRecordTextShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~QueryCloudRecordTextShrinkRequest() = default;
};
class QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<string> word{};
  shared_ptr<string> wordId{};

  QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList() {}

  explicit QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (word) {
      res["Word"] = boost::any(*word);
    }
    if (wordId) {
      res["WordId"] = boost::any(*wordId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Word") != m.end() && !m["Word"].empty()) {
      word = make_shared<string>(boost::any_cast<string>(m["Word"]));
    }
    if (m.find("WordId") != m.end() && !m["WordId"].empty()) {
      wordId = make_shared<string>(boost::any_cast<string>(m["WordId"]));
    }
  }


  virtual ~QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList() = default;
};
class QueryCloudRecordTextResponseBodyParagraphListSentenceList : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> sentence{};
  shared_ptr<long> startTime{};
  shared_ptr<string> userId{};
  shared_ptr<vector<QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList>> wordList{};

  QueryCloudRecordTextResponseBodyParagraphListSentenceList() {}

  explicit QueryCloudRecordTextResponseBodyParagraphListSentenceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (sentence) {
      res["Sentence"] = boost::any(*sentence);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (wordList) {
      vector<boost::any> temp1;
      for(auto item1:*wordList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WordList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Sentence") != m.end() && !m["Sentence"].empty()) {
      sentence = make_shared<string>(boost::any_cast<string>(m["Sentence"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WordList") != m.end() && !m["WordList"].empty()) {
      if (typeid(vector<boost::any>) == m["WordList"].type()) {
        vector<QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WordList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wordList = make_shared<vector<QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList>>(expect1);
      }
    }
  }


  virtual ~QueryCloudRecordTextResponseBodyParagraphListSentenceList() = default;
};
class QueryCloudRecordTextResponseBodyParagraphList : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> nextTtoken{};
  shared_ptr<string> nickName{};
  shared_ptr<string> paragraph{};
  shared_ptr<long> recordId{};
  shared_ptr<vector<QueryCloudRecordTextResponseBodyParagraphListSentenceList>> sentenceList{};
  shared_ptr<long> startTime{};
  shared_ptr<long> status{};
  shared_ptr<string> userId{};

  QueryCloudRecordTextResponseBodyParagraphList() {}

  explicit QueryCloudRecordTextResponseBodyParagraphList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (nextTtoken) {
      res["NextTtoken"] = boost::any(*nextTtoken);
    }
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (paragraph) {
      res["Paragraph"] = boost::any(*paragraph);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (sentenceList) {
      vector<boost::any> temp1;
      for(auto item1:*sentenceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SentenceList"] = boost::any(temp1);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("NextTtoken") != m.end() && !m["NextTtoken"].empty()) {
      nextTtoken = make_shared<long>(boost::any_cast<long>(m["NextTtoken"]));
    }
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("Paragraph") != m.end() && !m["Paragraph"].empty()) {
      paragraph = make_shared<string>(boost::any_cast<string>(m["Paragraph"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<long>(boost::any_cast<long>(m["RecordId"]));
    }
    if (m.find("SentenceList") != m.end() && !m["SentenceList"].empty()) {
      if (typeid(vector<boost::any>) == m["SentenceList"].type()) {
        vector<QueryCloudRecordTextResponseBodyParagraphListSentenceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SentenceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCloudRecordTextResponseBodyParagraphListSentenceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sentenceList = make_shared<vector<QueryCloudRecordTextResponseBodyParagraphListSentenceList>>(expect1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryCloudRecordTextResponseBodyParagraphList() = default;
};
class QueryCloudRecordTextResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> hasMore{};
  shared_ptr<vector<QueryCloudRecordTextResponseBodyParagraphList>> paragraphList{};
  shared_ptr<string> requestId{};

  QueryCloudRecordTextResponseBody() {}

  explicit QueryCloudRecordTextResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasMore) {
      res["hasMore"] = boost::any(*hasMore);
    }
    if (paragraphList) {
      vector<boost::any> temp1;
      for(auto item1:*paragraphList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["paragraphList"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hasMore") != m.end() && !m["hasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["hasMore"]));
    }
    if (m.find("paragraphList") != m.end() && !m["paragraphList"].empty()) {
      if (typeid(vector<boost::any>) == m["paragraphList"].type()) {
        vector<QueryCloudRecordTextResponseBodyParagraphList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["paragraphList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCloudRecordTextResponseBodyParagraphList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        paragraphList = make_shared<vector<QueryCloudRecordTextResponseBodyParagraphList>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~QueryCloudRecordTextResponseBody() = default;
};
class QueryCloudRecordTextResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryCloudRecordTextResponseBody> body{};

  QueryCloudRecordTextResponse() {}

  explicit QueryCloudRecordTextResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCloudRecordTextResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCloudRecordTextResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCloudRecordTextResponse() = default;
};
class QueryCloudRecordVideoHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryCloudRecordVideoHeadersAccountContext() {}

  explicit QueryCloudRecordVideoHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryCloudRecordVideoHeadersAccountContext() = default;
};
class QueryCloudRecordVideoHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryCloudRecordVideoHeadersAccountContext> accountContext{};

  QueryCloudRecordVideoHeaders() {}

  explicit QueryCloudRecordVideoHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryCloudRecordVideoHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryCloudRecordVideoHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryCloudRecordVideoHeaders() = default;
};
class QueryCloudRecordVideoShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryCloudRecordVideoShrinkHeaders() {}

  explicit QueryCloudRecordVideoShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryCloudRecordVideoShrinkHeaders() = default;
};
class QueryCloudRecordVideoRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryCloudRecordVideoRequestTenantContext() {}

  explicit QueryCloudRecordVideoRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryCloudRecordVideoRequestTenantContext() = default;
};
class QueryCloudRecordVideoRequest : public Darabonba::Model {
public:
  shared_ptr<QueryCloudRecordVideoRequestTenantContext> tenantContext{};
  shared_ptr<string> conferenceId{};

  QueryCloudRecordVideoRequest() {}

  explicit QueryCloudRecordVideoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryCloudRecordVideoRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryCloudRecordVideoRequestTenantContext>(model1);
      }
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~QueryCloudRecordVideoRequest() = default;
};
class QueryCloudRecordVideoShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> conferenceId{};

  QueryCloudRecordVideoShrinkRequest() {}

  explicit QueryCloudRecordVideoShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~QueryCloudRecordVideoShrinkRequest() = default;
};
class QueryCloudRecordVideoResponseBodyVideoList : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<long> endTime{};
  shared_ptr<long> fileSize{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> recordId{};
  shared_ptr<long> recordType{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> userId{};

  QueryCloudRecordVideoResponseBodyVideoList() {}

  explicit QueryCloudRecordVideoResponseBodyVideoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (recordType) {
      res["RecordType"] = boost::any(*recordType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["FileSize"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("RecordType") != m.end() && !m["RecordType"].empty()) {
      recordType = make_shared<long>(boost::any_cast<long>(m["RecordType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryCloudRecordVideoResponseBodyVideoList() = default;
};
class QueryCloudRecordVideoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<QueryCloudRecordVideoResponseBodyVideoList>> videoList{};

  QueryCloudRecordVideoResponseBody() {}

  explicit QueryCloudRecordVideoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (videoList) {
      vector<boost::any> temp1;
      for(auto item1:*videoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["videoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("videoList") != m.end() && !m["videoList"].empty()) {
      if (typeid(vector<boost::any>) == m["videoList"].type()) {
        vector<QueryCloudRecordVideoResponseBodyVideoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["videoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCloudRecordVideoResponseBodyVideoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoList = make_shared<vector<QueryCloudRecordVideoResponseBodyVideoList>>(expect1);
      }
    }
  }


  virtual ~QueryCloudRecordVideoResponseBody() = default;
};
class QueryCloudRecordVideoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryCloudRecordVideoResponseBody> body{};

  QueryCloudRecordVideoResponse() {}

  explicit QueryCloudRecordVideoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCloudRecordVideoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCloudRecordVideoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCloudRecordVideoResponse() = default;
};
class QueryCloudRecordVideoPlayInfoHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryCloudRecordVideoPlayInfoHeadersAccountContext() {}

  explicit QueryCloudRecordVideoPlayInfoHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryCloudRecordVideoPlayInfoHeadersAccountContext() = default;
};
class QueryCloudRecordVideoPlayInfoHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryCloudRecordVideoPlayInfoHeadersAccountContext> accountContext{};

  QueryCloudRecordVideoPlayInfoHeaders() {}

  explicit QueryCloudRecordVideoPlayInfoHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryCloudRecordVideoPlayInfoHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryCloudRecordVideoPlayInfoHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryCloudRecordVideoPlayInfoHeaders() = default;
};
class QueryCloudRecordVideoPlayInfoShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryCloudRecordVideoPlayInfoShrinkHeaders() {}

  explicit QueryCloudRecordVideoPlayInfoShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryCloudRecordVideoPlayInfoShrinkHeaders() = default;
};
class QueryCloudRecordVideoPlayInfoRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryCloudRecordVideoPlayInfoRequestTenantContext() {}

  explicit QueryCloudRecordVideoPlayInfoRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryCloudRecordVideoPlayInfoRequestTenantContext() = default;
};
class QueryCloudRecordVideoPlayInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> conferenceId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> regionId{};
  shared_ptr<QueryCloudRecordVideoPlayInfoRequestTenantContext> tenantContext{};

  QueryCloudRecordVideoPlayInfoRequest() {}

  explicit QueryCloudRecordVideoPlayInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conferenceId) {
      res["ConferenceId"] = boost::any(*conferenceId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConferenceId") != m.end() && !m["ConferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["ConferenceId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryCloudRecordVideoPlayInfoRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryCloudRecordVideoPlayInfoRequestTenantContext>(model1);
      }
    }
  }


  virtual ~QueryCloudRecordVideoPlayInfoRequest() = default;
};
class QueryCloudRecordVideoPlayInfoShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> conferenceId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> tenantContextShrink{};

  QueryCloudRecordVideoPlayInfoShrinkRequest() {}

  explicit QueryCloudRecordVideoPlayInfoShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conferenceId) {
      res["ConferenceId"] = boost::any(*conferenceId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConferenceId") != m.end() && !m["ConferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["ConferenceId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~QueryCloudRecordVideoPlayInfoShrinkRequest() = default;
};
class QueryCloudRecordVideoPlayInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<long> fileSize{};
  shared_ptr<string> mp4FileUrl{};
  shared_ptr<string> playUrl{};
  shared_ptr<string> requestId{};
  shared_ptr<long> status{};

  QueryCloudRecordVideoPlayInfoResponseBody() {}

  explicit QueryCloudRecordVideoPlayInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["duration"] = boost::any(*duration);
    }
    if (fileSize) {
      res["fileSize"] = boost::any(*fileSize);
    }
    if (mp4FileUrl) {
      res["mp4FileUrl"] = boost::any(*mp4FileUrl);
    }
    if (playUrl) {
      res["playUrl"] = boost::any(*playUrl);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("duration") != m.end() && !m["duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["duration"]));
    }
    if (m.find("fileSize") != m.end() && !m["fileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["fileSize"]));
    }
    if (m.find("mp4FileUrl") != m.end() && !m["mp4FileUrl"].empty()) {
      mp4FileUrl = make_shared<string>(boost::any_cast<string>(m["mp4FileUrl"]));
    }
    if (m.find("playUrl") != m.end() && !m["playUrl"].empty()) {
      playUrl = make_shared<string>(boost::any_cast<string>(m["playUrl"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
  }


  virtual ~QueryCloudRecordVideoPlayInfoResponseBody() = default;
};
class QueryCloudRecordVideoPlayInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryCloudRecordVideoPlayInfoResponseBody> body{};

  QueryCloudRecordVideoPlayInfoResponse() {}

  explicit QueryCloudRecordVideoPlayInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCloudRecordVideoPlayInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCloudRecordVideoPlayInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCloudRecordVideoPlayInfoResponse() = default;
};
class QueryConferenceInfoHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryConferenceInfoHeadersAccountContext() {}

  explicit QueryConferenceInfoHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryConferenceInfoHeadersAccountContext() = default;
};
class QueryConferenceInfoHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryConferenceInfoHeadersAccountContext> accountContext{};

  QueryConferenceInfoHeaders() {}

  explicit QueryConferenceInfoHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryConferenceInfoHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryConferenceInfoHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryConferenceInfoHeaders() = default;
};
class QueryConferenceInfoShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryConferenceInfoShrinkHeaders() {}

  explicit QueryConferenceInfoShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryConferenceInfoShrinkHeaders() = default;
};
class QueryConferenceInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> conferenceId{};

  QueryConferenceInfoRequest() {}

  explicit QueryConferenceInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~QueryConferenceInfoRequest() = default;
};
class QueryConferenceInfoResponseBodyConfInfo : public Darabonba::Model {
public:
  shared_ptr<long> activeNum{};
  shared_ptr<long> attendNum{};
  shared_ptr<long> confDuration{};
  shared_ptr<string> conferenceId{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> creatorNick{};
  shared_ptr<long> endTime{};
  shared_ptr<string> externalLinkUrl{};
  shared_ptr<long> invitedNum{};
  shared_ptr<string> roomCode{};
  shared_ptr<long> startTime{};
  shared_ptr<long> status{};
  shared_ptr<string> title{};

  QueryConferenceInfoResponseBodyConfInfo() {}

  explicit QueryConferenceInfoResponseBodyConfInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeNum) {
      res["ActiveNum"] = boost::any(*activeNum);
    }
    if (attendNum) {
      res["AttendNum"] = boost::any(*attendNum);
    }
    if (confDuration) {
      res["ConfDuration"] = boost::any(*confDuration);
    }
    if (conferenceId) {
      res["ConferenceId"] = boost::any(*conferenceId);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (creatorNick) {
      res["CreatorNick"] = boost::any(*creatorNick);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (externalLinkUrl) {
      res["ExternalLinkUrl"] = boost::any(*externalLinkUrl);
    }
    if (invitedNum) {
      res["InvitedNum"] = boost::any(*invitedNum);
    }
    if (roomCode) {
      res["RoomCode"] = boost::any(*roomCode);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveNum") != m.end() && !m["ActiveNum"].empty()) {
      activeNum = make_shared<long>(boost::any_cast<long>(m["ActiveNum"]));
    }
    if (m.find("AttendNum") != m.end() && !m["AttendNum"].empty()) {
      attendNum = make_shared<long>(boost::any_cast<long>(m["AttendNum"]));
    }
    if (m.find("ConfDuration") != m.end() && !m["ConfDuration"].empty()) {
      confDuration = make_shared<long>(boost::any_cast<long>(m["ConfDuration"]));
    }
    if (m.find("ConferenceId") != m.end() && !m["ConferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["ConferenceId"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("CreatorNick") != m.end() && !m["CreatorNick"].empty()) {
      creatorNick = make_shared<string>(boost::any_cast<string>(m["CreatorNick"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ExternalLinkUrl") != m.end() && !m["ExternalLinkUrl"].empty()) {
      externalLinkUrl = make_shared<string>(boost::any_cast<string>(m["ExternalLinkUrl"]));
    }
    if (m.find("InvitedNum") != m.end() && !m["InvitedNum"].empty()) {
      invitedNum = make_shared<long>(boost::any_cast<long>(m["InvitedNum"]));
    }
    if (m.find("RoomCode") != m.end() && !m["RoomCode"].empty()) {
      roomCode = make_shared<string>(boost::any_cast<string>(m["RoomCode"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~QueryConferenceInfoResponseBodyConfInfo() = default;
};
class QueryConferenceInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryConferenceInfoResponseBodyConfInfo> confInfo{};
  shared_ptr<string> requestId{};

  QueryConferenceInfoResponseBody() {}

  explicit QueryConferenceInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (confInfo) {
      res["confInfo"] = confInfo ? boost::any(confInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("confInfo") != m.end() && !m["confInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["confInfo"].type()) {
        QueryConferenceInfoResponseBodyConfInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["confInfo"]));
        confInfo = make_shared<QueryConferenceInfoResponseBodyConfInfo>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~QueryConferenceInfoResponseBody() = default;
};
class QueryConferenceInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryConferenceInfoResponseBody> body{};

  QueryConferenceInfoResponse() {}

  explicit QueryConferenceInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryConferenceInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryConferenceInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryConferenceInfoResponse() = default;
};
class QueryConferenceMembersHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryConferenceMembersHeadersAccountContext() {}

  explicit QueryConferenceMembersHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryConferenceMembersHeadersAccountContext() = default;
};
class QueryConferenceMembersHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryConferenceMembersHeadersAccountContext> accountContext{};

  QueryConferenceMembersHeaders() {}

  explicit QueryConferenceMembersHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryConferenceMembersHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryConferenceMembersHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryConferenceMembersHeaders() = default;
};
class QueryConferenceMembersShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryConferenceMembersShrinkHeaders() {}

  explicit QueryConferenceMembersShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryConferenceMembersShrinkHeaders() = default;
};
class QueryConferenceMembersRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryConferenceMembersRequestTenantContext() {}

  explicit QueryConferenceMembersRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryConferenceMembersRequestTenantContext() = default;
};
class QueryConferenceMembersRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<QueryConferenceMembersRequestTenantContext> tenantContext{};
  shared_ptr<string> conferenceId{};

  QueryConferenceMembersRequest() {}

  explicit QueryConferenceMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryConferenceMembersRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryConferenceMembersRequestTenantContext>(model1);
      }
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~QueryConferenceMembersRequest() = default;
};
class QueryConferenceMembersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> conferenceId{};

  QueryConferenceMembersShrinkRequest() {}

  explicit QueryConferenceMembersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~QueryConferenceMembersShrinkRequest() = default;
};
class QueryConferenceMembersResponseBodyMemberModels : public Darabonba::Model {
public:
  shared_ptr<long> attendStatus{};
  shared_ptr<bool> coHost{};
  shared_ptr<string> conferenceId{};
  shared_ptr<long> duration{};
  shared_ptr<bool> host{};
  shared_ptr<long> joinTime{};
  shared_ptr<long> leaveTime{};
  shared_ptr<bool> outerOrgMember{};
  shared_ptr<bool> pstnJoin{};
  shared_ptr<string> userId{};
  shared_ptr<string> userNick{};

  QueryConferenceMembersResponseBodyMemberModels() {}

  explicit QueryConferenceMembersResponseBodyMemberModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendStatus) {
      res["AttendStatus"] = boost::any(*attendStatus);
    }
    if (coHost) {
      res["CoHost"] = boost::any(*coHost);
    }
    if (conferenceId) {
      res["ConferenceId"] = boost::any(*conferenceId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (joinTime) {
      res["JoinTime"] = boost::any(*joinTime);
    }
    if (leaveTime) {
      res["LeaveTime"] = boost::any(*leaveTime);
    }
    if (outerOrgMember) {
      res["OuterOrgMember"] = boost::any(*outerOrgMember);
    }
    if (pstnJoin) {
      res["PstnJoin"] = boost::any(*pstnJoin);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userNick) {
      res["UserNick"] = boost::any(*userNick);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttendStatus") != m.end() && !m["AttendStatus"].empty()) {
      attendStatus = make_shared<long>(boost::any_cast<long>(m["AttendStatus"]));
    }
    if (m.find("CoHost") != m.end() && !m["CoHost"].empty()) {
      coHost = make_shared<bool>(boost::any_cast<bool>(m["CoHost"]));
    }
    if (m.find("ConferenceId") != m.end() && !m["ConferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["ConferenceId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<bool>(boost::any_cast<bool>(m["Host"]));
    }
    if (m.find("JoinTime") != m.end() && !m["JoinTime"].empty()) {
      joinTime = make_shared<long>(boost::any_cast<long>(m["JoinTime"]));
    }
    if (m.find("LeaveTime") != m.end() && !m["LeaveTime"].empty()) {
      leaveTime = make_shared<long>(boost::any_cast<long>(m["LeaveTime"]));
    }
    if (m.find("OuterOrgMember") != m.end() && !m["OuterOrgMember"].empty()) {
      outerOrgMember = make_shared<bool>(boost::any_cast<bool>(m["OuterOrgMember"]));
    }
    if (m.find("PstnJoin") != m.end() && !m["PstnJoin"].empty()) {
      pstnJoin = make_shared<bool>(boost::any_cast<bool>(m["PstnJoin"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserNick") != m.end() && !m["UserNick"].empty()) {
      userNick = make_shared<string>(boost::any_cast<string>(m["UserNick"]));
    }
  }


  virtual ~QueryConferenceMembersResponseBodyMemberModels() = default;
};
class QueryConferenceMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryConferenceMembersResponseBodyMemberModels>> memberModels{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  QueryConferenceMembersResponseBody() {}

  explicit QueryConferenceMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberModels) {
      vector<boost::any> temp1;
      for(auto item1:*memberModels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["memberModels"] = boost::any(temp1);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("memberModels") != m.end() && !m["memberModels"].empty()) {
      if (typeid(vector<boost::any>) == m["memberModels"].type()) {
        vector<QueryConferenceMembersResponseBodyMemberModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["memberModels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryConferenceMembersResponseBodyMemberModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        memberModels = make_shared<vector<QueryConferenceMembersResponseBodyMemberModels>>(expect1);
      }
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~QueryConferenceMembersResponseBody() = default;
};
class QueryConferenceMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryConferenceMembersResponseBody> body{};

  QueryConferenceMembersResponse() {}

  explicit QueryConferenceMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryConferenceMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryConferenceMembersResponseBody>(model1);
      }
    }
  }


  virtual ~QueryConferenceMembersResponse() = default;
};
class QueryDentryHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryDentryHeadersAccountContext() {}

  explicit QueryDentryHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryDentryHeadersAccountContext() = default;
};
class QueryDentryHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryDentryHeadersAccountContext> accountContext{};

  QueryDentryHeaders() {}

  explicit QueryDentryHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryDentryHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryDentryHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryDentryHeaders() = default;
};
class QueryDentryShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryDentryShrinkHeaders() {}

  explicit QueryDentryShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryDentryShrinkHeaders() = default;
};
class QueryDentryRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryDentryRequestTenantContext() {}

  explicit QueryDentryRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryDentryRequestTenantContext() = default;
};
class QueryDentryRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryId{};
  shared_ptr<bool> includeSpace{};
  shared_ptr<string> spaceId{};
  shared_ptr<QueryDentryRequestTenantContext> tenantContext{};

  QueryDentryRequest() {}

  explicit QueryDentryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryId) {
      res["DentryId"] = boost::any(*dentryId);
    }
    if (includeSpace) {
      res["IncludeSpace"] = boost::any(*includeSpace);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryId") != m.end() && !m["DentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["DentryId"]));
    }
    if (m.find("IncludeSpace") != m.end() && !m["IncludeSpace"].empty()) {
      includeSpace = make_shared<bool>(boost::any_cast<bool>(m["IncludeSpace"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryDentryRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryDentryRequestTenantContext>(model1);
      }
    }
  }


  virtual ~QueryDentryRequest() = default;
};
class QueryDentryShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dentryId{};
  shared_ptr<bool> includeSpace{};
  shared_ptr<string> spaceId{};
  shared_ptr<string> tenantContextShrink{};

  QueryDentryShrinkRequest() {}

  explicit QueryDentryShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryId) {
      res["DentryId"] = boost::any(*dentryId);
    }
    if (includeSpace) {
      res["IncludeSpace"] = boost::any(*includeSpace);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryId") != m.end() && !m["DentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["DentryId"]));
    }
    if (m.find("IncludeSpace") != m.end() && !m["IncludeSpace"].empty()) {
      includeSpace = make_shared<bool>(boost::any_cast<bool>(m["IncludeSpace"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~QueryDentryShrinkRequest() = default;
};
class QueryDentryResponseBodyCreator : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> userId{};

  QueryDentryResponseBodyCreator() {}

  explicit QueryDentryResponseBodyCreator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryDentryResponseBodyCreator() = default;
};
class QueryDentryResponseBodyLinkSourceInfoIconUrl : public Darabonba::Model {
public:
  shared_ptr<string> line{};
  shared_ptr<string> small{};

  QueryDentryResponseBodyLinkSourceInfoIconUrl() {}

  explicit QueryDentryResponseBodyLinkSourceInfoIconUrl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (small) {
      res["Small"] = boost::any(*small);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("Small") != m.end() && !m["Small"].empty()) {
      small = make_shared<string>(boost::any_cast<string>(m["Small"]));
    }
  }


  virtual ~QueryDentryResponseBodyLinkSourceInfoIconUrl() = default;
};
class QueryDentryResponseBodyLinkSourceInfo : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<QueryDentryResponseBodyLinkSourceInfoIconUrl> iconUrl{};
  shared_ptr<string> id{};
  shared_ptr<long> linkType{};
  shared_ptr<string> spaceId{};

  QueryDentryResponseBodyLinkSourceInfo() {}

  explicit QueryDentryResponseBodyLinkSourceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (iconUrl) {
      res["IconUrl"] = iconUrl ? boost::any(iconUrl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (linkType) {
      res["LinkType"] = boost::any(*linkType);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("IconUrl") != m.end() && !m["IconUrl"].empty()) {
      if (typeid(map<string, boost::any>) == m["IconUrl"].type()) {
        QueryDentryResponseBodyLinkSourceInfoIconUrl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IconUrl"]));
        iconUrl = make_shared<QueryDentryResponseBodyLinkSourceInfoIconUrl>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LinkType") != m.end() && !m["LinkType"].empty()) {
      linkType = make_shared<long>(boost::any_cast<long>(m["LinkType"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
  }


  virtual ~QueryDentryResponseBodyLinkSourceInfo() = default;
};
class QueryDentryResponseBodySpaceHdIconVO : public Darabonba::Model {
public:
  shared_ptr<string> icon{};
  shared_ptr<string> type{};

  QueryDentryResponseBodySpaceHdIconVO() {}

  explicit QueryDentryResponseBodySpaceHdIconVO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryDentryResponseBodySpaceHdIconVO() = default;
};
class QueryDentryResponseBodySpaceIconVO : public Darabonba::Model {
public:
  shared_ptr<string> icon{};
  shared_ptr<string> type{};

  QueryDentryResponseBodySpaceIconVO() {}

  explicit QueryDentryResponseBodySpaceIconVO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryDentryResponseBodySpaceIconVO() = default;
};
class QueryDentryResponseBodySpaceOwner : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> userId{};

  QueryDentryResponseBodySpaceOwner() {}

  explicit QueryDentryResponseBodySpaceOwner(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryDentryResponseBodySpaceOwner() = default;
};
class QueryDentryResponseBodySpaceRecentListCreator : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> userId{};

  QueryDentryResponseBodySpaceRecentListCreator() {}

  explicit QueryDentryResponseBodySpaceRecentListCreator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryDentryResponseBodySpaceRecentListCreator() = default;
};
class QueryDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl : public Darabonba::Model {
public:
  shared_ptr<string> line{};
  shared_ptr<string> small{};

  QueryDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl() {}

  explicit QueryDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (line) {
      res["Line"] = boost::any(*line);
    }
    if (small) {
      res["Small"] = boost::any(*small);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<string>(boost::any_cast<string>(m["Line"]));
    }
    if (m.find("Small") != m.end() && !m["Small"].empty()) {
      small = make_shared<string>(boost::any_cast<string>(m["Small"]));
    }
  }


  virtual ~QueryDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl() = default;
};
class QueryDentryResponseBodySpaceRecentListLinkSourceInfo : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<QueryDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl> iconUrl{};
  shared_ptr<string> id{};
  shared_ptr<long> linkType{};
  shared_ptr<string> spaceId{};

  QueryDentryResponseBodySpaceRecentListLinkSourceInfo() {}

  explicit QueryDentryResponseBodySpaceRecentListLinkSourceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (iconUrl) {
      res["IconUrl"] = iconUrl ? boost::any(iconUrl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (linkType) {
      res["LinkType"] = boost::any(*linkType);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("IconUrl") != m.end() && !m["IconUrl"].empty()) {
      if (typeid(map<string, boost::any>) == m["IconUrl"].type()) {
        QueryDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IconUrl"]));
        iconUrl = make_shared<QueryDentryResponseBodySpaceRecentListLinkSourceInfoIconUrl>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LinkType") != m.end() && !m["LinkType"].empty()) {
      linkType = make_shared<long>(boost::any_cast<long>(m["LinkType"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
  }


  virtual ~QueryDentryResponseBodySpaceRecentListLinkSourceInfo() = default;
};
class QueryDentryResponseBodySpaceRecentListStatisticalInfo : public Darabonba::Model {
public:
  shared_ptr<long> wordCount{};

  QueryDentryResponseBodySpaceRecentListStatisticalInfo() {}

  explicit QueryDentryResponseBodySpaceRecentListStatisticalInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (wordCount) {
      res["WordCount"] = boost::any(*wordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WordCount") != m.end() && !m["WordCount"].empty()) {
      wordCount = make_shared<long>(boost::any_cast<long>(m["WordCount"]));
    }
  }


  virtual ~QueryDentryResponseBodySpaceRecentListStatisticalInfo() = default;
};
class QueryDentryResponseBodySpaceRecentListUpdater : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> userId{};

  QueryDentryResponseBodySpaceRecentListUpdater() {}

  explicit QueryDentryResponseBodySpaceRecentListUpdater(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryDentryResponseBodySpaceRecentListUpdater() = default;
};
class QueryDentryResponseBodySpaceRecentListVisitorInfo : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dentryActions{};
  shared_ptr<string> roleCode{};
  shared_ptr<vector<string>> spaceActions{};

  QueryDentryResponseBodySpaceRecentListVisitorInfo() {}

  explicit QueryDentryResponseBodySpaceRecentListVisitorInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryActions) {
      res["DentryActions"] = boost::any(*dentryActions);
    }
    if (roleCode) {
      res["RoleCode"] = boost::any(*roleCode);
    }
    if (spaceActions) {
      res["SpaceActions"] = boost::any(*spaceActions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryActions") != m.end() && !m["DentryActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DentryActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DentryActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dentryActions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoleCode") != m.end() && !m["RoleCode"].empty()) {
      roleCode = make_shared<string>(boost::any_cast<string>(m["RoleCode"]));
    }
    if (m.find("SpaceActions") != m.end() && !m["SpaceActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SpaceActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SpaceActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      spaceActions = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryDentryResponseBodySpaceRecentListVisitorInfo() = default;
};
class QueryDentryResponseBodySpaceRecentList : public Darabonba::Model {
public:
  shared_ptr<string> contentType{};
  shared_ptr<long> createdTime{};
  shared_ptr<QueryDentryResponseBodySpaceRecentListCreator> creator{};
  shared_ptr<string> dentryId{};
  shared_ptr<string> dentryType{};
  shared_ptr<string> dentryUuid{};
  shared_ptr<string> docKey{};
  shared_ptr<string> extension{};
  shared_ptr<bool> hasChildren{};
  shared_ptr<QueryDentryResponseBodySpaceRecentListLinkSourceInfo> linkSourceInfo{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<boost::any> space{};
  shared_ptr<string> spaceId{};
  shared_ptr<QueryDentryResponseBodySpaceRecentListStatisticalInfo> statisticalInfo{};
  shared_ptr<long> updatedTime{};
  shared_ptr<QueryDentryResponseBodySpaceRecentListUpdater> updater{};
  shared_ptr<string> url{};
  shared_ptr<QueryDentryResponseBodySpaceRecentListVisitorInfo> visitorInfo{};

  QueryDentryResponseBodySpaceRecentList() {}

  explicit QueryDentryResponseBodySpaceRecentList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (creator) {
      res["Creator"] = creator ? boost::any(creator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dentryId) {
      res["DentryId"] = boost::any(*dentryId);
    }
    if (dentryType) {
      res["DentryType"] = boost::any(*dentryType);
    }
    if (dentryUuid) {
      res["DentryUuid"] = boost::any(*dentryUuid);
    }
    if (docKey) {
      res["DocKey"] = boost::any(*docKey);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (hasChildren) {
      res["HasChildren"] = boost::any(*hasChildren);
    }
    if (linkSourceInfo) {
      res["LinkSourceInfo"] = linkSourceInfo ? boost::any(linkSourceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (space) {
      res["Space"] = boost::any(*space);
    }
    if (spaceId) {
      res["SpaceId"] = boost::any(*spaceId);
    }
    if (statisticalInfo) {
      res["StatisticalInfo"] = statisticalInfo ? boost::any(statisticalInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    if (updater) {
      res["Updater"] = updater ? boost::any(updater->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (visitorInfo) {
      res["VisitorInfo"] = visitorInfo ? boost::any(visitorInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      if (typeid(map<string, boost::any>) == m["Creator"].type()) {
        QueryDentryResponseBodySpaceRecentListCreator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Creator"]));
        creator = make_shared<QueryDentryResponseBodySpaceRecentListCreator>(model1);
      }
    }
    if (m.find("DentryId") != m.end() && !m["DentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["DentryId"]));
    }
    if (m.find("DentryType") != m.end() && !m["DentryType"].empty()) {
      dentryType = make_shared<string>(boost::any_cast<string>(m["DentryType"]));
    }
    if (m.find("DentryUuid") != m.end() && !m["DentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["DentryUuid"]));
    }
    if (m.find("DocKey") != m.end() && !m["DocKey"].empty()) {
      docKey = make_shared<string>(boost::any_cast<string>(m["DocKey"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("HasChildren") != m.end() && !m["HasChildren"].empty()) {
      hasChildren = make_shared<bool>(boost::any_cast<bool>(m["HasChildren"]));
    }
    if (m.find("LinkSourceInfo") != m.end() && !m["LinkSourceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["LinkSourceInfo"].type()) {
        QueryDentryResponseBodySpaceRecentListLinkSourceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LinkSourceInfo"]));
        linkSourceInfo = make_shared<QueryDentryResponseBodySpaceRecentListLinkSourceInfo>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Space") != m.end() && !m["Space"].empty()) {
      space = make_shared<boost::any>(boost::any_cast<boost::any>(m["Space"]));
    }
    if (m.find("SpaceId") != m.end() && !m["SpaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["SpaceId"]));
    }
    if (m.find("StatisticalInfo") != m.end() && !m["StatisticalInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatisticalInfo"].type()) {
        QueryDentryResponseBodySpaceRecentListStatisticalInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatisticalInfo"]));
        statisticalInfo = make_shared<QueryDentryResponseBodySpaceRecentListStatisticalInfo>(model1);
      }
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["UpdatedTime"]));
    }
    if (m.find("Updater") != m.end() && !m["Updater"].empty()) {
      if (typeid(map<string, boost::any>) == m["Updater"].type()) {
        QueryDentryResponseBodySpaceRecentListUpdater model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Updater"]));
        updater = make_shared<QueryDentryResponseBodySpaceRecentListUpdater>(model1);
      }
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("VisitorInfo") != m.end() && !m["VisitorInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["VisitorInfo"].type()) {
        QueryDentryResponseBodySpaceRecentListVisitorInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VisitorInfo"]));
        visitorInfo = make_shared<QueryDentryResponseBodySpaceRecentListVisitorInfo>(model1);
      }
    }
  }


  virtual ~QueryDentryResponseBodySpaceRecentList() = default;
};
class QueryDentryResponseBodySpaceVisitorInfo : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dentryActions{};
  shared_ptr<string> roleCode{};
  shared_ptr<vector<string>> spaceActions{};

  QueryDentryResponseBodySpaceVisitorInfo() {}

  explicit QueryDentryResponseBodySpaceVisitorInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryActions) {
      res["DentryActions"] = boost::any(*dentryActions);
    }
    if (roleCode) {
      res["RoleCode"] = boost::any(*roleCode);
    }
    if (spaceActions) {
      res["SpaceActions"] = boost::any(*spaceActions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryActions") != m.end() && !m["DentryActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DentryActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DentryActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dentryActions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoleCode") != m.end() && !m["RoleCode"].empty()) {
      roleCode = make_shared<string>(boost::any_cast<string>(m["RoleCode"]));
    }
    if (m.find("SpaceActions") != m.end() && !m["SpaceActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SpaceActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SpaceActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      spaceActions = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryDentryResponseBodySpaceVisitorInfo() = default;
};
class QueryDentryResponseBodySpace : public Darabonba::Model {
public:
  shared_ptr<string> cover{};
  shared_ptr<string> description{};
  shared_ptr<QueryDentryResponseBodySpaceHdIconVO> hdIconVO{};
  shared_ptr<QueryDentryResponseBodySpaceIconVO> iconVO{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<QueryDentryResponseBodySpaceOwner> owner{};
  shared_ptr<vector<QueryDentryResponseBodySpaceRecentList>> recentList{};
  shared_ptr<long> type{};
  shared_ptr<string> url{};
  shared_ptr<QueryDentryResponseBodySpaceVisitorInfo> visitorInfo{};

  QueryDentryResponseBodySpace() {}

  explicit QueryDentryResponseBodySpace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cover) {
      res["Cover"] = boost::any(*cover);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hdIconVO) {
      res["HdIconVO"] = hdIconVO ? boost::any(hdIconVO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (iconVO) {
      res["IconVO"] = iconVO ? boost::any(iconVO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = owner ? boost::any(owner->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recentList) {
      vector<boost::any> temp1;
      for(auto item1:*recentList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecentList"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (visitorInfo) {
      res["VisitorInfo"] = visitorInfo ? boost::any(visitorInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      cover = make_shared<string>(boost::any_cast<string>(m["Cover"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HdIconVO") != m.end() && !m["HdIconVO"].empty()) {
      if (typeid(map<string, boost::any>) == m["HdIconVO"].type()) {
        QueryDentryResponseBodySpaceHdIconVO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HdIconVO"]));
        hdIconVO = make_shared<QueryDentryResponseBodySpaceHdIconVO>(model1);
      }
    }
    if (m.find("IconVO") != m.end() && !m["IconVO"].empty()) {
      if (typeid(map<string, boost::any>) == m["IconVO"].type()) {
        QueryDentryResponseBodySpaceIconVO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IconVO"]));
        iconVO = make_shared<QueryDentryResponseBodySpaceIconVO>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      if (typeid(map<string, boost::any>) == m["Owner"].type()) {
        QueryDentryResponseBodySpaceOwner model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Owner"]));
        owner = make_shared<QueryDentryResponseBodySpaceOwner>(model1);
      }
    }
    if (m.find("RecentList") != m.end() && !m["RecentList"].empty()) {
      if (typeid(vector<boost::any>) == m["RecentList"].type()) {
        vector<QueryDentryResponseBodySpaceRecentList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecentList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDentryResponseBodySpaceRecentList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recentList = make_shared<vector<QueryDentryResponseBodySpaceRecentList>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("VisitorInfo") != m.end() && !m["VisitorInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["VisitorInfo"].type()) {
        QueryDentryResponseBodySpaceVisitorInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VisitorInfo"]));
        visitorInfo = make_shared<QueryDentryResponseBodySpaceVisitorInfo>(model1);
      }
    }
  }


  virtual ~QueryDentryResponseBodySpace() = default;
};
class QueryDentryResponseBodyUpdater : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> userId{};

  QueryDentryResponseBodyUpdater() {}

  explicit QueryDentryResponseBodyUpdater(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryDentryResponseBodyUpdater() = default;
};
class QueryDentryResponseBodyVisitorInfo : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dentryActions{};
  shared_ptr<string> roleCode{};
  shared_ptr<vector<string>> spaceActions{};

  QueryDentryResponseBodyVisitorInfo() {}

  explicit QueryDentryResponseBodyVisitorInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dentryActions) {
      res["DentryActions"] = boost::any(*dentryActions);
    }
    if (roleCode) {
      res["RoleCode"] = boost::any(*roleCode);
    }
    if (spaceActions) {
      res["SpaceActions"] = boost::any(*spaceActions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DentryActions") != m.end() && !m["DentryActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DentryActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DentryActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dentryActions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoleCode") != m.end() && !m["RoleCode"].empty()) {
      roleCode = make_shared<string>(boost::any_cast<string>(m["RoleCode"]));
    }
    if (m.find("SpaceActions") != m.end() && !m["SpaceActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SpaceActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SpaceActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      spaceActions = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryDentryResponseBodyVisitorInfo() = default;
};
class QueryDentryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> contentType{};
  shared_ptr<long> createdTime{};
  shared_ptr<QueryDentryResponseBodyCreator> creator{};
  shared_ptr<string> dentryId{};
  shared_ptr<string> dentryType{};
  shared_ptr<string> dentryUuid{};
  shared_ptr<string> docKey{};
  shared_ptr<string> extension{};
  shared_ptr<bool> hasChildren{};
  shared_ptr<QueryDentryResponseBodyLinkSourceInfo> linkSourceInfo{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryDentryResponseBodySpace> space{};
  shared_ptr<string> spaceId{};
  shared_ptr<long> updatedTime{};
  shared_ptr<QueryDentryResponseBodyUpdater> updater{};
  shared_ptr<string> url{};
  shared_ptr<QueryDentryResponseBodyVisitorInfo> visitorInfo{};

  QueryDentryResponseBody() {}

  explicit QueryDentryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentType) {
      res["contentType"] = boost::any(*contentType);
    }
    if (createdTime) {
      res["createdTime"] = boost::any(*createdTime);
    }
    if (creator) {
      res["creator"] = creator ? boost::any(creator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dentryId) {
      res["dentryId"] = boost::any(*dentryId);
    }
    if (dentryType) {
      res["dentryType"] = boost::any(*dentryType);
    }
    if (dentryUuid) {
      res["dentryUuid"] = boost::any(*dentryUuid);
    }
    if (docKey) {
      res["docKey"] = boost::any(*docKey);
    }
    if (extension) {
      res["extension"] = boost::any(*extension);
    }
    if (hasChildren) {
      res["hasChildren"] = boost::any(*hasChildren);
    }
    if (linkSourceInfo) {
      res["linkSourceInfo"] = linkSourceInfo ? boost::any(linkSourceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (space) {
      res["space"] = space ? boost::any(space->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spaceId) {
      res["spaceId"] = boost::any(*spaceId);
    }
    if (updatedTime) {
      res["updatedTime"] = boost::any(*updatedTime);
    }
    if (updater) {
      res["updater"] = updater ? boost::any(updater->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    if (visitorInfo) {
      res["visitorInfo"] = visitorInfo ? boost::any(visitorInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("contentType") != m.end() && !m["contentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["contentType"]));
    }
    if (m.find("createdTime") != m.end() && !m["createdTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["createdTime"]));
    }
    if (m.find("creator") != m.end() && !m["creator"].empty()) {
      if (typeid(map<string, boost::any>) == m["creator"].type()) {
        QueryDentryResponseBodyCreator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["creator"]));
        creator = make_shared<QueryDentryResponseBodyCreator>(model1);
      }
    }
    if (m.find("dentryId") != m.end() && !m["dentryId"].empty()) {
      dentryId = make_shared<string>(boost::any_cast<string>(m["dentryId"]));
    }
    if (m.find("dentryType") != m.end() && !m["dentryType"].empty()) {
      dentryType = make_shared<string>(boost::any_cast<string>(m["dentryType"]));
    }
    if (m.find("dentryUuid") != m.end() && !m["dentryUuid"].empty()) {
      dentryUuid = make_shared<string>(boost::any_cast<string>(m["dentryUuid"]));
    }
    if (m.find("docKey") != m.end() && !m["docKey"].empty()) {
      docKey = make_shared<string>(boost::any_cast<string>(m["docKey"]));
    }
    if (m.find("extension") != m.end() && !m["extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["extension"]));
    }
    if (m.find("hasChildren") != m.end() && !m["hasChildren"].empty()) {
      hasChildren = make_shared<bool>(boost::any_cast<bool>(m["hasChildren"]));
    }
    if (m.find("linkSourceInfo") != m.end() && !m["linkSourceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["linkSourceInfo"].type()) {
        QueryDentryResponseBodyLinkSourceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["linkSourceInfo"]));
        linkSourceInfo = make_shared<QueryDentryResponseBodyLinkSourceInfo>(model1);
      }
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("space") != m.end() && !m["space"].empty()) {
      if (typeid(map<string, boost::any>) == m["space"].type()) {
        QueryDentryResponseBodySpace model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["space"]));
        space = make_shared<QueryDentryResponseBodySpace>(model1);
      }
    }
    if (m.find("spaceId") != m.end() && !m["spaceId"].empty()) {
      spaceId = make_shared<string>(boost::any_cast<string>(m["spaceId"]));
    }
    if (m.find("updatedTime") != m.end() && !m["updatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["updatedTime"]));
    }
    if (m.find("updater") != m.end() && !m["updater"].empty()) {
      if (typeid(map<string, boost::any>) == m["updater"].type()) {
        QueryDentryResponseBodyUpdater model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["updater"]));
        updater = make_shared<QueryDentryResponseBodyUpdater>(model1);
      }
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
    if (m.find("visitorInfo") != m.end() && !m["visitorInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["visitorInfo"].type()) {
        QueryDentryResponseBodyVisitorInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["visitorInfo"]));
        visitorInfo = make_shared<QueryDentryResponseBodyVisitorInfo>(model1);
      }
    }
  }


  virtual ~QueryDentryResponseBody() = default;
};
class QueryDentryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDentryResponseBody> body{};

  QueryDentryResponse() {}

  explicit QueryDentryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDentryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDentryResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDentryResponse() = default;
};
class QueryLiveInfoHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryLiveInfoHeadersAccountContext() {}

  explicit QueryLiveInfoHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryLiveInfoHeadersAccountContext() = default;
};
class QueryLiveInfoHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryLiveInfoHeadersAccountContext> accountContext{};

  QueryLiveInfoHeaders() {}

  explicit QueryLiveInfoHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryLiveInfoHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryLiveInfoHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryLiveInfoHeaders() = default;
};
class QueryLiveInfoShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryLiveInfoShrinkHeaders() {}

  explicit QueryLiveInfoShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryLiveInfoShrinkHeaders() = default;
};
class QueryLiveInfoRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryLiveInfoRequestTenantContext() {}

  explicit QueryLiveInfoRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryLiveInfoRequestTenantContext() = default;
};
class QueryLiveInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveId{};
  shared_ptr<QueryLiveInfoRequestTenantContext> tenantContext{};

  QueryLiveInfoRequest() {}

  explicit QueryLiveInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveId) {
      res["LiveId"] = boost::any(*liveId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveId") != m.end() && !m["LiveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["LiveId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryLiveInfoRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryLiveInfoRequestTenantContext>(model1);
      }
    }
  }


  virtual ~QueryLiveInfoRequest() = default;
};
class QueryLiveInfoShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveId{};
  shared_ptr<string> tenantContextShrink{};

  QueryLiveInfoShrinkRequest() {}

  explicit QueryLiveInfoShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveId) {
      res["LiveId"] = boost::any(*liveId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveId") != m.end() && !m["LiveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["LiveId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~QueryLiveInfoShrinkRequest() = default;
};
class QueryLiveInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> coverUrl{};
  shared_ptr<long> duration{};
  shared_ptr<long> endTime{};
  shared_ptr<string> introduction{};
  shared_ptr<string> liveId{};
  shared_ptr<string> livePlayUrl{};
  shared_ptr<long> liveStatus{};
  shared_ptr<long> playbackDuration{};
  shared_ptr<string> requestId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> subscribeCount{};
  shared_ptr<string> title{};
  shared_ptr<long> uv{};

  QueryLiveInfoResponseBody() {}

  explicit QueryLiveInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverUrl) {
      res["coverUrl"] = boost::any(*coverUrl);
    }
    if (duration) {
      res["duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (introduction) {
      res["introduction"] = boost::any(*introduction);
    }
    if (liveId) {
      res["liveId"] = boost::any(*liveId);
    }
    if (livePlayUrl) {
      res["livePlayUrl"] = boost::any(*livePlayUrl);
    }
    if (liveStatus) {
      res["liveStatus"] = boost::any(*liveStatus);
    }
    if (playbackDuration) {
      res["playbackDuration"] = boost::any(*playbackDuration);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (subscribeCount) {
      res["subscribeCount"] = boost::any(*subscribeCount);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (uv) {
      res["uv"] = boost::any(*uv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("coverUrl") != m.end() && !m["coverUrl"].empty()) {
      coverUrl = make_shared<string>(boost::any_cast<string>(m["coverUrl"]));
    }
    if (m.find("duration") != m.end() && !m["duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["duration"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("introduction") != m.end() && !m["introduction"].empty()) {
      introduction = make_shared<string>(boost::any_cast<string>(m["introduction"]));
    }
    if (m.find("liveId") != m.end() && !m["liveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["liveId"]));
    }
    if (m.find("livePlayUrl") != m.end() && !m["livePlayUrl"].empty()) {
      livePlayUrl = make_shared<string>(boost::any_cast<string>(m["livePlayUrl"]));
    }
    if (m.find("liveStatus") != m.end() && !m["liveStatus"].empty()) {
      liveStatus = make_shared<long>(boost::any_cast<long>(m["liveStatus"]));
    }
    if (m.find("playbackDuration") != m.end() && !m["playbackDuration"].empty()) {
      playbackDuration = make_shared<long>(boost::any_cast<long>(m["playbackDuration"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("subscribeCount") != m.end() && !m["subscribeCount"].empty()) {
      subscribeCount = make_shared<long>(boost::any_cast<long>(m["subscribeCount"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("uv") != m.end() && !m["uv"].empty()) {
      uv = make_shared<long>(boost::any_cast<long>(m["uv"]));
    }
  }


  virtual ~QueryLiveInfoResponseBody() = default;
};
class QueryLiveInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryLiveInfoResponseBody> body{};

  QueryLiveInfoResponse() {}

  explicit QueryLiveInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryLiveInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryLiveInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryLiveInfoResponse() = default;
};
class QueryLiveWatchDetailHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryLiveWatchDetailHeadersAccountContext() {}

  explicit QueryLiveWatchDetailHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryLiveWatchDetailHeadersAccountContext() = default;
};
class QueryLiveWatchDetailHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryLiveWatchDetailHeadersAccountContext> accountContext{};

  QueryLiveWatchDetailHeaders() {}

  explicit QueryLiveWatchDetailHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryLiveWatchDetailHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryLiveWatchDetailHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryLiveWatchDetailHeaders() = default;
};
class QueryLiveWatchDetailShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryLiveWatchDetailShrinkHeaders() {}

  explicit QueryLiveWatchDetailShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryLiveWatchDetailShrinkHeaders() = default;
};
class QueryLiveWatchDetailRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryLiveWatchDetailRequestTenantContext() {}

  explicit QueryLiveWatchDetailRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryLiveWatchDetailRequestTenantContext() = default;
};
class QueryLiveWatchDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveId{};
  shared_ptr<QueryLiveWatchDetailRequestTenantContext> tenantContext{};

  QueryLiveWatchDetailRequest() {}

  explicit QueryLiveWatchDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveId) {
      res["LiveId"] = boost::any(*liveId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveId") != m.end() && !m["LiveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["LiveId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryLiveWatchDetailRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryLiveWatchDetailRequestTenantContext>(model1);
      }
    }
  }


  virtual ~QueryLiveWatchDetailRequest() = default;
};
class QueryLiveWatchDetailShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveId{};
  shared_ptr<string> tenantContextShrink{};

  QueryLiveWatchDetailShrinkRequest() {}

  explicit QueryLiveWatchDetailShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveId) {
      res["LiveId"] = boost::any(*liveId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveId") != m.end() && !m["LiveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["LiveId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~QueryLiveWatchDetailShrinkRequest() = default;
};
class QueryLiveWatchDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> avgWatchTime{};
  shared_ptr<long> liveUv{};
  shared_ptr<long> msgCount{};
  shared_ptr<long> playbackUv{};
  shared_ptr<long> praiseCount{};
  shared_ptr<long> pv{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalWatchTime{};
  shared_ptr<long> uv{};

  QueryLiveWatchDetailResponseBody() {}

  explicit QueryLiveWatchDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgWatchTime) {
      res["avgWatchTime"] = boost::any(*avgWatchTime);
    }
    if (liveUv) {
      res["liveUv"] = boost::any(*liveUv);
    }
    if (msgCount) {
      res["msgCount"] = boost::any(*msgCount);
    }
    if (playbackUv) {
      res["playbackUv"] = boost::any(*playbackUv);
    }
    if (praiseCount) {
      res["praiseCount"] = boost::any(*praiseCount);
    }
    if (pv) {
      res["pv"] = boost::any(*pv);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalWatchTime) {
      res["totalWatchTime"] = boost::any(*totalWatchTime);
    }
    if (uv) {
      res["uv"] = boost::any(*uv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("avgWatchTime") != m.end() && !m["avgWatchTime"].empty()) {
      avgWatchTime = make_shared<long>(boost::any_cast<long>(m["avgWatchTime"]));
    }
    if (m.find("liveUv") != m.end() && !m["liveUv"].empty()) {
      liveUv = make_shared<long>(boost::any_cast<long>(m["liveUv"]));
    }
    if (m.find("msgCount") != m.end() && !m["msgCount"].empty()) {
      msgCount = make_shared<long>(boost::any_cast<long>(m["msgCount"]));
    }
    if (m.find("playbackUv") != m.end() && !m["playbackUv"].empty()) {
      playbackUv = make_shared<long>(boost::any_cast<long>(m["playbackUv"]));
    }
    if (m.find("praiseCount") != m.end() && !m["praiseCount"].empty()) {
      praiseCount = make_shared<long>(boost::any_cast<long>(m["praiseCount"]));
    }
    if (m.find("pv") != m.end() && !m["pv"].empty()) {
      pv = make_shared<long>(boost::any_cast<long>(m["pv"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalWatchTime") != m.end() && !m["totalWatchTime"].empty()) {
      totalWatchTime = make_shared<long>(boost::any_cast<long>(m["totalWatchTime"]));
    }
    if (m.find("uv") != m.end() && !m["uv"].empty()) {
      uv = make_shared<long>(boost::any_cast<long>(m["uv"]));
    }
  }


  virtual ~QueryLiveWatchDetailResponseBody() = default;
};
class QueryLiveWatchDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryLiveWatchDetailResponseBody> body{};

  QueryLiveWatchDetailResponse() {}

  explicit QueryLiveWatchDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryLiveWatchDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryLiveWatchDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryLiveWatchDetailResponse() = default;
};
class QueryLiveWatchUserListHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryLiveWatchUserListHeadersAccountContext() {}

  explicit QueryLiveWatchUserListHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryLiveWatchUserListHeadersAccountContext() = default;
};
class QueryLiveWatchUserListHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryLiveWatchUserListHeadersAccountContext> accountContext{};

  QueryLiveWatchUserListHeaders() {}

  explicit QueryLiveWatchUserListHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryLiveWatchUserListHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryLiveWatchUserListHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryLiveWatchUserListHeaders() = default;
};
class QueryLiveWatchUserListShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryLiveWatchUserListShrinkHeaders() {}

  explicit QueryLiveWatchUserListShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryLiveWatchUserListShrinkHeaders() = default;
};
class QueryLiveWatchUserListRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryLiveWatchUserListRequestTenantContext() {}

  explicit QueryLiveWatchUserListRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryLiveWatchUserListRequestTenantContext() = default;
};
class QueryLiveWatchUserListRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<QueryLiveWatchUserListRequestTenantContext> tenantContext{};

  QueryLiveWatchUserListRequest() {}

  explicit QueryLiveWatchUserListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveId) {
      res["LiveId"] = boost::any(*liveId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveId") != m.end() && !m["LiveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["LiveId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryLiveWatchUserListRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryLiveWatchUserListRequestTenantContext>(model1);
      }
    }
  }


  virtual ~QueryLiveWatchUserListRequest() = default;
};
class QueryLiveWatchUserListShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> liveId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> tenantContextShrink{};

  QueryLiveWatchUserListShrinkRequest() {}

  explicit QueryLiveWatchUserListShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveId) {
      res["LiveId"] = boost::any(*liveId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveId") != m.end() && !m["LiveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["LiveId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~QueryLiveWatchUserListShrinkRequest() = default;
};
class QueryLiveWatchUserListResponseBodyOrgUsesList : public Darabonba::Model {
public:
  shared_ptr<string> deptName{};
  shared_ptr<string> name{};
  shared_ptr<string> userId{};
  shared_ptr<long> watchLiveTime{};
  shared_ptr<long> watchPlaybackTime{};
  shared_ptr<long> watchProgressMs{};

  QueryLiveWatchUserListResponseBodyOrgUsesList() {}

  explicit QueryLiveWatchUserListResponseBodyOrgUsesList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deptName) {
      res["DeptName"] = boost::any(*deptName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (watchLiveTime) {
      res["WatchLiveTime"] = boost::any(*watchLiveTime);
    }
    if (watchPlaybackTime) {
      res["WatchPlaybackTime"] = boost::any(*watchPlaybackTime);
    }
    if (watchProgressMs) {
      res["WatchProgressMs"] = boost::any(*watchProgressMs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeptName") != m.end() && !m["DeptName"].empty()) {
      deptName = make_shared<string>(boost::any_cast<string>(m["DeptName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WatchLiveTime") != m.end() && !m["WatchLiveTime"].empty()) {
      watchLiveTime = make_shared<long>(boost::any_cast<long>(m["WatchLiveTime"]));
    }
    if (m.find("WatchPlaybackTime") != m.end() && !m["WatchPlaybackTime"].empty()) {
      watchPlaybackTime = make_shared<long>(boost::any_cast<long>(m["WatchPlaybackTime"]));
    }
    if (m.find("WatchProgressMs") != m.end() && !m["WatchProgressMs"].empty()) {
      watchProgressMs = make_shared<long>(boost::any_cast<long>(m["WatchProgressMs"]));
    }
  }


  virtual ~QueryLiveWatchUserListResponseBodyOrgUsesList() = default;
};
class QueryLiveWatchUserListResponseBodyOutOrgUserList : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> watchLiveTime{};
  shared_ptr<long> watchPlaybackTime{};
  shared_ptr<long> watchProgressMs{};

  QueryLiveWatchUserListResponseBodyOutOrgUserList() {}

  explicit QueryLiveWatchUserListResponseBodyOutOrgUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (watchLiveTime) {
      res["WatchLiveTime"] = boost::any(*watchLiveTime);
    }
    if (watchPlaybackTime) {
      res["WatchPlaybackTime"] = boost::any(*watchPlaybackTime);
    }
    if (watchProgressMs) {
      res["WatchProgressMs"] = boost::any(*watchProgressMs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("WatchLiveTime") != m.end() && !m["WatchLiveTime"].empty()) {
      watchLiveTime = make_shared<long>(boost::any_cast<long>(m["WatchLiveTime"]));
    }
    if (m.find("WatchPlaybackTime") != m.end() && !m["WatchPlaybackTime"].empty()) {
      watchPlaybackTime = make_shared<long>(boost::any_cast<long>(m["WatchPlaybackTime"]));
    }
    if (m.find("WatchProgressMs") != m.end() && !m["WatchProgressMs"].empty()) {
      watchProgressMs = make_shared<long>(boost::any_cast<long>(m["WatchProgressMs"]));
    }
  }


  virtual ~QueryLiveWatchUserListResponseBodyOutOrgUserList() = default;
};
class QueryLiveWatchUserListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryLiveWatchUserListResponseBodyOrgUsesList>> orgUsesList{};
  shared_ptr<vector<QueryLiveWatchUserListResponseBodyOutOrgUserList>> outOrgUserList{};
  shared_ptr<string> requestId{};

  QueryLiveWatchUserListResponseBody() {}

  explicit QueryLiveWatchUserListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orgUsesList) {
      vector<boost::any> temp1;
      for(auto item1:*orgUsesList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["orgUsesList"] = boost::any(temp1);
    }
    if (outOrgUserList) {
      vector<boost::any> temp1;
      for(auto item1:*outOrgUserList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["outOrgUserList"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("orgUsesList") != m.end() && !m["orgUsesList"].empty()) {
      if (typeid(vector<boost::any>) == m["orgUsesList"].type()) {
        vector<QueryLiveWatchUserListResponseBodyOrgUsesList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["orgUsesList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryLiveWatchUserListResponseBodyOrgUsesList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        orgUsesList = make_shared<vector<QueryLiveWatchUserListResponseBodyOrgUsesList>>(expect1);
      }
    }
    if (m.find("outOrgUserList") != m.end() && !m["outOrgUserList"].empty()) {
      if (typeid(vector<boost::any>) == m["outOrgUserList"].type()) {
        vector<QueryLiveWatchUserListResponseBodyOutOrgUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["outOrgUserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryLiveWatchUserListResponseBodyOutOrgUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outOrgUserList = make_shared<vector<QueryLiveWatchUserListResponseBodyOutOrgUserList>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~QueryLiveWatchUserListResponseBody() = default;
};
class QueryLiveWatchUserListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryLiveWatchUserListResponseBody> body{};

  QueryLiveWatchUserListResponse() {}

  explicit QueryLiveWatchUserListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryLiveWatchUserListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryLiveWatchUserListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryLiveWatchUserListResponse() = default;
};
class QueryMeetingRoomHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryMeetingRoomHeadersAccountContext() {}

  explicit QueryMeetingRoomHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryMeetingRoomHeadersAccountContext() = default;
};
class QueryMeetingRoomHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryMeetingRoomHeadersAccountContext> accountContext{};

  QueryMeetingRoomHeaders() {}

  explicit QueryMeetingRoomHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryMeetingRoomHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryMeetingRoomHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomHeaders() = default;
};
class QueryMeetingRoomShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryMeetingRoomShrinkHeaders() {}

  explicit QueryMeetingRoomShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryMeetingRoomShrinkHeaders() = default;
};
class QueryMeetingRoomRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryMeetingRoomRequestTenantContext() {}

  explicit QueryMeetingRoomRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryMeetingRoomRequestTenantContext() = default;
};
class QueryMeetingRoomRequest : public Darabonba::Model {
public:
  shared_ptr<string> roomId{};
  shared_ptr<QueryMeetingRoomRequestTenantContext> tenantContext{};

  QueryMeetingRoomRequest() {}

  explicit QueryMeetingRoomRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryMeetingRoomRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryMeetingRoomRequestTenantContext>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomRequest() = default;
};
class QueryMeetingRoomShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> roomId{};
  shared_ptr<string> tenantContextShrink{};

  QueryMeetingRoomShrinkRequest() {}

  explicit QueryMeetingRoomShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~QueryMeetingRoomShrinkRequest() = default;
};
class QueryMeetingRoomResponseBodyResultRoomGroup : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<long> parentId{};

  QueryMeetingRoomResponseBodyResultRoomGroup() {}

  explicit QueryMeetingRoomResponseBodyResultRoomGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
  }


  virtual ~QueryMeetingRoomResponseBodyResultRoomGroup() = default;
};
class QueryMeetingRoomResponseBodyResultRoomLabels : public Darabonba::Model {
public:
  shared_ptr<long> labelId{};
  shared_ptr<string> labelName{};

  QueryMeetingRoomResponseBodyResultRoomLabels() {}

  explicit QueryMeetingRoomResponseBodyResultRoomLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (labelId) {
      res["LabelId"] = boost::any(*labelId);
    }
    if (labelName) {
      res["LabelName"] = boost::any(*labelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LabelId") != m.end() && !m["LabelId"].empty()) {
      labelId = make_shared<long>(boost::any_cast<long>(m["LabelId"]));
    }
    if (m.find("LabelName") != m.end() && !m["LabelName"].empty()) {
      labelName = make_shared<string>(boost::any_cast<string>(m["LabelName"]));
    }
  }


  virtual ~QueryMeetingRoomResponseBodyResultRoomLabels() = default;
};
class QueryMeetingRoomResponseBodyResultRoomLocation : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> title{};

  QueryMeetingRoomResponseBodyResultRoomLocation() {}

  explicit QueryMeetingRoomResponseBodyResultRoomLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~QueryMeetingRoomResponseBodyResultRoomLocation() = default;
};
class QueryMeetingRoomResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<string> isvRoomId{};
  shared_ptr<long> roomCapacity{};
  shared_ptr<QueryMeetingRoomResponseBodyResultRoomGroup> roomGroup{};
  shared_ptr<string> roomId{};
  shared_ptr<vector<QueryMeetingRoomResponseBodyResultRoomLabels>> roomLabels{};
  shared_ptr<QueryMeetingRoomResponseBodyResultRoomLocation> roomLocation{};
  shared_ptr<string> roomName{};
  shared_ptr<string> roomPicture{};
  shared_ptr<string> roomStaffId{};
  shared_ptr<long> roomStatus{};

  QueryMeetingRoomResponseBodyResult() {}

  explicit QueryMeetingRoomResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (isvRoomId) {
      res["IsvRoomId"] = boost::any(*isvRoomId);
    }
    if (roomCapacity) {
      res["RoomCapacity"] = boost::any(*roomCapacity);
    }
    if (roomGroup) {
      res["RoomGroup"] = roomGroup ? boost::any(roomGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    if (roomLabels) {
      vector<boost::any> temp1;
      for(auto item1:*roomLabels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RoomLabels"] = boost::any(temp1);
    }
    if (roomLocation) {
      res["RoomLocation"] = roomLocation ? boost::any(roomLocation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (roomName) {
      res["RoomName"] = boost::any(*roomName);
    }
    if (roomPicture) {
      res["RoomPicture"] = boost::any(*roomPicture);
    }
    if (roomStaffId) {
      res["RoomStaffId"] = boost::any(*roomStaffId);
    }
    if (roomStatus) {
      res["RoomStatus"] = boost::any(*roomStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("IsvRoomId") != m.end() && !m["IsvRoomId"].empty()) {
      isvRoomId = make_shared<string>(boost::any_cast<string>(m["IsvRoomId"]));
    }
    if (m.find("RoomCapacity") != m.end() && !m["RoomCapacity"].empty()) {
      roomCapacity = make_shared<long>(boost::any_cast<long>(m["RoomCapacity"]));
    }
    if (m.find("RoomGroup") != m.end() && !m["RoomGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoomGroup"].type()) {
        QueryMeetingRoomResponseBodyResultRoomGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoomGroup"]));
        roomGroup = make_shared<QueryMeetingRoomResponseBodyResultRoomGroup>(model1);
      }
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
    if (m.find("RoomLabels") != m.end() && !m["RoomLabels"].empty()) {
      if (typeid(vector<boost::any>) == m["RoomLabels"].type()) {
        vector<QueryMeetingRoomResponseBodyResultRoomLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RoomLabels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMeetingRoomResponseBodyResultRoomLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roomLabels = make_shared<vector<QueryMeetingRoomResponseBodyResultRoomLabels>>(expect1);
      }
    }
    if (m.find("RoomLocation") != m.end() && !m["RoomLocation"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoomLocation"].type()) {
        QueryMeetingRoomResponseBodyResultRoomLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoomLocation"]));
        roomLocation = make_shared<QueryMeetingRoomResponseBodyResultRoomLocation>(model1);
      }
    }
    if (m.find("RoomName") != m.end() && !m["RoomName"].empty()) {
      roomName = make_shared<string>(boost::any_cast<string>(m["RoomName"]));
    }
    if (m.find("RoomPicture") != m.end() && !m["RoomPicture"].empty()) {
      roomPicture = make_shared<string>(boost::any_cast<string>(m["RoomPicture"]));
    }
    if (m.find("RoomStaffId") != m.end() && !m["RoomStaffId"].empty()) {
      roomStaffId = make_shared<string>(boost::any_cast<string>(m["RoomStaffId"]));
    }
    if (m.find("RoomStatus") != m.end() && !m["RoomStatus"].empty()) {
      roomStatus = make_shared<long>(boost::any_cast<long>(m["RoomStatus"]));
    }
  }


  virtual ~QueryMeetingRoomResponseBodyResult() = default;
};
class QueryMeetingRoomResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryMeetingRoomResponseBodyResult> result{};

  QueryMeetingRoomResponseBody() {}

  explicit QueryMeetingRoomResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(map<string, boost::any>) == m["result"].type()) {
        QueryMeetingRoomResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["result"]));
        result = make_shared<QueryMeetingRoomResponseBodyResult>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomResponseBody() = default;
};
class QueryMeetingRoomResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMeetingRoomResponseBody> body{};

  QueryMeetingRoomResponse() {}

  explicit QueryMeetingRoomResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMeetingRoomResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMeetingRoomResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomResponse() = default;
};
class QueryMeetingRoomGroupHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryMeetingRoomGroupHeadersAccountContext() {}

  explicit QueryMeetingRoomGroupHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryMeetingRoomGroupHeadersAccountContext() = default;
};
class QueryMeetingRoomGroupHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryMeetingRoomGroupHeadersAccountContext> accountContext{};

  QueryMeetingRoomGroupHeaders() {}

  explicit QueryMeetingRoomGroupHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryMeetingRoomGroupHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryMeetingRoomGroupHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomGroupHeaders() = default;
};
class QueryMeetingRoomGroupShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryMeetingRoomGroupShrinkHeaders() {}

  explicit QueryMeetingRoomGroupShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryMeetingRoomGroupShrinkHeaders() = default;
};
class QueryMeetingRoomGroupRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryMeetingRoomGroupRequestTenantContext() {}

  explicit QueryMeetingRoomGroupRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryMeetingRoomGroupRequestTenantContext() = default;
};
class QueryMeetingRoomGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<QueryMeetingRoomGroupRequestTenantContext> tenantContext{};

  QueryMeetingRoomGroupRequest() {}

  explicit QueryMeetingRoomGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryMeetingRoomGroupRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryMeetingRoomGroupRequestTenantContext>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomGroupRequest() = default;
};
class QueryMeetingRoomGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> tenantContextShrink{};

  QueryMeetingRoomGroupShrinkRequest() {}

  explicit QueryMeetingRoomGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~QueryMeetingRoomGroupShrinkRequest() = default;
};
class QueryMeetingRoomGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<long> parentId{};
  shared_ptr<string> requestId{};

  QueryMeetingRoomGroupResponseBody() {}

  explicit QueryMeetingRoomGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["groupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["groupName"] = boost::any(*groupName);
    }
    if (parentId) {
      res["parentId"] = boost::any(*parentId);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("groupId") != m.end() && !m["groupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["groupId"]));
    }
    if (m.find("groupName") != m.end() && !m["groupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["groupName"]));
    }
    if (m.find("parentId") != m.end() && !m["parentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["parentId"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~QueryMeetingRoomGroupResponseBody() = default;
};
class QueryMeetingRoomGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMeetingRoomGroupResponseBody> body{};

  QueryMeetingRoomGroupResponse() {}

  explicit QueryMeetingRoomGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMeetingRoomGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMeetingRoomGroupResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomGroupResponse() = default;
};
class QueryMeetingRoomGroupListHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryMeetingRoomGroupListHeadersAccountContext() {}

  explicit QueryMeetingRoomGroupListHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryMeetingRoomGroupListHeadersAccountContext() = default;
};
class QueryMeetingRoomGroupListHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryMeetingRoomGroupListHeadersAccountContext> accountContext{};

  QueryMeetingRoomGroupListHeaders() {}

  explicit QueryMeetingRoomGroupListHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryMeetingRoomGroupListHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryMeetingRoomGroupListHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomGroupListHeaders() = default;
};
class QueryMeetingRoomGroupListShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryMeetingRoomGroupListShrinkHeaders() {}

  explicit QueryMeetingRoomGroupListShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryMeetingRoomGroupListShrinkHeaders() = default;
};
class QueryMeetingRoomGroupListRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryMeetingRoomGroupListRequestTenantContext() {}

  explicit QueryMeetingRoomGroupListRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryMeetingRoomGroupListRequestTenantContext() = default;
};
class QueryMeetingRoomGroupListRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> request{};
  shared_ptr<QueryMeetingRoomGroupListRequestTenantContext> tenantContext{};

  QueryMeetingRoomGroupListRequest() {}

  explicit QueryMeetingRoomGroupListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (request) {
      res["Request"] = boost::any(*request);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Request") != m.end() && !m["Request"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Request"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      request = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryMeetingRoomGroupListRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryMeetingRoomGroupListRequestTenantContext>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomGroupListRequest() = default;
};
class QueryMeetingRoomGroupListShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> requestShrink{};
  shared_ptr<string> tenantContextShrink{};

  QueryMeetingRoomGroupListShrinkRequest() {}

  explicit QueryMeetingRoomGroupListShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestShrink) {
      res["Request"] = boost::any(*requestShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Request") != m.end() && !m["Request"].empty()) {
      requestShrink = make_shared<string>(boost::any_cast<string>(m["Request"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~QueryMeetingRoomGroupListShrinkRequest() = default;
};
class QueryMeetingRoomGroupListResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<long> parentId{};

  QueryMeetingRoomGroupListResponseBodyResult() {}

  explicit QueryMeetingRoomGroupListResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
  }


  virtual ~QueryMeetingRoomGroupListResponseBodyResult() = default;
};
class QueryMeetingRoomGroupListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<QueryMeetingRoomGroupListResponseBodyResult>> result{};

  QueryMeetingRoomGroupListResponseBody() {}

  explicit QueryMeetingRoomGroupListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<QueryMeetingRoomGroupListResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMeetingRoomGroupListResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<QueryMeetingRoomGroupListResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~QueryMeetingRoomGroupListResponseBody() = default;
};
class QueryMeetingRoomGroupListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMeetingRoomGroupListResponseBody> body{};

  QueryMeetingRoomGroupListResponse() {}

  explicit QueryMeetingRoomGroupListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMeetingRoomGroupListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMeetingRoomGroupListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomGroupListResponse() = default;
};
class QueryMeetingRoomListHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryMeetingRoomListHeadersAccountContext() {}

  explicit QueryMeetingRoomListHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryMeetingRoomListHeadersAccountContext() = default;
};
class QueryMeetingRoomListHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryMeetingRoomListHeadersAccountContext> accountContext{};

  QueryMeetingRoomListHeaders() {}

  explicit QueryMeetingRoomListHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryMeetingRoomListHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryMeetingRoomListHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomListHeaders() = default;
};
class QueryMeetingRoomListShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryMeetingRoomListShrinkHeaders() {}

  explicit QueryMeetingRoomListShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryMeetingRoomListShrinkHeaders() = default;
};
class QueryMeetingRoomListRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryMeetingRoomListRequestTenantContext() {}

  explicit QueryMeetingRoomListRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryMeetingRoomListRequestTenantContext() = default;
};
class QueryMeetingRoomListRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<long> nextToken{};
  shared_ptr<QueryMeetingRoomListRequestTenantContext> tenantContext{};

  QueryMeetingRoomListRequest() {}

  explicit QueryMeetingRoomListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryMeetingRoomListRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryMeetingRoomListRequestTenantContext>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomListRequest() = default;
};
class QueryMeetingRoomListShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<long> nextToken{};
  shared_ptr<string> tenantContextShrink{};

  QueryMeetingRoomListShrinkRequest() {}

  explicit QueryMeetingRoomListShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["NextToken"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~QueryMeetingRoomListShrinkRequest() = default;
};
class QueryMeetingRoomListResponseBodyResultRoomGroup : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<long> parentId{};

  QueryMeetingRoomListResponseBodyResultRoomGroup() {}

  explicit QueryMeetingRoomListResponseBodyResultRoomGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
  }


  virtual ~QueryMeetingRoomListResponseBodyResultRoomGroup() = default;
};
class QueryMeetingRoomListResponseBodyResultRoomLabels : public Darabonba::Model {
public:
  shared_ptr<long> labelId{};
  shared_ptr<string> labelName{};

  QueryMeetingRoomListResponseBodyResultRoomLabels() {}

  explicit QueryMeetingRoomListResponseBodyResultRoomLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (labelId) {
      res["LabelId"] = boost::any(*labelId);
    }
    if (labelName) {
      res["LabelName"] = boost::any(*labelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LabelId") != m.end() && !m["LabelId"].empty()) {
      labelId = make_shared<long>(boost::any_cast<long>(m["LabelId"]));
    }
    if (m.find("LabelName") != m.end() && !m["LabelName"].empty()) {
      labelName = make_shared<string>(boost::any_cast<string>(m["LabelName"]));
    }
  }


  virtual ~QueryMeetingRoomListResponseBodyResultRoomLabels() = default;
};
class QueryMeetingRoomListResponseBodyResultRoomLocation : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> title{};

  QueryMeetingRoomListResponseBodyResultRoomLocation() {}

  explicit QueryMeetingRoomListResponseBodyResultRoomLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~QueryMeetingRoomListResponseBodyResultRoomLocation() = default;
};
class QueryMeetingRoomListResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> corpId{};
  shared_ptr<string> isvRoomId{};
  shared_ptr<long> roomCapacity{};
  shared_ptr<QueryMeetingRoomListResponseBodyResultRoomGroup> roomGroup{};
  shared_ptr<string> roomId{};
  shared_ptr<vector<QueryMeetingRoomListResponseBodyResultRoomLabels>> roomLabels{};
  shared_ptr<QueryMeetingRoomListResponseBodyResultRoomLocation> roomLocation{};
  shared_ptr<string> roomName{};
  shared_ptr<string> roomPicture{};
  shared_ptr<string> roomStaffId{};
  shared_ptr<long> roomStatus{};

  QueryMeetingRoomListResponseBodyResult() {}

  explicit QueryMeetingRoomListResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (isvRoomId) {
      res["IsvRoomId"] = boost::any(*isvRoomId);
    }
    if (roomCapacity) {
      res["RoomCapacity"] = boost::any(*roomCapacity);
    }
    if (roomGroup) {
      res["RoomGroup"] = roomGroup ? boost::any(roomGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    if (roomLabels) {
      vector<boost::any> temp1;
      for(auto item1:*roomLabels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RoomLabels"] = boost::any(temp1);
    }
    if (roomLocation) {
      res["RoomLocation"] = roomLocation ? boost::any(roomLocation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (roomName) {
      res["RoomName"] = boost::any(*roomName);
    }
    if (roomPicture) {
      res["RoomPicture"] = boost::any(*roomPicture);
    }
    if (roomStaffId) {
      res["RoomStaffId"] = boost::any(*roomStaffId);
    }
    if (roomStatus) {
      res["RoomStatus"] = boost::any(*roomStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("IsvRoomId") != m.end() && !m["IsvRoomId"].empty()) {
      isvRoomId = make_shared<string>(boost::any_cast<string>(m["IsvRoomId"]));
    }
    if (m.find("RoomCapacity") != m.end() && !m["RoomCapacity"].empty()) {
      roomCapacity = make_shared<long>(boost::any_cast<long>(m["RoomCapacity"]));
    }
    if (m.find("RoomGroup") != m.end() && !m["RoomGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoomGroup"].type()) {
        QueryMeetingRoomListResponseBodyResultRoomGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoomGroup"]));
        roomGroup = make_shared<QueryMeetingRoomListResponseBodyResultRoomGroup>(model1);
      }
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
    if (m.find("RoomLabels") != m.end() && !m["RoomLabels"].empty()) {
      if (typeid(vector<boost::any>) == m["RoomLabels"].type()) {
        vector<QueryMeetingRoomListResponseBodyResultRoomLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RoomLabels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMeetingRoomListResponseBodyResultRoomLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roomLabels = make_shared<vector<QueryMeetingRoomListResponseBodyResultRoomLabels>>(expect1);
      }
    }
    if (m.find("RoomLocation") != m.end() && !m["RoomLocation"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoomLocation"].type()) {
        QueryMeetingRoomListResponseBodyResultRoomLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoomLocation"]));
        roomLocation = make_shared<QueryMeetingRoomListResponseBodyResultRoomLocation>(model1);
      }
    }
    if (m.find("RoomName") != m.end() && !m["RoomName"].empty()) {
      roomName = make_shared<string>(boost::any_cast<string>(m["RoomName"]));
    }
    if (m.find("RoomPicture") != m.end() && !m["RoomPicture"].empty()) {
      roomPicture = make_shared<string>(boost::any_cast<string>(m["RoomPicture"]));
    }
    if (m.find("RoomStaffId") != m.end() && !m["RoomStaffId"].empty()) {
      roomStaffId = make_shared<string>(boost::any_cast<string>(m["RoomStaffId"]));
    }
    if (m.find("RoomStatus") != m.end() && !m["RoomStatus"].empty()) {
      roomStatus = make_shared<long>(boost::any_cast<long>(m["RoomStatus"]));
    }
  }


  virtual ~QueryMeetingRoomListResponseBodyResult() = default;
};
class QueryMeetingRoomListResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> hasMore{};
  shared_ptr<long> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<QueryMeetingRoomListResponseBodyResult>> result{};

  QueryMeetingRoomListResponseBody() {}

  explicit QueryMeetingRoomListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasMore) {
      res["hasMore"] = boost::any(*hasMore);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hasMore") != m.end() && !m["hasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["hasMore"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<long>(boost::any_cast<long>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      if (typeid(vector<boost::any>) == m["result"].type()) {
        vector<QueryMeetingRoomListResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMeetingRoomListResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<QueryMeetingRoomListResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~QueryMeetingRoomListResponseBody() = default;
};
class QueryMeetingRoomListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMeetingRoomListResponseBody> body{};

  QueryMeetingRoomListResponse() {}

  explicit QueryMeetingRoomListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMeetingRoomListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMeetingRoomListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMeetingRoomListResponse() = default;
};
class QueryOrgTodoTasksHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryOrgTodoTasksHeadersAccountContext() {}

  explicit QueryOrgTodoTasksHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryOrgTodoTasksHeadersAccountContext() = default;
};
class QueryOrgTodoTasksHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryOrgTodoTasksHeadersAccountContext> accountContext{};

  QueryOrgTodoTasksHeaders() {}

  explicit QueryOrgTodoTasksHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryOrgTodoTasksHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryOrgTodoTasksHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryOrgTodoTasksHeaders() = default;
};
class QueryOrgTodoTasksShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryOrgTodoTasksShrinkHeaders() {}

  explicit QueryOrgTodoTasksShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryOrgTodoTasksShrinkHeaders() = default;
};
class QueryOrgTodoTasksRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryOrgTodoTasksRequestTenantContext() {}

  explicit QueryOrgTodoTasksRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryOrgTodoTasksRequestTenantContext() = default;
};
class QueryOrgTodoTasksRequest : public Darabonba::Model {
public:
  shared_ptr<QueryOrgTodoTasksRequestTenantContext> tenantContext{};
  shared_ptr<bool> isDone{};
  shared_ptr<string> nextToken{};

  QueryOrgTodoTasksRequest() {}

  explicit QueryOrgTodoTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isDone) {
      res["isDone"] = boost::any(*isDone);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryOrgTodoTasksRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryOrgTodoTasksRequestTenantContext>(model1);
      }
    }
    if (m.find("isDone") != m.end() && !m["isDone"].empty()) {
      isDone = make_shared<bool>(boost::any_cast<bool>(m["isDone"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
  }


  virtual ~QueryOrgTodoTasksRequest() = default;
};
class QueryOrgTodoTasksShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<bool> isDone{};
  shared_ptr<string> nextToken{};

  QueryOrgTodoTasksShrinkRequest() {}

  explicit QueryOrgTodoTasksShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (isDone) {
      res["isDone"] = boost::any(*isDone);
    }
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("isDone") != m.end() && !m["isDone"].empty()) {
      isDone = make_shared<bool>(boost::any_cast<bool>(m["isDone"]));
    }
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
  }


  virtual ~QueryOrgTodoTasksShrinkRequest() = default;
};
class QueryOrgTodoTasksResponseBodyTodoCardsDetailUrl : public Darabonba::Model {
public:
  shared_ptr<string> appUrl{};
  shared_ptr<string> pcUrl{};

  QueryOrgTodoTasksResponseBodyTodoCardsDetailUrl() {}

  explicit QueryOrgTodoTasksResponseBodyTodoCardsDetailUrl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appUrl) {
      res["appUrl"] = boost::any(*appUrl);
    }
    if (pcUrl) {
      res["pcUrl"] = boost::any(*pcUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("appUrl") != m.end() && !m["appUrl"].empty()) {
      appUrl = make_shared<string>(boost::any_cast<string>(m["appUrl"]));
    }
    if (m.find("pcUrl") != m.end() && !m["pcUrl"].empty()) {
      pcUrl = make_shared<string>(boost::any_cast<string>(m["pcUrl"]));
    }
  }


  virtual ~QueryOrgTodoTasksResponseBodyTodoCardsDetailUrl() = default;
};
class QueryOrgTodoTasksResponseBodyTodoCards : public Darabonba::Model {
public:
  shared_ptr<string> bizTag{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<QueryOrgTodoTasksResponseBodyTodoCardsDetailUrl> detailUrl{};
  shared_ptr<long> dueTime{};
  shared_ptr<bool> isDone{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<long> priority{};
  shared_ptr<string> sourceId{};
  shared_ptr<string> subject{};
  shared_ptr<string> taskId{};

  QueryOrgTodoTasksResponseBodyTodoCards() {}

  explicit QueryOrgTodoTasksResponseBodyTodoCards(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizTag) {
      res["bizTag"] = boost::any(*bizTag);
    }
    if (createdTime) {
      res["createdTime"] = boost::any(*createdTime);
    }
    if (creatorId) {
      res["creatorId"] = boost::any(*creatorId);
    }
    if (detailUrl) {
      res["detailUrl"] = detailUrl ? boost::any(detailUrl->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dueTime) {
      res["dueTime"] = boost::any(*dueTime);
    }
    if (isDone) {
      res["isDone"] = boost::any(*isDone);
    }
    if (modifiedTime) {
      res["modifiedTime"] = boost::any(*modifiedTime);
    }
    if (priority) {
      res["priority"] = boost::any(*priority);
    }
    if (sourceId) {
      res["sourceId"] = boost::any(*sourceId);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bizTag") != m.end() && !m["bizTag"].empty()) {
      bizTag = make_shared<string>(boost::any_cast<string>(m["bizTag"]));
    }
    if (m.find("createdTime") != m.end() && !m["createdTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["createdTime"]));
    }
    if (m.find("creatorId") != m.end() && !m["creatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["creatorId"]));
    }
    if (m.find("detailUrl") != m.end() && !m["detailUrl"].empty()) {
      if (typeid(map<string, boost::any>) == m["detailUrl"].type()) {
        QueryOrgTodoTasksResponseBodyTodoCardsDetailUrl model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["detailUrl"]));
        detailUrl = make_shared<QueryOrgTodoTasksResponseBodyTodoCardsDetailUrl>(model1);
      }
    }
    if (m.find("dueTime") != m.end() && !m["dueTime"].empty()) {
      dueTime = make_shared<long>(boost::any_cast<long>(m["dueTime"]));
    }
    if (m.find("isDone") != m.end() && !m["isDone"].empty()) {
      isDone = make_shared<bool>(boost::any_cast<bool>(m["isDone"]));
    }
    if (m.find("modifiedTime") != m.end() && !m["modifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["modifiedTime"]));
    }
    if (m.find("priority") != m.end() && !m["priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["priority"]));
    }
    if (m.find("sourceId") != m.end() && !m["sourceId"].empty()) {
      sourceId = make_shared<string>(boost::any_cast<string>(m["sourceId"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
  }


  virtual ~QueryOrgTodoTasksResponseBodyTodoCards() = default;
};
class QueryOrgTodoTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<QueryOrgTodoTasksResponseBodyTodoCards>> todoCards{};

  QueryOrgTodoTasksResponseBody() {}

  explicit QueryOrgTodoTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["nextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (todoCards) {
      vector<boost::any> temp1;
      for(auto item1:*todoCards){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["todoCards"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nextToken") != m.end() && !m["nextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["nextToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("todoCards") != m.end() && !m["todoCards"].empty()) {
      if (typeid(vector<boost::any>) == m["todoCards"].type()) {
        vector<QueryOrgTodoTasksResponseBodyTodoCards> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["todoCards"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrgTodoTasksResponseBodyTodoCards model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        todoCards = make_shared<vector<QueryOrgTodoTasksResponseBodyTodoCards>>(expect1);
      }
    }
  }


  virtual ~QueryOrgTodoTasksResponseBody() = default;
};
class QueryOrgTodoTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryOrgTodoTasksResponseBody> body{};

  QueryOrgTodoTasksResponse() {}

  explicit QueryOrgTodoTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOrgTodoTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOrgTodoTasksResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOrgTodoTasksResponse() = default;
};
class QueryScheduleConferenceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  QueryScheduleConferenceHeadersAccountContext() {}

  explicit QueryScheduleConferenceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~QueryScheduleConferenceHeadersAccountContext() = default;
};
class QueryScheduleConferenceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<QueryScheduleConferenceHeadersAccountContext> accountContext{};

  QueryScheduleConferenceHeaders() {}

  explicit QueryScheduleConferenceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        QueryScheduleConferenceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<QueryScheduleConferenceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~QueryScheduleConferenceHeaders() = default;
};
class QueryScheduleConferenceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  QueryScheduleConferenceShrinkHeaders() {}

  explicit QueryScheduleConferenceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~QueryScheduleConferenceShrinkHeaders() = default;
};
class QueryScheduleConferenceRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  QueryScheduleConferenceRequestTenantContext() {}

  explicit QueryScheduleConferenceRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~QueryScheduleConferenceRequestTenantContext() = default;
};
class QueryScheduleConferenceRequest : public Darabonba::Model {
public:
  shared_ptr<string> requestUnionId{};
  shared_ptr<QueryScheduleConferenceRequestTenantContext> tenantContext{};

  QueryScheduleConferenceRequest() {}

  explicit QueryScheduleConferenceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestUnionId) {
      res["RequestUnionId"] = boost::any(*requestUnionId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestUnionId") != m.end() && !m["RequestUnionId"].empty()) {
      requestUnionId = make_shared<string>(boost::any_cast<string>(m["RequestUnionId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        QueryScheduleConferenceRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<QueryScheduleConferenceRequestTenantContext>(model1);
      }
    }
  }


  virtual ~QueryScheduleConferenceRequest() = default;
};
class QueryScheduleConferenceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> requestUnionId{};
  shared_ptr<string> tenantContextShrink{};

  QueryScheduleConferenceShrinkRequest() {}

  explicit QueryScheduleConferenceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestUnionId) {
      res["RequestUnionId"] = boost::any(*requestUnionId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestUnionId") != m.end() && !m["RequestUnionId"].empty()) {
      requestUnionId = make_shared<string>(boost::any_cast<string>(m["RequestUnionId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~QueryScheduleConferenceShrinkRequest() = default;
};
class QueryScheduleConferenceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<vector<string>> phones{};
  shared_ptr<string> requestId{};
  shared_ptr<string> roomCode{};
  shared_ptr<string> scheduleConferenceId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  QueryScheduleConferenceResponseBody() {}

  explicit QueryScheduleConferenceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (phones) {
      res["phones"] = boost::any(*phones);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (roomCode) {
      res["roomCode"] = boost::any(*roomCode);
    }
    if (scheduleConferenceId) {
      res["scheduleConferenceId"] = boost::any(*scheduleConferenceId);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("phones") != m.end() && !m["phones"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["phones"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["phones"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      phones = make_shared<vector<string>>(toVec1);
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("roomCode") != m.end() && !m["roomCode"].empty()) {
      roomCode = make_shared<string>(boost::any_cast<string>(m["roomCode"]));
    }
    if (m.find("scheduleConferenceId") != m.end() && !m["scheduleConferenceId"].empty()) {
      scheduleConferenceId = make_shared<string>(boost::any_cast<string>(m["scheduleConferenceId"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~QueryScheduleConferenceResponseBody() = default;
};
class QueryScheduleConferenceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryScheduleConferenceResponseBody> body{};

  QueryScheduleConferenceResponse() {}

  explicit QueryScheduleConferenceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryScheduleConferenceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryScheduleConferenceResponseBody>(model1);
      }
    }
  }


  virtual ~QueryScheduleConferenceResponse() = default;
};
class ReceiverListReportHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ReceiverListReportHeadersAccountContext() {}

  explicit ReceiverListReportHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~ReceiverListReportHeadersAccountContext() = default;
};
class ReceiverListReportHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<ReceiverListReportHeadersAccountContext> accountContext{};

  ReceiverListReportHeaders() {}

  explicit ReceiverListReportHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        ReceiverListReportHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<ReceiverListReportHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~ReceiverListReportHeaders() = default;
};
class ReceiverListReportShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  ReceiverListReportShrinkHeaders() {}

  explicit ReceiverListReportShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~ReceiverListReportShrinkHeaders() = default;
};
class ReceiverListReportRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  ReceiverListReportRequestTenantContext() {}

  explicit ReceiverListReportRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~ReceiverListReportRequestTenantContext() = default;
};
class ReceiverListReportRequest : public Darabonba::Model {
public:
  shared_ptr<long> offset{};
  shared_ptr<string> reportId{};
  shared_ptr<long> size{};
  shared_ptr<ReceiverListReportRequestTenantContext> tenantContext{};

  ReceiverListReportRequest() {}

  explicit ReceiverListReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        ReceiverListReportRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<ReceiverListReportRequestTenantContext>(model1);
      }
    }
  }


  virtual ~ReceiverListReportRequest() = default;
};
class ReceiverListReportShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> offset{};
  shared_ptr<string> reportId{};
  shared_ptr<long> size{};
  shared_ptr<string> tenantContextShrink{};

  ReceiverListReportShrinkRequest() {}

  explicit ReceiverListReportShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~ReceiverListReportShrinkRequest() = default;
};
class ReceiverListReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> hasMore{};
  shared_ptr<long> nextCursor{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> useridList{};

  ReceiverListReportResponseBody() {}

  explicit ReceiverListReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasMore) {
      res["hasMore"] = boost::any(*hasMore);
    }
    if (nextCursor) {
      res["nextCursor"] = boost::any(*nextCursor);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (useridList) {
      res["useridList"] = boost::any(*useridList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hasMore") != m.end() && !m["hasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["hasMore"]));
    }
    if (m.find("nextCursor") != m.end() && !m["nextCursor"].empty()) {
      nextCursor = make_shared<long>(boost::any_cast<long>(m["nextCursor"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("useridList") != m.end() && !m["useridList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["useridList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["useridList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      useridList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ReceiverListReportResponseBody() = default;
};
class ReceiverListReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReceiverListReportResponseBody> body{};

  ReceiverListReportResponse() {}

  explicit ReceiverListReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReceiverListReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReceiverListReportResponseBody>(model1);
      }
    }
  }


  virtual ~ReceiverListReportResponse() = default;
};
class RemoveAttendeeHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  RemoveAttendeeHeadersAccountContext() {}

  explicit RemoveAttendeeHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~RemoveAttendeeHeadersAccountContext() = default;
};
class RemoveAttendeeHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<RemoveAttendeeHeadersAccountContext> accountContext{};

  RemoveAttendeeHeaders() {}

  explicit RemoveAttendeeHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        RemoveAttendeeHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<RemoveAttendeeHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~RemoveAttendeeHeaders() = default;
};
class RemoveAttendeeShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  RemoveAttendeeShrinkHeaders() {}

  explicit RemoveAttendeeShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~RemoveAttendeeShrinkHeaders() = default;
};
class RemoveAttendeeRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> attendeesToRemove{};
  shared_ptr<string> calendarId{};
  shared_ptr<string> eventId{};

  RemoveAttendeeRequest() {}

  explicit RemoveAttendeeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendeesToRemove) {
      res["AttendeesToRemove"] = boost::any(*attendeesToRemove);
    }
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttendeesToRemove") != m.end() && !m["AttendeesToRemove"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AttendeesToRemove"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AttendeesToRemove"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      attendeesToRemove = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
  }


  virtual ~RemoveAttendeeRequest() = default;
};
class RemoveAttendeeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> attendeesToRemoveShrink{};
  shared_ptr<string> calendarId{};
  shared_ptr<string> eventId{};

  RemoveAttendeeShrinkRequest() {}

  explicit RemoveAttendeeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attendeesToRemoveShrink) {
      res["AttendeesToRemove"] = boost::any(*attendeesToRemoveShrink);
    }
    if (calendarId) {
      res["CalendarId"] = boost::any(*calendarId);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttendeesToRemove") != m.end() && !m["AttendeesToRemove"].empty()) {
      attendeesToRemoveShrink = make_shared<string>(boost::any_cast<string>(m["AttendeesToRemove"]));
    }
    if (m.find("CalendarId") != m.end() && !m["CalendarId"].empty()) {
      calendarId = make_shared<string>(boost::any_cast<string>(m["CalendarId"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
  }


  virtual ~RemoveAttendeeShrinkRequest() = default;
};
class RemoveAttendeeResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};

  RemoveAttendeeResponseBodyContent() {}

  explicit RemoveAttendeeResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
  }


  virtual ~RemoveAttendeeResponseBodyContent() = default;
};
class RemoveAttendeeResponseBody : public Darabonba::Model {
public:
  shared_ptr<RemoveAttendeeResponseBodyContent> content{};
  shared_ptr<string> errorCode{};
  shared_ptr<map<string, boost::any>> errorCtx{};
  shared_ptr<string> errorMsg{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RemoveAttendeeResponseBody() {}

  explicit RemoveAttendeeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorCtx) {
      res["ErrorCtx"] = boost::any(*errorCtx);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        RemoveAttendeeResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<RemoveAttendeeResponseBodyContent>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorCtx") != m.end() && !m["ErrorCtx"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ErrorCtx"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      errorCtx = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RemoveAttendeeResponseBody() = default;
};
class RemoveAttendeeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveAttendeeResponseBody> body{};

  RemoveAttendeeResponse() {}

  explicit RemoveAttendeeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveAttendeeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveAttendeeResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveAttendeeResponse() = default;
};
class SaveContentHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SaveContentHeadersAccountContext() {}

  explicit SaveContentHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SaveContentHeadersAccountContext() = default;
};
class SaveContentHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SaveContentHeadersAccountContext> accountContext{};

  SaveContentHeaders() {}

  explicit SaveContentHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SaveContentHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SaveContentHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SaveContentHeaders() = default;
};
class SaveContentShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SaveContentShrinkHeaders() {}

  explicit SaveContentShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SaveContentShrinkHeaders() = default;
};
class SaveContentRequestContents : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentType{};
  shared_ptr<string> key{};
  shared_ptr<long> sort{};
  shared_ptr<long> type{};

  SaveContentRequestContents() {}

  explicit SaveContentRequestContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<long>(boost::any_cast<long>(m["Sort"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~SaveContentRequestContents() = default;
};
class SaveContentRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  SaveContentRequestTenantContext() {}

  explicit SaveContentRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~SaveContentRequestTenantContext() = default;
};
class SaveContentRequest : public Darabonba::Model {
public:
  shared_ptr<vector<SaveContentRequestContents>> contents{};
  shared_ptr<string> ddFrom{};
  shared_ptr<string> templateId{};
  shared_ptr<SaveContentRequestTenantContext> tenantContext{};

  SaveContentRequest() {}

  explicit SaveContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contents) {
      vector<boost::any> temp1;
      for(auto item1:*contents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contents"] = boost::any(temp1);
    }
    if (ddFrom) {
      res["DdFrom"] = boost::any(*ddFrom);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      if (typeid(vector<boost::any>) == m["Contents"].type()) {
        vector<SaveContentRequestContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SaveContentRequestContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contents = make_shared<vector<SaveContentRequestContents>>(expect1);
      }
    }
    if (m.find("DdFrom") != m.end() && !m["DdFrom"].empty()) {
      ddFrom = make_shared<string>(boost::any_cast<string>(m["DdFrom"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        SaveContentRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<SaveContentRequestTenantContext>(model1);
      }
    }
  }


  virtual ~SaveContentRequest() = default;
};
class SaveContentShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> contentsShrink{};
  shared_ptr<string> ddFrom{};
  shared_ptr<string> templateId{};
  shared_ptr<string> tenantContextShrink{};

  SaveContentShrinkRequest() {}

  explicit SaveContentShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentsShrink) {
      res["Contents"] = boost::any(*contentsShrink);
    }
    if (ddFrom) {
      res["DdFrom"] = boost::any(*ddFrom);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      contentsShrink = make_shared<string>(boost::any_cast<string>(m["Contents"]));
    }
    if (m.find("DdFrom") != m.end() && !m["DdFrom"].empty()) {
      ddFrom = make_shared<string>(boost::any_cast<string>(m["DdFrom"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~SaveContentShrinkRequest() = default;
};
class SaveContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SaveContentResponseBody() {}

  explicit SaveContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~SaveContentResponseBody() = default;
};
class SaveContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveContentResponseBody> body{};

  SaveContentResponse() {}

  explicit SaveContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveContentResponseBody>(model1);
      }
    }
  }


  virtual ~SaveContentResponse() = default;
};
class SetColumnsVisibilityHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SetColumnsVisibilityHeadersAccountContext() {}

  explicit SetColumnsVisibilityHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SetColumnsVisibilityHeadersAccountContext() = default;
};
class SetColumnsVisibilityHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SetColumnsVisibilityHeadersAccountContext> accountContext{};

  SetColumnsVisibilityHeaders() {}

  explicit SetColumnsVisibilityHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SetColumnsVisibilityHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SetColumnsVisibilityHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SetColumnsVisibilityHeaders() = default;
};
class SetColumnsVisibilityShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SetColumnsVisibilityShrinkHeaders() {}

  explicit SetColumnsVisibilityShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SetColumnsVisibilityShrinkHeaders() = default;
};
class SetColumnsVisibilityRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  SetColumnsVisibilityRequestTenantContext() {}

  explicit SetColumnsVisibilityRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~SetColumnsVisibilityRequestTenantContext() = default;
};
class SetColumnsVisibilityRequest : public Darabonba::Model {
public:
  shared_ptr<long> column{};
  shared_ptr<long> columnCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<SetColumnsVisibilityRequestTenantContext> tenantContext{};
  shared_ptr<string> visibility{};
  shared_ptr<string> workbookId{};

  SetColumnsVisibilityRequest() {}

  explicit SetColumnsVisibilityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (column) {
      res["Column"] = boost::any(*column);
    }
    if (columnCount) {
      res["ColumnCount"] = boost::any(*columnCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Column") != m.end() && !m["Column"].empty()) {
      column = make_shared<long>(boost::any_cast<long>(m["Column"]));
    }
    if (m.find("ColumnCount") != m.end() && !m["ColumnCount"].empty()) {
      columnCount = make_shared<long>(boost::any_cast<long>(m["ColumnCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        SetColumnsVisibilityRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<SetColumnsVisibilityRequestTenantContext>(model1);
      }
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~SetColumnsVisibilityRequest() = default;
};
class SetColumnsVisibilityShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> column{};
  shared_ptr<long> columnCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> visibility{};
  shared_ptr<string> workbookId{};

  SetColumnsVisibilityShrinkRequest() {}

  explicit SetColumnsVisibilityShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (column) {
      res["Column"] = boost::any(*column);
    }
    if (columnCount) {
      res["ColumnCount"] = boost::any(*columnCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Column") != m.end() && !m["Column"].empty()) {
      column = make_shared<long>(boost::any_cast<long>(m["Column"]));
    }
    if (m.find("ColumnCount") != m.end() && !m["ColumnCount"].empty()) {
      columnCount = make_shared<long>(boost::any_cast<long>(m["ColumnCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~SetColumnsVisibilityShrinkRequest() = default;
};
class SetColumnsVisibilityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  SetColumnsVisibilityResponseBody() {}

  explicit SetColumnsVisibilityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~SetColumnsVisibilityResponseBody() = default;
};
class SetColumnsVisibilityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetColumnsVisibilityResponseBody> body{};

  SetColumnsVisibilityResponse() {}

  explicit SetColumnsVisibilityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetColumnsVisibilityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetColumnsVisibilityResponseBody>(model1);
      }
    }
  }


  virtual ~SetColumnsVisibilityResponse() = default;
};
class SetRowsVisibilityHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SetRowsVisibilityHeadersAccountContext() {}

  explicit SetRowsVisibilityHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SetRowsVisibilityHeadersAccountContext() = default;
};
class SetRowsVisibilityHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SetRowsVisibilityHeadersAccountContext> accountContext{};

  SetRowsVisibilityHeaders() {}

  explicit SetRowsVisibilityHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SetRowsVisibilityHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SetRowsVisibilityHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SetRowsVisibilityHeaders() = default;
};
class SetRowsVisibilityShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SetRowsVisibilityShrinkHeaders() {}

  explicit SetRowsVisibilityShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SetRowsVisibilityShrinkHeaders() = default;
};
class SetRowsVisibilityRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  SetRowsVisibilityRequestTenantContext() {}

  explicit SetRowsVisibilityRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~SetRowsVisibilityRequestTenantContext() = default;
};
class SetRowsVisibilityRequest : public Darabonba::Model {
public:
  shared_ptr<long> row{};
  shared_ptr<long> rowCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<SetRowsVisibilityRequestTenantContext> tenantContext{};
  shared_ptr<string> visibility{};
  shared_ptr<string> workbookId{};

  SetRowsVisibilityRequest() {}

  explicit SetRowsVisibilityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (row) {
      res["Row"] = boost::any(*row);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Row") != m.end() && !m["Row"].empty()) {
      row = make_shared<long>(boost::any_cast<long>(m["Row"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["RowCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        SetRowsVisibilityRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<SetRowsVisibilityRequestTenantContext>(model1);
      }
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~SetRowsVisibilityRequest() = default;
};
class SetRowsVisibilityShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> row{};
  shared_ptr<long> rowCount{};
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> visibility{};
  shared_ptr<string> workbookId{};

  SetRowsVisibilityShrinkRequest() {}

  explicit SetRowsVisibilityShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (row) {
      res["Row"] = boost::any(*row);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Row") != m.end() && !m["Row"].empty()) {
      row = make_shared<long>(boost::any_cast<long>(m["Row"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["RowCount"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~SetRowsVisibilityShrinkRequest() = default;
};
class SetRowsVisibilityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  SetRowsVisibilityResponseBody() {}

  explicit SetRowsVisibilityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~SetRowsVisibilityResponseBody() = default;
};
class SetRowsVisibilityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetRowsVisibilityResponseBody> body{};

  SetRowsVisibilityResponse() {}

  explicit SetRowsVisibilityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetRowsVisibilityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetRowsVisibilityResponseBody>(model1);
      }
    }
  }


  virtual ~SetRowsVisibilityResponse() = default;
};
class SimpleListReportHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  SimpleListReportHeadersAccountContext() {}

  explicit SimpleListReportHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~SimpleListReportHeadersAccountContext() = default;
};
class SimpleListReportHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<SimpleListReportHeadersAccountContext> accountContext{};

  SimpleListReportHeaders() {}

  explicit SimpleListReportHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        SimpleListReportHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<SimpleListReportHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~SimpleListReportHeaders() = default;
};
class SimpleListReportShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  SimpleListReportShrinkHeaders() {}

  explicit SimpleListReportShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~SimpleListReportShrinkHeaders() = default;
};
class SimpleListReportRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  SimpleListReportRequestTenantContext() {}

  explicit SimpleListReportRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~SimpleListReportRequestTenantContext() = default;
};
class SimpleListReportRequest : public Darabonba::Model {
public:
  shared_ptr<long> cursor{};
  shared_ptr<long> endTime{};
  shared_ptr<long> size{};
  shared_ptr<long> startTime{};
  shared_ptr<string> templateName{};
  shared_ptr<SimpleListReportRequestTenantContext> tenantContext{};

  SimpleListReportRequest() {}

  explicit SimpleListReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cursor) {
      res["Cursor"] = boost::any(*cursor);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cursor") != m.end() && !m["Cursor"].empty()) {
      cursor = make_shared<long>(boost::any_cast<long>(m["Cursor"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        SimpleListReportRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<SimpleListReportRequestTenantContext>(model1);
      }
    }
  }


  virtual ~SimpleListReportRequest() = default;
};
class SimpleListReportShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> cursor{};
  shared_ptr<long> endTime{};
  shared_ptr<long> size{};
  shared_ptr<long> startTime{};
  shared_ptr<string> templateName{};
  shared_ptr<string> tenantContextShrink{};

  SimpleListReportShrinkRequest() {}

  explicit SimpleListReportShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cursor) {
      res["Cursor"] = boost::any(*cursor);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cursor") != m.end() && !m["Cursor"].empty()) {
      cursor = make_shared<long>(boost::any_cast<long>(m["Cursor"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~SimpleListReportShrinkRequest() = default;
};
class SimpleListReportResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> creatorName{};
  shared_ptr<string> deptName{};
  shared_ptr<string> remark{};
  shared_ptr<string> reportId{};
  shared_ptr<string> templateName{};

  SimpleListReportResponseBodyDataList() {}

  explicit SimpleListReportResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (deptName) {
      res["DeptName"] = boost::any(*deptName);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("DeptName") != m.end() && !m["DeptName"].empty()) {
      deptName = make_shared<string>(boost::any_cast<string>(m["DeptName"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~SimpleListReportResponseBodyDataList() = default;
};
class SimpleListReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<SimpleListReportResponseBodyDataList>> dataList{};
  shared_ptr<bool> hasMore{};
  shared_ptr<long> nextCursor{};
  shared_ptr<string> requestId{};
  shared_ptr<long> size{};

  SimpleListReportResponseBody() {}

  explicit SimpleListReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataList) {
      vector<boost::any> temp1;
      for(auto item1:*dataList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dataList"] = boost::any(temp1);
    }
    if (hasMore) {
      res["hasMore"] = boost::any(*hasMore);
    }
    if (nextCursor) {
      res["nextCursor"] = boost::any(*nextCursor);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dataList") != m.end() && !m["dataList"].empty()) {
      if (typeid(vector<boost::any>) == m["dataList"].type()) {
        vector<SimpleListReportResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dataList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SimpleListReportResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataList = make_shared<vector<SimpleListReportResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("hasMore") != m.end() && !m["hasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["hasMore"]));
    }
    if (m.find("nextCursor") != m.end() && !m["nextCursor"].empty()) {
      nextCursor = make_shared<long>(boost::any_cast<long>(m["nextCursor"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
  }


  virtual ~SimpleListReportResponseBody() = default;
};
class SimpleListReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SimpleListReportResponseBody> body{};

  SimpleListReportResponse() {}

  explicit SimpleListReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SimpleListReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SimpleListReportResponseBody>(model1);
      }
    }
  }


  virtual ~SimpleListReportResponse() = default;
};
class StartCloudRecordHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  StartCloudRecordHeadersAccountContext() {}

  explicit StartCloudRecordHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~StartCloudRecordHeadersAccountContext() = default;
};
class StartCloudRecordHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<StartCloudRecordHeadersAccountContext> accountContext{};

  StartCloudRecordHeaders() {}

  explicit StartCloudRecordHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        StartCloudRecordHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<StartCloudRecordHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~StartCloudRecordHeaders() = default;
};
class StartCloudRecordShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  StartCloudRecordShrinkHeaders() {}

  explicit StartCloudRecordShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~StartCloudRecordShrinkHeaders() = default;
};
class StartCloudRecordRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  StartCloudRecordRequestTenantContext() {}

  explicit StartCloudRecordRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~StartCloudRecordRequestTenantContext() = default;
};
class StartCloudRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> mode{};
  shared_ptr<string> smallWindowPosition{};
  shared_ptr<StartCloudRecordRequestTenantContext> tenantContext{};
  shared_ptr<string> conferenceId{};

  StartCloudRecordRequest() {}

  explicit StartCloudRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (smallWindowPosition) {
      res["SmallWindowPosition"] = boost::any(*smallWindowPosition);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("SmallWindowPosition") != m.end() && !m["SmallWindowPosition"].empty()) {
      smallWindowPosition = make_shared<string>(boost::any_cast<string>(m["SmallWindowPosition"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        StartCloudRecordRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<StartCloudRecordRequestTenantContext>(model1);
      }
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~StartCloudRecordRequest() = default;
};
class StartCloudRecordShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> mode{};
  shared_ptr<string> smallWindowPosition{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> conferenceId{};

  StartCloudRecordShrinkRequest() {}

  explicit StartCloudRecordShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (smallWindowPosition) {
      res["SmallWindowPosition"] = boost::any(*smallWindowPosition);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("SmallWindowPosition") != m.end() && !m["SmallWindowPosition"].empty()) {
      smallWindowPosition = make_shared<string>(boost::any_cast<string>(m["SmallWindowPosition"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~StartCloudRecordShrinkRequest() = default;
};
class StartCloudRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> requestId{};

  StartCloudRecordResponseBody() {}

  explicit StartCloudRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~StartCloudRecordResponseBody() = default;
};
class StartCloudRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartCloudRecordResponseBody> body{};

  StartCloudRecordResponse() {}

  explicit StartCloudRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartCloudRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartCloudRecordResponseBody>(model1);
      }
    }
  }


  virtual ~StartCloudRecordResponse() = default;
};
class StatisticsListByTypeReportHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  StatisticsListByTypeReportHeadersAccountContext() {}

  explicit StatisticsListByTypeReportHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~StatisticsListByTypeReportHeadersAccountContext() = default;
};
class StatisticsListByTypeReportHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<StatisticsListByTypeReportHeadersAccountContext> accountContext{};

  StatisticsListByTypeReportHeaders() {}

  explicit StatisticsListByTypeReportHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        StatisticsListByTypeReportHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<StatisticsListByTypeReportHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~StatisticsListByTypeReportHeaders() = default;
};
class StatisticsListByTypeReportShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  StatisticsListByTypeReportShrinkHeaders() {}

  explicit StatisticsListByTypeReportShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~StatisticsListByTypeReportShrinkHeaders() = default;
};
class StatisticsListByTypeReportRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  StatisticsListByTypeReportRequestTenantContext() {}

  explicit StatisticsListByTypeReportRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~StatisticsListByTypeReportRequestTenantContext() = default;
};
class StatisticsListByTypeReportRequest : public Darabonba::Model {
public:
  shared_ptr<long> offset{};
  shared_ptr<string> reportId{};
  shared_ptr<long> size{};
  shared_ptr<StatisticsListByTypeReportRequestTenantContext> tenantContext{};
  shared_ptr<long> type{};

  StatisticsListByTypeReportRequest() {}

  explicit StatisticsListByTypeReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        StatisticsListByTypeReportRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<StatisticsListByTypeReportRequestTenantContext>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~StatisticsListByTypeReportRequest() = default;
};
class StatisticsListByTypeReportShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> offset{};
  shared_ptr<string> reportId{};
  shared_ptr<long> size{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<long> type{};

  StatisticsListByTypeReportShrinkRequest() {}

  explicit StatisticsListByTypeReportShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~StatisticsListByTypeReportShrinkRequest() = default;
};
class StatisticsListByTypeReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> hasMore{};
  shared_ptr<long> nextCursor{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> useridList{};

  StatisticsListByTypeReportResponseBody() {}

  explicit StatisticsListByTypeReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasMore) {
      res["hasMore"] = boost::any(*hasMore);
    }
    if (nextCursor) {
      res["nextCursor"] = boost::any(*nextCursor);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (useridList) {
      res["useridList"] = boost::any(*useridList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("hasMore") != m.end() && !m["hasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["hasMore"]));
    }
    if (m.find("nextCursor") != m.end() && !m["nextCursor"].empty()) {
      nextCursor = make_shared<long>(boost::any_cast<long>(m["nextCursor"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("useridList") != m.end() && !m["useridList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["useridList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["useridList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      useridList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~StatisticsListByTypeReportResponseBody() = default;
};
class StatisticsListByTypeReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StatisticsListByTypeReportResponseBody> body{};

  StatisticsListByTypeReportResponse() {}

  explicit StatisticsListByTypeReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StatisticsListByTypeReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StatisticsListByTypeReportResponseBody>(model1);
      }
    }
  }


  virtual ~StatisticsListByTypeReportResponse() = default;
};
class StatisticsReportHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  StatisticsReportHeadersAccountContext() {}

  explicit StatisticsReportHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~StatisticsReportHeadersAccountContext() = default;
};
class StatisticsReportHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<StatisticsReportHeadersAccountContext> accountContext{};

  StatisticsReportHeaders() {}

  explicit StatisticsReportHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        StatisticsReportHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<StatisticsReportHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~StatisticsReportHeaders() = default;
};
class StatisticsReportShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  StatisticsReportShrinkHeaders() {}

  explicit StatisticsReportShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~StatisticsReportShrinkHeaders() = default;
};
class StatisticsReportRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  StatisticsReportRequestTenantContext() {}

  explicit StatisticsReportRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~StatisticsReportRequestTenantContext() = default;
};
class StatisticsReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> reportId{};
  shared_ptr<StatisticsReportRequestTenantContext> tenantContext{};

  StatisticsReportRequest() {}

  explicit StatisticsReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        StatisticsReportRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<StatisticsReportRequestTenantContext>(model1);
      }
    }
  }


  virtual ~StatisticsReportRequest() = default;
};
class StatisticsReportShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> reportId{};
  shared_ptr<string> tenantContextShrink{};

  StatisticsReportShrinkRequest() {}

  explicit StatisticsReportShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~StatisticsReportShrinkRequest() = default;
};
class StatisticsReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> commentNum{};
  shared_ptr<long> commentUserNum{};
  shared_ptr<long> likeNum{};
  shared_ptr<long> readNum{};
  shared_ptr<string> requestId{};

  StatisticsReportResponseBody() {}

  explicit StatisticsReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commentNum) {
      res["commentNum"] = boost::any(*commentNum);
    }
    if (commentUserNum) {
      res["commentUserNum"] = boost::any(*commentUserNum);
    }
    if (likeNum) {
      res["likeNum"] = boost::any(*likeNum);
    }
    if (readNum) {
      res["readNum"] = boost::any(*readNum);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commentNum") != m.end() && !m["commentNum"].empty()) {
      commentNum = make_shared<long>(boost::any_cast<long>(m["commentNum"]));
    }
    if (m.find("commentUserNum") != m.end() && !m["commentUserNum"].empty()) {
      commentUserNum = make_shared<long>(boost::any_cast<long>(m["commentUserNum"]));
    }
    if (m.find("likeNum") != m.end() && !m["likeNum"].empty()) {
      likeNum = make_shared<long>(boost::any_cast<long>(m["likeNum"]));
    }
    if (m.find("readNum") != m.end() && !m["readNum"].empty()) {
      readNum = make_shared<long>(boost::any_cast<long>(m["readNum"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~StatisticsReportResponseBody() = default;
};
class StatisticsReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StatisticsReportResponseBody> body{};

  StatisticsReportResponse() {}

  explicit StatisticsReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StatisticsReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StatisticsReportResponseBody>(model1);
      }
    }
  }


  virtual ~StatisticsReportResponse() = default;
};
class StopCloudRecordHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  StopCloudRecordHeadersAccountContext() {}

  explicit StopCloudRecordHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~StopCloudRecordHeadersAccountContext() = default;
};
class StopCloudRecordHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<StopCloudRecordHeadersAccountContext> accountContext{};

  StopCloudRecordHeaders() {}

  explicit StopCloudRecordHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        StopCloudRecordHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<StopCloudRecordHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~StopCloudRecordHeaders() = default;
};
class StopCloudRecordShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  StopCloudRecordShrinkHeaders() {}

  explicit StopCloudRecordShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~StopCloudRecordShrinkHeaders() = default;
};
class StopCloudRecordRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  StopCloudRecordRequestTenantContext() {}

  explicit StopCloudRecordRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~StopCloudRecordRequestTenantContext() = default;
};
class StopCloudRecordRequest : public Darabonba::Model {
public:
  shared_ptr<StopCloudRecordRequestTenantContext> tenantContext{};
  shared_ptr<string> conferenceId{};

  StopCloudRecordRequest() {}

  explicit StopCloudRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        StopCloudRecordRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<StopCloudRecordRequestTenantContext>(model1);
      }
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~StopCloudRecordRequest() = default;
};
class StopCloudRecordShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> conferenceId{};

  StopCloudRecordShrinkRequest() {}

  explicit StopCloudRecordShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (conferenceId) {
      res["conferenceId"] = boost::any(*conferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("conferenceId") != m.end() && !m["conferenceId"].empty()) {
      conferenceId = make_shared<string>(boost::any_cast<string>(m["conferenceId"]));
    }
  }


  virtual ~StopCloudRecordShrinkRequest() = default;
};
class StopCloudRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> requestId{};

  StopCloudRecordResponseBody() {}

  explicit StopCloudRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~StopCloudRecordResponseBody() = default;
};
class StopCloudRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopCloudRecordResponseBody> body{};

  StopCloudRecordResponse() {}

  explicit StopCloudRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopCloudRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopCloudRecordResponseBody>(model1);
      }
    }
  }


  virtual ~StopCloudRecordResponse() = default;
};
class UpdateLiveHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateLiveHeadersAccountContext() {}

  explicit UpdateLiveHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateLiveHeadersAccountContext() = default;
};
class UpdateLiveHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateLiveHeadersAccountContext> accountContext{};

  UpdateLiveHeaders() {}

  explicit UpdateLiveHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateLiveHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateLiveHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateLiveHeaders() = default;
};
class UpdateLiveShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateLiveShrinkHeaders() {}

  explicit UpdateLiveShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateLiveShrinkHeaders() = default;
};
class UpdateLiveRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateLiveRequestTenantContext() {}

  explicit UpdateLiveRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateLiveRequestTenantContext() = default;
};
class UpdateLiveRequest : public Darabonba::Model {
public:
  shared_ptr<string> coverUrl{};
  shared_ptr<string> introduction{};
  shared_ptr<string> liveId{};
  shared_ptr<long> preEndTime{};
  shared_ptr<long> preStartTime{};
  shared_ptr<UpdateLiveRequestTenantContext> tenantContext{};
  shared_ptr<string> title{};

  UpdateLiveRequest() {}

  explicit UpdateLiveRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverUrl) {
      res["CoverUrl"] = boost::any(*coverUrl);
    }
    if (introduction) {
      res["Introduction"] = boost::any(*introduction);
    }
    if (liveId) {
      res["LiveId"] = boost::any(*liveId);
    }
    if (preEndTime) {
      res["PreEndTime"] = boost::any(*preEndTime);
    }
    if (preStartTime) {
      res["PreStartTime"] = boost::any(*preStartTime);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverUrl") != m.end() && !m["CoverUrl"].empty()) {
      coverUrl = make_shared<string>(boost::any_cast<string>(m["CoverUrl"]));
    }
    if (m.find("Introduction") != m.end() && !m["Introduction"].empty()) {
      introduction = make_shared<string>(boost::any_cast<string>(m["Introduction"]));
    }
    if (m.find("LiveId") != m.end() && !m["LiveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["LiveId"]));
    }
    if (m.find("PreEndTime") != m.end() && !m["PreEndTime"].empty()) {
      preEndTime = make_shared<long>(boost::any_cast<long>(m["PreEndTime"]));
    }
    if (m.find("PreStartTime") != m.end() && !m["PreStartTime"].empty()) {
      preStartTime = make_shared<long>(boost::any_cast<long>(m["PreStartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateLiveRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateLiveRequestTenantContext>(model1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateLiveRequest() = default;
};
class UpdateLiveShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> coverUrl{};
  shared_ptr<string> introduction{};
  shared_ptr<string> liveId{};
  shared_ptr<long> preEndTime{};
  shared_ptr<long> preStartTime{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> title{};

  UpdateLiveShrinkRequest() {}

  explicit UpdateLiveShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverUrl) {
      res["CoverUrl"] = boost::any(*coverUrl);
    }
    if (introduction) {
      res["Introduction"] = boost::any(*introduction);
    }
    if (liveId) {
      res["LiveId"] = boost::any(*liveId);
    }
    if (preEndTime) {
      res["PreEndTime"] = boost::any(*preEndTime);
    }
    if (preStartTime) {
      res["PreStartTime"] = boost::any(*preStartTime);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverUrl") != m.end() && !m["CoverUrl"].empty()) {
      coverUrl = make_shared<string>(boost::any_cast<string>(m["CoverUrl"]));
    }
    if (m.find("Introduction") != m.end() && !m["Introduction"].empty()) {
      introduction = make_shared<string>(boost::any_cast<string>(m["Introduction"]));
    }
    if (m.find("LiveId") != m.end() && !m["LiveId"].empty()) {
      liveId = make_shared<string>(boost::any_cast<string>(m["LiveId"]));
    }
    if (m.find("PreEndTime") != m.end() && !m["PreEndTime"].empty()) {
      preEndTime = make_shared<long>(boost::any_cast<long>(m["PreEndTime"]));
    }
    if (m.find("PreStartTime") != m.end() && !m["PreStartTime"].empty()) {
      preStartTime = make_shared<long>(boost::any_cast<long>(m["PreStartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateLiveShrinkRequest() = default;
};
class UpdateLiveResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateLiveResponseBody() {}

  explicit UpdateLiveResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateLiveResponseBody() = default;
};
class UpdateLiveResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveResponseBody> body{};

  UpdateLiveResponse() {}

  explicit UpdateLiveResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveResponse() = default;
};
class UpdateMeetingRoomHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateMeetingRoomHeadersAccountContext() {}

  explicit UpdateMeetingRoomHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateMeetingRoomHeadersAccountContext() = default;
};
class UpdateMeetingRoomHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateMeetingRoomHeadersAccountContext> accountContext{};

  UpdateMeetingRoomHeaders() {}

  explicit UpdateMeetingRoomHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateMeetingRoomHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateMeetingRoomHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateMeetingRoomHeaders() = default;
};
class UpdateMeetingRoomShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateMeetingRoomShrinkHeaders() {}

  explicit UpdateMeetingRoomShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateMeetingRoomShrinkHeaders() = default;
};
class UpdateMeetingRoomRequestRoomLocation : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> title{};

  UpdateMeetingRoomRequestRoomLocation() {}

  explicit UpdateMeetingRoomRequestRoomLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateMeetingRoomRequestRoomLocation() = default;
};
class UpdateMeetingRoomRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateMeetingRoomRequestTenantContext() {}

  explicit UpdateMeetingRoomRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateMeetingRoomRequestTenantContext() = default;
};
class UpdateMeetingRoomRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> isvRoomId{};
  shared_ptr<long> roomCapacity{};
  shared_ptr<string> roomId{};
  shared_ptr<vector<long>> roomLabelIds{};
  shared_ptr<UpdateMeetingRoomRequestRoomLocation> roomLocation{};
  shared_ptr<string> roomName{};
  shared_ptr<string> roomPicture{};
  shared_ptr<long> roomStatus{};
  shared_ptr<UpdateMeetingRoomRequestTenantContext> tenantContext{};

  UpdateMeetingRoomRequest() {}

  explicit UpdateMeetingRoomRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (isvRoomId) {
      res["IsvRoomId"] = boost::any(*isvRoomId);
    }
    if (roomCapacity) {
      res["RoomCapacity"] = boost::any(*roomCapacity);
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    if (roomLabelIds) {
      res["RoomLabelIds"] = boost::any(*roomLabelIds);
    }
    if (roomLocation) {
      res["RoomLocation"] = roomLocation ? boost::any(roomLocation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (roomName) {
      res["RoomName"] = boost::any(*roomName);
    }
    if (roomPicture) {
      res["RoomPicture"] = boost::any(*roomPicture);
    }
    if (roomStatus) {
      res["RoomStatus"] = boost::any(*roomStatus);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("IsvRoomId") != m.end() && !m["IsvRoomId"].empty()) {
      isvRoomId = make_shared<string>(boost::any_cast<string>(m["IsvRoomId"]));
    }
    if (m.find("RoomCapacity") != m.end() && !m["RoomCapacity"].empty()) {
      roomCapacity = make_shared<long>(boost::any_cast<long>(m["RoomCapacity"]));
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
    if (m.find("RoomLabelIds") != m.end() && !m["RoomLabelIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RoomLabelIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoomLabelIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      roomLabelIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RoomLocation") != m.end() && !m["RoomLocation"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoomLocation"].type()) {
        UpdateMeetingRoomRequestRoomLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoomLocation"]));
        roomLocation = make_shared<UpdateMeetingRoomRequestRoomLocation>(model1);
      }
    }
    if (m.find("RoomName") != m.end() && !m["RoomName"].empty()) {
      roomName = make_shared<string>(boost::any_cast<string>(m["RoomName"]));
    }
    if (m.find("RoomPicture") != m.end() && !m["RoomPicture"].empty()) {
      roomPicture = make_shared<string>(boost::any_cast<string>(m["RoomPicture"]));
    }
    if (m.find("RoomStatus") != m.end() && !m["RoomStatus"].empty()) {
      roomStatus = make_shared<long>(boost::any_cast<long>(m["RoomStatus"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateMeetingRoomRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateMeetingRoomRequestTenantContext>(model1);
      }
    }
  }


  virtual ~UpdateMeetingRoomRequest() = default;
};
class UpdateMeetingRoomShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> isvRoomId{};
  shared_ptr<long> roomCapacity{};
  shared_ptr<string> roomId{};
  shared_ptr<string> roomLabelIdsShrink{};
  shared_ptr<string> roomLocationShrink{};
  shared_ptr<string> roomName{};
  shared_ptr<string> roomPicture{};
  shared_ptr<long> roomStatus{};
  shared_ptr<string> tenantContextShrink{};

  UpdateMeetingRoomShrinkRequest() {}

  explicit UpdateMeetingRoomShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (isvRoomId) {
      res["IsvRoomId"] = boost::any(*isvRoomId);
    }
    if (roomCapacity) {
      res["RoomCapacity"] = boost::any(*roomCapacity);
    }
    if (roomId) {
      res["RoomId"] = boost::any(*roomId);
    }
    if (roomLabelIdsShrink) {
      res["RoomLabelIds"] = boost::any(*roomLabelIdsShrink);
    }
    if (roomLocationShrink) {
      res["RoomLocation"] = boost::any(*roomLocationShrink);
    }
    if (roomName) {
      res["RoomName"] = boost::any(*roomName);
    }
    if (roomPicture) {
      res["RoomPicture"] = boost::any(*roomPicture);
    }
    if (roomStatus) {
      res["RoomStatus"] = boost::any(*roomStatus);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("IsvRoomId") != m.end() && !m["IsvRoomId"].empty()) {
      isvRoomId = make_shared<string>(boost::any_cast<string>(m["IsvRoomId"]));
    }
    if (m.find("RoomCapacity") != m.end() && !m["RoomCapacity"].empty()) {
      roomCapacity = make_shared<long>(boost::any_cast<long>(m["RoomCapacity"]));
    }
    if (m.find("RoomId") != m.end() && !m["RoomId"].empty()) {
      roomId = make_shared<string>(boost::any_cast<string>(m["RoomId"]));
    }
    if (m.find("RoomLabelIds") != m.end() && !m["RoomLabelIds"].empty()) {
      roomLabelIdsShrink = make_shared<string>(boost::any_cast<string>(m["RoomLabelIds"]));
    }
    if (m.find("RoomLocation") != m.end() && !m["RoomLocation"].empty()) {
      roomLocationShrink = make_shared<string>(boost::any_cast<string>(m["RoomLocation"]));
    }
    if (m.find("RoomName") != m.end() && !m["RoomName"].empty()) {
      roomName = make_shared<string>(boost::any_cast<string>(m["RoomName"]));
    }
    if (m.find("RoomPicture") != m.end() && !m["RoomPicture"].empty()) {
      roomPicture = make_shared<string>(boost::any_cast<string>(m["RoomPicture"]));
    }
    if (m.find("RoomStatus") != m.end() && !m["RoomStatus"].empty()) {
      roomStatus = make_shared<long>(boost::any_cast<long>(m["RoomStatus"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~UpdateMeetingRoomShrinkRequest() = default;
};
class UpdateMeetingRoomResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> result{};
  shared_ptr<string> requestId{};

  UpdateMeetingRoomResponseBody() {}

  explicit UpdateMeetingRoomResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateMeetingRoomResponseBody() = default;
};
class UpdateMeetingRoomResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMeetingRoomResponseBody> body{};

  UpdateMeetingRoomResponse() {}

  explicit UpdateMeetingRoomResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMeetingRoomResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMeetingRoomResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMeetingRoomResponse() = default;
};
class UpdateMeetingRoomGroupHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateMeetingRoomGroupHeadersAccountContext() {}

  explicit UpdateMeetingRoomGroupHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateMeetingRoomGroupHeadersAccountContext() = default;
};
class UpdateMeetingRoomGroupHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateMeetingRoomGroupHeadersAccountContext> accountContext{};

  UpdateMeetingRoomGroupHeaders() {}

  explicit UpdateMeetingRoomGroupHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateMeetingRoomGroupHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateMeetingRoomGroupHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateMeetingRoomGroupHeaders() = default;
};
class UpdateMeetingRoomGroupShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateMeetingRoomGroupShrinkHeaders() {}

  explicit UpdateMeetingRoomGroupShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateMeetingRoomGroupShrinkHeaders() = default;
};
class UpdateMeetingRoomGroupRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateMeetingRoomGroupRequestTenantContext() {}

  explicit UpdateMeetingRoomGroupRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateMeetingRoomGroupRequestTenantContext() = default;
};
class UpdateMeetingRoomGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<UpdateMeetingRoomGroupRequestTenantContext> tenantContext{};

  UpdateMeetingRoomGroupRequest() {}

  explicit UpdateMeetingRoomGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateMeetingRoomGroupRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateMeetingRoomGroupRequestTenantContext>(model1);
      }
    }
  }


  virtual ~UpdateMeetingRoomGroupRequest() = default;
};
class UpdateMeetingRoomGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> tenantContextShrink{};

  UpdateMeetingRoomGroupShrinkRequest() {}

  explicit UpdateMeetingRoomGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
  }


  virtual ~UpdateMeetingRoomGroupShrinkRequest() = default;
};
class UpdateMeetingRoomGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UpdateMeetingRoomGroupResponseBody() {}

  explicit UpdateMeetingRoomGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~UpdateMeetingRoomGroupResponseBody() = default;
};
class UpdateMeetingRoomGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMeetingRoomGroupResponseBody> body{};

  UpdateMeetingRoomGroupResponse() {}

  explicit UpdateMeetingRoomGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMeetingRoomGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMeetingRoomGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMeetingRoomGroupResponse() = default;
};
class UpdateRangeHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateRangeHeadersAccountContext() {}

  explicit UpdateRangeHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateRangeHeadersAccountContext() = default;
};
class UpdateRangeHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateRangeHeadersAccountContext> accountContext{};

  UpdateRangeHeaders() {}

  explicit UpdateRangeHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateRangeHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateRangeHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateRangeHeaders() = default;
};
class UpdateRangeShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateRangeShrinkHeaders() {}

  explicit UpdateRangeShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateRangeShrinkHeaders() = default;
};
class UpdateRangeRequestHyperlinks : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> link{};
  shared_ptr<string> text{};

  UpdateRangeRequestHyperlinks() {}

  explicit UpdateRangeRequestHyperlinks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (link) {
      res["Link"] = boost::any(*link);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Link") != m.end() && !m["Link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["Link"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~UpdateRangeRequestHyperlinks() = default;
};
class UpdateRangeRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateRangeRequestTenantContext() {}

  explicit UpdateRangeRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateRangeRequestTenantContext() = default;
};
class UpdateRangeRequest : public Darabonba::Model {
public:
  shared_ptr<vector<vector<string>>> backgroundColors{};
  shared_ptr<vector<vector<undefined>>> hyperlinks{};
  shared_ptr<string> numberFormat{};
  shared_ptr<string> rangeAddress{};
  shared_ptr<string> sheetId{};
  shared_ptr<UpdateRangeRequestTenantContext> tenantContext{};
  shared_ptr<vector<vector<string>>> values{};
  shared_ptr<string> workbookId{};

  UpdateRangeRequest() {}

  explicit UpdateRangeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backgroundColors) {
      res["BackgroundColors"] = boost::any(*backgroundColors);
    }
    if (hyperlinks) {
      vector<boost::any> temp1;
      for(auto item1:*hyperlinks){
        vector<boost::any> temp2;
        for(auto item2:item1){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1 = boost::any(temp2);
      }
      res["Hyperlinks"] = boost::any(temp1);
    }
    if (numberFormat) {
      res["NumberFormat"] = boost::any(*numberFormat);
    }
    if (rangeAddress) {
      res["RangeAddress"] = boost::any(*rangeAddress);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackgroundColors") != m.end() && !m["BackgroundColors"].empty()) {
      vector<vector<string>> toVec1;
      if (typeid(vector<boost::any>) == m["BackgroundColors"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BackgroundColors"]);
        for (auto item:vec1) {
          vector<string> toVec2;
          if (typeid(vector<boost::any>) == item.type()) {
            vector<boost::any> vec2 = boost::any_cast<vector<boost::any>>(item);
            for (auto item:vec2) {
               toVec2.push_back(boost::any_cast<string>(item));
            }
          }
           toVec1 = toVec2;
        }
      }
      backgroundColors = make_shared<vector<vector<string>>>(toVec1);
    }
    if (m.find("Hyperlinks") != m.end() && !m["Hyperlinks"].empty()) {
      if (typeid(vector<boost::any>) == m["Hyperlinks"].type()) {
        vector<vector<undefined>> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hyperlinks"])){
          if (typeid(vector<boost::any>) == item1.type()) {
            vector<undefined> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                undefined model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1.push_back(expect2);
          }
        }
        hyperlinks = make_shared<vector<vector<undefined>>>(expect1);
      }
    }
    if (m.find("NumberFormat") != m.end() && !m["NumberFormat"].empty()) {
      numberFormat = make_shared<string>(boost::any_cast<string>(m["NumberFormat"]));
    }
    if (m.find("RangeAddress") != m.end() && !m["RangeAddress"].empty()) {
      rangeAddress = make_shared<string>(boost::any_cast<string>(m["RangeAddress"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateRangeRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateRangeRequestTenantContext>(model1);
      }
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<vector<string>> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
          vector<string> toVec2;
          if (typeid(vector<boost::any>) == item.type()) {
            vector<boost::any> vec2 = boost::any_cast<vector<boost::any>>(item);
            for (auto item:vec2) {
               toVec2.push_back(boost::any_cast<string>(item));
            }
          }
           toVec1 = toVec2;
        }
      }
      values = make_shared<vector<vector<string>>>(toVec1);
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~UpdateRangeRequest() = default;
};
class UpdateRangeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> backgroundColorsShrink{};
  shared_ptr<string> hyperlinksShrink{};
  shared_ptr<string> numberFormat{};
  shared_ptr<string> rangeAddress{};
  shared_ptr<string> sheetId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> valuesShrink{};
  shared_ptr<string> workbookId{};

  UpdateRangeShrinkRequest() {}

  explicit UpdateRangeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backgroundColorsShrink) {
      res["BackgroundColors"] = boost::any(*backgroundColorsShrink);
    }
    if (hyperlinksShrink) {
      res["Hyperlinks"] = boost::any(*hyperlinksShrink);
    }
    if (numberFormat) {
      res["NumberFormat"] = boost::any(*numberFormat);
    }
    if (rangeAddress) {
      res["RangeAddress"] = boost::any(*rangeAddress);
    }
    if (sheetId) {
      res["SheetId"] = boost::any(*sheetId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (valuesShrink) {
      res["Values"] = boost::any(*valuesShrink);
    }
    if (workbookId) {
      res["WorkbookId"] = boost::any(*workbookId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackgroundColors") != m.end() && !m["BackgroundColors"].empty()) {
      backgroundColorsShrink = make_shared<string>(boost::any_cast<string>(m["BackgroundColors"]));
    }
    if (m.find("Hyperlinks") != m.end() && !m["Hyperlinks"].empty()) {
      hyperlinksShrink = make_shared<string>(boost::any_cast<string>(m["Hyperlinks"]));
    }
    if (m.find("NumberFormat") != m.end() && !m["NumberFormat"].empty()) {
      numberFormat = make_shared<string>(boost::any_cast<string>(m["NumberFormat"]));
    }
    if (m.find("RangeAddress") != m.end() && !m["RangeAddress"].empty()) {
      rangeAddress = make_shared<string>(boost::any_cast<string>(m["RangeAddress"]));
    }
    if (m.find("SheetId") != m.end() && !m["SheetId"].empty()) {
      sheetId = make_shared<string>(boost::any_cast<string>(m["SheetId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      valuesShrink = make_shared<string>(boost::any_cast<string>(m["Values"]));
    }
    if (m.find("WorkbookId") != m.end() && !m["WorkbookId"].empty()) {
      workbookId = make_shared<string>(boost::any_cast<string>(m["WorkbookId"]));
    }
  }


  virtual ~UpdateRangeShrinkRequest() = default;
};
class UpdateRangeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> a1Notation{};
  shared_ptr<string> requestId{};

  UpdateRangeResponseBody() {}

  explicit UpdateRangeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (a1Notation) {
      res["a1Notation"] = boost::any(*a1Notation);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("a1Notation") != m.end() && !m["a1Notation"].empty()) {
      a1Notation = make_shared<string>(boost::any_cast<string>(m["a1Notation"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateRangeResponseBody() = default;
};
class UpdateRangeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRangeResponseBody> body{};

  UpdateRangeResponse() {}

  explicit UpdateRangeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRangeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRangeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRangeResponse() = default;
};
class UpdateScheduleConferenceHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateScheduleConferenceHeadersAccountContext() {}

  explicit UpdateScheduleConferenceHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateScheduleConferenceHeadersAccountContext() = default;
};
class UpdateScheduleConferenceHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateScheduleConferenceHeadersAccountContext> accountContext{};

  UpdateScheduleConferenceHeaders() {}

  explicit UpdateScheduleConferenceHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateScheduleConferenceHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateScheduleConferenceHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateScheduleConferenceHeaders() = default;
};
class UpdateScheduleConferenceShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateScheduleConferenceShrinkHeaders() {}

  explicit UpdateScheduleConferenceShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateScheduleConferenceShrinkHeaders() = default;
};
class UpdateScheduleConferenceRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateScheduleConferenceRequestTenantContext() {}

  explicit UpdateScheduleConferenceRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateScheduleConferenceRequestTenantContext() = default;
};
class UpdateScheduleConferenceRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> scheduleConferenceId{};
  shared_ptr<long> startTime{};
  shared_ptr<UpdateScheduleConferenceRequestTenantContext> tenantContext{};
  shared_ptr<string> title{};

  UpdateScheduleConferenceRequest() {}

  explicit UpdateScheduleConferenceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (scheduleConferenceId) {
      res["ScheduleConferenceId"] = boost::any(*scheduleConferenceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ScheduleConferenceId") != m.end() && !m["ScheduleConferenceId"].empty()) {
      scheduleConferenceId = make_shared<string>(boost::any_cast<string>(m["ScheduleConferenceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateScheduleConferenceRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateScheduleConferenceRequestTenantContext>(model1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateScheduleConferenceRequest() = default;
};
class UpdateScheduleConferenceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> scheduleConferenceId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> title{};

  UpdateScheduleConferenceShrinkRequest() {}

  explicit UpdateScheduleConferenceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (scheduleConferenceId) {
      res["ScheduleConferenceId"] = boost::any(*scheduleConferenceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ScheduleConferenceId") != m.end() && !m["ScheduleConferenceId"].empty()) {
      scheduleConferenceId = make_shared<string>(boost::any_cast<string>(m["ScheduleConferenceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateScheduleConferenceShrinkRequest() = default;
};
class UpdateScheduleConferenceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateScheduleConferenceResponseBody() {}

  explicit UpdateScheduleConferenceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (success) {
      res["success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("success") != m.end() && !m["success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["success"]));
    }
  }


  virtual ~UpdateScheduleConferenceResponseBody() = default;
};
class UpdateScheduleConferenceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateScheduleConferenceResponseBody> body{};

  UpdateScheduleConferenceResponse() {}

  explicit UpdateScheduleConferenceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateScheduleConferenceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateScheduleConferenceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateScheduleConferenceResponse() = default;
};
class UpdateTodoTaskHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateTodoTaskHeadersAccountContext() {}

  explicit UpdateTodoTaskHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateTodoTaskHeadersAccountContext() = default;
};
class UpdateTodoTaskHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateTodoTaskHeadersAccountContext> accountContext{};

  UpdateTodoTaskHeaders() {}

  explicit UpdateTodoTaskHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateTodoTaskHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateTodoTaskHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateTodoTaskHeaders() = default;
};
class UpdateTodoTaskShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateTodoTaskShrinkHeaders() {}

  explicit UpdateTodoTaskShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateTodoTaskShrinkHeaders() = default;
};
class UpdateTodoTaskRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateTodoTaskRequestTenantContext() {}

  explicit UpdateTodoTaskRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateTodoTaskRequestTenantContext() = default;
};
class UpdateTodoTaskRequest : public Darabonba::Model {
public:
  shared_ptr<UpdateTodoTaskRequestTenantContext> tenantContext{};
  shared_ptr<string> description{};
  shared_ptr<bool> done{};
  shared_ptr<long> dueTime{};
  shared_ptr<vector<string>> executorIds{};
  shared_ptr<vector<string>> participantIds{};
  shared_ptr<string> subject{};
  shared_ptr<string> taskId{};

  UpdateTodoTaskRequest() {}

  explicit UpdateTodoTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (done) {
      res["done"] = boost::any(*done);
    }
    if (dueTime) {
      res["dueTime"] = boost::any(*dueTime);
    }
    if (executorIds) {
      res["executorIds"] = boost::any(*executorIds);
    }
    if (participantIds) {
      res["participantIds"] = boost::any(*participantIds);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateTodoTaskRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateTodoTaskRequestTenantContext>(model1);
      }
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("done") != m.end() && !m["done"].empty()) {
      done = make_shared<bool>(boost::any_cast<bool>(m["done"]));
    }
    if (m.find("dueTime") != m.end() && !m["dueTime"].empty()) {
      dueTime = make_shared<long>(boost::any_cast<long>(m["dueTime"]));
    }
    if (m.find("executorIds") != m.end() && !m["executorIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["executorIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["executorIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      executorIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("participantIds") != m.end() && !m["participantIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["participantIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["participantIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      participantIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
  }


  virtual ~UpdateTodoTaskRequest() = default;
};
class UpdateTodoTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> description{};
  shared_ptr<bool> done{};
  shared_ptr<long> dueTime{};
  shared_ptr<string> executorIdsShrink{};
  shared_ptr<string> participantIdsShrink{};
  shared_ptr<string> subject{};
  shared_ptr<string> taskId{};

  UpdateTodoTaskShrinkRequest() {}

  explicit UpdateTodoTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (done) {
      res["done"] = boost::any(*done);
    }
    if (dueTime) {
      res["dueTime"] = boost::any(*dueTime);
    }
    if (executorIdsShrink) {
      res["executorIds"] = boost::any(*executorIdsShrink);
    }
    if (participantIdsShrink) {
      res["participantIds"] = boost::any(*participantIdsShrink);
    }
    if (subject) {
      res["subject"] = boost::any(*subject);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("done") != m.end() && !m["done"].empty()) {
      done = make_shared<bool>(boost::any_cast<bool>(m["done"]));
    }
    if (m.find("dueTime") != m.end() && !m["dueTime"].empty()) {
      dueTime = make_shared<long>(boost::any_cast<long>(m["dueTime"]));
    }
    if (m.find("executorIds") != m.end() && !m["executorIds"].empty()) {
      executorIdsShrink = make_shared<string>(boost::any_cast<string>(m["executorIds"]));
    }
    if (m.find("participantIds") != m.end() && !m["participantIds"].empty()) {
      participantIdsShrink = make_shared<string>(boost::any_cast<string>(m["participantIds"]));
    }
    if (m.find("subject") != m.end() && !m["subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["subject"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
  }


  virtual ~UpdateTodoTaskShrinkRequest() = default;
};
class UpdateTodoTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UpdateTodoTaskResponseBody() {}

  explicit UpdateTodoTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~UpdateTodoTaskResponseBody() = default;
};
class UpdateTodoTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTodoTaskResponseBody> body{};

  UpdateTodoTaskResponse() {}

  explicit UpdateTodoTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTodoTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTodoTaskResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTodoTaskResponse() = default;
};
class UpdateTodoTaskExecutorStatusHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateTodoTaskExecutorStatusHeadersAccountContext() {}

  explicit UpdateTodoTaskExecutorStatusHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateTodoTaskExecutorStatusHeadersAccountContext() = default;
};
class UpdateTodoTaskExecutorStatusHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateTodoTaskExecutorStatusHeadersAccountContext> accountContext{};

  UpdateTodoTaskExecutorStatusHeaders() {}

  explicit UpdateTodoTaskExecutorStatusHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateTodoTaskExecutorStatusHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateTodoTaskExecutorStatusHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateTodoTaskExecutorStatusHeaders() = default;
};
class UpdateTodoTaskExecutorStatusShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateTodoTaskExecutorStatusShrinkHeaders() {}

  explicit UpdateTodoTaskExecutorStatusShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateTodoTaskExecutorStatusShrinkHeaders() = default;
};
class UpdateTodoTaskExecutorStatusRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateTodoTaskExecutorStatusRequestTenantContext() {}

  explicit UpdateTodoTaskExecutorStatusRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateTodoTaskExecutorStatusRequestTenantContext() = default;
};
class UpdateTodoTaskExecutorStatusRequestExecutorStatusList : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<bool> isDone{};

  UpdateTodoTaskExecutorStatusRequestExecutorStatusList() {}

  explicit UpdateTodoTaskExecutorStatusRequestExecutorStatusList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isDone) {
      res["isDone"] = boost::any(*isDone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("isDone") != m.end() && !m["isDone"].empty()) {
      isDone = make_shared<bool>(boost::any_cast<bool>(m["isDone"]));
    }
  }


  virtual ~UpdateTodoTaskExecutorStatusRequestExecutorStatusList() = default;
};
class UpdateTodoTaskExecutorStatusRequest : public Darabonba::Model {
public:
  shared_ptr<UpdateTodoTaskExecutorStatusRequestTenantContext> tenantContext{};
  shared_ptr<vector<UpdateTodoTaskExecutorStatusRequestExecutorStatusList>> executorStatusList{};
  shared_ptr<string> operatorId{};
  shared_ptr<string> taskId{};

  UpdateTodoTaskExecutorStatusRequest() {}

  explicit UpdateTodoTaskExecutorStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (executorStatusList) {
      vector<boost::any> temp1;
      for(auto item1:*executorStatusList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["executorStatusList"] = boost::any(temp1);
    }
    if (operatorId) {
      res["operatorId"] = boost::any(*operatorId);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateTodoTaskExecutorStatusRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateTodoTaskExecutorStatusRequestTenantContext>(model1);
      }
    }
    if (m.find("executorStatusList") != m.end() && !m["executorStatusList"].empty()) {
      if (typeid(vector<boost::any>) == m["executorStatusList"].type()) {
        vector<UpdateTodoTaskExecutorStatusRequestExecutorStatusList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["executorStatusList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTodoTaskExecutorStatusRequestExecutorStatusList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        executorStatusList = make_shared<vector<UpdateTodoTaskExecutorStatusRequestExecutorStatusList>>(expect1);
      }
    }
    if (m.find("operatorId") != m.end() && !m["operatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["operatorId"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
  }


  virtual ~UpdateTodoTaskExecutorStatusRequest() = default;
};
class UpdateTodoTaskExecutorStatusShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> executorStatusListShrink{};
  shared_ptr<string> operatorId{};
  shared_ptr<string> taskId{};

  UpdateTodoTaskExecutorStatusShrinkRequest() {}

  explicit UpdateTodoTaskExecutorStatusShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (executorStatusListShrink) {
      res["executorStatusList"] = boost::any(*executorStatusListShrink);
    }
    if (operatorId) {
      res["operatorId"] = boost::any(*operatorId);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("executorStatusList") != m.end() && !m["executorStatusList"].empty()) {
      executorStatusListShrink = make_shared<string>(boost::any_cast<string>(m["executorStatusList"]));
    }
    if (m.find("operatorId") != m.end() && !m["operatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["operatorId"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
  }


  virtual ~UpdateTodoTaskExecutorStatusShrinkRequest() = default;
};
class UpdateTodoTaskExecutorStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UpdateTodoTaskExecutorStatusResponseBody() {}

  explicit UpdateTodoTaskExecutorStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["result"]));
    }
  }


  virtual ~UpdateTodoTaskExecutorStatusResponseBody() = default;
};
class UpdateTodoTaskExecutorStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTodoTaskExecutorStatusResponseBody> body{};

  UpdateTodoTaskExecutorStatusResponse() {}

  explicit UpdateTodoTaskExecutorStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTodoTaskExecutorStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTodoTaskExecutorStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTodoTaskExecutorStatusResponse() = default;
};
class UpdateWorkspaceDocMembersHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateWorkspaceDocMembersHeadersAccountContext() {}

  explicit UpdateWorkspaceDocMembersHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateWorkspaceDocMembersHeadersAccountContext() = default;
};
class UpdateWorkspaceDocMembersHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateWorkspaceDocMembersHeadersAccountContext> accountContext{};

  UpdateWorkspaceDocMembersHeaders() {}

  explicit UpdateWorkspaceDocMembersHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateWorkspaceDocMembersHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateWorkspaceDocMembersHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateWorkspaceDocMembersHeaders() = default;
};
class UpdateWorkspaceDocMembersShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateWorkspaceDocMembersShrinkHeaders() {}

  explicit UpdateWorkspaceDocMembersShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateWorkspaceDocMembersShrinkHeaders() = default;
};
class UpdateWorkspaceDocMembersRequestMembers : public Darabonba::Model {
public:
  shared_ptr<string> memberId{};
  shared_ptr<string> memberType{};
  shared_ptr<string> roleType{};

  UpdateWorkspaceDocMembersRequestMembers() {}

  explicit UpdateWorkspaceDocMembersRequestMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberId) {
      res["MemberId"] = boost::any(*memberId);
    }
    if (memberType) {
      res["MemberType"] = boost::any(*memberType);
    }
    if (roleType) {
      res["RoleType"] = boost::any(*roleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemberId") != m.end() && !m["MemberId"].empty()) {
      memberId = make_shared<string>(boost::any_cast<string>(m["MemberId"]));
    }
    if (m.find("MemberType") != m.end() && !m["MemberType"].empty()) {
      memberType = make_shared<string>(boost::any_cast<string>(m["MemberType"]));
    }
    if (m.find("RoleType") != m.end() && !m["RoleType"].empty()) {
      roleType = make_shared<string>(boost::any_cast<string>(m["RoleType"]));
    }
  }


  virtual ~UpdateWorkspaceDocMembersRequestMembers() = default;
};
class UpdateWorkspaceDocMembersRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateWorkspaceDocMembersRequestTenantContext() {}

  explicit UpdateWorkspaceDocMembersRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateWorkspaceDocMembersRequestTenantContext() = default;
};
class UpdateWorkspaceDocMembersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateWorkspaceDocMembersRequestMembers>> members{};
  shared_ptr<string> nodeId{};
  shared_ptr<UpdateWorkspaceDocMembersRequestTenantContext> tenantContext{};
  shared_ptr<string> workspaceId{};

  UpdateWorkspaceDocMembersRequest() {}

  explicit UpdateWorkspaceDocMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (members) {
      vector<boost::any> temp1;
      for(auto item1:*members){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Members"] = boost::any(temp1);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      if (typeid(vector<boost::any>) == m["Members"].type()) {
        vector<UpdateWorkspaceDocMembersRequestMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Members"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWorkspaceDocMembersRequestMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        members = make_shared<vector<UpdateWorkspaceDocMembersRequestMembers>>(expect1);
      }
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateWorkspaceDocMembersRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateWorkspaceDocMembersRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~UpdateWorkspaceDocMembersRequest() = default;
};
class UpdateWorkspaceDocMembersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> membersShrink{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workspaceId{};

  UpdateWorkspaceDocMembersShrinkRequest() {}

  explicit UpdateWorkspaceDocMembersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (membersShrink) {
      res["Members"] = boost::any(*membersShrink);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      membersShrink = make_shared<string>(boost::any_cast<string>(m["Members"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~UpdateWorkspaceDocMembersShrinkRequest() = default;
};
class UpdateWorkspaceDocMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateWorkspaceDocMembersResponseBody() {}

  explicit UpdateWorkspaceDocMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateWorkspaceDocMembersResponseBody() = default;
};
class UpdateWorkspaceDocMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateWorkspaceDocMembersResponseBody> body{};

  UpdateWorkspaceDocMembersResponse() {}

  explicit UpdateWorkspaceDocMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWorkspaceDocMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWorkspaceDocMembersResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateWorkspaceDocMembersResponse() = default;
};
class UpdateWorkspaceMembersHeadersAccountContext : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateWorkspaceMembersHeadersAccountContext() {}

  explicit UpdateWorkspaceMembersHeadersAccountContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["accountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountId") != m.end() && !m["accountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["accountId"]));
    }
  }


  virtual ~UpdateWorkspaceMembersHeadersAccountContext() = default;
};
class UpdateWorkspaceMembersHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<UpdateWorkspaceMembersHeadersAccountContext> accountContext{};

  UpdateWorkspaceMembersHeaders() {}

  explicit UpdateWorkspaceMembersHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContext) {
      res["AccountContext"] = accountContext ? boost::any(accountContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountContext"].type()) {
        UpdateWorkspaceMembersHeadersAccountContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountContext"]));
        accountContext = make_shared<UpdateWorkspaceMembersHeadersAccountContext>(model1);
      }
    }
  }


  virtual ~UpdateWorkspaceMembersHeaders() = default;
};
class UpdateWorkspaceMembersShrinkHeaders : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> commonHeaders{};
  shared_ptr<string> accountContextShrink{};

  UpdateWorkspaceMembersShrinkHeaders() {}

  explicit UpdateWorkspaceMembersShrinkHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonHeaders) {
      res["commonHeaders"] = boost::any(*commonHeaders);
    }
    if (accountContextShrink) {
      res["AccountContext"] = boost::any(*accountContextShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commonHeaders") != m.end() && !m["commonHeaders"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["commonHeaders"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      commonHeaders = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("AccountContext") != m.end() && !m["AccountContext"].empty()) {
      accountContextShrink = make_shared<string>(boost::any_cast<string>(m["AccountContext"]));
    }
  }


  virtual ~UpdateWorkspaceMembersShrinkHeaders() = default;
};
class UpdateWorkspaceMembersRequestMembers : public Darabonba::Model {
public:
  shared_ptr<string> memberId{};
  shared_ptr<string> memberType{};
  shared_ptr<string> roleType{};

  UpdateWorkspaceMembersRequestMembers() {}

  explicit UpdateWorkspaceMembersRequestMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberId) {
      res["MemberId"] = boost::any(*memberId);
    }
    if (memberType) {
      res["MemberType"] = boost::any(*memberType);
    }
    if (roleType) {
      res["RoleType"] = boost::any(*roleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemberId") != m.end() && !m["MemberId"].empty()) {
      memberId = make_shared<string>(boost::any_cast<string>(m["MemberId"]));
    }
    if (m.find("MemberType") != m.end() && !m["MemberType"].empty()) {
      memberType = make_shared<string>(boost::any_cast<string>(m["MemberType"]));
    }
    if (m.find("RoleType") != m.end() && !m["RoleType"].empty()) {
      roleType = make_shared<string>(boost::any_cast<string>(m["RoleType"]));
    }
  }


  virtual ~UpdateWorkspaceMembersRequestMembers() = default;
};
class UpdateWorkspaceMembersRequestTenantContext : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  UpdateWorkspaceMembersRequestTenantContext() {}

  explicit UpdateWorkspaceMembersRequestTenantContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["tenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantId") != m.end() && !m["tenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["tenantId"]));
    }
  }


  virtual ~UpdateWorkspaceMembersRequestTenantContext() = default;
};
class UpdateWorkspaceMembersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateWorkspaceMembersRequestMembers>> members{};
  shared_ptr<UpdateWorkspaceMembersRequestTenantContext> tenantContext{};
  shared_ptr<string> workspaceId{};

  UpdateWorkspaceMembersRequest() {}

  explicit UpdateWorkspaceMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (members) {
      vector<boost::any> temp1;
      for(auto item1:*members){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Members"] = boost::any(temp1);
    }
    if (tenantContext) {
      res["TenantContext"] = tenantContext ? boost::any(tenantContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      if (typeid(vector<boost::any>) == m["Members"].type()) {
        vector<UpdateWorkspaceMembersRequestMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Members"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWorkspaceMembersRequestMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        members = make_shared<vector<UpdateWorkspaceMembersRequestMembers>>(expect1);
      }
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantContext"].type()) {
        UpdateWorkspaceMembersRequestTenantContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantContext"]));
        tenantContext = make_shared<UpdateWorkspaceMembersRequestTenantContext>(model1);
      }
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~UpdateWorkspaceMembersRequest() = default;
};
class UpdateWorkspaceMembersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> membersShrink{};
  shared_ptr<string> tenantContextShrink{};
  shared_ptr<string> workspaceId{};

  UpdateWorkspaceMembersShrinkRequest() {}

  explicit UpdateWorkspaceMembersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (membersShrink) {
      res["Members"] = boost::any(*membersShrink);
    }
    if (tenantContextShrink) {
      res["TenantContext"] = boost::any(*tenantContextShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      membersShrink = make_shared<string>(boost::any_cast<string>(m["Members"]));
    }
    if (m.find("TenantContext") != m.end() && !m["TenantContext"].empty()) {
      tenantContextShrink = make_shared<string>(boost::any_cast<string>(m["TenantContext"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~UpdateWorkspaceMembersShrinkRequest() = default;
};
class UpdateWorkspaceMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateWorkspaceMembersResponseBody() {}

  explicit UpdateWorkspaceMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateWorkspaceMembersResponseBody() = default;
};
class UpdateWorkspaceMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateWorkspaceMembersResponseBody> body{};

  UpdateWorkspaceMembersResponse() {}

  explicit UpdateWorkspaceMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWorkspaceMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWorkspaceMembersResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateWorkspaceMembersResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddAttendeeResponse addAttendeeWithOptions(shared_ptr<AddAttendeeRequest> tmpReq, shared_ptr<AddAttendeeHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddAttendeeResponse addAttendee(shared_ptr<AddAttendeeRequest> request);
  AddWorkspaceResponse addWorkspaceWithOptions(shared_ptr<AddWorkspaceRequest> tmpReq, shared_ptr<AddWorkspaceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddWorkspaceResponse addWorkspace(shared_ptr<AddWorkspaceRequest> request);
  AddWorkspaceDocMembersResponse addWorkspaceDocMembersWithOptions(shared_ptr<AddWorkspaceDocMembersRequest> tmpReq, shared_ptr<AddWorkspaceDocMembersHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddWorkspaceDocMembersResponse addWorkspaceDocMembers(shared_ptr<AddWorkspaceDocMembersRequest> request);
  AddWorkspaceMembersResponse addWorkspaceMembersWithOptions(shared_ptr<AddWorkspaceMembersRequest> tmpReq, shared_ptr<AddWorkspaceMembersHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddWorkspaceMembersResponse addWorkspaceMembers(shared_ptr<AddWorkspaceMembersRequest> request);
  CancelScheduleConferenceResponse cancelScheduleConferenceWithOptions(shared_ptr<CancelScheduleConferenceRequest> tmpReq, shared_ptr<CancelScheduleConferenceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelScheduleConferenceResponse cancelScheduleConference(shared_ptr<CancelScheduleConferenceRequest> request);
  ClearResponse clearWithOptions(shared_ptr<ClearRequest> tmpReq, shared_ptr<ClearHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ClearResponse clear(shared_ptr<ClearRequest> request);
  ClearDataResponse clearDataWithOptions(shared_ptr<ClearDataRequest> tmpReq, shared_ptr<ClearDataHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ClearDataResponse clearData(shared_ptr<ClearDataRequest> request);
  CommentListReportResponse commentListReportWithOptions(shared_ptr<CommentListReportRequest> tmpReq, shared_ptr<CommentListReportHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CommentListReportResponse commentListReport(shared_ptr<CommentListReportRequest> request);
  CreateEventResponse createEventWithOptions(shared_ptr<CreateEventRequest> tmpReq, shared_ptr<CreateEventHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEventResponse createEvent(shared_ptr<CreateEventRequest> request);
  CreateLiveResponse createLiveWithOptions(shared_ptr<CreateLiveRequest> tmpReq, shared_ptr<CreateLiveHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLiveResponse createLive(shared_ptr<CreateLiveRequest> request);
  CreateMeetingRoomResponse createMeetingRoomWithOptions(shared_ptr<CreateMeetingRoomRequest> tmpReq, shared_ptr<CreateMeetingRoomHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMeetingRoomResponse createMeetingRoom(shared_ptr<CreateMeetingRoomRequest> request);
  CreateMeetingRoomGroupResponse createMeetingRoomGroupWithOptions(shared_ptr<CreateMeetingRoomGroupRequest> tmpReq, shared_ptr<CreateMeetingRoomGroupHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMeetingRoomGroupResponse createMeetingRoomGroup(shared_ptr<CreateMeetingRoomGroupRequest> request);
  CreateReportResponse createReportWithOptions(shared_ptr<CreateReportRequest> tmpReq, shared_ptr<CreateReportHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateReportResponse createReport(shared_ptr<CreateReportRequest> request);
  CreateScheduleConferenceResponse createScheduleConferenceWithOptions(shared_ptr<CreateScheduleConferenceRequest> tmpReq, shared_ptr<CreateScheduleConferenceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateScheduleConferenceResponse createScheduleConference(shared_ptr<CreateScheduleConferenceRequest> request);
  CreateSheetResponse createSheetWithOptions(shared_ptr<CreateSheetRequest> tmpReq, shared_ptr<CreateSheetHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSheetResponse createSheet(shared_ptr<CreateSheetRequest> request);
  CreateTodoTaskResponse createTodoTaskWithOptions(shared_ptr<CreateTodoTaskRequest> tmpReq, shared_ptr<CreateTodoTaskHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTodoTaskResponse createTodoTask(shared_ptr<CreateTodoTaskRequest> request);
  CreateVideoConferenceResponse createVideoConferenceWithOptions(shared_ptr<CreateVideoConferenceRequest> tmpReq, shared_ptr<CreateVideoConferenceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVideoConferenceResponse createVideoConference(shared_ptr<CreateVideoConferenceRequest> request);
  CreateWorkspaceResponse createWorkspaceWithOptions(shared_ptr<CreateWorkspaceRequest> tmpReq, shared_ptr<CreateWorkspaceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWorkspaceResponse createWorkspace(shared_ptr<CreateWorkspaceRequest> request);
  CreateWorkspaceDocResponse createWorkspaceDocWithOptions(shared_ptr<CreateWorkspaceDocRequest> tmpReq, shared_ptr<CreateWorkspaceDocHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWorkspaceDocResponse createWorkspaceDoc(shared_ptr<CreateWorkspaceDocRequest> request);
  DeleteColumnsResponse deleteColumnsWithOptions(shared_ptr<DeleteColumnsRequest> tmpReq, shared_ptr<DeleteColumnsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteColumnsResponse deleteColumns(shared_ptr<DeleteColumnsRequest> request);
  DeleteEventResponse deleteEventWithOptions(shared_ptr<DeleteEventRequest> request, shared_ptr<DeleteEventHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEventResponse deleteEvent(shared_ptr<DeleteEventRequest> request);
  DeleteLiveResponse deleteLiveWithOptions(shared_ptr<DeleteLiveRequest> tmpReq, shared_ptr<DeleteLiveHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveResponse deleteLive(shared_ptr<DeleteLiveRequest> request);
  DeleteMeetingRoomResponse deleteMeetingRoomWithOptions(shared_ptr<DeleteMeetingRoomRequest> tmpReq, shared_ptr<DeleteMeetingRoomHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMeetingRoomResponse deleteMeetingRoom(shared_ptr<DeleteMeetingRoomRequest> request);
  DeleteMeetingRoomGroupResponse deleteMeetingRoomGroupWithOptions(shared_ptr<DeleteMeetingRoomGroupRequest> tmpReq, shared_ptr<DeleteMeetingRoomGroupHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMeetingRoomGroupResponse deleteMeetingRoomGroup(shared_ptr<DeleteMeetingRoomGroupRequest> request);
  DeleteRowsResponse deleteRowsWithOptions(shared_ptr<DeleteRowsRequest> tmpReq, shared_ptr<DeleteRowsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRowsResponse deleteRows(shared_ptr<DeleteRowsRequest> request);
  DeleteSheetResponse deleteSheetWithOptions(shared_ptr<DeleteSheetRequest> tmpReq, shared_ptr<DeleteSheetHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSheetResponse deleteSheet(shared_ptr<DeleteSheetRequest> request);
  DeleteTodoTaskResponse deleteTodoTaskWithOptions(shared_ptr<DeleteTodoTaskRequest> tmpReq, shared_ptr<DeleteTodoTaskHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTodoTaskResponse deleteTodoTask(shared_ptr<DeleteTodoTaskRequest> request);
  DeleteWorkspaceDocMembersResponse deleteWorkspaceDocMembersWithOptions(shared_ptr<DeleteWorkspaceDocMembersRequest> tmpReq, shared_ptr<DeleteWorkspaceDocMembersHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWorkspaceDocMembersResponse deleteWorkspaceDocMembers(shared_ptr<DeleteWorkspaceDocMembersRequest> request);
  DeleteWorkspaceMembersResponse deleteWorkspaceMembersWithOptions(shared_ptr<DeleteWorkspaceMembersRequest> tmpReq, shared_ptr<DeleteWorkspaceMembersHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWorkspaceMembersResponse deleteWorkspaceMembers(shared_ptr<DeleteWorkspaceMembersRequest> request);
  GetAllSheetsResponse getAllSheetsWithOptions(shared_ptr<GetAllSheetsRequest> tmpReq, shared_ptr<GetAllSheetsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAllSheetsResponse getAllSheets(shared_ptr<GetAllSheetsRequest> request);
  GetEventResponse getEventWithOptions(shared_ptr<GetEventRequest> request, shared_ptr<GetEventHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEventResponse getEvent(shared_ptr<GetEventRequest> request);
  GetMineWorkspaceResponse getMineWorkspaceWithOptions(shared_ptr<GetMineWorkspaceRequest> tmpReq, shared_ptr<GetMineWorkspaceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMineWorkspaceResponse getMineWorkspace(shared_ptr<GetMineWorkspaceRequest> request);
  GetNodeResponse getNodeWithOptions(shared_ptr<GetNodeRequest> tmpReq, shared_ptr<GetNodeHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodeResponse getNode(shared_ptr<GetNodeRequest> request);
  GetNodeByUrlResponse getNodeByUrlWithOptions(shared_ptr<GetNodeByUrlRequest> tmpReq, shared_ptr<GetNodeByUrlHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodeByUrlResponse getNodeByUrl(shared_ptr<GetNodeByUrlRequest> request);
  GetNodesResponse getNodesWithOptions(shared_ptr<GetNodesRequest> tmpReq, shared_ptr<GetNodesHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodesResponse getNodes(shared_ptr<GetNodesRequest> request);
  GetRangeResponse getRangeWithOptions(shared_ptr<GetRangeRequest> tmpReq, shared_ptr<GetRangeHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRangeResponse getRange(shared_ptr<GetRangeRequest> request);
  GetReportTemplateByNameResponse getReportTemplateByNameWithOptions(shared_ptr<GetReportTemplateByNameRequest> tmpReq, shared_ptr<GetReportTemplateByNameHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetReportTemplateByNameResponse getReportTemplateByName(shared_ptr<GetReportTemplateByNameRequest> request);
  GetReportUnReadCountResponse getReportUnReadCountWithOptions(shared_ptr<GetReportUnReadCountRequest> tmpReq, shared_ptr<GetReportUnReadCountHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetReportUnReadCountResponse getReportUnReadCount(shared_ptr<GetReportUnReadCountRequest> request);
  GetSheetResponse getSheetWithOptions(shared_ptr<GetSheetRequest> tmpReq, shared_ptr<GetSheetHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSheetResponse getSheet(shared_ptr<GetSheetRequest> request);
  GetSpaceDirectoriesResponse getSpaceDirectoriesWithOptions(shared_ptr<GetSpaceDirectoriesRequest> tmpReq, shared_ptr<GetSpaceDirectoriesHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSpaceDirectoriesResponse getSpaceDirectories(shared_ptr<GetSpaceDirectoriesRequest> request);
  GetTemplateListByUserIdResponse getTemplateListByUserIdWithOptions(shared_ptr<GetTemplateListByUserIdRequest> tmpReq, shared_ptr<GetTemplateListByUserIdHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTemplateListByUserIdResponse getTemplateListByUserId(shared_ptr<GetTemplateListByUserIdRequest> request);
  GetUserResponse getUserWithOptions(shared_ptr<GetUserRequest> tmpReq, shared_ptr<GetUserHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserResponse getUser(shared_ptr<GetUserRequest> request);
  GetWorkspaceResponse getWorkspaceWithOptions(shared_ptr<GetWorkspaceRequest> tmpReq, shared_ptr<GetWorkspaceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWorkspaceResponse getWorkspace(shared_ptr<GetWorkspaceRequest> request);
  GetWorkspacesResponse getWorkspacesWithOptions(shared_ptr<GetWorkspacesRequest> tmpReq, shared_ptr<GetWorkspacesHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWorkspacesResponse getWorkspaces(shared_ptr<GetWorkspacesRequest> request);
  InsertColumnsBeforeResponse insertColumnsBeforeWithOptions(shared_ptr<InsertColumnsBeforeRequest> tmpReq, shared_ptr<InsertColumnsBeforeHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertColumnsBeforeResponse insertColumnsBefore(shared_ptr<InsertColumnsBeforeRequest> request);
  InsertRowsBeforeResponse insertRowsBeforeWithOptions(shared_ptr<InsertRowsBeforeRequest> tmpReq, shared_ptr<InsertRowsBeforeHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertRowsBeforeResponse insertRowsBefore(shared_ptr<InsertRowsBeforeRequest> request);
  InviteUsersResponse inviteUsersWithOptions(shared_ptr<InviteUsersRequest> tmpReq, shared_ptr<InviteUsersHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InviteUsersResponse inviteUsers(shared_ptr<InviteUsersRequest> request);
  ListCalendarsResponse listCalendarsWithOptions(shared_ptr<ListCalendarsRequest> tmpReq, shared_ptr<ListCalendarsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCalendarsResponse listCalendars(shared_ptr<ListCalendarsRequest> request);
  ListEventsResponse listEventsWithOptions(shared_ptr<ListEventsRequest> request, shared_ptr<ListEventsHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEventsResponse listEvents(shared_ptr<ListEventsRequest> request);
  ListNodesResponse listNodesWithOptions(shared_ptr<ListNodesRequest> tmpReq, shared_ptr<ListNodesHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNodesResponse listNodes(shared_ptr<ListNodesRequest> request);
  ListReportResponse listReportWithOptions(shared_ptr<ListReportRequest> tmpReq, shared_ptr<ListReportHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListReportResponse listReport(shared_ptr<ListReportRequest> request);
  ListWorkspacesResponse listWorkspacesWithOptions(shared_ptr<ListWorkspacesRequest> tmpReq, shared_ptr<ListWorkspacesHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWorkspacesResponse listWorkspaces(shared_ptr<ListWorkspacesRequest> request);
  PatchEventResponse patchEventWithOptions(shared_ptr<PatchEventRequest> tmpReq, shared_ptr<PatchEventHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PatchEventResponse patchEvent(shared_ptr<PatchEventRequest> request);
  QueryCloudRecordTextResponse queryCloudRecordTextWithOptions(shared_ptr<QueryCloudRecordTextRequest> tmpReq, shared_ptr<QueryCloudRecordTextHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCloudRecordTextResponse queryCloudRecordText(shared_ptr<QueryCloudRecordTextRequest> request);
  QueryCloudRecordVideoResponse queryCloudRecordVideoWithOptions(shared_ptr<QueryCloudRecordVideoRequest> tmpReq, shared_ptr<QueryCloudRecordVideoHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCloudRecordVideoResponse queryCloudRecordVideo(shared_ptr<QueryCloudRecordVideoRequest> request);
  QueryCloudRecordVideoPlayInfoResponse queryCloudRecordVideoPlayInfoWithOptions(shared_ptr<QueryCloudRecordVideoPlayInfoRequest> tmpReq, shared_ptr<QueryCloudRecordVideoPlayInfoHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCloudRecordVideoPlayInfoResponse queryCloudRecordVideoPlayInfo(shared_ptr<QueryCloudRecordVideoPlayInfoRequest> request);
  QueryConferenceInfoResponse queryConferenceInfoWithOptions(shared_ptr<QueryConferenceInfoRequest> request, shared_ptr<QueryConferenceInfoHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryConferenceInfoResponse queryConferenceInfo(shared_ptr<QueryConferenceInfoRequest> request);
  QueryConferenceMembersResponse queryConferenceMembersWithOptions(shared_ptr<QueryConferenceMembersRequest> tmpReq, shared_ptr<QueryConferenceMembersHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryConferenceMembersResponse queryConferenceMembers(shared_ptr<QueryConferenceMembersRequest> request);
  QueryDentryResponse queryDentryWithOptions(shared_ptr<QueryDentryRequest> tmpReq, shared_ptr<QueryDentryHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDentryResponse queryDentry(shared_ptr<QueryDentryRequest> request);
  QueryLiveInfoResponse queryLiveInfoWithOptions(shared_ptr<QueryLiveInfoRequest> tmpReq, shared_ptr<QueryLiveInfoHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryLiveInfoResponse queryLiveInfo(shared_ptr<QueryLiveInfoRequest> request);
  QueryLiveWatchDetailResponse queryLiveWatchDetailWithOptions(shared_ptr<QueryLiveWatchDetailRequest> tmpReq, shared_ptr<QueryLiveWatchDetailHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryLiveWatchDetailResponse queryLiveWatchDetail(shared_ptr<QueryLiveWatchDetailRequest> request);
  QueryLiveWatchUserListResponse queryLiveWatchUserListWithOptions(shared_ptr<QueryLiveWatchUserListRequest> tmpReq, shared_ptr<QueryLiveWatchUserListHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryLiveWatchUserListResponse queryLiveWatchUserList(shared_ptr<QueryLiveWatchUserListRequest> request);
  QueryMeetingRoomResponse queryMeetingRoomWithOptions(shared_ptr<QueryMeetingRoomRequest> tmpReq, shared_ptr<QueryMeetingRoomHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMeetingRoomResponse queryMeetingRoom(shared_ptr<QueryMeetingRoomRequest> request);
  QueryMeetingRoomGroupResponse queryMeetingRoomGroupWithOptions(shared_ptr<QueryMeetingRoomGroupRequest> tmpReq, shared_ptr<QueryMeetingRoomGroupHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMeetingRoomGroupResponse queryMeetingRoomGroup(shared_ptr<QueryMeetingRoomGroupRequest> request);
  QueryMeetingRoomGroupListResponse queryMeetingRoomGroupListWithOptions(shared_ptr<QueryMeetingRoomGroupListRequest> tmpReq, shared_ptr<QueryMeetingRoomGroupListHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMeetingRoomGroupListResponse queryMeetingRoomGroupList(shared_ptr<QueryMeetingRoomGroupListRequest> request);
  QueryMeetingRoomListResponse queryMeetingRoomListWithOptions(shared_ptr<QueryMeetingRoomListRequest> tmpReq, shared_ptr<QueryMeetingRoomListHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMeetingRoomListResponse queryMeetingRoomList(shared_ptr<QueryMeetingRoomListRequest> request);
  QueryOrgTodoTasksResponse queryOrgTodoTasksWithOptions(shared_ptr<QueryOrgTodoTasksRequest> tmpReq, shared_ptr<QueryOrgTodoTasksHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOrgTodoTasksResponse queryOrgTodoTasks(shared_ptr<QueryOrgTodoTasksRequest> request);
  QueryScheduleConferenceResponse queryScheduleConferenceWithOptions(shared_ptr<QueryScheduleConferenceRequest> tmpReq, shared_ptr<QueryScheduleConferenceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryScheduleConferenceResponse queryScheduleConference(shared_ptr<QueryScheduleConferenceRequest> request);
  ReceiverListReportResponse receiverListReportWithOptions(shared_ptr<ReceiverListReportRequest> tmpReq, shared_ptr<ReceiverListReportHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReceiverListReportResponse receiverListReport(shared_ptr<ReceiverListReportRequest> request);
  RemoveAttendeeResponse removeAttendeeWithOptions(shared_ptr<RemoveAttendeeRequest> tmpReq, shared_ptr<RemoveAttendeeHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveAttendeeResponse removeAttendee(shared_ptr<RemoveAttendeeRequest> request);
  SaveContentResponse saveContentWithOptions(shared_ptr<SaveContentRequest> tmpReq, shared_ptr<SaveContentHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveContentResponse saveContent(shared_ptr<SaveContentRequest> request);
  SetColumnsVisibilityResponse setColumnsVisibilityWithOptions(shared_ptr<SetColumnsVisibilityRequest> tmpReq, shared_ptr<SetColumnsVisibilityHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetColumnsVisibilityResponse setColumnsVisibility(shared_ptr<SetColumnsVisibilityRequest> request);
  SetRowsVisibilityResponse setRowsVisibilityWithOptions(shared_ptr<SetRowsVisibilityRequest> tmpReq, shared_ptr<SetRowsVisibilityHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetRowsVisibilityResponse setRowsVisibility(shared_ptr<SetRowsVisibilityRequest> request);
  SimpleListReportResponse simpleListReportWithOptions(shared_ptr<SimpleListReportRequest> tmpReq, shared_ptr<SimpleListReportHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SimpleListReportResponse simpleListReport(shared_ptr<SimpleListReportRequest> request);
  StartCloudRecordResponse startCloudRecordWithOptions(shared_ptr<StartCloudRecordRequest> tmpReq, shared_ptr<StartCloudRecordHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartCloudRecordResponse startCloudRecord(shared_ptr<StartCloudRecordRequest> request);
  StatisticsListByTypeReportResponse statisticsListByTypeReportWithOptions(shared_ptr<StatisticsListByTypeReportRequest> tmpReq, shared_ptr<StatisticsListByTypeReportHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StatisticsListByTypeReportResponse statisticsListByTypeReport(shared_ptr<StatisticsListByTypeReportRequest> request);
  StatisticsReportResponse statisticsReportWithOptions(shared_ptr<StatisticsReportRequest> tmpReq, shared_ptr<StatisticsReportHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StatisticsReportResponse statisticsReport(shared_ptr<StatisticsReportRequest> request);
  StopCloudRecordResponse stopCloudRecordWithOptions(shared_ptr<StopCloudRecordRequest> tmpReq, shared_ptr<StopCloudRecordHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopCloudRecordResponse stopCloudRecord(shared_ptr<StopCloudRecordRequest> request);
  UpdateLiveResponse updateLiveWithOptions(shared_ptr<UpdateLiveRequest> tmpReq, shared_ptr<UpdateLiveHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveResponse updateLive(shared_ptr<UpdateLiveRequest> request);
  UpdateMeetingRoomResponse updateMeetingRoomWithOptions(shared_ptr<UpdateMeetingRoomRequest> tmpReq, shared_ptr<UpdateMeetingRoomHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMeetingRoomResponse updateMeetingRoom(shared_ptr<UpdateMeetingRoomRequest> request);
  UpdateMeetingRoomGroupResponse updateMeetingRoomGroupWithOptions(shared_ptr<UpdateMeetingRoomGroupRequest> tmpReq, shared_ptr<UpdateMeetingRoomGroupHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMeetingRoomGroupResponse updateMeetingRoomGroup(shared_ptr<UpdateMeetingRoomGroupRequest> request);
  UpdateRangeResponse updateRangeWithOptions(shared_ptr<UpdateRangeRequest> tmpReq, shared_ptr<UpdateRangeHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRangeResponse updateRange(shared_ptr<UpdateRangeRequest> request);
  UpdateScheduleConferenceResponse updateScheduleConferenceWithOptions(shared_ptr<UpdateScheduleConferenceRequest> tmpReq, shared_ptr<UpdateScheduleConferenceHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateScheduleConferenceResponse updateScheduleConference(shared_ptr<UpdateScheduleConferenceRequest> request);
  UpdateTodoTaskResponse updateTodoTaskWithOptions(shared_ptr<UpdateTodoTaskRequest> tmpReq, shared_ptr<UpdateTodoTaskHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTodoTaskResponse updateTodoTask(shared_ptr<UpdateTodoTaskRequest> request);
  UpdateTodoTaskExecutorStatusResponse updateTodoTaskExecutorStatusWithOptions(shared_ptr<UpdateTodoTaskExecutorStatusRequest> tmpReq, shared_ptr<UpdateTodoTaskExecutorStatusHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTodoTaskExecutorStatusResponse updateTodoTaskExecutorStatus(shared_ptr<UpdateTodoTaskExecutorStatusRequest> request);
  UpdateWorkspaceDocMembersResponse updateWorkspaceDocMembersWithOptions(shared_ptr<UpdateWorkspaceDocMembersRequest> tmpReq, shared_ptr<UpdateWorkspaceDocMembersHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWorkspaceDocMembersResponse updateWorkspaceDocMembers(shared_ptr<UpdateWorkspaceDocMembersRequest> request);
  UpdateWorkspaceMembersResponse updateWorkspaceMembersWithOptions(shared_ptr<UpdateWorkspaceMembersRequest> tmpReq, shared_ptr<UpdateWorkspaceMembersHeaders> tmpHeader, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWorkspaceMembersResponse updateWorkspaceMembers(shared_ptr<UpdateWorkspaceMembersRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Aliding20230426

#endif
