// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_CDN20180510_H_
#define ALIBABACLOUD_CDN20180510_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Cdn20180510 {
class AddCdnDomainRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  AddCdnDomainRequestTag() {}

  explicit AddCdnDomainRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~AddCdnDomainRequestTag() = default;
};
class AddCdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdnType{};
  shared_ptr<string> checkUrl{};
  shared_ptr<string> domainName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> scope{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> sources{};
  shared_ptr<vector<AddCdnDomainRequestTag>> tag{};
  shared_ptr<string> topLevelDomain{};

  AddCdnDomainRequest() {}

  explicit AddCdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdnType) {
      res["CdnType"] = boost::any(*cdnType);
    }
    if (checkUrl) {
      res["CheckUrl"] = boost::any(*checkUrl);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (sources) {
      res["Sources"] = boost::any(*sources);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (topLevelDomain) {
      res["TopLevelDomain"] = boost::any(*topLevelDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdnType") != m.end() && !m["CdnType"].empty()) {
      cdnType = make_shared<string>(boost::any_cast<string>(m["CdnType"]));
    }
    if (m.find("CheckUrl") != m.end() && !m["CheckUrl"].empty()) {
      checkUrl = make_shared<string>(boost::any_cast<string>(m["CheckUrl"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sources = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<AddCdnDomainRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddCdnDomainRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<AddCdnDomainRequestTag>>(expect1);
      }
    }
    if (m.find("TopLevelDomain") != m.end() && !m["TopLevelDomain"].empty()) {
      topLevelDomain = make_shared<string>(boost::any_cast<string>(m["TopLevelDomain"]));
    }
  }


  virtual ~AddCdnDomainRequest() = default;
};
class AddCdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddCdnDomainResponseBody() {}

  explicit AddCdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCdnDomainResponseBody() = default;
};
class AddCdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCdnDomainResponseBody> body{};

  AddCdnDomainResponse() {}

  explicit AddCdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~AddCdnDomainResponse() = default;
};
class AddFCTriggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> eventMetaName{};
  shared_ptr<string> eventMetaVersion{};
  shared_ptr<string> functionARN{};
  shared_ptr<string> notes{};
  shared_ptr<string> roleARN{};
  shared_ptr<string> sourceARN{};
  shared_ptr<string> triggerARN{};

  AddFCTriggerRequest() {}

  explicit AddFCTriggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventMetaName) {
      res["EventMetaName"] = boost::any(*eventMetaName);
    }
    if (eventMetaVersion) {
      res["EventMetaVersion"] = boost::any(*eventMetaVersion);
    }
    if (functionARN) {
      res["FunctionARN"] = boost::any(*functionARN);
    }
    if (notes) {
      res["Notes"] = boost::any(*notes);
    }
    if (roleARN) {
      res["RoleARN"] = boost::any(*roleARN);
    }
    if (sourceARN) {
      res["SourceARN"] = boost::any(*sourceARN);
    }
    if (triggerARN) {
      res["TriggerARN"] = boost::any(*triggerARN);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventMetaName") != m.end() && !m["EventMetaName"].empty()) {
      eventMetaName = make_shared<string>(boost::any_cast<string>(m["EventMetaName"]));
    }
    if (m.find("EventMetaVersion") != m.end() && !m["EventMetaVersion"].empty()) {
      eventMetaVersion = make_shared<string>(boost::any_cast<string>(m["EventMetaVersion"]));
    }
    if (m.find("FunctionARN") != m.end() && !m["FunctionARN"].empty()) {
      functionARN = make_shared<string>(boost::any_cast<string>(m["FunctionARN"]));
    }
    if (m.find("Notes") != m.end() && !m["Notes"].empty()) {
      notes = make_shared<string>(boost::any_cast<string>(m["Notes"]));
    }
    if (m.find("RoleARN") != m.end() && !m["RoleARN"].empty()) {
      roleARN = make_shared<string>(boost::any_cast<string>(m["RoleARN"]));
    }
    if (m.find("SourceARN") != m.end() && !m["SourceARN"].empty()) {
      sourceARN = make_shared<string>(boost::any_cast<string>(m["SourceARN"]));
    }
    if (m.find("TriggerARN") != m.end() && !m["TriggerARN"].empty()) {
      triggerARN = make_shared<string>(boost::any_cast<string>(m["TriggerARN"]));
    }
  }


  virtual ~AddFCTriggerRequest() = default;
};
class AddFCTriggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddFCTriggerResponseBody() {}

  explicit AddFCTriggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddFCTriggerResponseBody() = default;
};
class AddFCTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddFCTriggerResponseBody> body{};

  AddFCTriggerResponse() {}

  explicit AddFCTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddFCTriggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddFCTriggerResponseBody>(model1);
      }
    }
  }


  virtual ~AddFCTriggerResponse() = default;
};
class BatchAddCdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdnType{};
  shared_ptr<string> checkUrl{};
  shared_ptr<string> domainName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> scope{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> sources{};
  shared_ptr<string> topLevelDomain{};

  BatchAddCdnDomainRequest() {}

  explicit BatchAddCdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdnType) {
      res["CdnType"] = boost::any(*cdnType);
    }
    if (checkUrl) {
      res["CheckUrl"] = boost::any(*checkUrl);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (sources) {
      res["Sources"] = boost::any(*sources);
    }
    if (topLevelDomain) {
      res["TopLevelDomain"] = boost::any(*topLevelDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdnType") != m.end() && !m["CdnType"].empty()) {
      cdnType = make_shared<string>(boost::any_cast<string>(m["CdnType"]));
    }
    if (m.find("CheckUrl") != m.end() && !m["CheckUrl"].empty()) {
      checkUrl = make_shared<string>(boost::any_cast<string>(m["CheckUrl"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sources = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
    if (m.find("TopLevelDomain") != m.end() && !m["TopLevelDomain"].empty()) {
      topLevelDomain = make_shared<string>(boost::any_cast<string>(m["TopLevelDomain"]));
    }
  }


  virtual ~BatchAddCdnDomainRequest() = default;
};
class BatchAddCdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchAddCdnDomainResponseBody() {}

  explicit BatchAddCdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchAddCdnDomainResponseBody() = default;
};
class BatchAddCdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchAddCdnDomainResponseBody> body{};

  BatchAddCdnDomainResponse() {}

  explicit BatchAddCdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchAddCdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchAddCdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~BatchAddCdnDomainResponse() = default;
};
class BatchDeleteCdnDomainConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<string> functionNames{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  BatchDeleteCdnDomainConfigRequest() {}

  explicit BatchDeleteCdnDomainConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (functionNames) {
      res["FunctionNames"] = boost::any(*functionNames);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("FunctionNames") != m.end() && !m["FunctionNames"].empty()) {
      functionNames = make_shared<string>(boost::any_cast<string>(m["FunctionNames"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~BatchDeleteCdnDomainConfigRequest() = default;
};
class BatchDeleteCdnDomainConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchDeleteCdnDomainConfigResponseBody() {}

  explicit BatchDeleteCdnDomainConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchDeleteCdnDomainConfigResponseBody() = default;
};
class BatchDeleteCdnDomainConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchDeleteCdnDomainConfigResponseBody> body{};

  BatchDeleteCdnDomainConfigResponse() {}

  explicit BatchDeleteCdnDomainConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchDeleteCdnDomainConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchDeleteCdnDomainConfigResponseBody>(model1);
      }
    }
  }


  virtual ~BatchDeleteCdnDomainConfigResponse() = default;
};
class BatchSetCdnDomainConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<string> functions{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  BatchSetCdnDomainConfigRequest() {}

  explicit BatchSetCdnDomainConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (functions) {
      res["Functions"] = boost::any(*functions);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("Functions") != m.end() && !m["Functions"].empty()) {
      functions = make_shared<string>(boost::any_cast<string>(m["Functions"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~BatchSetCdnDomainConfigRequest() = default;
};
class BatchSetCdnDomainConfigResponseBodyDomainConfigListDomainConfigModel : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> functionName{};

  BatchSetCdnDomainConfigResponseBodyDomainConfigListDomainConfigModel() {}

  explicit BatchSetCdnDomainConfigResponseBodyDomainConfigListDomainConfigModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
  }


  virtual ~BatchSetCdnDomainConfigResponseBodyDomainConfigListDomainConfigModel() = default;
};
class BatchSetCdnDomainConfigResponseBodyDomainConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<BatchSetCdnDomainConfigResponseBodyDomainConfigListDomainConfigModel>> domainConfigModel{};

  BatchSetCdnDomainConfigResponseBodyDomainConfigList() {}

  explicit BatchSetCdnDomainConfigResponseBodyDomainConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfigModel) {
      vector<boost::any> temp1;
      for(auto item1:*domainConfigModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainConfigModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfigModel") != m.end() && !m["DomainConfigModel"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainConfigModel"].type()) {
        vector<BatchSetCdnDomainConfigResponseBodyDomainConfigListDomainConfigModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainConfigModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchSetCdnDomainConfigResponseBodyDomainConfigListDomainConfigModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainConfigModel = make_shared<vector<BatchSetCdnDomainConfigResponseBodyDomainConfigListDomainConfigModel>>(expect1);
      }
    }
  }


  virtual ~BatchSetCdnDomainConfigResponseBodyDomainConfigList() = default;
};
class BatchSetCdnDomainConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<BatchSetCdnDomainConfigResponseBodyDomainConfigList> domainConfigList{};
  shared_ptr<string> requestId{};

  BatchSetCdnDomainConfigResponseBody() {}

  explicit BatchSetCdnDomainConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfigList) {
      res["DomainConfigList"] = domainConfigList ? boost::any(domainConfigList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfigList") != m.end() && !m["DomainConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainConfigList"].type()) {
        BatchSetCdnDomainConfigResponseBodyDomainConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainConfigList"]));
        domainConfigList = make_shared<BatchSetCdnDomainConfigResponseBodyDomainConfigList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchSetCdnDomainConfigResponseBody() = default;
};
class BatchSetCdnDomainConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchSetCdnDomainConfigResponseBody> body{};

  BatchSetCdnDomainConfigResponse() {}

  explicit BatchSetCdnDomainConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchSetCdnDomainConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchSetCdnDomainConfigResponseBody>(model1);
      }
    }
  }


  virtual ~BatchSetCdnDomainConfigResponse() = default;
};
class BatchSetCdnDomainServerCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> certName{};
  shared_ptr<string> certType{};
  shared_ptr<string> domainName{};
  shared_ptr<string> forceSet{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> SSLPri{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> SSLPub{};
  shared_ptr<string> securityToken{};

  BatchSetCdnDomainServerCertificateRequest() {}

  explicit BatchSetCdnDomainServerCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (forceSet) {
      res["ForceSet"] = boost::any(*forceSet);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (SSLPri) {
      res["SSLPri"] = boost::any(*SSLPri);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ForceSet") != m.end() && !m["ForceSet"].empty()) {
      forceSet = make_shared<string>(boost::any_cast<string>(m["ForceSet"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SSLPri") != m.end() && !m["SSLPri"].empty()) {
      SSLPri = make_shared<string>(boost::any_cast<string>(m["SSLPri"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~BatchSetCdnDomainServerCertificateRequest() = default;
};
class BatchSetCdnDomainServerCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchSetCdnDomainServerCertificateResponseBody() {}

  explicit BatchSetCdnDomainServerCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchSetCdnDomainServerCertificateResponseBody() = default;
};
class BatchSetCdnDomainServerCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchSetCdnDomainServerCertificateResponseBody> body{};

  BatchSetCdnDomainServerCertificateResponse() {}

  explicit BatchSetCdnDomainServerCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchSetCdnDomainServerCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchSetCdnDomainServerCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~BatchSetCdnDomainServerCertificateResponse() = default;
};
class BatchStartCdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  BatchStartCdnDomainRequest() {}

  explicit BatchStartCdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~BatchStartCdnDomainRequest() = default;
};
class BatchStartCdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchStartCdnDomainResponseBody() {}

  explicit BatchStartCdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchStartCdnDomainResponseBody() = default;
};
class BatchStartCdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchStartCdnDomainResponseBody> body{};

  BatchStartCdnDomainResponse() {}

  explicit BatchStartCdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchStartCdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchStartCdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~BatchStartCdnDomainResponse() = default;
};
class BatchStopCdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  BatchStopCdnDomainRequest() {}

  explicit BatchStopCdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~BatchStopCdnDomainRequest() = default;
};
class BatchStopCdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchStopCdnDomainResponseBody() {}

  explicit BatchStopCdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchStopCdnDomainResponseBody() = default;
};
class BatchStopCdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchStopCdnDomainResponseBody> body{};

  BatchStopCdnDomainResponse() {}

  explicit BatchStopCdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchStopCdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchStopCdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~BatchStopCdnDomainResponse() = default;
};
class BatchUpdateCdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> sources{};
  shared_ptr<string> topLevelDomain{};

  BatchUpdateCdnDomainRequest() {}

  explicit BatchUpdateCdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (sources) {
      res["Sources"] = boost::any(*sources);
    }
    if (topLevelDomain) {
      res["TopLevelDomain"] = boost::any(*topLevelDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sources = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
    if (m.find("TopLevelDomain") != m.end() && !m["TopLevelDomain"].empty()) {
      topLevelDomain = make_shared<string>(boost::any_cast<string>(m["TopLevelDomain"]));
    }
  }


  virtual ~BatchUpdateCdnDomainRequest() = default;
};
class BatchUpdateCdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchUpdateCdnDomainResponseBody() {}

  explicit BatchUpdateCdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchUpdateCdnDomainResponseBody() = default;
};
class BatchUpdateCdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchUpdateCdnDomainResponseBody> body{};

  BatchUpdateCdnDomainResponse() {}

  explicit BatchUpdateCdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchUpdateCdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchUpdateCdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~BatchUpdateCdnDomainResponse() = default;
};
class ChangeCdnDomainToDcdnRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> operation{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  ChangeCdnDomainToDcdnRequest() {}

  explicit ChangeCdnDomainToDcdnRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ChangeCdnDomainToDcdnRequest() = default;
};
class ChangeCdnDomainToDcdnResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  ChangeCdnDomainToDcdnResponseBody() {}

  explicit ChangeCdnDomainToDcdnResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ChangeCdnDomainToDcdnResponseBody() = default;
};
class ChangeCdnDomainToDcdnResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeCdnDomainToDcdnResponseBody> body{};

  ChangeCdnDomainToDcdnResponse() {}

  explicit ChangeCdnDomainToDcdnResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeCdnDomainToDcdnResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeCdnDomainToDcdnResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeCdnDomainToDcdnResponse() = default;
};
class CreateCdnCertificateSigningRequestRequest : public Darabonba::Model {
public:
  shared_ptr<string> city{};
  shared_ptr<string> commonName{};
  shared_ptr<string> country{};
  shared_ptr<string> email{};
  shared_ptr<string> organization{};
  shared_ptr<string> organizationUnit{};
  shared_ptr<string> SANs{};
  shared_ptr<string> state{};

  CreateCdnCertificateSigningRequestRequest() {}

  explicit CreateCdnCertificateSigningRequestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (organization) {
      res["Organization"] = boost::any(*organization);
    }
    if (organizationUnit) {
      res["OrganizationUnit"] = boost::any(*organizationUnit);
    }
    if (SANs) {
      res["SANs"] = boost::any(*SANs);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Organization") != m.end() && !m["Organization"].empty()) {
      organization = make_shared<string>(boost::any_cast<string>(m["Organization"]));
    }
    if (m.find("OrganizationUnit") != m.end() && !m["OrganizationUnit"].empty()) {
      organizationUnit = make_shared<string>(boost::any_cast<string>(m["OrganizationUnit"]));
    }
    if (m.find("SANs") != m.end() && !m["SANs"].empty()) {
      SANs = make_shared<string>(boost::any_cast<string>(m["SANs"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~CreateCdnCertificateSigningRequestRequest() = default;
};
class CreateCdnCertificateSigningRequestResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> commonName{};
  shared_ptr<string> csr{};
  shared_ptr<string> pubMd5{};
  shared_ptr<string> requestId{};

  CreateCdnCertificateSigningRequestResponseBody() {}

  explicit CreateCdnCertificateSigningRequestResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (csr) {
      res["Csr"] = boost::any(*csr);
    }
    if (pubMd5) {
      res["PubMd5"] = boost::any(*pubMd5);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("Csr") != m.end() && !m["Csr"].empty()) {
      csr = make_shared<string>(boost::any_cast<string>(m["Csr"]));
    }
    if (m.find("PubMd5") != m.end() && !m["PubMd5"].empty()) {
      pubMd5 = make_shared<string>(boost::any_cast<string>(m["PubMd5"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCdnCertificateSigningRequestResponseBody() = default;
};
class CreateCdnCertificateSigningRequestResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCdnCertificateSigningRequestResponseBody> body{};

  CreateCdnCertificateSigningRequestResponse() {}

  explicit CreateCdnCertificateSigningRequestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCdnCertificateSigningRequestResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCdnCertificateSigningRequestResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCdnCertificateSigningRequestResponse() = default;
};
class CreateCdnDeliverTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> deliver{};
  shared_ptr<string> domainName{};
  shared_ptr<string> name{};
  shared_ptr<string> reports{};
  shared_ptr<string> schedule{};

  CreateCdnDeliverTaskRequest() {}

  explicit CreateCdnDeliverTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliver) {
      res["Deliver"] = boost::any(*deliver);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (reports) {
      res["Reports"] = boost::any(*reports);
    }
    if (schedule) {
      res["Schedule"] = boost::any(*schedule);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Deliver") != m.end() && !m["Deliver"].empty()) {
      deliver = make_shared<string>(boost::any_cast<string>(m["Deliver"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Reports") != m.end() && !m["Reports"].empty()) {
      reports = make_shared<string>(boost::any_cast<string>(m["Reports"]));
    }
    if (m.find("Schedule") != m.end() && !m["Schedule"].empty()) {
      schedule = make_shared<string>(boost::any_cast<string>(m["Schedule"]));
    }
  }


  virtual ~CreateCdnDeliverTaskRequest() = default;
};
class CreateCdnDeliverTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> deliverId{};
  shared_ptr<string> requestId{};

  CreateCdnDeliverTaskResponseBody() {}

  explicit CreateCdnDeliverTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliverId) {
      res["DeliverId"] = boost::any(*deliverId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliverId") != m.end() && !m["DeliverId"].empty()) {
      deliverId = make_shared<string>(boost::any_cast<string>(m["DeliverId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCdnDeliverTaskResponseBody() = default;
};
class CreateCdnDeliverTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCdnDeliverTaskResponseBody> body{};

  CreateCdnDeliverTaskResponse() {}

  explicit CreateCdnDeliverTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCdnDeliverTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCdnDeliverTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCdnDeliverTaskResponse() = default;
};
class CreateCdnSubTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> reportIds{};

  CreateCdnSubTaskRequest() {}

  explicit CreateCdnSubTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (reportIds) {
      res["ReportIds"] = boost::any(*reportIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ReportIds") != m.end() && !m["ReportIds"].empty()) {
      reportIds = make_shared<string>(boost::any_cast<string>(m["ReportIds"]));
    }
  }


  virtual ~CreateCdnSubTaskRequest() = default;
};
class CreateCdnSubTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateCdnSubTaskResponseBody() {}

  explicit CreateCdnSubTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCdnSubTaskResponseBody() = default;
};
class CreateCdnSubTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCdnSubTaskResponseBody> body{};

  CreateCdnSubTaskResponse() {}

  explicit CreateCdnSubTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCdnSubTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCdnSubTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCdnSubTaskResponse() = default;
};
class CreateRealTimeLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> logstore{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};

  CreateRealTimeLogDeliveryRequest() {}

  explicit CreateRealTimeLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~CreateRealTimeLogDeliveryRequest() = default;
};
class CreateRealTimeLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateRealTimeLogDeliveryResponseBody() {}

  explicit CreateRealTimeLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateRealTimeLogDeliveryResponseBody() = default;
};
class CreateRealTimeLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRealTimeLogDeliveryResponseBody> body{};

  CreateRealTimeLogDeliveryResponse() {}

  explicit CreateRealTimeLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRealTimeLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRealTimeLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRealTimeLogDeliveryResponse() = default;
};
class CreateUsageDetailDataExportTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<string> endTime{};
  shared_ptr<string> group{};
  shared_ptr<string> language{};
  shared_ptr<string> startTime{};
  shared_ptr<string> taskName{};
  shared_ptr<string> type{};

  CreateUsageDetailDataExportTaskRequest() {}

  explicit CreateUsageDetailDataExportTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateUsageDetailDataExportTaskRequest() = default;
};
class CreateUsageDetailDataExportTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> taskId{};

  CreateUsageDetailDataExportTaskResponseBody() {}

  explicit CreateUsageDetailDataExportTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateUsageDetailDataExportTaskResponseBody() = default;
};
class CreateUsageDetailDataExportTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUsageDetailDataExportTaskResponseBody> body{};

  CreateUsageDetailDataExportTaskResponse() {}

  explicit CreateUsageDetailDataExportTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUsageDetailDataExportTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUsageDetailDataExportTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUsageDetailDataExportTaskResponse() = default;
};
class CreateUserUsageDataExportTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> language{};
  shared_ptr<string> startTime{};
  shared_ptr<string> taskName{};

  CreateUserUsageDataExportTaskRequest() {}

  explicit CreateUserUsageDataExportTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~CreateUserUsageDataExportTaskRequest() = default;
};
class CreateUserUsageDataExportTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> taskId{};

  CreateUserUsageDataExportTaskResponseBody() {}

  explicit CreateUserUsageDataExportTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateUserUsageDataExportTaskResponseBody() = default;
};
class CreateUserUsageDataExportTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUserUsageDataExportTaskResponseBody> body{};

  CreateUserUsageDataExportTaskResponse() {}

  explicit CreateUserUsageDataExportTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUserUsageDataExportTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUserUsageDataExportTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUserUsageDataExportTaskResponse() = default;
};
class DeleteCdnDeliverTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> deliverId{};

  DeleteCdnDeliverTaskRequest() {}

  explicit DeleteCdnDeliverTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliverId) {
      res["DeliverId"] = boost::any(*deliverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliverId") != m.end() && !m["DeliverId"].empty()) {
      deliverId = make_shared<long>(boost::any_cast<long>(m["DeliverId"]));
    }
  }


  virtual ~DeleteCdnDeliverTaskRequest() = default;
};
class DeleteCdnDeliverTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCdnDeliverTaskResponseBody() {}

  explicit DeleteCdnDeliverTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCdnDeliverTaskResponseBody() = default;
};
class DeleteCdnDeliverTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCdnDeliverTaskResponseBody> body{};

  DeleteCdnDeliverTaskResponse() {}

  explicit DeleteCdnDeliverTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCdnDeliverTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCdnDeliverTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCdnDeliverTaskResponse() = default;
};
class DeleteCdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};

  DeleteCdnDomainRequest() {}

  explicit DeleteCdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DeleteCdnDomainRequest() = default;
};
class DeleteCdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCdnDomainResponseBody() {}

  explicit DeleteCdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCdnDomainResponseBody() = default;
};
class DeleteCdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCdnDomainResponseBody> body{};

  DeleteCdnDomainResponse() {}

  explicit DeleteCdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCdnDomainResponse() = default;
};
class DeleteCdnSubTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCdnSubTaskResponseBody() {}

  explicit DeleteCdnSubTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCdnSubTaskResponseBody() = default;
};
class DeleteCdnSubTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCdnSubTaskResponseBody> body{};

  DeleteCdnSubTaskResponse() {}

  explicit DeleteCdnSubTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCdnSubTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCdnSubTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCdnSubTaskResponse() = default;
};
class DeleteFCTriggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> triggerARN{};

  DeleteFCTriggerRequest() {}

  explicit DeleteFCTriggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (triggerARN) {
      res["TriggerARN"] = boost::any(*triggerARN);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TriggerARN") != m.end() && !m["TriggerARN"].empty()) {
      triggerARN = make_shared<string>(boost::any_cast<string>(m["TriggerARN"]));
    }
  }


  virtual ~DeleteFCTriggerRequest() = default;
};
class DeleteFCTriggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteFCTriggerResponseBody() {}

  explicit DeleteFCTriggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteFCTriggerResponseBody() = default;
};
class DeleteFCTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFCTriggerResponseBody> body{};

  DeleteFCTriggerResponse() {}

  explicit DeleteFCTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFCTriggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFCTriggerResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFCTriggerResponse() = default;
};
class DeleteRealTimeLogLogstoreRequest : public Darabonba::Model {
public:
  shared_ptr<string> logstore{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};

  DeleteRealTimeLogLogstoreRequest() {}

  explicit DeleteRealTimeLogLogstoreRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~DeleteRealTimeLogLogstoreRequest() = default;
};
class DeleteRealTimeLogLogstoreResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteRealTimeLogLogstoreResponseBody() {}

  explicit DeleteRealTimeLogLogstoreResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRealTimeLogLogstoreResponseBody() = default;
};
class DeleteRealTimeLogLogstoreResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRealTimeLogLogstoreResponseBody> body{};

  DeleteRealTimeLogLogstoreResponse() {}

  explicit DeleteRealTimeLogLogstoreResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRealTimeLogLogstoreResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRealTimeLogLogstoreResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRealTimeLogLogstoreResponse() = default;
};
class DeleteRealtimeLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> logstore{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};

  DeleteRealtimeLogDeliveryRequest() {}

  explicit DeleteRealtimeLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~DeleteRealtimeLogDeliveryRequest() = default;
};
class DeleteRealtimeLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteRealtimeLogDeliveryResponseBody() {}

  explicit DeleteRealtimeLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRealtimeLogDeliveryResponseBody() = default;
};
class DeleteRealtimeLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRealtimeLogDeliveryResponseBody> body{};

  DeleteRealtimeLogDeliveryResponse() {}

  explicit DeleteRealtimeLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRealtimeLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRealtimeLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRealtimeLogDeliveryResponse() = default;
};
class DeleteSpecificConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DeleteSpecificConfigRequest() {}

  explicit DeleteSpecificConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteSpecificConfigRequest() = default;
};
class DeleteSpecificConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSpecificConfigResponseBody() {}

  explicit DeleteSpecificConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSpecificConfigResponseBody() = default;
};
class DeleteSpecificConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSpecificConfigResponseBody> body{};

  DeleteSpecificConfigResponse() {}

  explicit DeleteSpecificConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSpecificConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSpecificConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSpecificConfigResponse() = default;
};
class DeleteSpecificStagingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DeleteSpecificStagingConfigRequest() {}

  explicit DeleteSpecificStagingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteSpecificStagingConfigRequest() = default;
};
class DeleteSpecificStagingConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSpecificStagingConfigResponseBody() {}

  explicit DeleteSpecificStagingConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSpecificStagingConfigResponseBody() = default;
};
class DeleteSpecificStagingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSpecificStagingConfigResponseBody> body{};

  DeleteSpecificStagingConfigResponse() {}

  explicit DeleteSpecificStagingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSpecificStagingConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSpecificStagingConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSpecificStagingConfigResponse() = default;
};
class DeleteUsageDetailDataExportTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  DeleteUsageDetailDataExportTaskRequest() {}

  explicit DeleteUsageDetailDataExportTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DeleteUsageDetailDataExportTaskRequest() = default;
};
class DeleteUsageDetailDataExportTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteUsageDetailDataExportTaskResponseBody() {}

  explicit DeleteUsageDetailDataExportTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteUsageDetailDataExportTaskResponseBody() = default;
};
class DeleteUsageDetailDataExportTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteUsageDetailDataExportTaskResponseBody> body{};

  DeleteUsageDetailDataExportTaskResponse() {}

  explicit DeleteUsageDetailDataExportTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteUsageDetailDataExportTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteUsageDetailDataExportTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteUsageDetailDataExportTaskResponse() = default;
};
class DeleteUserUsageDataExportTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  DeleteUserUsageDataExportTaskRequest() {}

  explicit DeleteUserUsageDataExportTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DeleteUserUsageDataExportTaskRequest() = default;
};
class DeleteUserUsageDataExportTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteUserUsageDataExportTaskResponseBody() {}

  explicit DeleteUserUsageDataExportTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteUserUsageDataExportTaskResponseBody() = default;
};
class DeleteUserUsageDataExportTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteUserUsageDataExportTaskResponseBody> body{};

  DeleteUserUsageDataExportTaskResponse() {}

  explicit DeleteUserUsageDataExportTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteUserUsageDataExportTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteUserUsageDataExportTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteUserUsageDataExportTaskResponse() = default;
};
class DescribeBlockedRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> language{};

  DescribeBlockedRegionsRequest() {}

  explicit DescribeBlockedRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (language) {
      res["Language"] = boost::any(*language);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
  }


  virtual ~DescribeBlockedRegionsRequest() = default;
};
class DescribeBlockedRegionsResponseBodyInfoListInfoItem : public Darabonba::Model {
public:
  shared_ptr<string> continent{};
  shared_ptr<string> countriesAndRegions{};
  shared_ptr<string> countriesAndRegionsName{};

  DescribeBlockedRegionsResponseBodyInfoListInfoItem() {}

  explicit DescribeBlockedRegionsResponseBodyInfoListInfoItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (continent) {
      res["Continent"] = boost::any(*continent);
    }
    if (countriesAndRegions) {
      res["CountriesAndRegions"] = boost::any(*countriesAndRegions);
    }
    if (countriesAndRegionsName) {
      res["CountriesAndRegionsName"] = boost::any(*countriesAndRegionsName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Continent") != m.end() && !m["Continent"].empty()) {
      continent = make_shared<string>(boost::any_cast<string>(m["Continent"]));
    }
    if (m.find("CountriesAndRegions") != m.end() && !m["CountriesAndRegions"].empty()) {
      countriesAndRegions = make_shared<string>(boost::any_cast<string>(m["CountriesAndRegions"]));
    }
    if (m.find("CountriesAndRegionsName") != m.end() && !m["CountriesAndRegionsName"].empty()) {
      countriesAndRegionsName = make_shared<string>(boost::any_cast<string>(m["CountriesAndRegionsName"]));
    }
  }


  virtual ~DescribeBlockedRegionsResponseBodyInfoListInfoItem() = default;
};
class DescribeBlockedRegionsResponseBodyInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBlockedRegionsResponseBodyInfoListInfoItem>> infoItem{};

  DescribeBlockedRegionsResponseBodyInfoList() {}

  explicit DescribeBlockedRegionsResponseBodyInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (infoItem) {
      vector<boost::any> temp1;
      for(auto item1:*infoItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InfoItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InfoItem") != m.end() && !m["InfoItem"].empty()) {
      if (typeid(vector<boost::any>) == m["InfoItem"].type()) {
        vector<DescribeBlockedRegionsResponseBodyInfoListInfoItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InfoItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBlockedRegionsResponseBodyInfoListInfoItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        infoItem = make_shared<vector<DescribeBlockedRegionsResponseBodyInfoListInfoItem>>(expect1);
      }
    }
  }


  virtual ~DescribeBlockedRegionsResponseBodyInfoList() = default;
};
class DescribeBlockedRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeBlockedRegionsResponseBodyInfoList> infoList{};
  shared_ptr<string> requestId{};

  DescribeBlockedRegionsResponseBody() {}

  explicit DescribeBlockedRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (infoList) {
      res["InfoList"] = infoList ? boost::any(infoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InfoList") != m.end() && !m["InfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InfoList"].type()) {
        DescribeBlockedRegionsResponseBodyInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InfoList"]));
        infoList = make_shared<DescribeBlockedRegionsResponseBodyInfoList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeBlockedRegionsResponseBody() = default;
};
class DescribeBlockedRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBlockedRegionsResponseBody> body{};

  DescribeBlockedRegionsResponse() {}

  explicit DescribeBlockedRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBlockedRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBlockedRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBlockedRegionsResponse() = default;
};
class DescribeCdnCertificateDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> certName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeCdnCertificateDetailRequest() {}

  explicit DescribeCdnCertificateDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeCdnCertificateDetailRequest() = default;
};
class DescribeCdnCertificateDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> cert{};
  shared_ptr<long> certId{};
  shared_ptr<string> certName{};
  shared_ptr<string> key{};
  shared_ptr<string> requestId{};

  DescribeCdnCertificateDetailResponseBody() {}

  explicit DescribeCdnCertificateDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cert) {
      res["Cert"] = boost::any(*cert);
    }
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cert") != m.end() && !m["Cert"].empty()) {
      cert = make_shared<string>(boost::any_cast<string>(m["Cert"]));
    }
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<long>(boost::any_cast<long>(m["CertId"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCdnCertificateDetailResponseBody() = default;
};
class DescribeCdnCertificateDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnCertificateDetailResponseBody> body{};

  DescribeCdnCertificateDetailResponse() {}

  explicit DescribeCdnCertificateDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnCertificateDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnCertificateDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnCertificateDetailResponse() = default;
};
class DescribeCdnCertificateDetailByIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> certId{};
  shared_ptr<string> certRegion{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeCdnCertificateDetailByIdRequest() {}

  explicit DescribeCdnCertificateDetailByIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certRegion) {
      res["CertRegion"] = boost::any(*certRegion);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<string>(boost::any_cast<string>(m["CertId"]));
    }
    if (m.find("CertRegion") != m.end() && !m["CertRegion"].empty()) {
      certRegion = make_shared<string>(boost::any_cast<string>(m["CertRegion"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeCdnCertificateDetailByIdRequest() = default;
};
class DescribeCdnCertificateDetailByIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> cert{};
  shared_ptr<long> certId{};
  shared_ptr<string> certName{};
  shared_ptr<string> key{};
  shared_ptr<string> requestId{};

  DescribeCdnCertificateDetailByIdResponseBody() {}

  explicit DescribeCdnCertificateDetailByIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cert) {
      res["Cert"] = boost::any(*cert);
    }
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cert") != m.end() && !m["Cert"].empty()) {
      cert = make_shared<string>(boost::any_cast<string>(m["Cert"]));
    }
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<long>(boost::any_cast<long>(m["CertId"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCdnCertificateDetailByIdResponseBody() = default;
};
class DescribeCdnCertificateDetailByIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnCertificateDetailByIdResponseBody> body{};

  DescribeCdnCertificateDetailByIdResponse() {}

  explicit DescribeCdnCertificateDetailByIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnCertificateDetailByIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnCertificateDetailByIdResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnCertificateDetailByIdResponse() = default;
};
class DescribeCdnCertificateListRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeCdnCertificateListRequest() {}

  explicit DescribeCdnCertificateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeCdnCertificateListRequest() = default;
};
class DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert : public Darabonba::Model {
public:
  shared_ptr<long> certId{};
  shared_ptr<string> certName{};
  shared_ptr<string> common{};
  shared_ptr<string> fingerprint{};
  shared_ptr<string> issuer{};
  shared_ptr<long> lastTime{};

  DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert() {}

  explicit DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (common) {
      res["Common"] = boost::any(*common);
    }
    if (fingerprint) {
      res["Fingerprint"] = boost::any(*fingerprint);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    if (lastTime) {
      res["LastTime"] = boost::any(*lastTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<long>(boost::any_cast<long>(m["CertId"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Common") != m.end() && !m["Common"].empty()) {
      common = make_shared<string>(boost::any_cast<string>(m["Common"]));
    }
    if (m.find("Fingerprint") != m.end() && !m["Fingerprint"].empty()) {
      fingerprint = make_shared<string>(boost::any_cast<string>(m["Fingerprint"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
    if (m.find("LastTime") != m.end() && !m["LastTime"].empty()) {
      lastTime = make_shared<long>(boost::any_cast<long>(m["LastTime"]));
    }
  }


  virtual ~DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert() = default;
};
class DescribeCdnCertificateListResponseBodyCertificateListModelCertList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert>> cert{};

  DescribeCdnCertificateListResponseBodyCertificateListModelCertList() {}

  explicit DescribeCdnCertificateListResponseBodyCertificateListModelCertList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cert) {
      vector<boost::any> temp1;
      for(auto item1:*cert){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Cert"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cert") != m.end() && !m["Cert"].empty()) {
      if (typeid(vector<boost::any>) == m["Cert"].type()) {
        vector<DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Cert"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cert = make_shared<vector<DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert>>(expect1);
      }
    }
  }


  virtual ~DescribeCdnCertificateListResponseBodyCertificateListModelCertList() = default;
};
class DescribeCdnCertificateListResponseBodyCertificateListModel : public Darabonba::Model {
public:
  shared_ptr<DescribeCdnCertificateListResponseBodyCertificateListModelCertList> certList{};
  shared_ptr<long> count{};

  DescribeCdnCertificateListResponseBodyCertificateListModel() {}

  explicit DescribeCdnCertificateListResponseBodyCertificateListModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certList) {
      res["CertList"] = certList ? boost::any(certList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertList") != m.end() && !m["CertList"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertList"].type()) {
        DescribeCdnCertificateListResponseBodyCertificateListModelCertList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertList"]));
        certList = make_shared<DescribeCdnCertificateListResponseBodyCertificateListModelCertList>(model1);
      }
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeCdnCertificateListResponseBodyCertificateListModel() = default;
};
class DescribeCdnCertificateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCdnCertificateListResponseBodyCertificateListModel> certificateListModel{};
  shared_ptr<string> requestId{};

  DescribeCdnCertificateListResponseBody() {}

  explicit DescribeCdnCertificateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateListModel) {
      res["CertificateListModel"] = certificateListModel ? boost::any(certificateListModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateListModel") != m.end() && !m["CertificateListModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertificateListModel"].type()) {
        DescribeCdnCertificateListResponseBodyCertificateListModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertificateListModel"]));
        certificateListModel = make_shared<DescribeCdnCertificateListResponseBodyCertificateListModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCdnCertificateListResponseBody() = default;
};
class DescribeCdnCertificateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnCertificateListResponseBody> body{};

  DescribeCdnCertificateListResponse() {}

  explicit DescribeCdnCertificateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnCertificateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnCertificateListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnCertificateListResponse() = default;
};
class DescribeCdnConditionIPBInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataId{};

  DescribeCdnConditionIPBInfoRequest() {}

  explicit DescribeCdnConditionIPBInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
  }


  virtual ~DescribeCdnConditionIPBInfoRequest() = default;
};
class DescribeCdnConditionIPBInfoResponseBodyDatas : public Darabonba::Model {
public:
  shared_ptr<string> value{};

  DescribeCdnConditionIPBInfoResponseBodyDatas() {}

  explicit DescribeCdnConditionIPBInfoResponseBodyDatas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeCdnConditionIPBInfoResponseBodyDatas() = default;
};
class DescribeCdnConditionIPBInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnConditionIPBInfoResponseBodyDatas>> datas{};
  shared_ptr<string> requestId{};

  DescribeCdnConditionIPBInfoResponseBody() {}

  explicit DescribeCdnConditionIPBInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datas) {
      vector<boost::any> temp1;
      for(auto item1:*datas){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Datas"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Datas") != m.end() && !m["Datas"].empty()) {
      if (typeid(vector<boost::any>) == m["Datas"].type()) {
        vector<DescribeCdnConditionIPBInfoResponseBodyDatas> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Datas"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnConditionIPBInfoResponseBodyDatas model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        datas = make_shared<vector<DescribeCdnConditionIPBInfoResponseBodyDatas>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCdnConditionIPBInfoResponseBody() = default;
};
class DescribeCdnConditionIPBInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnConditionIPBInfoResponseBody> body{};

  DescribeCdnConditionIPBInfoResponse() {}

  explicit DescribeCdnConditionIPBInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnConditionIPBInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnConditionIPBInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnConditionIPBInfoResponse() = default;
};
class DescribeCdnDeletedDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeCdnDeletedDomainsRequest() {}

  explicit DescribeCdnDeletedDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeCdnDeletedDomainsRequest() = default;
};
class DescribeCdnDeletedDomainsResponseBodyDomainsPageData : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> gmtModified{};

  DescribeCdnDeletedDomainsResponseBodyDomainsPageData() {}

  explicit DescribeCdnDeletedDomainsResponseBodyDomainsPageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
  }


  virtual ~DescribeCdnDeletedDomainsResponseBodyDomainsPageData() = default;
};
class DescribeCdnDeletedDomainsResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnDeletedDomainsResponseBodyDomainsPageData>> pageData{};

  DescribeCdnDeletedDomainsResponseBodyDomains() {}

  explicit DescribeCdnDeletedDomainsResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageData) {
      vector<boost::any> temp1;
      for(auto item1:*pageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageData") != m.end() && !m["PageData"].empty()) {
      if (typeid(vector<boost::any>) == m["PageData"].type()) {
        vector<DescribeCdnDeletedDomainsResponseBodyDomainsPageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnDeletedDomainsResponseBodyDomainsPageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pageData = make_shared<vector<DescribeCdnDeletedDomainsResponseBodyDomainsPageData>>(expect1);
      }
    }
  }


  virtual ~DescribeCdnDeletedDomainsResponseBodyDomains() = default;
};
class DescribeCdnDeletedDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCdnDeletedDomainsResponseBodyDomains> domains{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeCdnDeletedDomainsResponseBody() {}

  explicit DescribeCdnDeletedDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = domains ? boost::any(domains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(map<string, boost::any>) == m["Domains"].type()) {
        DescribeCdnDeletedDomainsResponseBodyDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Domains"]));
        domains = make_shared<DescribeCdnDeletedDomainsResponseBodyDomains>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeCdnDeletedDomainsResponseBody() = default;
};
class DescribeCdnDeletedDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnDeletedDomainsResponseBody> body{};

  DescribeCdnDeletedDomainsResponse() {}

  explicit DescribeCdnDeletedDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnDeletedDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnDeletedDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnDeletedDomainsResponse() = default;
};
class DescribeCdnDeliverListRequest : public Darabonba::Model {
public:
  shared_ptr<long> deliverId{};

  DescribeCdnDeliverListRequest() {}

  explicit DescribeCdnDeliverListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliverId) {
      res["DeliverId"] = boost::any(*deliverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliverId") != m.end() && !m["DeliverId"].empty()) {
      deliverId = make_shared<long>(boost::any_cast<long>(m["DeliverId"]));
    }
  }


  virtual ~DescribeCdnDeliverListRequest() = default;
};
class DescribeCdnDeliverListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  DescribeCdnDeliverListResponseBody() {}

  explicit DescribeCdnDeliverListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCdnDeliverListResponseBody() = default;
};
class DescribeCdnDeliverListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnDeliverListResponseBody> body{};

  DescribeCdnDeliverListResponse() {}

  explicit DescribeCdnDeliverListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnDeliverListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnDeliverListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnDeliverListResponse() = default;
};
class DescribeCdnDomainByCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<bool> exact{};
  shared_ptr<string> SSLPub{};
  shared_ptr<bool> SSLStatus{};

  DescribeCdnDomainByCertificateRequest() {}

  explicit DescribeCdnDomainByCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exact) {
      res["Exact"] = boost::any(*exact);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (SSLStatus) {
      res["SSLStatus"] = boost::any(*SSLStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Exact") != m.end() && !m["Exact"].empty()) {
      exact = make_shared<bool>(boost::any_cast<bool>(m["Exact"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("SSLStatus") != m.end() && !m["SSLStatus"].empty()) {
      SSLStatus = make_shared<bool>(boost::any_cast<bool>(m["SSLStatus"]));
    }
  }


  virtual ~DescribeCdnDomainByCertificateRequest() = default;
};
class DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo : public Darabonba::Model {
public:
  shared_ptr<string> certCaIsLegacy{};
  shared_ptr<string> certExpireTime{};
  shared_ptr<string> certExpired{};
  shared_ptr<string> certStartTime{};
  shared_ptr<string> certSubjectCommonName{};
  shared_ptr<string> certType{};
  shared_ptr<string> domainList{};
  shared_ptr<string> domainNames{};
  shared_ptr<string> issuer{};

  DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo() {}

  explicit DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certCaIsLegacy) {
      res["CertCaIsLegacy"] = boost::any(*certCaIsLegacy);
    }
    if (certExpireTime) {
      res["CertExpireTime"] = boost::any(*certExpireTime);
    }
    if (certExpired) {
      res["CertExpired"] = boost::any(*certExpired);
    }
    if (certStartTime) {
      res["CertStartTime"] = boost::any(*certStartTime);
    }
    if (certSubjectCommonName) {
      res["CertSubjectCommonName"] = boost::any(*certSubjectCommonName);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (domainList) {
      res["DomainList"] = boost::any(*domainList);
    }
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertCaIsLegacy") != m.end() && !m["CertCaIsLegacy"].empty()) {
      certCaIsLegacy = make_shared<string>(boost::any_cast<string>(m["CertCaIsLegacy"]));
    }
    if (m.find("CertExpireTime") != m.end() && !m["CertExpireTime"].empty()) {
      certExpireTime = make_shared<string>(boost::any_cast<string>(m["CertExpireTime"]));
    }
    if (m.find("CertExpired") != m.end() && !m["CertExpired"].empty()) {
      certExpired = make_shared<string>(boost::any_cast<string>(m["CertExpired"]));
    }
    if (m.find("CertStartTime") != m.end() && !m["CertStartTime"].empty()) {
      certStartTime = make_shared<string>(boost::any_cast<string>(m["CertStartTime"]));
    }
    if (m.find("CertSubjectCommonName") != m.end() && !m["CertSubjectCommonName"].empty()) {
      certSubjectCommonName = make_shared<string>(boost::any_cast<string>(m["CertSubjectCommonName"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("DomainList") != m.end() && !m["DomainList"].empty()) {
      domainList = make_shared<string>(boost::any_cast<string>(m["DomainList"]));
    }
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
  }


  virtual ~DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo() = default;
};
class DescribeCdnDomainByCertificateResponseBodyCertInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo>> certInfo{};

  DescribeCdnDomainByCertificateResponseBodyCertInfos() {}

  explicit DescribeCdnDomainByCertificateResponseBodyCertInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfo) {
      vector<boost::any> temp1;
      for(auto item1:*certInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CertInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfo") != m.end() && !m["CertInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["CertInfo"].type()) {
        vector<DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CertInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certInfo = make_shared<vector<DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeCdnDomainByCertificateResponseBodyCertInfos() = default;
};
class DescribeCdnDomainByCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCdnDomainByCertificateResponseBodyCertInfos> certInfos{};
  shared_ptr<string> requestId{};

  DescribeCdnDomainByCertificateResponseBody() {}

  explicit DescribeCdnDomainByCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfos) {
      res["CertInfos"] = certInfos ? boost::any(certInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfos") != m.end() && !m["CertInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertInfos"].type()) {
        DescribeCdnDomainByCertificateResponseBodyCertInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertInfos"]));
        certInfos = make_shared<DescribeCdnDomainByCertificateResponseBodyCertInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCdnDomainByCertificateResponseBody() = default;
};
class DescribeCdnDomainByCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnDomainByCertificateResponseBody> body{};

  DescribeCdnDomainByCertificateResponse() {}

  explicit DescribeCdnDomainByCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnDomainByCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnDomainByCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnDomainByCertificateResponse() = default;
};
class DescribeCdnDomainConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> functionNames{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeCdnDomainConfigsRequest() {}

  explicit DescribeCdnDomainConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functionNames) {
      res["FunctionNames"] = boost::any(*functionNames);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FunctionNames") != m.end() && !m["FunctionNames"].empty()) {
      functionNames = make_shared<string>(boost::any_cast<string>(m["FunctionNames"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeCdnDomainConfigsRequest() = default;
};
class DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg : public Darabonba::Model {
public:
  shared_ptr<string> argName{};
  shared_ptr<string> argValue{};

  DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg() {}

  explicit DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (argName) {
      res["ArgName"] = boost::any(*argName);
    }
    if (argValue) {
      res["ArgValue"] = boost::any(*argValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArgName") != m.end() && !m["ArgName"].empty()) {
      argName = make_shared<string>(boost::any_cast<string>(m["ArgName"]));
    }
    if (m.find("ArgValue") != m.end() && !m["ArgValue"].empty()) {
      argValue = make_shared<string>(boost::any_cast<string>(m["ArgValue"]));
    }
  }


  virtual ~DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg() = default;
};
class DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg>> functionArg{};

  DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs() {}

  explicit DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionArg) {
      vector<boost::any> temp1;
      for(auto item1:*functionArg){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FunctionArg"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionArg") != m.end() && !m["FunctionArg"].empty()) {
      if (typeid(vector<boost::any>) == m["FunctionArg"].type()) {
        vector<DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FunctionArg"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        functionArg = make_shared<vector<DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg>>(expect1);
      }
    }
  }


  virtual ~DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs() = default;
};
class DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs> functionArgs{};
  shared_ptr<string> functionName{};
  shared_ptr<string> parentId{};
  shared_ptr<string> status{};

  DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig() {}

  explicit DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (functionArgs) {
      res["FunctionArgs"] = functionArgs ? boost::any(functionArgs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("FunctionArgs") != m.end() && !m["FunctionArgs"].empty()) {
      if (typeid(map<string, boost::any>) == m["FunctionArgs"].type()) {
        DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FunctionArgs"]));
        functionArgs = make_shared<DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs>(model1);
      }
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig() = default;
};
class DescribeCdnDomainConfigsResponseBodyDomainConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig>> domainConfig{};

  DescribeCdnDomainConfigsResponseBodyDomainConfigs() {}

  explicit DescribeCdnDomainConfigsResponseBodyDomainConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfig) {
      vector<boost::any> temp1;
      for(auto item1:*domainConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfig") != m.end() && !m["DomainConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainConfig"].type()) {
        vector<DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainConfig = make_shared<vector<DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeCdnDomainConfigsResponseBodyDomainConfigs() = default;
};
class DescribeCdnDomainConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCdnDomainConfigsResponseBodyDomainConfigs> domainConfigs{};
  shared_ptr<string> requestId{};

  DescribeCdnDomainConfigsResponseBody() {}

  explicit DescribeCdnDomainConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfigs) {
      res["DomainConfigs"] = domainConfigs ? boost::any(domainConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfigs") != m.end() && !m["DomainConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainConfigs"].type()) {
        DescribeCdnDomainConfigsResponseBodyDomainConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainConfigs"]));
        domainConfigs = make_shared<DescribeCdnDomainConfigsResponseBodyDomainConfigs>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCdnDomainConfigsResponseBody() = default;
};
class DescribeCdnDomainConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnDomainConfigsResponseBody> body{};

  DescribeCdnDomainConfigsResponse() {}

  explicit DescribeCdnDomainConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnDomainConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnDomainConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnDomainConfigsResponse() = default;
};
class DescribeCdnDomainDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeCdnDomainDetailRequest() {}

  explicit DescribeCdnDomainDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeCdnDomainDetailRequest() = default;
};
class DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> enabled{};
  shared_ptr<long> port{};
  shared_ptr<string> priority{};
  shared_ptr<string> type{};
  shared_ptr<string> weight{};

  DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel() {}

  explicit DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<string>(boost::any_cast<string>(m["Enabled"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<string>(boost::any_cast<string>(m["Weight"]));
    }
  }


  virtual ~DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel() = default;
};
class DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModels : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel>> sourceModel{};

  DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModels() {}

  explicit DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceModel) {
      vector<boost::any> temp1;
      for(auto item1:*sourceModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceModel") != m.end() && !m["SourceModel"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceModel"].type()) {
        vector<DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceModel = make_shared<vector<DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel>>(expect1);
      }
    }
  }


  virtual ~DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModels() = default;
};
class DescribeCdnDomainDetailResponseBodyGetDomainDetailModel : public Darabonba::Model {
public:
  shared_ptr<string> cdnType{};
  shared_ptr<string> cname{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> gmtCreated{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> httpsCname{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> scope{};
  shared_ptr<string> serverCertificateStatus{};
  shared_ptr<DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModels> sourceModels{};

  DescribeCdnDomainDetailResponseBodyGetDomainDetailModel() {}

  explicit DescribeCdnDomainDetailResponseBodyGetDomainDetailModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdnType) {
      res["CdnType"] = boost::any(*cdnType);
    }
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (httpsCname) {
      res["HttpsCname"] = boost::any(*httpsCname);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (serverCertificateStatus) {
      res["ServerCertificateStatus"] = boost::any(*serverCertificateStatus);
    }
    if (sourceModels) {
      res["SourceModels"] = sourceModels ? boost::any(sourceModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdnType") != m.end() && !m["CdnType"].empty()) {
      cdnType = make_shared<string>(boost::any_cast<string>(m["CdnType"]));
    }
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<string>(boost::any_cast<string>(m["GmtCreated"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("HttpsCname") != m.end() && !m["HttpsCname"].empty()) {
      httpsCname = make_shared<string>(boost::any_cast<string>(m["HttpsCname"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("ServerCertificateStatus") != m.end() && !m["ServerCertificateStatus"].empty()) {
      serverCertificateStatus = make_shared<string>(boost::any_cast<string>(m["ServerCertificateStatus"]));
    }
    if (m.find("SourceModels") != m.end() && !m["SourceModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceModels"].type()) {
        DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceModels"]));
        sourceModels = make_shared<DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModels>(model1);
      }
    }
  }


  virtual ~DescribeCdnDomainDetailResponseBodyGetDomainDetailModel() = default;
};
class DescribeCdnDomainDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCdnDomainDetailResponseBodyGetDomainDetailModel> getDomainDetailModel{};
  shared_ptr<string> requestId{};

  DescribeCdnDomainDetailResponseBody() {}

  explicit DescribeCdnDomainDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (getDomainDetailModel) {
      res["GetDomainDetailModel"] = getDomainDetailModel ? boost::any(getDomainDetailModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GetDomainDetailModel") != m.end() && !m["GetDomainDetailModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["GetDomainDetailModel"].type()) {
        DescribeCdnDomainDetailResponseBodyGetDomainDetailModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GetDomainDetailModel"]));
        getDomainDetailModel = make_shared<DescribeCdnDomainDetailResponseBodyGetDomainDetailModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCdnDomainDetailResponseBody() = default;
};
class DescribeCdnDomainDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnDomainDetailResponseBody> body{};

  DescribeCdnDomainDetailResponse() {}

  explicit DescribeCdnDomainDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnDomainDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnDomainDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnDomainDetailResponse() = default;
};
class DescribeCdnDomainLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};

  DescribeCdnDomainLogsRequest() {}

  explicit DescribeCdnDomainLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeCdnDomainLogsRequest() = default;
};
class DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> logName{};
  shared_ptr<string> logPath{};
  shared_ptr<long> logSize{};
  shared_ptr<string> startTime{};

  DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail() {}

  explicit DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (logName) {
      res["LogName"] = boost::any(*logName);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (logSize) {
      res["LogSize"] = boost::any(*logSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("LogName") != m.end() && !m["LogName"].empty()) {
      logName = make_shared<string>(boost::any_cast<string>(m["LogName"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("LogSize") != m.end() && !m["LogSize"].empty()) {
      logSize = make_shared<long>(boost::any_cast<long>(m["LogSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail() = default;
};
class DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail>> logInfoDetail{};

  DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfos() {}

  explicit DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logInfoDetail) {
      vector<boost::any> temp1;
      for(auto item1:*logInfoDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogInfoDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogInfoDetail") != m.end() && !m["LogInfoDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["LogInfoDetail"].type()) {
        vector<DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogInfoDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logInfoDetail = make_shared<vector<DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfos() = default;
};
class DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailPageInfos : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailPageInfos() {}

  explicit DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailPageInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailPageInfos() = default;
};
class DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> logCount{};
  shared_ptr<DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfos> logInfos{};
  shared_ptr<DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailPageInfos> pageInfos{};

  DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail() {}

  explicit DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (logCount) {
      res["LogCount"] = boost::any(*logCount);
    }
    if (logInfos) {
      res["LogInfos"] = logInfos ? boost::any(logInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageInfos) {
      res["PageInfos"] = pageInfos ? boost::any(pageInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("LogCount") != m.end() && !m["LogCount"].empty()) {
      logCount = make_shared<long>(boost::any_cast<long>(m["LogCount"]));
    }
    if (m.find("LogInfos") != m.end() && !m["LogInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogInfos"].type()) {
        DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogInfos"]));
        logInfos = make_shared<DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfos>(model1);
      }
    }
    if (m.find("PageInfos") != m.end() && !m["PageInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfos"].type()) {
        DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailPageInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfos"]));
        pageInfos = make_shared<DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailPageInfos>(model1);
      }
    }
  }


  virtual ~DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail() = default;
};
class DescribeCdnDomainLogsResponseBodyDomainLogDetails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail>> domainLogDetail{};

  DescribeCdnDomainLogsResponseBodyDomainLogDetails() {}

  explicit DescribeCdnDomainLogsResponseBodyDomainLogDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLogDetail) {
      vector<boost::any> temp1;
      for(auto item1:*domainLogDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainLogDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLogDetail") != m.end() && !m["DomainLogDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainLogDetail"].type()) {
        vector<DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainLogDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainLogDetail = make_shared<vector<DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeCdnDomainLogsResponseBodyDomainLogDetails() = default;
};
class DescribeCdnDomainLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCdnDomainLogsResponseBodyDomainLogDetails> domainLogDetails{};
  shared_ptr<string> requestId{};

  DescribeCdnDomainLogsResponseBody() {}

  explicit DescribeCdnDomainLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLogDetails) {
      res["DomainLogDetails"] = domainLogDetails ? boost::any(domainLogDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLogDetails") != m.end() && !m["DomainLogDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainLogDetails"].type()) {
        DescribeCdnDomainLogsResponseBodyDomainLogDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainLogDetails"]));
        domainLogDetails = make_shared<DescribeCdnDomainLogsResponseBodyDomainLogDetails>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCdnDomainLogsResponseBody() = default;
};
class DescribeCdnDomainLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnDomainLogsResponseBody> body{};

  DescribeCdnDomainLogsResponse() {}

  explicit DescribeCdnDomainLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnDomainLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnDomainLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnDomainLogsResponse() = default;
};
class DescribeCdnDomainStagingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> functionNames{};

  DescribeCdnDomainStagingConfigRequest() {}

  explicit DescribeCdnDomainStagingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functionNames) {
      res["FunctionNames"] = boost::any(*functionNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FunctionNames") != m.end() && !m["FunctionNames"].empty()) {
      functionNames = make_shared<string>(boost::any_cast<string>(m["FunctionNames"]));
    }
  }


  virtual ~DescribeCdnDomainStagingConfigRequest() = default;
};
class DescribeCdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs : public Darabonba::Model {
public:
  shared_ptr<string> argName{};
  shared_ptr<string> argValue{};

  DescribeCdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs() {}

  explicit DescribeCdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (argName) {
      res["ArgName"] = boost::any(*argName);
    }
    if (argValue) {
      res["ArgValue"] = boost::any(*argValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArgName") != m.end() && !m["ArgName"].empty()) {
      argName = make_shared<string>(boost::any_cast<string>(m["ArgName"]));
    }
    if (m.find("ArgValue") != m.end() && !m["ArgValue"].empty()) {
      argValue = make_shared<string>(boost::any_cast<string>(m["ArgValue"]));
    }
  }


  virtual ~DescribeCdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs() = default;
};
class DescribeCdnDomainStagingConfigResponseBodyDomainConfigs : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<vector<DescribeCdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs>> functionArgs{};
  shared_ptr<string> functionName{};
  shared_ptr<string> parentId{};
  shared_ptr<string> status{};

  DescribeCdnDomainStagingConfigResponseBodyDomainConfigs() {}

  explicit DescribeCdnDomainStagingConfigResponseBodyDomainConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (functionArgs) {
      vector<boost::any> temp1;
      for(auto item1:*functionArgs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FunctionArgs"] = boost::any(temp1);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("FunctionArgs") != m.end() && !m["FunctionArgs"].empty()) {
      if (typeid(vector<boost::any>) == m["FunctionArgs"].type()) {
        vector<DescribeCdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FunctionArgs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        functionArgs = make_shared<vector<DescribeCdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs>>(expect1);
      }
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeCdnDomainStagingConfigResponseBodyDomainConfigs() = default;
};
class DescribeCdnDomainStagingConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnDomainStagingConfigResponseBodyDomainConfigs>> domainConfigs{};
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};

  DescribeCdnDomainStagingConfigResponseBody() {}

  explicit DescribeCdnDomainStagingConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*domainConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainConfigs"] = boost::any(temp1);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfigs") != m.end() && !m["DomainConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainConfigs"].type()) {
        vector<DescribeCdnDomainStagingConfigResponseBodyDomainConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnDomainStagingConfigResponseBodyDomainConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainConfigs = make_shared<vector<DescribeCdnDomainStagingConfigResponseBodyDomainConfigs>>(expect1);
      }
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCdnDomainStagingConfigResponseBody() = default;
};
class DescribeCdnDomainStagingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnDomainStagingConfigResponseBody> body{};

  DescribeCdnDomainStagingConfigResponse() {}

  explicit DescribeCdnDomainStagingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnDomainStagingConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnDomainStagingConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnDomainStagingConfigResponse() = default;
};
class DescribeCdnHttpsDomainListRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeCdnHttpsDomainListRequest() {}

  explicit DescribeCdnHttpsDomainListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeCdnHttpsDomainListRequest() = default;
};
class DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo : public Darabonba::Model {
public:
  shared_ptr<string> certCommonName{};
  shared_ptr<string> certExpireTime{};
  shared_ptr<string> certName{};
  shared_ptr<string> certStartTime{};
  shared_ptr<string> certStatus{};
  shared_ptr<string> certType{};
  shared_ptr<string> certUpdateTime{};
  shared_ptr<string> domainName{};

  DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo() {}

  explicit DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certCommonName) {
      res["CertCommonName"] = boost::any(*certCommonName);
    }
    if (certExpireTime) {
      res["CertExpireTime"] = boost::any(*certExpireTime);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certStartTime) {
      res["CertStartTime"] = boost::any(*certStartTime);
    }
    if (certStatus) {
      res["CertStatus"] = boost::any(*certStatus);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (certUpdateTime) {
      res["CertUpdateTime"] = boost::any(*certUpdateTime);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertCommonName") != m.end() && !m["CertCommonName"].empty()) {
      certCommonName = make_shared<string>(boost::any_cast<string>(m["CertCommonName"]));
    }
    if (m.find("CertExpireTime") != m.end() && !m["CertExpireTime"].empty()) {
      certExpireTime = make_shared<string>(boost::any_cast<string>(m["CertExpireTime"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertStartTime") != m.end() && !m["CertStartTime"].empty()) {
      certStartTime = make_shared<string>(boost::any_cast<string>(m["CertStartTime"]));
    }
    if (m.find("CertStatus") != m.end() && !m["CertStatus"].empty()) {
      certStatus = make_shared<string>(boost::any_cast<string>(m["CertStatus"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("CertUpdateTime") != m.end() && !m["CertUpdateTime"].empty()) {
      certUpdateTime = make_shared<string>(boost::any_cast<string>(m["CertUpdateTime"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo() = default;
};
class DescribeCdnHttpsDomainListResponseBodyCertInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo>> certInfo{};

  DescribeCdnHttpsDomainListResponseBodyCertInfos() {}

  explicit DescribeCdnHttpsDomainListResponseBodyCertInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfo) {
      vector<boost::any> temp1;
      for(auto item1:*certInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CertInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfo") != m.end() && !m["CertInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["CertInfo"].type()) {
        vector<DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CertInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certInfo = make_shared<vector<DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeCdnHttpsDomainListResponseBodyCertInfos() = default;
};
class DescribeCdnHttpsDomainListResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCdnHttpsDomainListResponseBodyCertInfos> certInfos{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeCdnHttpsDomainListResponseBody() {}

  explicit DescribeCdnHttpsDomainListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfos) {
      res["CertInfos"] = certInfos ? boost::any(certInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfos") != m.end() && !m["CertInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertInfos"].type()) {
        DescribeCdnHttpsDomainListResponseBodyCertInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertInfos"]));
        certInfos = make_shared<DescribeCdnHttpsDomainListResponseBodyCertInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeCdnHttpsDomainListResponseBody() = default;
};
class DescribeCdnHttpsDomainListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnHttpsDomainListResponseBody> body{};

  DescribeCdnHttpsDomainListResponse() {}

  explicit DescribeCdnHttpsDomainListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnHttpsDomainListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnHttpsDomainListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnHttpsDomainListResponse() = default;
};
class DescribeCdnOrderCommodityCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> commodityCode{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeCdnOrderCommodityCodeRequest() {}

  explicit DescribeCdnOrderCommodityCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeCdnOrderCommodityCodeRequest() = default;
};
class DescribeCdnOrderCommodityCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderCommodityCode{};
  shared_ptr<string> requestId{};

  DescribeCdnOrderCommodityCodeResponseBody() {}

  explicit DescribeCdnOrderCommodityCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderCommodityCode) {
      res["OrderCommodityCode"] = boost::any(*orderCommodityCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderCommodityCode") != m.end() && !m["OrderCommodityCode"].empty()) {
      orderCommodityCode = make_shared<string>(boost::any_cast<string>(m["OrderCommodityCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCdnOrderCommodityCodeResponseBody() = default;
};
class DescribeCdnOrderCommodityCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnOrderCommodityCodeResponseBody> body{};

  DescribeCdnOrderCommodityCodeResponse() {}

  explicit DescribeCdnOrderCommodityCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnOrderCommodityCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnOrderCommodityCodeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnOrderCommodityCodeResponse() = default;
};
class DescribeCdnRegionAndIspRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeCdnRegionAndIspRequest() {}

  explicit DescribeCdnRegionAndIspRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeCdnRegionAndIspRequest() = default;
};
class DescribeCdnRegionAndIspResponseBodyIspsIsp : public Darabonba::Model {
public:
  shared_ptr<string> nameEn{};
  shared_ptr<string> nameZh{};

  DescribeCdnRegionAndIspResponseBodyIspsIsp() {}

  explicit DescribeCdnRegionAndIspResponseBodyIspsIsp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameEn) {
      res["NameEn"] = boost::any(*nameEn);
    }
    if (nameZh) {
      res["NameZh"] = boost::any(*nameZh);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameEn") != m.end() && !m["NameEn"].empty()) {
      nameEn = make_shared<string>(boost::any_cast<string>(m["NameEn"]));
    }
    if (m.find("NameZh") != m.end() && !m["NameZh"].empty()) {
      nameZh = make_shared<string>(boost::any_cast<string>(m["NameZh"]));
    }
  }


  virtual ~DescribeCdnRegionAndIspResponseBodyIspsIsp() = default;
};
class DescribeCdnRegionAndIspResponseBodyIsps : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnRegionAndIspResponseBodyIspsIsp>> isp{};

  DescribeCdnRegionAndIspResponseBodyIsps() {}

  explicit DescribeCdnRegionAndIspResponseBodyIsps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isp) {
      vector<boost::any> temp1;
      for(auto item1:*isp){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Isp"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      if (typeid(vector<boost::any>) == m["Isp"].type()) {
        vector<DescribeCdnRegionAndIspResponseBodyIspsIsp> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Isp"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnRegionAndIspResponseBodyIspsIsp model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        isp = make_shared<vector<DescribeCdnRegionAndIspResponseBodyIspsIsp>>(expect1);
      }
    }
  }


  virtual ~DescribeCdnRegionAndIspResponseBodyIsps() = default;
};
class DescribeCdnRegionAndIspResponseBodyRegionsRegion : public Darabonba::Model {
public:
  shared_ptr<string> nameEn{};
  shared_ptr<string> nameZh{};

  DescribeCdnRegionAndIspResponseBodyRegionsRegion() {}

  explicit DescribeCdnRegionAndIspResponseBodyRegionsRegion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameEn) {
      res["NameEn"] = boost::any(*nameEn);
    }
    if (nameZh) {
      res["NameZh"] = boost::any(*nameZh);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameEn") != m.end() && !m["NameEn"].empty()) {
      nameEn = make_shared<string>(boost::any_cast<string>(m["NameEn"]));
    }
    if (m.find("NameZh") != m.end() && !m["NameZh"].empty()) {
      nameZh = make_shared<string>(boost::any_cast<string>(m["NameZh"]));
    }
  }


  virtual ~DescribeCdnRegionAndIspResponseBodyRegionsRegion() = default;
};
class DescribeCdnRegionAndIspResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnRegionAndIspResponseBodyRegionsRegion>> region{};

  DescribeCdnRegionAndIspResponseBodyRegions() {}

  explicit DescribeCdnRegionAndIspResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      vector<boost::any> temp1;
      for(auto item1:*region){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Region"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      if (typeid(vector<boost::any>) == m["Region"].type()) {
        vector<DescribeCdnRegionAndIspResponseBodyRegionsRegion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Region"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnRegionAndIspResponseBodyRegionsRegion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        region = make_shared<vector<DescribeCdnRegionAndIspResponseBodyRegionsRegion>>(expect1);
      }
    }
  }


  virtual ~DescribeCdnRegionAndIspResponseBodyRegions() = default;
};
class DescribeCdnRegionAndIspResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCdnRegionAndIspResponseBodyIsps> isps{};
  shared_ptr<DescribeCdnRegionAndIspResponseBodyRegions> regions{};
  shared_ptr<string> requestId{};

  DescribeCdnRegionAndIspResponseBody() {}

  explicit DescribeCdnRegionAndIspResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isps) {
      res["Isps"] = isps ? boost::any(isps->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regions) {
      res["Regions"] = regions ? boost::any(regions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Isps") != m.end() && !m["Isps"].empty()) {
      if (typeid(map<string, boost::any>) == m["Isps"].type()) {
        DescribeCdnRegionAndIspResponseBodyIsps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Isps"]));
        isps = make_shared<DescribeCdnRegionAndIspResponseBodyIsps>(model1);
      }
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Regions"].type()) {
        DescribeCdnRegionAndIspResponseBodyRegions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Regions"]));
        regions = make_shared<DescribeCdnRegionAndIspResponseBodyRegions>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCdnRegionAndIspResponseBody() = default;
};
class DescribeCdnRegionAndIspResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnRegionAndIspResponseBody> body{};

  DescribeCdnRegionAndIspResponse() {}

  explicit DescribeCdnRegionAndIspResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnRegionAndIspResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnRegionAndIspResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnRegionAndIspResponse() = default;
};
class DescribeCdnReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> isOverseas{};
  shared_ptr<long> reportId{};
  shared_ptr<string> startTime{};

  DescribeCdnReportRequest() {}

  explicit DescribeCdnReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (isOverseas) {
      res["IsOverseas"] = boost::any(*isOverseas);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("IsOverseas") != m.end() && !m["IsOverseas"].empty()) {
      isOverseas = make_shared<string>(boost::any_cast<string>(m["IsOverseas"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<long>(boost::any_cast<long>(m["ReportId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeCdnReportRequest() = default;
};
class DescribeCdnReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  DescribeCdnReportResponseBody() {}

  explicit DescribeCdnReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCdnReportResponseBody() = default;
};
class DescribeCdnReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnReportResponseBody> body{};

  DescribeCdnReportResponse() {}

  explicit DescribeCdnReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnReportResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnReportResponse() = default;
};
class DescribeCdnReportListRequest : public Darabonba::Model {
public:
  shared_ptr<long> reportId{};

  DescribeCdnReportListRequest() {}

  explicit DescribeCdnReportListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<long>(boost::any_cast<long>(m["ReportId"]));
    }
  }


  virtual ~DescribeCdnReportListRequest() = default;
};
class DescribeCdnReportListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  DescribeCdnReportListResponseBody() {}

  explicit DescribeCdnReportListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCdnReportListResponseBody() = default;
};
class DescribeCdnReportListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnReportListResponseBody> body{};

  DescribeCdnReportListResponse() {}

  explicit DescribeCdnReportListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnReportListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnReportListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnReportListResponse() = default;
};
class DescribeCdnSMCertificateDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> certIdentifier{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeCdnSMCertificateDetailRequest() {}

  explicit DescribeCdnSMCertificateDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certIdentifier) {
      res["CertIdentifier"] = boost::any(*certIdentifier);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertIdentifier") != m.end() && !m["CertIdentifier"].empty()) {
      certIdentifier = make_shared<string>(boost::any_cast<string>(m["CertIdentifier"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeCdnSMCertificateDetailRequest() = default;
};
class DescribeCdnSMCertificateDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> certExpireTime{};
  shared_ptr<string> certIdentifier{};
  shared_ptr<string> certName{};
  shared_ptr<string> certOrg{};
  shared_ptr<string> commonName{};
  shared_ptr<string> encryptCertificate{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sans{};
  shared_ptr<string> signCertificate{};

  DescribeCdnSMCertificateDetailResponseBody() {}

  explicit DescribeCdnSMCertificateDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certExpireTime) {
      res["CertExpireTime"] = boost::any(*certExpireTime);
    }
    if (certIdentifier) {
      res["CertIdentifier"] = boost::any(*certIdentifier);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certOrg) {
      res["CertOrg"] = boost::any(*certOrg);
    }
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (encryptCertificate) {
      res["EncryptCertificate"] = boost::any(*encryptCertificate);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sans) {
      res["Sans"] = boost::any(*sans);
    }
    if (signCertificate) {
      res["SignCertificate"] = boost::any(*signCertificate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertExpireTime") != m.end() && !m["CertExpireTime"].empty()) {
      certExpireTime = make_shared<string>(boost::any_cast<string>(m["CertExpireTime"]));
    }
    if (m.find("CertIdentifier") != m.end() && !m["CertIdentifier"].empty()) {
      certIdentifier = make_shared<string>(boost::any_cast<string>(m["CertIdentifier"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertOrg") != m.end() && !m["CertOrg"].empty()) {
      certOrg = make_shared<string>(boost::any_cast<string>(m["CertOrg"]));
    }
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("EncryptCertificate") != m.end() && !m["EncryptCertificate"].empty()) {
      encryptCertificate = make_shared<string>(boost::any_cast<string>(m["EncryptCertificate"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Sans") != m.end() && !m["Sans"].empty()) {
      sans = make_shared<string>(boost::any_cast<string>(m["Sans"]));
    }
    if (m.find("SignCertificate") != m.end() && !m["SignCertificate"].empty()) {
      signCertificate = make_shared<string>(boost::any_cast<string>(m["SignCertificate"]));
    }
  }


  virtual ~DescribeCdnSMCertificateDetailResponseBody() = default;
};
class DescribeCdnSMCertificateDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnSMCertificateDetailResponseBody> body{};

  DescribeCdnSMCertificateDetailResponse() {}

  explicit DescribeCdnSMCertificateDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnSMCertificateDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnSMCertificateDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnSMCertificateDetailResponse() = default;
};
class DescribeCdnSMCertificateListRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeCdnSMCertificateListRequest() {}

  explicit DescribeCdnSMCertificateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeCdnSMCertificateListRequest() = default;
};
class DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert : public Darabonba::Model {
public:
  shared_ptr<string> certIdentifier{};
  shared_ptr<string> certName{};
  shared_ptr<string> common{};
  shared_ptr<string> issuer{};

  DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert() {}

  explicit DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certIdentifier) {
      res["CertIdentifier"] = boost::any(*certIdentifier);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (common) {
      res["Common"] = boost::any(*common);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertIdentifier") != m.end() && !m["CertIdentifier"].empty()) {
      certIdentifier = make_shared<string>(boost::any_cast<string>(m["CertIdentifier"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Common") != m.end() && !m["Common"].empty()) {
      common = make_shared<string>(boost::any_cast<string>(m["Common"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
  }


  virtual ~DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert() = default;
};
class DescribeCdnSMCertificateListResponseBodyCertificateListModelCertList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert>> cert{};

  DescribeCdnSMCertificateListResponseBodyCertificateListModelCertList() {}

  explicit DescribeCdnSMCertificateListResponseBodyCertificateListModelCertList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cert) {
      vector<boost::any> temp1;
      for(auto item1:*cert){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Cert"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cert") != m.end() && !m["Cert"].empty()) {
      if (typeid(vector<boost::any>) == m["Cert"].type()) {
        vector<DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Cert"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cert = make_shared<vector<DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert>>(expect1);
      }
    }
  }


  virtual ~DescribeCdnSMCertificateListResponseBodyCertificateListModelCertList() = default;
};
class DescribeCdnSMCertificateListResponseBodyCertificateListModel : public Darabonba::Model {
public:
  shared_ptr<DescribeCdnSMCertificateListResponseBodyCertificateListModelCertList> certList{};
  shared_ptr<long> count{};

  DescribeCdnSMCertificateListResponseBodyCertificateListModel() {}

  explicit DescribeCdnSMCertificateListResponseBodyCertificateListModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certList) {
      res["CertList"] = certList ? boost::any(certList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertList") != m.end() && !m["CertList"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertList"].type()) {
        DescribeCdnSMCertificateListResponseBodyCertificateListModelCertList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertList"]));
        certList = make_shared<DescribeCdnSMCertificateListResponseBodyCertificateListModelCertList>(model1);
      }
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeCdnSMCertificateListResponseBodyCertificateListModel() = default;
};
class DescribeCdnSMCertificateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCdnSMCertificateListResponseBodyCertificateListModel> certificateListModel{};
  shared_ptr<string> requestId{};

  DescribeCdnSMCertificateListResponseBody() {}

  explicit DescribeCdnSMCertificateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateListModel) {
      res["CertificateListModel"] = certificateListModel ? boost::any(certificateListModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateListModel") != m.end() && !m["CertificateListModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertificateListModel"].type()) {
        DescribeCdnSMCertificateListResponseBodyCertificateListModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertificateListModel"]));
        certificateListModel = make_shared<DescribeCdnSMCertificateListResponseBodyCertificateListModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCdnSMCertificateListResponseBody() = default;
};
class DescribeCdnSMCertificateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnSMCertificateListResponseBody> body{};

  DescribeCdnSMCertificateListResponse() {}

  explicit DescribeCdnSMCertificateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnSMCertificateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnSMCertificateListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnSMCertificateListResponse() = default;
};
class DescribeCdnSSLCertificateListRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchKeyword{};
  shared_ptr<string> securityToken{};

  DescribeCdnSSLCertificateListRequest() {}

  explicit DescribeCdnSSLCertificateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchKeyword) {
      res["SearchKeyword"] = boost::any(*searchKeyword);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchKeyword") != m.end() && !m["SearchKeyword"].empty()) {
      searchKeyword = make_shared<string>(boost::any_cast<string>(m["SearchKeyword"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeCdnSSLCertificateListRequest() = default;
};
class DescribeCdnSSLCertificateListResponseBodyCertificateListModelCertListCert : public Darabonba::Model {
public:
  shared_ptr<long> certId{};
  shared_ptr<string> certName{};
  shared_ptr<string> certRegion{};
  shared_ptr<string> common{};
  shared_ptr<string> fingerprint{};
  shared_ptr<string> issuer{};
  shared_ptr<long> lastTime{};

  DescribeCdnSSLCertificateListResponseBodyCertificateListModelCertListCert() {}

  explicit DescribeCdnSSLCertificateListResponseBodyCertificateListModelCertListCert(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certRegion) {
      res["CertRegion"] = boost::any(*certRegion);
    }
    if (common) {
      res["Common"] = boost::any(*common);
    }
    if (fingerprint) {
      res["Fingerprint"] = boost::any(*fingerprint);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    if (lastTime) {
      res["LastTime"] = boost::any(*lastTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<long>(boost::any_cast<long>(m["CertId"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertRegion") != m.end() && !m["CertRegion"].empty()) {
      certRegion = make_shared<string>(boost::any_cast<string>(m["CertRegion"]));
    }
    if (m.find("Common") != m.end() && !m["Common"].empty()) {
      common = make_shared<string>(boost::any_cast<string>(m["Common"]));
    }
    if (m.find("Fingerprint") != m.end() && !m["Fingerprint"].empty()) {
      fingerprint = make_shared<string>(boost::any_cast<string>(m["Fingerprint"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
    if (m.find("LastTime") != m.end() && !m["LastTime"].empty()) {
      lastTime = make_shared<long>(boost::any_cast<long>(m["LastTime"]));
    }
  }


  virtual ~DescribeCdnSSLCertificateListResponseBodyCertificateListModelCertListCert() = default;
};
class DescribeCdnSSLCertificateListResponseBodyCertificateListModelCertList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnSSLCertificateListResponseBodyCertificateListModelCertListCert>> cert{};

  DescribeCdnSSLCertificateListResponseBodyCertificateListModelCertList() {}

  explicit DescribeCdnSSLCertificateListResponseBodyCertificateListModelCertList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cert) {
      vector<boost::any> temp1;
      for(auto item1:*cert){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Cert"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cert") != m.end() && !m["Cert"].empty()) {
      if (typeid(vector<boost::any>) == m["Cert"].type()) {
        vector<DescribeCdnSSLCertificateListResponseBodyCertificateListModelCertListCert> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Cert"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnSSLCertificateListResponseBodyCertificateListModelCertListCert model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cert = make_shared<vector<DescribeCdnSSLCertificateListResponseBodyCertificateListModelCertListCert>>(expect1);
      }
    }
  }


  virtual ~DescribeCdnSSLCertificateListResponseBodyCertificateListModelCertList() = default;
};
class DescribeCdnSSLCertificateListResponseBodyCertificateListModel : public Darabonba::Model {
public:
  shared_ptr<DescribeCdnSSLCertificateListResponseBodyCertificateListModelCertList> certList{};
  shared_ptr<long> count{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeCdnSSLCertificateListResponseBodyCertificateListModel() {}

  explicit DescribeCdnSSLCertificateListResponseBodyCertificateListModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certList) {
      res["CertList"] = certList ? boost::any(certList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertList") != m.end() && !m["CertList"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertList"].type()) {
        DescribeCdnSSLCertificateListResponseBodyCertificateListModelCertList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertList"]));
        certList = make_shared<DescribeCdnSSLCertificateListResponseBodyCertificateListModelCertList>(model1);
      }
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeCdnSSLCertificateListResponseBodyCertificateListModel() = default;
};
class DescribeCdnSSLCertificateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCdnSSLCertificateListResponseBodyCertificateListModel> certificateListModel{};
  shared_ptr<string> requestId{};

  DescribeCdnSSLCertificateListResponseBody() {}

  explicit DescribeCdnSSLCertificateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateListModel) {
      res["CertificateListModel"] = certificateListModel ? boost::any(certificateListModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateListModel") != m.end() && !m["CertificateListModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertificateListModel"].type()) {
        DescribeCdnSSLCertificateListResponseBodyCertificateListModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertificateListModel"]));
        certificateListModel = make_shared<DescribeCdnSSLCertificateListResponseBodyCertificateListModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCdnSSLCertificateListResponseBody() = default;
};
class DescribeCdnSSLCertificateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnSSLCertificateListResponseBody> body{};

  DescribeCdnSSLCertificateListResponse() {}

  explicit DescribeCdnSSLCertificateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnSSLCertificateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnSSLCertificateListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnSSLCertificateListResponse() = default;
};
class DescribeCdnServiceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeCdnServiceRequest() {}

  explicit DescribeCdnServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeCdnServiceRequest() = default;
};
class DescribeCdnServiceResponseBodyOperationLocksLockReason : public Darabonba::Model {
public:
  shared_ptr<string> lockReason{};

  DescribeCdnServiceResponseBodyOperationLocksLockReason() {}

  explicit DescribeCdnServiceResponseBodyOperationLocksLockReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
  }


  virtual ~DescribeCdnServiceResponseBodyOperationLocksLockReason() = default;
};
class DescribeCdnServiceResponseBodyOperationLocks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnServiceResponseBodyOperationLocksLockReason>> lockReason{};

  DescribeCdnServiceResponseBodyOperationLocks() {}

  explicit DescribeCdnServiceResponseBodyOperationLocks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      vector<boost::any> temp1;
      for(auto item1:*lockReason){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LockReason"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      if (typeid(vector<boost::any>) == m["LockReason"].type()) {
        vector<DescribeCdnServiceResponseBodyOperationLocksLockReason> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LockReason"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnServiceResponseBodyOperationLocksLockReason model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lockReason = make_shared<vector<DescribeCdnServiceResponseBodyOperationLocksLockReason>>(expect1);
      }
    }
  }


  virtual ~DescribeCdnServiceResponseBodyOperationLocks() = default;
};
class DescribeCdnServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changingAffectTime{};
  shared_ptr<string> changingChargeType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> openingTime{};
  shared_ptr<DescribeCdnServiceResponseBodyOperationLocks> operationLocks{};
  shared_ptr<string> requestId{};

  DescribeCdnServiceResponseBody() {}

  explicit DescribeCdnServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changingAffectTime) {
      res["ChangingAffectTime"] = boost::any(*changingAffectTime);
    }
    if (changingChargeType) {
      res["ChangingChargeType"] = boost::any(*changingChargeType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (openingTime) {
      res["OpeningTime"] = boost::any(*openingTime);
    }
    if (operationLocks) {
      res["OperationLocks"] = operationLocks ? boost::any(operationLocks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangingAffectTime") != m.end() && !m["ChangingAffectTime"].empty()) {
      changingAffectTime = make_shared<string>(boost::any_cast<string>(m["ChangingAffectTime"]));
    }
    if (m.find("ChangingChargeType") != m.end() && !m["ChangingChargeType"].empty()) {
      changingChargeType = make_shared<string>(boost::any_cast<string>(m["ChangingChargeType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("OpeningTime") != m.end() && !m["OpeningTime"].empty()) {
      openingTime = make_shared<string>(boost::any_cast<string>(m["OpeningTime"]));
    }
    if (m.find("OperationLocks") != m.end() && !m["OperationLocks"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperationLocks"].type()) {
        DescribeCdnServiceResponseBodyOperationLocks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperationLocks"]));
        operationLocks = make_shared<DescribeCdnServiceResponseBodyOperationLocks>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCdnServiceResponseBody() = default;
};
class DescribeCdnServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnServiceResponseBody> body{};

  DescribeCdnServiceResponse() {}

  explicit DescribeCdnServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnServiceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnServiceResponse() = default;
};
class DescribeCdnSubListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  DescribeCdnSubListResponseBody() {}

  explicit DescribeCdnSubListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCdnSubListResponseBody() = default;
};
class DescribeCdnSubListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnSubListResponseBody> body{};

  DescribeCdnSubListResponse() {}

  explicit DescribeCdnSubListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnSubListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnSubListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnSubListResponse() = default;
};
class DescribeCdnUserBillHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeCdnUserBillHistoryRequest() {}

  explicit DescribeCdnUserBillHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeCdnUserBillHistoryRequest() = default;
};
class DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem : public Darabonba::Model {
public:
  shared_ptr<double> bandwidth{};
  shared_ptr<string> cdnRegion{};
  shared_ptr<string> chargeType{};
  shared_ptr<double> count{};
  shared_ptr<double> flow{};

  DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem() {}

  explicit DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (cdnRegion) {
      res["CdnRegion"] = boost::any(*cdnRegion);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<double>(boost::any_cast<double>(m["Bandwidth"]));
    }
    if (m.find("CdnRegion") != m.end() && !m["CdnRegion"].empty()) {
      cdnRegion = make_shared<string>(boost::any_cast<string>(m["CdnRegion"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<double>(boost::any_cast<double>(m["Count"]));
    }
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<double>(boost::any_cast<double>(m["Flow"]));
    }
  }


  virtual ~DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem() = default;
};
class DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem>> billingDataItem{};

  DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData() {}

  explicit DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billingDataItem) {
      vector<boost::any> temp1;
      for(auto item1:*billingDataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BillingDataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillingDataItem") != m.end() && !m["BillingDataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["BillingDataItem"].type()) {
        vector<DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BillingDataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        billingDataItem = make_shared<vector<DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData() = default;
};
class DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem : public Darabonba::Model {
public:
  shared_ptr<string> billTime{};
  shared_ptr<string> billType{};
  shared_ptr<DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData> billingData{};
  shared_ptr<string> dimension{};

  DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem() {}

  explicit DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billTime) {
      res["BillTime"] = boost::any(*billTime);
    }
    if (billType) {
      res["BillType"] = boost::any(*billType);
    }
    if (billingData) {
      res["BillingData"] = billingData ? boost::any(billingData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dimension) {
      res["Dimension"] = boost::any(*dimension);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillTime") != m.end() && !m["BillTime"].empty()) {
      billTime = make_shared<string>(boost::any_cast<string>(m["BillTime"]));
    }
    if (m.find("BillType") != m.end() && !m["BillType"].empty()) {
      billType = make_shared<string>(boost::any_cast<string>(m["BillType"]));
    }
    if (m.find("BillingData") != m.end() && !m["BillingData"].empty()) {
      if (typeid(map<string, boost::any>) == m["BillingData"].type()) {
        DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BillingData"]));
        billingData = make_shared<DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData>(model1);
      }
    }
    if (m.find("Dimension") != m.end() && !m["Dimension"].empty()) {
      dimension = make_shared<string>(boost::any_cast<string>(m["Dimension"]));
    }
  }


  virtual ~DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem() = default;
};
class DescribeCdnUserBillHistoryResponseBodyBillHistoryData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem>> billHistoryDataItem{};

  DescribeCdnUserBillHistoryResponseBodyBillHistoryData() {}

  explicit DescribeCdnUserBillHistoryResponseBodyBillHistoryData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billHistoryDataItem) {
      vector<boost::any> temp1;
      for(auto item1:*billHistoryDataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BillHistoryDataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillHistoryDataItem") != m.end() && !m["BillHistoryDataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["BillHistoryDataItem"].type()) {
        vector<DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BillHistoryDataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        billHistoryDataItem = make_shared<vector<DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeCdnUserBillHistoryResponseBodyBillHistoryData() = default;
};
class DescribeCdnUserBillHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCdnUserBillHistoryResponseBodyBillHistoryData> billHistoryData{};
  shared_ptr<string> requestId{};

  DescribeCdnUserBillHistoryResponseBody() {}

  explicit DescribeCdnUserBillHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billHistoryData) {
      res["BillHistoryData"] = billHistoryData ? boost::any(billHistoryData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillHistoryData") != m.end() && !m["BillHistoryData"].empty()) {
      if (typeid(map<string, boost::any>) == m["BillHistoryData"].type()) {
        DescribeCdnUserBillHistoryResponseBodyBillHistoryData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BillHistoryData"]));
        billHistoryData = make_shared<DescribeCdnUserBillHistoryResponseBodyBillHistoryData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCdnUserBillHistoryResponseBody() = default;
};
class DescribeCdnUserBillHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnUserBillHistoryResponseBody> body{};

  DescribeCdnUserBillHistoryResponse() {}

  explicit DescribeCdnUserBillHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnUserBillHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnUserBillHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnUserBillHistoryResponse() = default;
};
class DescribeCdnUserBillPredictionRequest : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> dimension{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeCdnUserBillPredictionRequest() {}

  explicit DescribeCdnUserBillPredictionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (dimension) {
      res["Dimension"] = boost::any(*dimension);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("Dimension") != m.end() && !m["Dimension"].empty()) {
      dimension = make_shared<string>(boost::any_cast<string>(m["Dimension"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeCdnUserBillPredictionRequest() = default;
};
class DescribeCdnUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> timeStp{};
  shared_ptr<double> value{};

  DescribeCdnUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem() {}

  explicit DescribeCdnUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (timeStp) {
      res["TimeStp"] = boost::any(*timeStp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("TimeStp") != m.end() && !m["TimeStp"].empty()) {
      timeStp = make_shared<string>(boost::any_cast<string>(m["TimeStp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~DescribeCdnUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem() = default;
};
class DescribeCdnUserBillPredictionResponseBodyBillPredictionData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem>> billPredictionDataItem{};

  DescribeCdnUserBillPredictionResponseBodyBillPredictionData() {}

  explicit DescribeCdnUserBillPredictionResponseBodyBillPredictionData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billPredictionDataItem) {
      vector<boost::any> temp1;
      for(auto item1:*billPredictionDataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BillPredictionDataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillPredictionDataItem") != m.end() && !m["BillPredictionDataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["BillPredictionDataItem"].type()) {
        vector<DescribeCdnUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BillPredictionDataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        billPredictionDataItem = make_shared<vector<DescribeCdnUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeCdnUserBillPredictionResponseBodyBillPredictionData() = default;
};
class DescribeCdnUserBillPredictionResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCdnUserBillPredictionResponseBodyBillPredictionData> billPredictionData{};
  shared_ptr<string> billType{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeCdnUserBillPredictionResponseBody() {}

  explicit DescribeCdnUserBillPredictionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billPredictionData) {
      res["BillPredictionData"] = billPredictionData ? boost::any(billPredictionData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (billType) {
      res["BillType"] = boost::any(*billType);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillPredictionData") != m.end() && !m["BillPredictionData"].empty()) {
      if (typeid(map<string, boost::any>) == m["BillPredictionData"].type()) {
        DescribeCdnUserBillPredictionResponseBodyBillPredictionData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BillPredictionData"]));
        billPredictionData = make_shared<DescribeCdnUserBillPredictionResponseBodyBillPredictionData>(model1);
      }
    }
    if (m.find("BillType") != m.end() && !m["BillType"].empty()) {
      billType = make_shared<string>(boost::any_cast<string>(m["BillType"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeCdnUserBillPredictionResponseBody() = default;
};
class DescribeCdnUserBillPredictionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnUserBillPredictionResponseBody> body{};

  DescribeCdnUserBillPredictionResponse() {}

  explicit DescribeCdnUserBillPredictionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnUserBillPredictionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnUserBillPredictionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnUserBillPredictionResponse() = default;
};
class DescribeCdnUserBillTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeCdnUserBillTypeRequest() {}

  explicit DescribeCdnUserBillTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeCdnUserBillTypeRequest() = default;
};
class DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem : public Darabonba::Model {
public:
  shared_ptr<string> billType{};
  shared_ptr<string> billingCycle{};
  shared_ptr<string> dimension{};
  shared_ptr<string> endTime{};
  shared_ptr<string> product{};
  shared_ptr<string> startTime{};

  DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem() {}

  explicit DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billType) {
      res["BillType"] = boost::any(*billType);
    }
    if (billingCycle) {
      res["BillingCycle"] = boost::any(*billingCycle);
    }
    if (dimension) {
      res["Dimension"] = boost::any(*dimension);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillType") != m.end() && !m["BillType"].empty()) {
      billType = make_shared<string>(boost::any_cast<string>(m["BillType"]));
    }
    if (m.find("BillingCycle") != m.end() && !m["BillingCycle"].empty()) {
      billingCycle = make_shared<string>(boost::any_cast<string>(m["BillingCycle"]));
    }
    if (m.find("Dimension") != m.end() && !m["Dimension"].empty()) {
      dimension = make_shared<string>(boost::any_cast<string>(m["Dimension"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem() = default;
};
class DescribeCdnUserBillTypeResponseBodyBillTypeData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem>> billTypeDataItem{};

  DescribeCdnUserBillTypeResponseBodyBillTypeData() {}

  explicit DescribeCdnUserBillTypeResponseBodyBillTypeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billTypeDataItem) {
      vector<boost::any> temp1;
      for(auto item1:*billTypeDataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BillTypeDataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillTypeDataItem") != m.end() && !m["BillTypeDataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["BillTypeDataItem"].type()) {
        vector<DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BillTypeDataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        billTypeDataItem = make_shared<vector<DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeCdnUserBillTypeResponseBodyBillTypeData() = default;
};
class DescribeCdnUserBillTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCdnUserBillTypeResponseBodyBillTypeData> billTypeData{};
  shared_ptr<string> requestId{};

  DescribeCdnUserBillTypeResponseBody() {}

  explicit DescribeCdnUserBillTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billTypeData) {
      res["BillTypeData"] = billTypeData ? boost::any(billTypeData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillTypeData") != m.end() && !m["BillTypeData"].empty()) {
      if (typeid(map<string, boost::any>) == m["BillTypeData"].type()) {
        DescribeCdnUserBillTypeResponseBodyBillTypeData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BillTypeData"]));
        billTypeData = make_shared<DescribeCdnUserBillTypeResponseBodyBillTypeData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCdnUserBillTypeResponseBody() = default;
};
class DescribeCdnUserBillTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnUserBillTypeResponseBody> body{};

  DescribeCdnUserBillTypeResponse() {}

  explicit DescribeCdnUserBillTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnUserBillTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnUserBillTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnUserBillTypeResponse() = default;
};
class DescribeCdnUserConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> functionName{};

  DescribeCdnUserConfigsRequest() {}

  explicit DescribeCdnUserConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
  }


  virtual ~DescribeCdnUserConfigsRequest() = default;
};
class DescribeCdnUserConfigsResponseBodyConfigs : public Darabonba::Model {
public:
  shared_ptr<string> argName{};
  shared_ptr<string> argValue{};
  shared_ptr<string> functionName{};

  DescribeCdnUserConfigsResponseBodyConfigs() {}

  explicit DescribeCdnUserConfigsResponseBodyConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (argName) {
      res["ArgName"] = boost::any(*argName);
    }
    if (argValue) {
      res["ArgValue"] = boost::any(*argValue);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArgName") != m.end() && !m["ArgName"].empty()) {
      argName = make_shared<string>(boost::any_cast<string>(m["ArgName"]));
    }
    if (m.find("ArgValue") != m.end() && !m["ArgValue"].empty()) {
      argValue = make_shared<string>(boost::any_cast<string>(m["ArgValue"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
  }


  virtual ~DescribeCdnUserConfigsResponseBodyConfigs() = default;
};
class DescribeCdnUserConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnUserConfigsResponseBodyConfigs>> configs{};
  shared_ptr<string> requestId{};

  DescribeCdnUserConfigsResponseBody() {}

  explicit DescribeCdnUserConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      if (typeid(vector<boost::any>) == m["Configs"].type()) {
        vector<DescribeCdnUserConfigsResponseBodyConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnUserConfigsResponseBodyConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<DescribeCdnUserConfigsResponseBodyConfigs>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCdnUserConfigsResponseBody() = default;
};
class DescribeCdnUserConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnUserConfigsResponseBody> body{};

  DescribeCdnUserConfigsResponse() {}

  explicit DescribeCdnUserConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnUserConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnUserConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnUserConfigsResponse() = default;
};
class DescribeCdnUserDomainsByFuncRequest : public Darabonba::Model {
public:
  shared_ptr<long> funcId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};

  DescribeCdnUserDomainsByFuncRequest() {}

  explicit DescribeCdnUserDomainsByFuncRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (funcId) {
      res["FuncId"] = boost::any(*funcId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FuncId") != m.end() && !m["FuncId"].empty()) {
      funcId = make_shared<long>(boost::any_cast<long>(m["FuncId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeCdnUserDomainsByFuncRequest() = default;
};
class DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> port{};
  shared_ptr<string> priority{};
  shared_ptr<string> type{};
  shared_ptr<string> weight{};

  DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource() {}

  explicit DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<string>(boost::any_cast<string>(m["Weight"]));
    }
  }


  virtual ~DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource() = default;
};
class DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource>> source{};

  DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSources() {}

  explicit DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      vector<boost::any> temp1;
      for(auto item1:*source){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Source"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      if (typeid(vector<boost::any>) == m["Source"].type()) {
        vector<DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Source"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        source = make_shared<vector<DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource>>(expect1);
      }
    }
  }


  virtual ~DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSources() = default;
};
class DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData : public Darabonba::Model {
public:
  shared_ptr<string> cdnType{};
  shared_ptr<string> cname{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> gmtCreated{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSources> sources{};
  shared_ptr<string> sslProtocol{};

  DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData() {}

  explicit DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdnType) {
      res["CdnType"] = boost::any(*cdnType);
    }
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (sources) {
      res["Sources"] = sources ? boost::any(sources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sslProtocol) {
      res["SslProtocol"] = boost::any(*sslProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdnType") != m.end() && !m["CdnType"].empty()) {
      cdnType = make_shared<string>(boost::any_cast<string>(m["CdnType"]));
    }
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<string>(boost::any_cast<string>(m["GmtCreated"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Sources"].type()) {
        DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Sources"]));
        sources = make_shared<DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSources>(model1);
      }
    }
    if (m.find("SslProtocol") != m.end() && !m["SslProtocol"].empty()) {
      sslProtocol = make_shared<string>(boost::any_cast<string>(m["SslProtocol"]));
    }
  }


  virtual ~DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData() = default;
};
class DescribeCdnUserDomainsByFuncResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData>> pageData{};

  DescribeCdnUserDomainsByFuncResponseBodyDomains() {}

  explicit DescribeCdnUserDomainsByFuncResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageData) {
      vector<boost::any> temp1;
      for(auto item1:*pageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageData") != m.end() && !m["PageData"].empty()) {
      if (typeid(vector<boost::any>) == m["PageData"].type()) {
        vector<DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pageData = make_shared<vector<DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData>>(expect1);
      }
    }
  }


  virtual ~DescribeCdnUserDomainsByFuncResponseBodyDomains() = default;
};
class DescribeCdnUserDomainsByFuncResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCdnUserDomainsByFuncResponseBodyDomains> domains{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeCdnUserDomainsByFuncResponseBody() {}

  explicit DescribeCdnUserDomainsByFuncResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = domains ? boost::any(domains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(map<string, boost::any>) == m["Domains"].type()) {
        DescribeCdnUserDomainsByFuncResponseBodyDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Domains"]));
        domains = make_shared<DescribeCdnUserDomainsByFuncResponseBodyDomains>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeCdnUserDomainsByFuncResponseBody() = default;
};
class DescribeCdnUserDomainsByFuncResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnUserDomainsByFuncResponseBody> body{};

  DescribeCdnUserDomainsByFuncResponse() {}

  explicit DescribeCdnUserDomainsByFuncResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnUserDomainsByFuncResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnUserDomainsByFuncResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnUserDomainsByFuncResponse() = default;
};
class DescribeCdnUserQuotaRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeCdnUserQuotaRequest() {}

  explicit DescribeCdnUserQuotaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeCdnUserQuotaRequest() = default;
};
class DescribeCdnUserQuotaResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> blockQuota{};
  shared_ptr<long> blockRemain{};
  shared_ptr<long> domainQuota{};
  shared_ptr<long> ignoreParamsQuota{};
  shared_ptr<long> ignoreParamsRemain{};
  shared_ptr<long> preloadQuota{};
  shared_ptr<long> preloadRemain{};
  shared_ptr<long> refreshDirQuota{};
  shared_ptr<long> refreshDirRemain{};
  shared_ptr<long> refreshUrlQuota{};
  shared_ptr<long> refreshUrlRemain{};
  shared_ptr<string> requestId{};

  DescribeCdnUserQuotaResponseBody() {}

  explicit DescribeCdnUserQuotaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockQuota) {
      res["BlockQuota"] = boost::any(*blockQuota);
    }
    if (blockRemain) {
      res["BlockRemain"] = boost::any(*blockRemain);
    }
    if (domainQuota) {
      res["DomainQuota"] = boost::any(*domainQuota);
    }
    if (ignoreParamsQuota) {
      res["IgnoreParamsQuota"] = boost::any(*ignoreParamsQuota);
    }
    if (ignoreParamsRemain) {
      res["IgnoreParamsRemain"] = boost::any(*ignoreParamsRemain);
    }
    if (preloadQuota) {
      res["PreloadQuota"] = boost::any(*preloadQuota);
    }
    if (preloadRemain) {
      res["PreloadRemain"] = boost::any(*preloadRemain);
    }
    if (refreshDirQuota) {
      res["RefreshDirQuota"] = boost::any(*refreshDirQuota);
    }
    if (refreshDirRemain) {
      res["RefreshDirRemain"] = boost::any(*refreshDirRemain);
    }
    if (refreshUrlQuota) {
      res["RefreshUrlQuota"] = boost::any(*refreshUrlQuota);
    }
    if (refreshUrlRemain) {
      res["RefreshUrlRemain"] = boost::any(*refreshUrlRemain);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockQuota") != m.end() && !m["BlockQuota"].empty()) {
      blockQuota = make_shared<long>(boost::any_cast<long>(m["BlockQuota"]));
    }
    if (m.find("BlockRemain") != m.end() && !m["BlockRemain"].empty()) {
      blockRemain = make_shared<long>(boost::any_cast<long>(m["BlockRemain"]));
    }
    if (m.find("DomainQuota") != m.end() && !m["DomainQuota"].empty()) {
      domainQuota = make_shared<long>(boost::any_cast<long>(m["DomainQuota"]));
    }
    if (m.find("IgnoreParamsQuota") != m.end() && !m["IgnoreParamsQuota"].empty()) {
      ignoreParamsQuota = make_shared<long>(boost::any_cast<long>(m["IgnoreParamsQuota"]));
    }
    if (m.find("IgnoreParamsRemain") != m.end() && !m["IgnoreParamsRemain"].empty()) {
      ignoreParamsRemain = make_shared<long>(boost::any_cast<long>(m["IgnoreParamsRemain"]));
    }
    if (m.find("PreloadQuota") != m.end() && !m["PreloadQuota"].empty()) {
      preloadQuota = make_shared<long>(boost::any_cast<long>(m["PreloadQuota"]));
    }
    if (m.find("PreloadRemain") != m.end() && !m["PreloadRemain"].empty()) {
      preloadRemain = make_shared<long>(boost::any_cast<long>(m["PreloadRemain"]));
    }
    if (m.find("RefreshDirQuota") != m.end() && !m["RefreshDirQuota"].empty()) {
      refreshDirQuota = make_shared<long>(boost::any_cast<long>(m["RefreshDirQuota"]));
    }
    if (m.find("RefreshDirRemain") != m.end() && !m["RefreshDirRemain"].empty()) {
      refreshDirRemain = make_shared<long>(boost::any_cast<long>(m["RefreshDirRemain"]));
    }
    if (m.find("RefreshUrlQuota") != m.end() && !m["RefreshUrlQuota"].empty()) {
      refreshUrlQuota = make_shared<long>(boost::any_cast<long>(m["RefreshUrlQuota"]));
    }
    if (m.find("RefreshUrlRemain") != m.end() && !m["RefreshUrlRemain"].empty()) {
      refreshUrlRemain = make_shared<long>(boost::any_cast<long>(m["RefreshUrlRemain"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCdnUserQuotaResponseBody() = default;
};
class DescribeCdnUserQuotaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnUserQuotaResponseBody> body{};

  DescribeCdnUserQuotaResponse() {}

  explicit DescribeCdnUserQuotaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnUserQuotaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnUserQuotaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnUserQuotaResponse() = default;
};
class DescribeCdnUserResourcePackageRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> status{};

  DescribeCdnUserResourcePackageRequest() {}

  explicit DescribeCdnUserResourcePackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeCdnUserResourcePackageRequest() = default;
};
class DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo : public Darabonba::Model {
public:
  shared_ptr<string> commodityCode{};
  shared_ptr<string> currCapacity{};
  shared_ptr<string> displayName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> initCapacity{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> templateName{};

  DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo() {}

  explicit DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (currCapacity) {
      res["CurrCapacity"] = boost::any(*currCapacity);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (initCapacity) {
      res["InitCapacity"] = boost::any(*initCapacity);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CurrCapacity") != m.end() && !m["CurrCapacity"].empty()) {
      currCapacity = make_shared<string>(boost::any_cast<string>(m["CurrCapacity"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InitCapacity") != m.end() && !m["InitCapacity"].empty()) {
      initCapacity = make_shared<string>(boost::any_cast<string>(m["InitCapacity"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo() = default;
};
class DescribeCdnUserResourcePackageResponseBodyResourcePackageInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo>> resourcePackageInfo{};

  DescribeCdnUserResourcePackageResponseBodyResourcePackageInfos() {}

  explicit DescribeCdnUserResourcePackageResponseBodyResourcePackageInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourcePackageInfo) {
      vector<boost::any> temp1;
      for(auto item1:*resourcePackageInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourcePackageInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourcePackageInfo") != m.end() && !m["ResourcePackageInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourcePackageInfo"].type()) {
        vector<DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourcePackageInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourcePackageInfo = make_shared<vector<DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeCdnUserResourcePackageResponseBodyResourcePackageInfos() = default;
};
class DescribeCdnUserResourcePackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeCdnUserResourcePackageResponseBodyResourcePackageInfos> resourcePackageInfos{};

  DescribeCdnUserResourcePackageResponseBody() {}

  explicit DescribeCdnUserResourcePackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourcePackageInfos) {
      res["ResourcePackageInfos"] = resourcePackageInfos ? boost::any(resourcePackageInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourcePackageInfos") != m.end() && !m["ResourcePackageInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourcePackageInfos"].type()) {
        DescribeCdnUserResourcePackageResponseBodyResourcePackageInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourcePackageInfos"]));
        resourcePackageInfos = make_shared<DescribeCdnUserResourcePackageResponseBodyResourcePackageInfos>(model1);
      }
    }
  }


  virtual ~DescribeCdnUserResourcePackageResponseBody() = default;
};
class DescribeCdnUserResourcePackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnUserResourcePackageResponseBody> body{};

  DescribeCdnUserResourcePackageResponse() {}

  explicit DescribeCdnUserResourcePackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnUserResourcePackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnUserResourcePackageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnUserResourcePackageResponse() = default;
};
class DescribeCdnWafDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};

  DescribeCdnWafDomainRequest() {}

  explicit DescribeCdnWafDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeCdnWafDomainRequest() = default;
};
class DescribeCdnWafDomainResponseBodyOutPutDomains : public Darabonba::Model {
public:
  shared_ptr<string> aclStatus{};
  shared_ptr<string> ccStatus{};
  shared_ptr<string> domain{};
  shared_ptr<string> status{};
  shared_ptr<string> wafStatus{};

  DescribeCdnWafDomainResponseBodyOutPutDomains() {}

  explicit DescribeCdnWafDomainResponseBodyOutPutDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclStatus) {
      res["AclStatus"] = boost::any(*aclStatus);
    }
    if (ccStatus) {
      res["CcStatus"] = boost::any(*ccStatus);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (wafStatus) {
      res["WafStatus"] = boost::any(*wafStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclStatus") != m.end() && !m["AclStatus"].empty()) {
      aclStatus = make_shared<string>(boost::any_cast<string>(m["AclStatus"]));
    }
    if (m.find("CcStatus") != m.end() && !m["CcStatus"].empty()) {
      ccStatus = make_shared<string>(boost::any_cast<string>(m["CcStatus"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("WafStatus") != m.end() && !m["WafStatus"].empty()) {
      wafStatus = make_shared<string>(boost::any_cast<string>(m["WafStatus"]));
    }
  }


  virtual ~DescribeCdnWafDomainResponseBodyOutPutDomains() = default;
};
class DescribeCdnWafDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCdnWafDomainResponseBodyOutPutDomains>> outPutDomains{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeCdnWafDomainResponseBody() {}

  explicit DescribeCdnWafDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outPutDomains) {
      vector<boost::any> temp1;
      for(auto item1:*outPutDomains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutPutDomains"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutPutDomains") != m.end() && !m["OutPutDomains"].empty()) {
      if (typeid(vector<boost::any>) == m["OutPutDomains"].type()) {
        vector<DescribeCdnWafDomainResponseBodyOutPutDomains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutPutDomains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCdnWafDomainResponseBodyOutPutDomains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outPutDomains = make_shared<vector<DescribeCdnWafDomainResponseBodyOutPutDomains>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeCdnWafDomainResponseBody() = default;
};
class DescribeCdnWafDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCdnWafDomainResponseBody> body{};

  DescribeCdnWafDomainResponse() {}

  explicit DescribeCdnWafDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCdnWafDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCdnWafDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCdnWafDomainResponse() = default;
};
class DescribeCertificateInfoByIDRequest : public Darabonba::Model {
public:
  shared_ptr<string> certId{};

  DescribeCertificateInfoByIDRequest() {}

  explicit DescribeCertificateInfoByIDRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<string>(boost::any_cast<string>(m["CertId"]));
    }
  }


  virtual ~DescribeCertificateInfoByIDRequest() = default;
};
class DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo : public Darabonba::Model {
public:
  shared_ptr<string> certExpireTime{};
  shared_ptr<string> certId{};
  shared_ptr<string> certName{};
  shared_ptr<string> certType{};
  shared_ptr<string> createTime{};
  shared_ptr<string> domainList{};
  shared_ptr<string> httpsCrt{};

  DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo() {}

  explicit DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certExpireTime) {
      res["CertExpireTime"] = boost::any(*certExpireTime);
    }
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domainList) {
      res["DomainList"] = boost::any(*domainList);
    }
    if (httpsCrt) {
      res["HttpsCrt"] = boost::any(*httpsCrt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertExpireTime") != m.end() && !m["CertExpireTime"].empty()) {
      certExpireTime = make_shared<string>(boost::any_cast<string>(m["CertExpireTime"]));
    }
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<string>(boost::any_cast<string>(m["CertId"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DomainList") != m.end() && !m["DomainList"].empty()) {
      domainList = make_shared<string>(boost::any_cast<string>(m["DomainList"]));
    }
    if (m.find("HttpsCrt") != m.end() && !m["HttpsCrt"].empty()) {
      httpsCrt = make_shared<string>(boost::any_cast<string>(m["HttpsCrt"]));
    }
  }


  virtual ~DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo() = default;
};
class DescribeCertificateInfoByIDResponseBodyCertInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo>> certInfo{};

  DescribeCertificateInfoByIDResponseBodyCertInfos() {}

  explicit DescribeCertificateInfoByIDResponseBodyCertInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfo) {
      vector<boost::any> temp1;
      for(auto item1:*certInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CertInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfo") != m.end() && !m["CertInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["CertInfo"].type()) {
        vector<DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CertInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certInfo = make_shared<vector<DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeCertificateInfoByIDResponseBodyCertInfos() = default;
};
class DescribeCertificateInfoByIDResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCertificateInfoByIDResponseBodyCertInfos> certInfos{};
  shared_ptr<string> requestId{};

  DescribeCertificateInfoByIDResponseBody() {}

  explicit DescribeCertificateInfoByIDResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfos) {
      res["CertInfos"] = certInfos ? boost::any(certInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfos") != m.end() && !m["CertInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertInfos"].type()) {
        DescribeCertificateInfoByIDResponseBodyCertInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertInfos"]));
        certInfos = make_shared<DescribeCertificateInfoByIDResponseBodyCertInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCertificateInfoByIDResponseBody() = default;
};
class DescribeCertificateInfoByIDResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCertificateInfoByIDResponseBody> body{};

  DescribeCertificateInfoByIDResponse() {}

  explicit DescribeCertificateInfoByIDResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCertificateInfoByIDResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCertificateInfoByIDResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCertificateInfoByIDResponse() = default;
};
class DescribeCustomLogConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> configId{};

  DescribeCustomLogConfigRequest() {}

  explicit DescribeCustomLogConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
  }


  virtual ~DescribeCustomLogConfigRequest() = default;
};
class DescribeCustomLogConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> remark{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sample{};
  shared_ptr<string> tag{};

  DescribeCustomLogConfigResponseBody() {}

  explicit DescribeCustomLogConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<string>(boost::any_cast<string>(m["Sample"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~DescribeCustomLogConfigResponseBody() = default;
};
class DescribeCustomLogConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCustomLogConfigResponseBody> body{};

  DescribeCustomLogConfigResponse() {}

  explicit DescribeCustomLogConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCustomLogConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCustomLogConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCustomLogConfigResponse() = default;
};
class DescribeDomainAverageResponseTimeRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> domainType{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timeMerge{};

  DescribeDomainAverageResponseTimeRequest() {}

  explicit DescribeDomainAverageResponseTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainType) {
      res["DomainType"] = boost::any(*domainType);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timeMerge) {
      res["TimeMerge"] = boost::any(*timeMerge);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainType") != m.end() && !m["DomainType"].empty()) {
      domainType = make_shared<string>(boost::any_cast<string>(m["DomainType"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TimeMerge") != m.end() && !m["TimeMerge"].empty()) {
      timeMerge = make_shared<string>(boost::any_cast<string>(m["TimeMerge"]));
    }
  }


  virtual ~DescribeDomainAverageResponseTimeRequest() = default;
};
class DescribeDomainAverageResponseTimeResponseBodyAvgRTPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDomainAverageResponseTimeResponseBodyAvgRTPerIntervalDataModule() {}

  explicit DescribeDomainAverageResponseTimeResponseBodyAvgRTPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainAverageResponseTimeResponseBodyAvgRTPerIntervalDataModule() = default;
};
class DescribeDomainAverageResponseTimeResponseBodyAvgRTPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainAverageResponseTimeResponseBodyAvgRTPerIntervalDataModule>> dataModule{};

  DescribeDomainAverageResponseTimeResponseBodyAvgRTPerInterval() {}

  explicit DescribeDomainAverageResponseTimeResponseBodyAvgRTPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDomainAverageResponseTimeResponseBodyAvgRTPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainAverageResponseTimeResponseBodyAvgRTPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDomainAverageResponseTimeResponseBodyAvgRTPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainAverageResponseTimeResponseBodyAvgRTPerInterval() = default;
};
class DescribeDomainAverageResponseTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDomainAverageResponseTimeResponseBodyAvgRTPerInterval> avgRTPerInterval{};
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDomainAverageResponseTimeResponseBody() {}

  explicit DescribeDomainAverageResponseTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgRTPerInterval) {
      res["AvgRTPerInterval"] = avgRTPerInterval ? boost::any(avgRTPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgRTPerInterval") != m.end() && !m["AvgRTPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvgRTPerInterval"].type()) {
        DescribeDomainAverageResponseTimeResponseBodyAvgRTPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvgRTPerInterval"]));
        avgRTPerInterval = make_shared<DescribeDomainAverageResponseTimeResponseBodyAvgRTPerInterval>(model1);
      }
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainAverageResponseTimeResponseBody() = default;
};
class DescribeDomainAverageResponseTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainAverageResponseTimeResponseBody> body{};

  DescribeDomainAverageResponseTimeResponse() {}

  explicit DescribeDomainAverageResponseTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainAverageResponseTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainAverageResponseTimeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainAverageResponseTimeResponse() = default;
};
class DescribeDomainBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDomainBpsDataRequest() {}

  explicit DescribeDomainBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainBpsDataRequest() = default;
};
class DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> domesticValue{};
  shared_ptr<string> httpsDomesticValue{};
  shared_ptr<string> httpsOverseasValue{};
  shared_ptr<string> httpsValue{};
  shared_ptr<string> overseasValue{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule() {}

  explicit DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domesticValue) {
      res["DomesticValue"] = boost::any(*domesticValue);
    }
    if (httpsDomesticValue) {
      res["HttpsDomesticValue"] = boost::any(*httpsDomesticValue);
    }
    if (httpsOverseasValue) {
      res["HttpsOverseasValue"] = boost::any(*httpsOverseasValue);
    }
    if (httpsValue) {
      res["HttpsValue"] = boost::any(*httpsValue);
    }
    if (overseasValue) {
      res["OverseasValue"] = boost::any(*overseasValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomesticValue") != m.end() && !m["DomesticValue"].empty()) {
      domesticValue = make_shared<string>(boost::any_cast<string>(m["DomesticValue"]));
    }
    if (m.find("HttpsDomesticValue") != m.end() && !m["HttpsDomesticValue"].empty()) {
      httpsDomesticValue = make_shared<string>(boost::any_cast<string>(m["HttpsDomesticValue"]));
    }
    if (m.find("HttpsOverseasValue") != m.end() && !m["HttpsOverseasValue"].empty()) {
      httpsOverseasValue = make_shared<string>(boost::any_cast<string>(m["HttpsOverseasValue"]));
    }
    if (m.find("HttpsValue") != m.end() && !m["HttpsValue"].empty()) {
      httpsValue = make_shared<string>(boost::any_cast<string>(m["HttpsValue"]));
    }
    if (m.find("OverseasValue") != m.end() && !m["OverseasValue"].empty()) {
      overseasValue = make_shared<string>(boost::any_cast<string>(m["OverseasValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule() = default;
};
class DescribeDomainBpsDataResponseBodyBpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule>> dataModule{};

  DescribeDomainBpsDataResponseBodyBpsDataPerInterval() {}

  explicit DescribeDomainBpsDataResponseBodyBpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainBpsDataResponseBodyBpsDataPerInterval() = default;
};
class DescribeDomainBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDomainBpsDataResponseBodyBpsDataPerInterval> bpsDataPerInterval{};
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDomainBpsDataResponseBody() {}

  explicit DescribeDomainBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsDataPerInterval) {
      res["BpsDataPerInterval"] = bpsDataPerInterval ? boost::any(bpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsDataPerInterval") != m.end() && !m["BpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["BpsDataPerInterval"].type()) {
        DescribeDomainBpsDataResponseBodyBpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BpsDataPerInterval"]));
        bpsDataPerInterval = make_shared<DescribeDomainBpsDataResponseBodyBpsDataPerInterval>(model1);
      }
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainBpsDataResponseBody() = default;
};
class DescribeDomainBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainBpsDataResponseBody> body{};

  DescribeDomainBpsDataResponse() {}

  explicit DescribeDomainBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainBpsDataResponse() = default;
};
class DescribeDomainBpsDataByLayerRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> layer{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDomainBpsDataByLayerRequest() {}

  explicit DescribeDomainBpsDataByLayerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (layer) {
      res["Layer"] = boost::any(*layer);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("Layer") != m.end() && !m["Layer"].empty()) {
      layer = make_shared<string>(boost::any_cast<string>(m["Layer"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainBpsDataByLayerRequest() = default;
};
class DescribeDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> trafficValue{};
  shared_ptr<string> value{};

  DescribeDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule() {}

  explicit DescribeDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (trafficValue) {
      res["TrafficValue"] = boost::any(*trafficValue);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("TrafficValue") != m.end() && !m["TrafficValue"].empty()) {
      trafficValue = make_shared<string>(boost::any_cast<string>(m["TrafficValue"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule() = default;
};
class DescribeDomainBpsDataByLayerResponseBodyBpsDataInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule>> dataModule{};

  DescribeDomainBpsDataByLayerResponseBodyBpsDataInterval() {}

  explicit DescribeDomainBpsDataByLayerResponseBodyBpsDataInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainBpsDataByLayerResponseBodyBpsDataInterval() = default;
};
class DescribeDomainBpsDataByLayerResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDomainBpsDataByLayerResponseBodyBpsDataInterval> bpsDataInterval{};
  shared_ptr<string> dataInterval{};
  shared_ptr<string> requestId{};

  DescribeDomainBpsDataByLayerResponseBody() {}

  explicit DescribeDomainBpsDataByLayerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsDataInterval) {
      res["BpsDataInterval"] = bpsDataInterval ? boost::any(bpsDataInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsDataInterval") != m.end() && !m["BpsDataInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["BpsDataInterval"].type()) {
        DescribeDomainBpsDataByLayerResponseBodyBpsDataInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BpsDataInterval"]));
        bpsDataInterval = make_shared<DescribeDomainBpsDataByLayerResponseBodyBpsDataInterval>(model1);
      }
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDomainBpsDataByLayerResponseBody() = default;
};
class DescribeDomainBpsDataByLayerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainBpsDataByLayerResponseBody> body{};

  DescribeDomainBpsDataByLayerResponse() {}

  explicit DescribeDomainBpsDataByLayerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainBpsDataByLayerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainBpsDataByLayerResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainBpsDataByLayerResponse() = default;
};
class DescribeDomainBpsDataByTimeStampRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> ispNames{};
  shared_ptr<string> locationNames{};
  shared_ptr<string> timePoint{};

  DescribeDomainBpsDataByTimeStampRequest() {}

  explicit DescribeDomainBpsDataByTimeStampRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ispNames) {
      res["IspNames"] = boost::any(*ispNames);
    }
    if (locationNames) {
      res["LocationNames"] = boost::any(*locationNames);
    }
    if (timePoint) {
      res["TimePoint"] = boost::any(*timePoint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("IspNames") != m.end() && !m["IspNames"].empty()) {
      ispNames = make_shared<string>(boost::any_cast<string>(m["IspNames"]));
    }
    if (m.find("LocationNames") != m.end() && !m["LocationNames"].empty()) {
      locationNames = make_shared<string>(boost::any_cast<string>(m["LocationNames"]));
    }
    if (m.find("TimePoint") != m.end() && !m["TimePoint"].empty()) {
      timePoint = make_shared<string>(boost::any_cast<string>(m["TimePoint"]));
    }
  }


  virtual ~DescribeDomainBpsDataByTimeStampRequest() = default;
};
class DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel : public Darabonba::Model {
public:
  shared_ptr<long> bps{};
  shared_ptr<string> ispName{};
  shared_ptr<string> locationName{};
  shared_ptr<string> timeStamp{};

  DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel() {}

  explicit DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (ispName) {
      res["IspName"] = boost::any(*ispName);
    }
    if (locationName) {
      res["LocationName"] = boost::any(*locationName);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<long>(boost::any_cast<long>(m["Bps"]));
    }
    if (m.find("IspName") != m.end() && !m["IspName"].empty()) {
      ispName = make_shared<string>(boost::any_cast<string>(m["IspName"]));
    }
    if (m.find("LocationName") != m.end() && !m["LocationName"].empty()) {
      locationName = make_shared<string>(boost::any_cast<string>(m["LocationName"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel() = default;
};
class DescribeDomainBpsDataByTimeStampResponseBodyBpsDataList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel>> bpsDataModel{};

  DescribeDomainBpsDataByTimeStampResponseBodyBpsDataList() {}

  explicit DescribeDomainBpsDataByTimeStampResponseBodyBpsDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsDataModel) {
      vector<boost::any> temp1;
      for(auto item1:*bpsDataModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BpsDataModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsDataModel") != m.end() && !m["BpsDataModel"].empty()) {
      if (typeid(vector<boost::any>) == m["BpsDataModel"].type()) {
        vector<DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BpsDataModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bpsDataModel = make_shared<vector<DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainBpsDataByTimeStampResponseBodyBpsDataList() = default;
};
class DescribeDomainBpsDataByTimeStampResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDomainBpsDataByTimeStampResponseBodyBpsDataList> bpsDataList{};
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> timeStamp{};

  DescribeDomainBpsDataByTimeStampResponseBody() {}

  explicit DescribeDomainBpsDataByTimeStampResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsDataList) {
      res["BpsDataList"] = bpsDataList ? boost::any(bpsDataList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsDataList") != m.end() && !m["BpsDataList"].empty()) {
      if (typeid(map<string, boost::any>) == m["BpsDataList"].type()) {
        DescribeDomainBpsDataByTimeStampResponseBodyBpsDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BpsDataList"]));
        bpsDataList = make_shared<DescribeDomainBpsDataByTimeStampResponseBodyBpsDataList>(model1);
      }
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDomainBpsDataByTimeStampResponseBody() = default;
};
class DescribeDomainBpsDataByTimeStampResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainBpsDataByTimeStampResponseBody> body{};

  DescribeDomainBpsDataByTimeStampResponse() {}

  explicit DescribeDomainBpsDataByTimeStampResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainBpsDataByTimeStampResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainBpsDataByTimeStampResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainBpsDataByTimeStampResponse() = default;
};
class DescribeDomainCcActivityLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> triggerObject{};
  shared_ptr<string> value{};

  DescribeDomainCcActivityLogRequest() {}

  explicit DescribeDomainCcActivityLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (triggerObject) {
      res["TriggerObject"] = boost::any(*triggerObject);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TriggerObject") != m.end() && !m["TriggerObject"].empty()) {
      triggerObject = make_shared<string>(boost::any_cast<string>(m["TriggerObject"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainCcActivityLogRequest() = default;
};
class DescribeDomainCcActivityLogResponseBodyActivityLog : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> domainName{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> triggerObject{};
  shared_ptr<long> ttl{};
  shared_ptr<string> value{};

  DescribeDomainCcActivityLogResponseBodyActivityLog() {}

  explicit DescribeDomainCcActivityLogResponseBodyActivityLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (triggerObject) {
      res["TriggerObject"] = boost::any(*triggerObject);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("TriggerObject") != m.end() && !m["TriggerObject"].empty()) {
      triggerObject = make_shared<string>(boost::any_cast<string>(m["TriggerObject"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainCcActivityLogResponseBodyActivityLog() = default;
};
class DescribeDomainCcActivityLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainCcActivityLogResponseBodyActivityLog>> activityLog{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  DescribeDomainCcActivityLogResponseBody() {}

  explicit DescribeDomainCcActivityLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityLog) {
      vector<boost::any> temp1;
      for(auto item1:*activityLog){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ActivityLog"] = boost::any(temp1);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityLog") != m.end() && !m["ActivityLog"].empty()) {
      if (typeid(vector<boost::any>) == m["ActivityLog"].type()) {
        vector<DescribeDomainCcActivityLogResponseBodyActivityLog> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ActivityLog"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainCcActivityLogResponseBodyActivityLog model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        activityLog = make_shared<vector<DescribeDomainCcActivityLogResponseBodyActivityLog>>(expect1);
      }
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeDomainCcActivityLogResponseBody() = default;
};
class DescribeDomainCcActivityLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainCcActivityLogResponseBody> body{};

  DescribeDomainCcActivityLogResponse() {}

  explicit DescribeDomainCcActivityLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainCcActivityLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainCcActivityLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainCcActivityLogResponse() = default;
};
class DescribeDomainCertificateInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};

  DescribeDomainCertificateInfoRequest() {}

  explicit DescribeDomainCertificateInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeDomainCertificateInfoRequest() = default;
};
class DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo : public Darabonba::Model {
public:
  shared_ptr<string> certDomainName{};
  shared_ptr<string> certExpireTime{};
  shared_ptr<string> certId{};
  shared_ptr<string> certLife{};
  shared_ptr<string> certName{};
  shared_ptr<string> certOrg{};
  shared_ptr<string> certRegion{};
  shared_ptr<string> certStartTime{};
  shared_ptr<string> certType{};
  shared_ptr<string> certUpdateTime{};
  shared_ptr<string> domainCnameStatus{};
  shared_ptr<string> domainName{};
  shared_ptr<string> serverCertificate{};
  shared_ptr<string> serverCertificateStatus{};
  shared_ptr<string> status{};

  DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo() {}

  explicit DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certDomainName) {
      res["CertDomainName"] = boost::any(*certDomainName);
    }
    if (certExpireTime) {
      res["CertExpireTime"] = boost::any(*certExpireTime);
    }
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certLife) {
      res["CertLife"] = boost::any(*certLife);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certOrg) {
      res["CertOrg"] = boost::any(*certOrg);
    }
    if (certRegion) {
      res["CertRegion"] = boost::any(*certRegion);
    }
    if (certStartTime) {
      res["CertStartTime"] = boost::any(*certStartTime);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (certUpdateTime) {
      res["CertUpdateTime"] = boost::any(*certUpdateTime);
    }
    if (domainCnameStatus) {
      res["DomainCnameStatus"] = boost::any(*domainCnameStatus);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (serverCertificate) {
      res["ServerCertificate"] = boost::any(*serverCertificate);
    }
    if (serverCertificateStatus) {
      res["ServerCertificateStatus"] = boost::any(*serverCertificateStatus);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertDomainName") != m.end() && !m["CertDomainName"].empty()) {
      certDomainName = make_shared<string>(boost::any_cast<string>(m["CertDomainName"]));
    }
    if (m.find("CertExpireTime") != m.end() && !m["CertExpireTime"].empty()) {
      certExpireTime = make_shared<string>(boost::any_cast<string>(m["CertExpireTime"]));
    }
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<string>(boost::any_cast<string>(m["CertId"]));
    }
    if (m.find("CertLife") != m.end() && !m["CertLife"].empty()) {
      certLife = make_shared<string>(boost::any_cast<string>(m["CertLife"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertOrg") != m.end() && !m["CertOrg"].empty()) {
      certOrg = make_shared<string>(boost::any_cast<string>(m["CertOrg"]));
    }
    if (m.find("CertRegion") != m.end() && !m["CertRegion"].empty()) {
      certRegion = make_shared<string>(boost::any_cast<string>(m["CertRegion"]));
    }
    if (m.find("CertStartTime") != m.end() && !m["CertStartTime"].empty()) {
      certStartTime = make_shared<string>(boost::any_cast<string>(m["CertStartTime"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("CertUpdateTime") != m.end() && !m["CertUpdateTime"].empty()) {
      certUpdateTime = make_shared<string>(boost::any_cast<string>(m["CertUpdateTime"]));
    }
    if (m.find("DomainCnameStatus") != m.end() && !m["DomainCnameStatus"].empty()) {
      domainCnameStatus = make_shared<string>(boost::any_cast<string>(m["DomainCnameStatus"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ServerCertificate") != m.end() && !m["ServerCertificate"].empty()) {
      serverCertificate = make_shared<string>(boost::any_cast<string>(m["ServerCertificate"]));
    }
    if (m.find("ServerCertificateStatus") != m.end() && !m["ServerCertificateStatus"].empty()) {
      serverCertificateStatus = make_shared<string>(boost::any_cast<string>(m["ServerCertificateStatus"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo() = default;
};
class DescribeDomainCertificateInfoResponseBodyCertInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo>> certInfo{};

  DescribeDomainCertificateInfoResponseBodyCertInfos() {}

  explicit DescribeDomainCertificateInfoResponseBodyCertInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfo) {
      vector<boost::any> temp1;
      for(auto item1:*certInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CertInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfo") != m.end() && !m["CertInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["CertInfo"].type()) {
        vector<DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CertInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certInfo = make_shared<vector<DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainCertificateInfoResponseBodyCertInfos() = default;
};
class DescribeDomainCertificateInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDomainCertificateInfoResponseBodyCertInfos> certInfos{};
  shared_ptr<string> requestId{};

  DescribeDomainCertificateInfoResponseBody() {}

  explicit DescribeDomainCertificateInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfos) {
      res["CertInfos"] = certInfos ? boost::any(certInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfos") != m.end() && !m["CertInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertInfos"].type()) {
        DescribeDomainCertificateInfoResponseBodyCertInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertInfos"]));
        certInfos = make_shared<DescribeDomainCertificateInfoResponseBodyCertInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDomainCertificateInfoResponseBody() = default;
};
class DescribeDomainCertificateInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainCertificateInfoResponseBody> body{};

  DescribeDomainCertificateInfoResponse() {}

  explicit DescribeDomainCertificateInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainCertificateInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainCertificateInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainCertificateInfoResponse() = default;
};
class DescribeDomainCnameRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};

  DescribeDomainCnameRequest() {}

  explicit DescribeDomainCnameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeDomainCnameRequest() = default;
};
class DescribeDomainCnameResponseBodyCnameDatasData : public Darabonba::Model {
public:
  shared_ptr<string> cname{};
  shared_ptr<string> domain{};
  shared_ptr<long> status{};

  DescribeDomainCnameResponseBodyCnameDatasData() {}

  explicit DescribeDomainCnameResponseBodyCnameDatasData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeDomainCnameResponseBodyCnameDatasData() = default;
};
class DescribeDomainCnameResponseBodyCnameDatas : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainCnameResponseBodyCnameDatasData>> data{};

  DescribeDomainCnameResponseBodyCnameDatas() {}

  explicit DescribeDomainCnameResponseBodyCnameDatas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeDomainCnameResponseBodyCnameDatasData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainCnameResponseBodyCnameDatasData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeDomainCnameResponseBodyCnameDatasData>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainCnameResponseBodyCnameDatas() = default;
};
class DescribeDomainCnameResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDomainCnameResponseBodyCnameDatas> cnameDatas{};
  shared_ptr<string> requestId{};

  DescribeDomainCnameResponseBody() {}

  explicit DescribeDomainCnameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cnameDatas) {
      res["CnameDatas"] = cnameDatas ? boost::any(cnameDatas->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CnameDatas") != m.end() && !m["CnameDatas"].empty()) {
      if (typeid(map<string, boost::any>) == m["CnameDatas"].type()) {
        DescribeDomainCnameResponseBodyCnameDatas model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CnameDatas"]));
        cnameDatas = make_shared<DescribeDomainCnameResponseBodyCnameDatas>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDomainCnameResponseBody() = default;
};
class DescribeDomainCnameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainCnameResponseBody> body{};

  DescribeDomainCnameResponse() {}

  explicit DescribeDomainCnameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainCnameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainCnameResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainCnameResponse() = default;
};
class DescribeDomainCustomLogConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};

  DescribeDomainCustomLogConfigRequest() {}

  explicit DescribeDomainCustomLogConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeDomainCustomLogConfigRequest() = default;
};
class DescribeDomainCustomLogConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<string> remark{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sample{};
  shared_ptr<string> tag{};

  DescribeDomainCustomLogConfigResponseBody() {}

  explicit DescribeDomainCustomLogConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<string>(boost::any_cast<string>(m["Sample"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~DescribeDomainCustomLogConfigResponseBody() = default;
};
class DescribeDomainCustomLogConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainCustomLogConfigResponseBody> body{};

  DescribeDomainCustomLogConfigResponse() {}

  explicit DescribeDomainCustomLogConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainCustomLogConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainCustomLogConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainCustomLogConfigResponse() = default;
};
class DescribeDomainDetailDataByLayerRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> field{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> layer{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDomainDetailDataByLayerRequest() {}

  explicit DescribeDomainDetailDataByLayerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (layer) {
      res["Layer"] = boost::any(*layer);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("Layer") != m.end() && !m["Layer"].empty()) {
      layer = make_shared<string>(boost::any_cast<string>(m["Layer"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainDetailDataByLayerRequest() = default;
};
class DescribeDomainDetailDataByLayerResponseBodyDataDataModule : public Darabonba::Model {
public:
  shared_ptr<long> acc{};
  shared_ptr<double> bps{};
  shared_ptr<string> domainName{};
  shared_ptr<string> httpCode{};
  shared_ptr<long> ipv6Acc{};
  shared_ptr<double> ipv6Bps{};
  shared_ptr<double> ipv6Qps{};
  shared_ptr<long> ipv6Traf{};
  shared_ptr<double> qps{};
  shared_ptr<string> timeStamp{};
  shared_ptr<long> traf{};

  DescribeDomainDetailDataByLayerResponseBodyDataDataModule() {}

  explicit DescribeDomainDetailDataByLayerResponseBodyDataDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acc) {
      res["Acc"] = boost::any(*acc);
    }
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (ipv6Acc) {
      res["Ipv6Acc"] = boost::any(*ipv6Acc);
    }
    if (ipv6Bps) {
      res["Ipv6Bps"] = boost::any(*ipv6Bps);
    }
    if (ipv6Qps) {
      res["Ipv6Qps"] = boost::any(*ipv6Qps);
    }
    if (ipv6Traf) {
      res["Ipv6Traf"] = boost::any(*ipv6Traf);
    }
    if (qps) {
      res["Qps"] = boost::any(*qps);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (traf) {
      res["Traf"] = boost::any(*traf);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Acc") != m.end() && !m["Acc"].empty()) {
      acc = make_shared<long>(boost::any_cast<long>(m["Acc"]));
    }
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<double>(boost::any_cast<double>(m["Bps"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Ipv6Acc") != m.end() && !m["Ipv6Acc"].empty()) {
      ipv6Acc = make_shared<long>(boost::any_cast<long>(m["Ipv6Acc"]));
    }
    if (m.find("Ipv6Bps") != m.end() && !m["Ipv6Bps"].empty()) {
      ipv6Bps = make_shared<double>(boost::any_cast<double>(m["Ipv6Bps"]));
    }
    if (m.find("Ipv6Qps") != m.end() && !m["Ipv6Qps"].empty()) {
      ipv6Qps = make_shared<double>(boost::any_cast<double>(m["Ipv6Qps"]));
    }
    if (m.find("Ipv6Traf") != m.end() && !m["Ipv6Traf"].empty()) {
      ipv6Traf = make_shared<long>(boost::any_cast<long>(m["Ipv6Traf"]));
    }
    if (m.find("Qps") != m.end() && !m["Qps"].empty()) {
      qps = make_shared<double>(boost::any_cast<double>(m["Qps"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Traf") != m.end() && !m["Traf"].empty()) {
      traf = make_shared<long>(boost::any_cast<long>(m["Traf"]));
    }
  }


  virtual ~DescribeDomainDetailDataByLayerResponseBodyDataDataModule() = default;
};
class DescribeDomainDetailDataByLayerResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainDetailDataByLayerResponseBodyDataDataModule>> dataModule{};

  DescribeDomainDetailDataByLayerResponseBodyData() {}

  explicit DescribeDomainDetailDataByLayerResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDomainDetailDataByLayerResponseBodyDataDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainDetailDataByLayerResponseBodyDataDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDomainDetailDataByLayerResponseBodyDataDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainDetailDataByLayerResponseBodyData() = default;
};
class DescribeDomainDetailDataByLayerResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDomainDetailDataByLayerResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribeDomainDetailDataByLayerResponseBody() {}

  explicit DescribeDomainDetailDataByLayerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeDomainDetailDataByLayerResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeDomainDetailDataByLayerResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDomainDetailDataByLayerResponseBody() = default;
};
class DescribeDomainDetailDataByLayerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainDetailDataByLayerResponseBody> body{};

  DescribeDomainDetailDataByLayerResponse() {}

  explicit DescribeDomainDetailDataByLayerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainDetailDataByLayerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainDetailDataByLayerResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainDetailDataByLayerResponse() = default;
};
class DescribeDomainHitRateDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> startTime{};

  DescribeDomainHitRateDataRequest() {}

  explicit DescribeDomainHitRateDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainHitRateDataRequest() = default;
};
class DescribeDomainHitRateDataResponseBodyHitRateIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> httpsValue{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDomainHitRateDataResponseBodyHitRateIntervalDataModule() {}

  explicit DescribeDomainHitRateDataResponseBodyHitRateIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpsValue) {
      res["HttpsValue"] = boost::any(*httpsValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpsValue") != m.end() && !m["HttpsValue"].empty()) {
      httpsValue = make_shared<string>(boost::any_cast<string>(m["HttpsValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainHitRateDataResponseBodyHitRateIntervalDataModule() = default;
};
class DescribeDomainHitRateDataResponseBodyHitRateInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainHitRateDataResponseBodyHitRateIntervalDataModule>> dataModule{};

  DescribeDomainHitRateDataResponseBodyHitRateInterval() {}

  explicit DescribeDomainHitRateDataResponseBodyHitRateInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDomainHitRateDataResponseBodyHitRateIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainHitRateDataResponseBodyHitRateIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDomainHitRateDataResponseBodyHitRateIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainHitRateDataResponseBodyHitRateInterval() = default;
};
class DescribeDomainHitRateDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeDomainHitRateDataResponseBodyHitRateInterval> hitRateInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDomainHitRateDataResponseBody() {}

  explicit DescribeDomainHitRateDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (hitRateInterval) {
      res["HitRateInterval"] = hitRateInterval ? boost::any(hitRateInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("HitRateInterval") != m.end() && !m["HitRateInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["HitRateInterval"].type()) {
        DescribeDomainHitRateDataResponseBodyHitRateInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HitRateInterval"]));
        hitRateInterval = make_shared<DescribeDomainHitRateDataResponseBodyHitRateInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainHitRateDataResponseBody() = default;
};
class DescribeDomainHitRateDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainHitRateDataResponseBody> body{};

  DescribeDomainHitRateDataResponse() {}

  explicit DescribeDomainHitRateDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainHitRateDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainHitRateDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainHitRateDataResponse() = default;
};
class DescribeDomainHttpCodeDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDomainHttpCodeDataRequest() {}

  explicit DescribeDomainHttpCodeDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainHttpCodeDataRequest() = default;
};
class DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> count{};
  shared_ptr<string> proportion{};

  DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData() {}

  explicit DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (proportion) {
      res["Proportion"] = boost::any(*proportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("Proportion") != m.end() && !m["Proportion"].empty()) {
      proportion = make_shared<string>(boost::any_cast<string>(m["Proportion"]));
    }
  }


  virtual ~DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData() = default;
};
class DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValue : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData>> codeProportionData{};

  DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValue() {}

  explicit DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeProportionData) {
      vector<boost::any> temp1;
      for(auto item1:*codeProportionData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CodeProportionData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodeProportionData") != m.end() && !m["CodeProportionData"].empty()) {
      if (typeid(vector<boost::any>) == m["CodeProportionData"].type()) {
        vector<DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CodeProportionData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        codeProportionData = make_shared<vector<DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValue() = default;
};
class DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageData : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValue> value{};

  DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageData() {}

  explicit DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = value ? boost::any(value->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(map<string, boost::any>) == m["Value"].type()) {
        DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Value"]));
        value = make_shared<DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValue>(model1);
      }
    }
  }


  virtual ~DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageData() = default;
};
class DescribeDomainHttpCodeDataResponseBodyHttpCodeData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageData>> usageData{};

  DescribeDomainHttpCodeDataResponseBodyHttpCodeData() {}

  explicit DescribeDomainHttpCodeDataResponseBodyHttpCodeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usageData) {
      vector<boost::any> temp1;
      for(auto item1:*usageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsageData") != m.end() && !m["UsageData"].empty()) {
      if (typeid(vector<boost::any>) == m["UsageData"].type()) {
        vector<DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usageData = make_shared<vector<DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageData>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainHttpCodeDataResponseBodyHttpCodeData() = default;
};
class DescribeDomainHttpCodeDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeDomainHttpCodeDataResponseBodyHttpCodeData> httpCodeData{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDomainHttpCodeDataResponseBody() {}

  explicit DescribeDomainHttpCodeDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (httpCodeData) {
      res["HttpCodeData"] = httpCodeData ? boost::any(httpCodeData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("HttpCodeData") != m.end() && !m["HttpCodeData"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpCodeData"].type()) {
        DescribeDomainHttpCodeDataResponseBodyHttpCodeData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpCodeData"]));
        httpCodeData = make_shared<DescribeDomainHttpCodeDataResponseBodyHttpCodeData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainHttpCodeDataResponseBody() = default;
};
class DescribeDomainHttpCodeDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainHttpCodeDataResponseBody> body{};

  DescribeDomainHttpCodeDataResponse() {}

  explicit DescribeDomainHttpCodeDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainHttpCodeDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainHttpCodeDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainHttpCodeDataResponse() = default;
};
class DescribeDomainHttpCodeDataByLayerRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> layer{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDomainHttpCodeDataByLayerRequest() {}

  explicit DescribeDomainHttpCodeDataByLayerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (layer) {
      res["Layer"] = boost::any(*layer);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("Layer") != m.end() && !m["Layer"].empty()) {
      layer = make_shared<string>(boost::any_cast<string>(m["Layer"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainHttpCodeDataByLayerRequest() = default;
};
class DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> totalValue{};
  shared_ptr<string> value{};

  DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule() {}

  explicit DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (totalValue) {
      res["TotalValue"] = boost::any(*totalValue);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("TotalValue") != m.end() && !m["TotalValue"].empty()) {
      totalValue = make_shared<string>(boost::any_cast<string>(m["TotalValue"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule() = default;
};
class DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule>> dataModule{};

  DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval() {}

  explicit DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval() = default;
};
class DescribeDomainHttpCodeDataByLayerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval> httpCodeDataInterval{};
  shared_ptr<string> requestId{};

  DescribeDomainHttpCodeDataByLayerResponseBody() {}

  explicit DescribeDomainHttpCodeDataByLayerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (httpCodeDataInterval) {
      res["HttpCodeDataInterval"] = httpCodeDataInterval ? boost::any(httpCodeDataInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("HttpCodeDataInterval") != m.end() && !m["HttpCodeDataInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpCodeDataInterval"].type()) {
        DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpCodeDataInterval"]));
        httpCodeDataInterval = make_shared<DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDomainHttpCodeDataByLayerResponseBody() = default;
};
class DescribeDomainHttpCodeDataByLayerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainHttpCodeDataByLayerResponseBody> body{};

  DescribeDomainHttpCodeDataByLayerResponse() {}

  explicit DescribeDomainHttpCodeDataByLayerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainHttpCodeDataByLayerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainHttpCodeDataByLayerResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainHttpCodeDataByLayerResponse() = default;
};
class DescribeDomainISPDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeDomainISPDataRequest() {}

  explicit DescribeDomainISPDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainISPDataRequest() = default;
};
class DescribeDomainISPDataResponseBodyValueISPProportionData : public Darabonba::Model {
public:
  shared_ptr<string> avgObjectSize{};
  shared_ptr<string> avgResponseRate{};
  shared_ptr<string> avgResponseTime{};
  shared_ptr<string> bps{};
  shared_ptr<string> bytesProportion{};
  shared_ptr<string> ISP{};
  shared_ptr<string> ispEname{};
  shared_ptr<string> proportion{};
  shared_ptr<string> qps{};
  shared_ptr<string> reqErrRate{};
  shared_ptr<string> totalBytes{};
  shared_ptr<string> totalQuery{};

  DescribeDomainISPDataResponseBodyValueISPProportionData() {}

  explicit DescribeDomainISPDataResponseBodyValueISPProportionData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgObjectSize) {
      res["AvgObjectSize"] = boost::any(*avgObjectSize);
    }
    if (avgResponseRate) {
      res["AvgResponseRate"] = boost::any(*avgResponseRate);
    }
    if (avgResponseTime) {
      res["AvgResponseTime"] = boost::any(*avgResponseTime);
    }
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (bytesProportion) {
      res["BytesProportion"] = boost::any(*bytesProportion);
    }
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    if (ispEname) {
      res["IspEname"] = boost::any(*ispEname);
    }
    if (proportion) {
      res["Proportion"] = boost::any(*proportion);
    }
    if (qps) {
      res["Qps"] = boost::any(*qps);
    }
    if (reqErrRate) {
      res["ReqErrRate"] = boost::any(*reqErrRate);
    }
    if (totalBytes) {
      res["TotalBytes"] = boost::any(*totalBytes);
    }
    if (totalQuery) {
      res["TotalQuery"] = boost::any(*totalQuery);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgObjectSize") != m.end() && !m["AvgObjectSize"].empty()) {
      avgObjectSize = make_shared<string>(boost::any_cast<string>(m["AvgObjectSize"]));
    }
    if (m.find("AvgResponseRate") != m.end() && !m["AvgResponseRate"].empty()) {
      avgResponseRate = make_shared<string>(boost::any_cast<string>(m["AvgResponseRate"]));
    }
    if (m.find("AvgResponseTime") != m.end() && !m["AvgResponseTime"].empty()) {
      avgResponseTime = make_shared<string>(boost::any_cast<string>(m["AvgResponseTime"]));
    }
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<string>(boost::any_cast<string>(m["Bps"]));
    }
    if (m.find("BytesProportion") != m.end() && !m["BytesProportion"].empty()) {
      bytesProportion = make_shared<string>(boost::any_cast<string>(m["BytesProportion"]));
    }
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
    if (m.find("IspEname") != m.end() && !m["IspEname"].empty()) {
      ispEname = make_shared<string>(boost::any_cast<string>(m["IspEname"]));
    }
    if (m.find("Proportion") != m.end() && !m["Proportion"].empty()) {
      proportion = make_shared<string>(boost::any_cast<string>(m["Proportion"]));
    }
    if (m.find("Qps") != m.end() && !m["Qps"].empty()) {
      qps = make_shared<string>(boost::any_cast<string>(m["Qps"]));
    }
    if (m.find("ReqErrRate") != m.end() && !m["ReqErrRate"].empty()) {
      reqErrRate = make_shared<string>(boost::any_cast<string>(m["ReqErrRate"]));
    }
    if (m.find("TotalBytes") != m.end() && !m["TotalBytes"].empty()) {
      totalBytes = make_shared<string>(boost::any_cast<string>(m["TotalBytes"]));
    }
    if (m.find("TotalQuery") != m.end() && !m["TotalQuery"].empty()) {
      totalQuery = make_shared<string>(boost::any_cast<string>(m["TotalQuery"]));
    }
  }


  virtual ~DescribeDomainISPDataResponseBodyValueISPProportionData() = default;
};
class DescribeDomainISPDataResponseBodyValue : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainISPDataResponseBodyValueISPProportionData>> ISPProportionData{};

  DescribeDomainISPDataResponseBodyValue() {}

  explicit DescribeDomainISPDataResponseBodyValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ISPProportionData) {
      vector<boost::any> temp1;
      for(auto item1:*ISPProportionData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ISPProportionData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ISPProportionData") != m.end() && !m["ISPProportionData"].empty()) {
      if (typeid(vector<boost::any>) == m["ISPProportionData"].type()) {
        vector<DescribeDomainISPDataResponseBodyValueISPProportionData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ISPProportionData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainISPDataResponseBodyValueISPProportionData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ISPProportionData = make_shared<vector<DescribeDomainISPDataResponseBodyValueISPProportionData>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainISPDataResponseBodyValue() = default;
};
class DescribeDomainISPDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeDomainISPDataResponseBodyValue> value{};

  DescribeDomainISPDataResponseBody() {}

  explicit DescribeDomainISPDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (value) {
      res["Value"] = value ? boost::any(value->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(map<string, boost::any>) == m["Value"].type()) {
        DescribeDomainISPDataResponseBodyValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Value"]));
        value = make_shared<DescribeDomainISPDataResponseBodyValue>(model1);
      }
    }
  }


  virtual ~DescribeDomainISPDataResponseBody() = default;
};
class DescribeDomainISPDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainISPDataResponseBody> body{};

  DescribeDomainISPDataResponse() {}

  explicit DescribeDomainISPDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainISPDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainISPDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainISPDataResponse() = default;
};
class DescribeDomainMax95BpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> cycle{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timePoint{};

  DescribeDomainMax95BpsDataRequest() {}

  explicit DescribeDomainMax95BpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycle) {
      res["Cycle"] = boost::any(*cycle);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timePoint) {
      res["TimePoint"] = boost::any(*timePoint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cycle") != m.end() && !m["Cycle"].empty()) {
      cycle = make_shared<string>(boost::any_cast<string>(m["Cycle"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TimePoint") != m.end() && !m["TimePoint"].empty()) {
      timePoint = make_shared<string>(boost::any_cast<string>(m["TimePoint"]));
    }
  }


  virtual ~DescribeDomainMax95BpsDataRequest() = default;
};
class DescribeDomainMax95BpsDataResponseBodyDetailDataMax95Detail : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<double> max95Bps{};
  shared_ptr<string> max95BpsPeakTime{};
  shared_ptr<string> timeStamp{};

  DescribeDomainMax95BpsDataResponseBodyDetailDataMax95Detail() {}

  explicit DescribeDomainMax95BpsDataResponseBodyDetailDataMax95Detail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (max95Bps) {
      res["Max95Bps"] = boost::any(*max95Bps);
    }
    if (max95BpsPeakTime) {
      res["Max95BpsPeakTime"] = boost::any(*max95BpsPeakTime);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("Max95Bps") != m.end() && !m["Max95Bps"].empty()) {
      max95Bps = make_shared<double>(boost::any_cast<double>(m["Max95Bps"]));
    }
    if (m.find("Max95BpsPeakTime") != m.end() && !m["Max95BpsPeakTime"].empty()) {
      max95BpsPeakTime = make_shared<string>(boost::any_cast<string>(m["Max95BpsPeakTime"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDomainMax95BpsDataResponseBodyDetailDataMax95Detail() = default;
};
class DescribeDomainMax95BpsDataResponseBodyDetailData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainMax95BpsDataResponseBodyDetailDataMax95Detail>> max95Detail{};

  DescribeDomainMax95BpsDataResponseBodyDetailData() {}

  explicit DescribeDomainMax95BpsDataResponseBodyDetailData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max95Detail) {
      vector<boost::any> temp1;
      for(auto item1:*max95Detail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Max95Detail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max95Detail") != m.end() && !m["Max95Detail"].empty()) {
      if (typeid(vector<boost::any>) == m["Max95Detail"].type()) {
        vector<DescribeDomainMax95BpsDataResponseBodyDetailDataMax95Detail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Max95Detail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainMax95BpsDataResponseBodyDetailDataMax95Detail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        max95Detail = make_shared<vector<DescribeDomainMax95BpsDataResponseBodyDetailDataMax95Detail>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainMax95BpsDataResponseBodyDetailData() = default;
};
class DescribeDomainMax95BpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDomainMax95BpsDataResponseBodyDetailData> detailData{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domesticMax95Bps{};
  shared_ptr<string> endTime{};
  shared_ptr<string> max95Bps{};
  shared_ptr<string> overseasMax95Bps{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDomainMax95BpsDataResponseBody() {}

  explicit DescribeDomainMax95BpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detailData) {
      res["DetailData"] = detailData ? boost::any(detailData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domesticMax95Bps) {
      res["DomesticMax95Bps"] = boost::any(*domesticMax95Bps);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (max95Bps) {
      res["Max95Bps"] = boost::any(*max95Bps);
    }
    if (overseasMax95Bps) {
      res["OverseasMax95Bps"] = boost::any(*overseasMax95Bps);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DetailData") != m.end() && !m["DetailData"].empty()) {
      if (typeid(map<string, boost::any>) == m["DetailData"].type()) {
        DescribeDomainMax95BpsDataResponseBodyDetailData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DetailData"]));
        detailData = make_shared<DescribeDomainMax95BpsDataResponseBodyDetailData>(model1);
      }
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomesticMax95Bps") != m.end() && !m["DomesticMax95Bps"].empty()) {
      domesticMax95Bps = make_shared<string>(boost::any_cast<string>(m["DomesticMax95Bps"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Max95Bps") != m.end() && !m["Max95Bps"].empty()) {
      max95Bps = make_shared<string>(boost::any_cast<string>(m["Max95Bps"]));
    }
    if (m.find("OverseasMax95Bps") != m.end() && !m["OverseasMax95Bps"].empty()) {
      overseasMax95Bps = make_shared<string>(boost::any_cast<string>(m["OverseasMax95Bps"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainMax95BpsDataResponseBody() = default;
};
class DescribeDomainMax95BpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainMax95BpsDataResponseBody> body{};

  DescribeDomainMax95BpsDataResponse() {}

  explicit DescribeDomainMax95BpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainMax95BpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainMax95BpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainMax95BpsDataResponse() = default;
};
class DescribeDomainMultiUsageDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeDomainMultiUsageDataRequest() {}

  explicit DescribeDomainMultiUsageDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainMultiUsageDataRequest() = default;
};
class DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> request{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> type{};

  DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule() {}

  explicit DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (request) {
      res["Request"] = boost::any(*request);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Request") != m.end() && !m["Request"].empty()) {
      request = make_shared<long>(boost::any_cast<long>(m["Request"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule() = default;
};
class DescribeDomainMultiUsageDataResponseBodyRequestPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule>> requestDataModule{};

  DescribeDomainMultiUsageDataResponseBodyRequestPerInterval() {}

  explicit DescribeDomainMultiUsageDataResponseBodyRequestPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestDataModule) {
      vector<boost::any> temp1;
      for(auto item1:*requestDataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestDataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestDataModule") != m.end() && !m["RequestDataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestDataModule"].type()) {
        vector<DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestDataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestDataModule = make_shared<vector<DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainMultiUsageDataResponseBodyRequestPerInterval() = default;
};
class DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<double> bps{};
  shared_ptr<string> domain{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> type{};

  DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule() {}

  explicit DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<double>(boost::any_cast<double>(m["Bps"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule() = default;
};
class DescribeDomainMultiUsageDataResponseBodyTrafficPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule>> trafficDataModule{};

  DescribeDomainMultiUsageDataResponseBodyTrafficPerInterval() {}

  explicit DescribeDomainMultiUsageDataResponseBodyTrafficPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trafficDataModule) {
      vector<boost::any> temp1;
      for(auto item1:*trafficDataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TrafficDataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TrafficDataModule") != m.end() && !m["TrafficDataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["TrafficDataModule"].type()) {
        vector<DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TrafficDataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trafficDataModule = make_shared<vector<DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainMultiUsageDataResponseBodyTrafficPerInterval() = default;
};
class DescribeDomainMultiUsageDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDomainMultiUsageDataResponseBodyRequestPerInterval> requestPerInterval{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeDomainMultiUsageDataResponseBodyTrafficPerInterval> trafficPerInterval{};

  DescribeDomainMultiUsageDataResponseBody() {}

  explicit DescribeDomainMultiUsageDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestPerInterval) {
      res["RequestPerInterval"] = requestPerInterval ? boost::any(requestPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (trafficPerInterval) {
      res["TrafficPerInterval"] = trafficPerInterval ? boost::any(trafficPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestPerInterval") != m.end() && !m["RequestPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestPerInterval"].type()) {
        DescribeDomainMultiUsageDataResponseBodyRequestPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestPerInterval"]));
        requestPerInterval = make_shared<DescribeDomainMultiUsageDataResponseBodyRequestPerInterval>(model1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TrafficPerInterval") != m.end() && !m["TrafficPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficPerInterval"].type()) {
        DescribeDomainMultiUsageDataResponseBodyTrafficPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficPerInterval"]));
        trafficPerInterval = make_shared<DescribeDomainMultiUsageDataResponseBodyTrafficPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDomainMultiUsageDataResponseBody() = default;
};
class DescribeDomainMultiUsageDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainMultiUsageDataResponseBody> body{};

  DescribeDomainMultiUsageDataResponse() {}

  explicit DescribeDomainMultiUsageDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainMultiUsageDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainMultiUsageDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainMultiUsageDataResponse() = default;
};
class DescribeDomainPathDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> path{};
  shared_ptr<string> startTime{};

  DescribeDomainPathDataRequest() {}

  explicit DescribeDomainPathDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainPathDataRequest() = default;
};
class DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData : public Darabonba::Model {
public:
  shared_ptr<long> acc{};
  shared_ptr<string> path{};
  shared_ptr<string> time{};
  shared_ptr<long> traffic{};

  DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData() {}

  explicit DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acc) {
      res["Acc"] = boost::any(*acc);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (traffic) {
      res["Traffic"] = boost::any(*traffic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Acc") != m.end() && !m["Acc"].empty()) {
      acc = make_shared<long>(boost::any_cast<long>(m["Acc"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Traffic") != m.end() && !m["Traffic"].empty()) {
      traffic = make_shared<long>(boost::any_cast<long>(m["Traffic"]));
    }
  }


  virtual ~DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData() = default;
};
class DescribeDomainPathDataResponseBodyPathDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData>> usageData{};

  DescribeDomainPathDataResponseBodyPathDataPerInterval() {}

  explicit DescribeDomainPathDataResponseBodyPathDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usageData) {
      vector<boost::any> temp1;
      for(auto item1:*usageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsageData") != m.end() && !m["UsageData"].empty()) {
      if (typeid(vector<boost::any>) == m["UsageData"].type()) {
        vector<DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usageData = make_shared<vector<DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainPathDataResponseBodyPathDataPerInterval() = default;
};
class DescribeDomainPathDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<DescribeDomainPathDataResponseBodyPathDataPerInterval> pathDataPerInterval{};
  shared_ptr<string> startTime{};
  shared_ptr<long> totalCount{};

  DescribeDomainPathDataResponseBody() {}

  explicit DescribeDomainPathDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pathDataPerInterval) {
      res["PathDataPerInterval"] = pathDataPerInterval ? boost::any(pathDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PathDataPerInterval") != m.end() && !m["PathDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["PathDataPerInterval"].type()) {
        DescribeDomainPathDataResponseBodyPathDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PathDataPerInterval"]));
        pathDataPerInterval = make_shared<DescribeDomainPathDataResponseBodyPathDataPerInterval>(model1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDomainPathDataResponseBody() = default;
};
class DescribeDomainPathDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainPathDataResponseBody> body{};

  DescribeDomainPathDataResponse() {}

  explicit DescribeDomainPathDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainPathDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainPathDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainPathDataResponse() = default;
};
class DescribeDomainPvDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeDomainPvDataRequest() {}

  explicit DescribeDomainPvDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainPvDataRequest() = default;
};
class DescribeDomainPvDataResponseBodyPvDataIntervalUsageData : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDomainPvDataResponseBodyPvDataIntervalUsageData() {}

  explicit DescribeDomainPvDataResponseBodyPvDataIntervalUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainPvDataResponseBodyPvDataIntervalUsageData() = default;
};
class DescribeDomainPvDataResponseBodyPvDataInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainPvDataResponseBodyPvDataIntervalUsageData>> usageData{};

  DescribeDomainPvDataResponseBodyPvDataInterval() {}

  explicit DescribeDomainPvDataResponseBodyPvDataInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usageData) {
      vector<boost::any> temp1;
      for(auto item1:*usageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsageData") != m.end() && !m["UsageData"].empty()) {
      if (typeid(vector<boost::any>) == m["UsageData"].type()) {
        vector<DescribeDomainPvDataResponseBodyPvDataIntervalUsageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainPvDataResponseBodyPvDataIntervalUsageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usageData = make_shared<vector<DescribeDomainPvDataResponseBodyPvDataIntervalUsageData>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainPvDataResponseBodyPvDataInterval() = default;
};
class DescribeDomainPvDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeDomainPvDataResponseBodyPvDataInterval> pvDataInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDomainPvDataResponseBody() {}

  explicit DescribeDomainPvDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pvDataInterval) {
      res["PvDataInterval"] = pvDataInterval ? boost::any(pvDataInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PvDataInterval") != m.end() && !m["PvDataInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["PvDataInterval"].type()) {
        DescribeDomainPvDataResponseBodyPvDataInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PvDataInterval"]));
        pvDataInterval = make_shared<DescribeDomainPvDataResponseBodyPvDataInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainPvDataResponseBody() = default;
};
class DescribeDomainPvDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainPvDataResponseBody> body{};

  DescribeDomainPvDataResponse() {}

  explicit DescribeDomainPvDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainPvDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainPvDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainPvDataResponse() = default;
};
class DescribeDomainQpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDomainQpsDataRequest() {}

  explicit DescribeDomainQpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainQpsDataRequest() = default;
};
class DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> accDomesticValue{};
  shared_ptr<string> accOverseasValue{};
  shared_ptr<string> accValue{};
  shared_ptr<string> domesticValue{};
  shared_ptr<string> httpsAccDomesticValue{};
  shared_ptr<string> httpsAccOverseasValue{};
  shared_ptr<string> httpsAccValue{};
  shared_ptr<string> httpsDomesticValue{};
  shared_ptr<string> httpsOverseasValue{};
  shared_ptr<string> httpsValue{};
  shared_ptr<string> overseasValue{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule() {}

  explicit DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accDomesticValue) {
      res["AccDomesticValue"] = boost::any(*accDomesticValue);
    }
    if (accOverseasValue) {
      res["AccOverseasValue"] = boost::any(*accOverseasValue);
    }
    if (accValue) {
      res["AccValue"] = boost::any(*accValue);
    }
    if (domesticValue) {
      res["DomesticValue"] = boost::any(*domesticValue);
    }
    if (httpsAccDomesticValue) {
      res["HttpsAccDomesticValue"] = boost::any(*httpsAccDomesticValue);
    }
    if (httpsAccOverseasValue) {
      res["HttpsAccOverseasValue"] = boost::any(*httpsAccOverseasValue);
    }
    if (httpsAccValue) {
      res["HttpsAccValue"] = boost::any(*httpsAccValue);
    }
    if (httpsDomesticValue) {
      res["HttpsDomesticValue"] = boost::any(*httpsDomesticValue);
    }
    if (httpsOverseasValue) {
      res["HttpsOverseasValue"] = boost::any(*httpsOverseasValue);
    }
    if (httpsValue) {
      res["HttpsValue"] = boost::any(*httpsValue);
    }
    if (overseasValue) {
      res["OverseasValue"] = boost::any(*overseasValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccDomesticValue") != m.end() && !m["AccDomesticValue"].empty()) {
      accDomesticValue = make_shared<string>(boost::any_cast<string>(m["AccDomesticValue"]));
    }
    if (m.find("AccOverseasValue") != m.end() && !m["AccOverseasValue"].empty()) {
      accOverseasValue = make_shared<string>(boost::any_cast<string>(m["AccOverseasValue"]));
    }
    if (m.find("AccValue") != m.end() && !m["AccValue"].empty()) {
      accValue = make_shared<string>(boost::any_cast<string>(m["AccValue"]));
    }
    if (m.find("DomesticValue") != m.end() && !m["DomesticValue"].empty()) {
      domesticValue = make_shared<string>(boost::any_cast<string>(m["DomesticValue"]));
    }
    if (m.find("HttpsAccDomesticValue") != m.end() && !m["HttpsAccDomesticValue"].empty()) {
      httpsAccDomesticValue = make_shared<string>(boost::any_cast<string>(m["HttpsAccDomesticValue"]));
    }
    if (m.find("HttpsAccOverseasValue") != m.end() && !m["HttpsAccOverseasValue"].empty()) {
      httpsAccOverseasValue = make_shared<string>(boost::any_cast<string>(m["HttpsAccOverseasValue"]));
    }
    if (m.find("HttpsAccValue") != m.end() && !m["HttpsAccValue"].empty()) {
      httpsAccValue = make_shared<string>(boost::any_cast<string>(m["HttpsAccValue"]));
    }
    if (m.find("HttpsDomesticValue") != m.end() && !m["HttpsDomesticValue"].empty()) {
      httpsDomesticValue = make_shared<string>(boost::any_cast<string>(m["HttpsDomesticValue"]));
    }
    if (m.find("HttpsOverseasValue") != m.end() && !m["HttpsOverseasValue"].empty()) {
      httpsOverseasValue = make_shared<string>(boost::any_cast<string>(m["HttpsOverseasValue"]));
    }
    if (m.find("HttpsValue") != m.end() && !m["HttpsValue"].empty()) {
      httpsValue = make_shared<string>(boost::any_cast<string>(m["HttpsValue"]));
    }
    if (m.find("OverseasValue") != m.end() && !m["OverseasValue"].empty()) {
      overseasValue = make_shared<string>(boost::any_cast<string>(m["OverseasValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule() = default;
};
class DescribeDomainQpsDataResponseBodyQpsDataInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule>> dataModule{};

  DescribeDomainQpsDataResponseBodyQpsDataInterval() {}

  explicit DescribeDomainQpsDataResponseBodyQpsDataInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainQpsDataResponseBodyQpsDataInterval() = default;
};
class DescribeDomainQpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeDomainQpsDataResponseBodyQpsDataInterval> qpsDataInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDomainQpsDataResponseBody() {}

  explicit DescribeDomainQpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (qpsDataInterval) {
      res["QpsDataInterval"] = qpsDataInterval ? boost::any(qpsDataInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("QpsDataInterval") != m.end() && !m["QpsDataInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["QpsDataInterval"].type()) {
        DescribeDomainQpsDataResponseBodyQpsDataInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QpsDataInterval"]));
        qpsDataInterval = make_shared<DescribeDomainQpsDataResponseBodyQpsDataInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainQpsDataResponseBody() = default;
};
class DescribeDomainQpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainQpsDataResponseBody> body{};

  DescribeDomainQpsDataResponse() {}

  explicit DescribeDomainQpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainQpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainQpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainQpsDataResponse() = default;
};
class DescribeDomainQpsDataByLayerRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> layer{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDomainQpsDataByLayerRequest() {}

  explicit DescribeDomainQpsDataByLayerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (layer) {
      res["Layer"] = boost::any(*layer);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("Layer") != m.end() && !m["Layer"].empty()) {
      layer = make_shared<string>(boost::any_cast<string>(m["Layer"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainQpsDataByLayerRequest() = default;
};
class DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> accDomesticValue{};
  shared_ptr<string> accOverseasValue{};
  shared_ptr<string> accValue{};
  shared_ptr<string> domesticValue{};
  shared_ptr<string> overseasValue{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule() {}

  explicit DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accDomesticValue) {
      res["AccDomesticValue"] = boost::any(*accDomesticValue);
    }
    if (accOverseasValue) {
      res["AccOverseasValue"] = boost::any(*accOverseasValue);
    }
    if (accValue) {
      res["AccValue"] = boost::any(*accValue);
    }
    if (domesticValue) {
      res["DomesticValue"] = boost::any(*domesticValue);
    }
    if (overseasValue) {
      res["OverseasValue"] = boost::any(*overseasValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccDomesticValue") != m.end() && !m["AccDomesticValue"].empty()) {
      accDomesticValue = make_shared<string>(boost::any_cast<string>(m["AccDomesticValue"]));
    }
    if (m.find("AccOverseasValue") != m.end() && !m["AccOverseasValue"].empty()) {
      accOverseasValue = make_shared<string>(boost::any_cast<string>(m["AccOverseasValue"]));
    }
    if (m.find("AccValue") != m.end() && !m["AccValue"].empty()) {
      accValue = make_shared<string>(boost::any_cast<string>(m["AccValue"]));
    }
    if (m.find("DomesticValue") != m.end() && !m["DomesticValue"].empty()) {
      domesticValue = make_shared<string>(boost::any_cast<string>(m["DomesticValue"]));
    }
    if (m.find("OverseasValue") != m.end() && !m["OverseasValue"].empty()) {
      overseasValue = make_shared<string>(boost::any_cast<string>(m["OverseasValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule() = default;
};
class DescribeDomainQpsDataByLayerResponseBodyQpsDataInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule>> dataModule{};

  DescribeDomainQpsDataByLayerResponseBodyQpsDataInterval() {}

  explicit DescribeDomainQpsDataByLayerResponseBodyQpsDataInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainQpsDataByLayerResponseBodyQpsDataInterval() = default;
};
class DescribeDomainQpsDataByLayerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> layer{};
  shared_ptr<DescribeDomainQpsDataByLayerResponseBodyQpsDataInterval> qpsDataInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDomainQpsDataByLayerResponseBody() {}

  explicit DescribeDomainQpsDataByLayerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (layer) {
      res["Layer"] = boost::any(*layer);
    }
    if (qpsDataInterval) {
      res["QpsDataInterval"] = qpsDataInterval ? boost::any(qpsDataInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Layer") != m.end() && !m["Layer"].empty()) {
      layer = make_shared<string>(boost::any_cast<string>(m["Layer"]));
    }
    if (m.find("QpsDataInterval") != m.end() && !m["QpsDataInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["QpsDataInterval"].type()) {
        DescribeDomainQpsDataByLayerResponseBodyQpsDataInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QpsDataInterval"]));
        qpsDataInterval = make_shared<DescribeDomainQpsDataByLayerResponseBodyQpsDataInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainQpsDataByLayerResponseBody() = default;
};
class DescribeDomainQpsDataByLayerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainQpsDataByLayerResponseBody> body{};

  DescribeDomainQpsDataByLayerResponse() {}

  explicit DescribeDomainQpsDataByLayerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainQpsDataByLayerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainQpsDataByLayerResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainQpsDataByLayerResponse() = default;
};
class DescribeDomainRealTimeBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDomainRealTimeBpsDataRequest() {}

  explicit DescribeDomainRealTimeBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainRealTimeBpsDataRequest() = default;
};
class DescribeDomainRealTimeBpsDataResponseBodyDataBpsModel : public Darabonba::Model {
public:
  shared_ptr<double> bps{};
  shared_ptr<string> timeStamp{};

  DescribeDomainRealTimeBpsDataResponseBodyDataBpsModel() {}

  explicit DescribeDomainRealTimeBpsDataResponseBodyDataBpsModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<double>(boost::any_cast<double>(m["Bps"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDomainRealTimeBpsDataResponseBodyDataBpsModel() = default;
};
class DescribeDomainRealTimeBpsDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainRealTimeBpsDataResponseBodyDataBpsModel>> bpsModel{};

  DescribeDomainRealTimeBpsDataResponseBodyData() {}

  explicit DescribeDomainRealTimeBpsDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsModel) {
      vector<boost::any> temp1;
      for(auto item1:*bpsModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BpsModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsModel") != m.end() && !m["BpsModel"].empty()) {
      if (typeid(vector<boost::any>) == m["BpsModel"].type()) {
        vector<DescribeDomainRealTimeBpsDataResponseBodyDataBpsModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BpsModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainRealTimeBpsDataResponseBodyDataBpsModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bpsModel = make_shared<vector<DescribeDomainRealTimeBpsDataResponseBodyDataBpsModel>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainRealTimeBpsDataResponseBodyData() = default;
};
class DescribeDomainRealTimeBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDomainRealTimeBpsDataResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribeDomainRealTimeBpsDataResponseBody() {}

  explicit DescribeDomainRealTimeBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeDomainRealTimeBpsDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeDomainRealTimeBpsDataResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDomainRealTimeBpsDataResponseBody() = default;
};
class DescribeDomainRealTimeBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainRealTimeBpsDataResponseBody> body{};

  DescribeDomainRealTimeBpsDataResponse() {}

  explicit DescribeDomainRealTimeBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainRealTimeBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainRealTimeBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainRealTimeBpsDataResponse() = default;
};
class DescribeDomainRealTimeByteHitRateDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeDomainRealTimeByteHitRateDataRequest() {}

  explicit DescribeDomainRealTimeByteHitRateDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainRealTimeByteHitRateDataRequest() = default;
};
class DescribeDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel : public Darabonba::Model {
public:
  shared_ptr<double> byteHitRate{};
  shared_ptr<string> timeStamp{};

  DescribeDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel() {}

  explicit DescribeDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (byteHitRate) {
      res["ByteHitRate"] = boost::any(*byteHitRate);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ByteHitRate") != m.end() && !m["ByteHitRate"].empty()) {
      byteHitRate = make_shared<double>(boost::any_cast<double>(m["ByteHitRate"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel() = default;
};
class DescribeDomainRealTimeByteHitRateDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel>> byteHitRateDataModel{};

  DescribeDomainRealTimeByteHitRateDataResponseBodyData() {}

  explicit DescribeDomainRealTimeByteHitRateDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (byteHitRateDataModel) {
      vector<boost::any> temp1;
      for(auto item1:*byteHitRateDataModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ByteHitRateDataModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ByteHitRateDataModel") != m.end() && !m["ByteHitRateDataModel"].empty()) {
      if (typeid(vector<boost::any>) == m["ByteHitRateDataModel"].type()) {
        vector<DescribeDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ByteHitRateDataModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        byteHitRateDataModel = make_shared<vector<DescribeDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainRealTimeByteHitRateDataResponseBodyData() = default;
};
class DescribeDomainRealTimeByteHitRateDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDomainRealTimeByteHitRateDataResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribeDomainRealTimeByteHitRateDataResponseBody() {}

  explicit DescribeDomainRealTimeByteHitRateDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeDomainRealTimeByteHitRateDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeDomainRealTimeByteHitRateDataResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDomainRealTimeByteHitRateDataResponseBody() = default;
};
class DescribeDomainRealTimeByteHitRateDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainRealTimeByteHitRateDataResponseBody> body{};

  DescribeDomainRealTimeByteHitRateDataResponse() {}

  explicit DescribeDomainRealTimeByteHitRateDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainRealTimeByteHitRateDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainRealTimeByteHitRateDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainRealTimeByteHitRateDataResponse() = default;
};
class DescribeDomainRealTimeDetailDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> field{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> merge{};
  shared_ptr<string> mergeLocIsp{};
  shared_ptr<string> startTime{};

  DescribeDomainRealTimeDetailDataRequest() {}

  explicit DescribeDomainRealTimeDetailDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (merge) {
      res["Merge"] = boost::any(*merge);
    }
    if (mergeLocIsp) {
      res["MergeLocIsp"] = boost::any(*mergeLocIsp);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("Merge") != m.end() && !m["Merge"].empty()) {
      merge = make_shared<string>(boost::any_cast<string>(m["Merge"]));
    }
    if (m.find("MergeLocIsp") != m.end() && !m["MergeLocIsp"].empty()) {
      mergeLocIsp = make_shared<string>(boost::any_cast<string>(m["MergeLocIsp"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainRealTimeDetailDataRequest() = default;
};
class DescribeDomainRealTimeDetailDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  DescribeDomainRealTimeDetailDataResponseBody() {}

  explicit DescribeDomainRealTimeDetailDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDomainRealTimeDetailDataResponseBody() = default;
};
class DescribeDomainRealTimeDetailDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainRealTimeDetailDataResponseBody> body{};

  DescribeDomainRealTimeDetailDataResponse() {}

  explicit DescribeDomainRealTimeDetailDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainRealTimeDetailDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainRealTimeDetailDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainRealTimeDetailDataResponse() = default;
};
class DescribeDomainRealTimeHttpCodeDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDomainRealTimeHttpCodeDataRequest() {}

  explicit DescribeDomainRealTimeHttpCodeDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainRealTimeHttpCodeDataRequest() = default;
};
class DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> count{};
  shared_ptr<string> proportion{};

  DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData() {}

  explicit DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (proportion) {
      res["Proportion"] = boost::any(*proportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("Proportion") != m.end() && !m["Proportion"].empty()) {
      proportion = make_shared<string>(boost::any_cast<string>(m["Proportion"]));
    }
  }


  virtual ~DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData() = default;
};
class DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData>> realTimeCodeProportionData{};

  DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue() {}

  explicit DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (realTimeCodeProportionData) {
      vector<boost::any> temp1;
      for(auto item1:*realTimeCodeProportionData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RealTimeCodeProportionData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RealTimeCodeProportionData") != m.end() && !m["RealTimeCodeProportionData"].empty()) {
      if (typeid(vector<boost::any>) == m["RealTimeCodeProportionData"].type()) {
        vector<DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RealTimeCodeProportionData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        realTimeCodeProportionData = make_shared<vector<DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue() = default;
};
class DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue> value{};

  DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData() {}

  explicit DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = value ? boost::any(value->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(map<string, boost::any>) == m["Value"].type()) {
        DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Value"]));
        value = make_shared<DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue>(model1);
      }
    }
  }


  virtual ~DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData() = default;
};
class DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData>> usageData{};

  DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData() {}

  explicit DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usageData) {
      vector<boost::any> temp1;
      for(auto item1:*usageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsageData") != m.end() && !m["UsageData"].empty()) {
      if (typeid(vector<boost::any>) == m["UsageData"].type()) {
        vector<DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usageData = make_shared<vector<DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData() = default;
};
class DescribeDomainRealTimeHttpCodeDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData> realTimeHttpCodeData{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDomainRealTimeHttpCodeDataResponseBody() {}

  explicit DescribeDomainRealTimeHttpCodeDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (realTimeHttpCodeData) {
      res["RealTimeHttpCodeData"] = realTimeHttpCodeData ? boost::any(realTimeHttpCodeData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RealTimeHttpCodeData") != m.end() && !m["RealTimeHttpCodeData"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeHttpCodeData"].type()) {
        DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeHttpCodeData"]));
        realTimeHttpCodeData = make_shared<DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainRealTimeHttpCodeDataResponseBody() = default;
};
class DescribeDomainRealTimeHttpCodeDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainRealTimeHttpCodeDataResponseBody> body{};

  DescribeDomainRealTimeHttpCodeDataResponse() {}

  explicit DescribeDomainRealTimeHttpCodeDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainRealTimeHttpCodeDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainRealTimeHttpCodeDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainRealTimeHttpCodeDataResponse() = default;
};
class DescribeDomainRealTimeQpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDomainRealTimeQpsDataRequest() {}

  explicit DescribeDomainRealTimeQpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainRealTimeQpsDataRequest() = default;
};
class DescribeDomainRealTimeQpsDataResponseBodyDataQpsModel : public Darabonba::Model {
public:
  shared_ptr<double> qps{};
  shared_ptr<string> timeStamp{};

  DescribeDomainRealTimeQpsDataResponseBodyDataQpsModel() {}

  explicit DescribeDomainRealTimeQpsDataResponseBodyDataQpsModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qps) {
      res["Qps"] = boost::any(*qps);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Qps") != m.end() && !m["Qps"].empty()) {
      qps = make_shared<double>(boost::any_cast<double>(m["Qps"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDomainRealTimeQpsDataResponseBodyDataQpsModel() = default;
};
class DescribeDomainRealTimeQpsDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainRealTimeQpsDataResponseBodyDataQpsModel>> qpsModel{};

  DescribeDomainRealTimeQpsDataResponseBodyData() {}

  explicit DescribeDomainRealTimeQpsDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qpsModel) {
      vector<boost::any> temp1;
      for(auto item1:*qpsModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QpsModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QpsModel") != m.end() && !m["QpsModel"].empty()) {
      if (typeid(vector<boost::any>) == m["QpsModel"].type()) {
        vector<DescribeDomainRealTimeQpsDataResponseBodyDataQpsModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QpsModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainRealTimeQpsDataResponseBodyDataQpsModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        qpsModel = make_shared<vector<DescribeDomainRealTimeQpsDataResponseBodyDataQpsModel>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainRealTimeQpsDataResponseBodyData() = default;
};
class DescribeDomainRealTimeQpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDomainRealTimeQpsDataResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribeDomainRealTimeQpsDataResponseBody() {}

  explicit DescribeDomainRealTimeQpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeDomainRealTimeQpsDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeDomainRealTimeQpsDataResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDomainRealTimeQpsDataResponseBody() = default;
};
class DescribeDomainRealTimeQpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainRealTimeQpsDataResponseBody> body{};

  DescribeDomainRealTimeQpsDataResponse() {}

  explicit DescribeDomainRealTimeQpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainRealTimeQpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainRealTimeQpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainRealTimeQpsDataResponse() = default;
};
class DescribeDomainRealTimeReqHitRateDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeDomainRealTimeReqHitRateDataRequest() {}

  explicit DescribeDomainRealTimeReqHitRateDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainRealTimeReqHitRateDataRequest() = default;
};
class DescribeDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel : public Darabonba::Model {
public:
  shared_ptr<double> reqHitRate{};
  shared_ptr<string> timeStamp{};

  DescribeDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel() {}

  explicit DescribeDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reqHitRate) {
      res["ReqHitRate"] = boost::any(*reqHitRate);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReqHitRate") != m.end() && !m["ReqHitRate"].empty()) {
      reqHitRate = make_shared<double>(boost::any_cast<double>(m["ReqHitRate"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel() = default;
};
class DescribeDomainRealTimeReqHitRateDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel>> reqHitRateDataModel{};

  DescribeDomainRealTimeReqHitRateDataResponseBodyData() {}

  explicit DescribeDomainRealTimeReqHitRateDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reqHitRateDataModel) {
      vector<boost::any> temp1;
      for(auto item1:*reqHitRateDataModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReqHitRateDataModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReqHitRateDataModel") != m.end() && !m["ReqHitRateDataModel"].empty()) {
      if (typeid(vector<boost::any>) == m["ReqHitRateDataModel"].type()) {
        vector<DescribeDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReqHitRateDataModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reqHitRateDataModel = make_shared<vector<DescribeDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainRealTimeReqHitRateDataResponseBodyData() = default;
};
class DescribeDomainRealTimeReqHitRateDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDomainRealTimeReqHitRateDataResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribeDomainRealTimeReqHitRateDataResponseBody() {}

  explicit DescribeDomainRealTimeReqHitRateDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeDomainRealTimeReqHitRateDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeDomainRealTimeReqHitRateDataResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDomainRealTimeReqHitRateDataResponseBody() = default;
};
class DescribeDomainRealTimeReqHitRateDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainRealTimeReqHitRateDataResponseBody> body{};

  DescribeDomainRealTimeReqHitRateDataResponse() {}

  explicit DescribeDomainRealTimeReqHitRateDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainRealTimeReqHitRateDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainRealTimeReqHitRateDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainRealTimeReqHitRateDataResponse() = default;
};
class DescribeDomainRealTimeSrcBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeDomainRealTimeSrcBpsDataRequest() {}

  explicit DescribeDomainRealTimeSrcBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainRealTimeSrcBpsDataRequest() = default;
};
class DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule() {}

  explicit DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule() = default;
};
class DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule>> dataModule{};

  DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval() {}

  explicit DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval() = default;
};
class DescribeDomainRealTimeSrcBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval> realTimeSrcBpsDataPerInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDomainRealTimeSrcBpsDataResponseBody() {}

  explicit DescribeDomainRealTimeSrcBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (realTimeSrcBpsDataPerInterval) {
      res["RealTimeSrcBpsDataPerInterval"] = realTimeSrcBpsDataPerInterval ? boost::any(realTimeSrcBpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RealTimeSrcBpsDataPerInterval") != m.end() && !m["RealTimeSrcBpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeSrcBpsDataPerInterval"].type()) {
        DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeSrcBpsDataPerInterval"]));
        realTimeSrcBpsDataPerInterval = make_shared<DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainRealTimeSrcBpsDataResponseBody() = default;
};
class DescribeDomainRealTimeSrcBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainRealTimeSrcBpsDataResponseBody> body{};

  DescribeDomainRealTimeSrcBpsDataResponse() {}

  explicit DescribeDomainRealTimeSrcBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainRealTimeSrcBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainRealTimeSrcBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainRealTimeSrcBpsDataResponse() = default;
};
class DescribeDomainRealTimeSrcHttpCodeDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDomainRealTimeSrcHttpCodeDataRequest() {}

  explicit DescribeDomainRealTimeSrcHttpCodeDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainRealTimeSrcHttpCodeDataRequest() = default;
};
class DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> count{};
  shared_ptr<string> proportion{};

  DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData() {}

  explicit DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (proportion) {
      res["Proportion"] = boost::any(*proportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("Proportion") != m.end() && !m["Proportion"].empty()) {
      proportion = make_shared<string>(boost::any_cast<string>(m["Proportion"]));
    }
  }


  virtual ~DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData() = default;
};
class DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData>> realTimeSrcCodeProportionData{};

  DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue() {}

  explicit DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (realTimeSrcCodeProportionData) {
      vector<boost::any> temp1;
      for(auto item1:*realTimeSrcCodeProportionData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RealTimeSrcCodeProportionData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RealTimeSrcCodeProportionData") != m.end() && !m["RealTimeSrcCodeProportionData"].empty()) {
      if (typeid(vector<boost::any>) == m["RealTimeSrcCodeProportionData"].type()) {
        vector<DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RealTimeSrcCodeProportionData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        realTimeSrcCodeProportionData = make_shared<vector<DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue() = default;
};
class DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue> value{};

  DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData() {}

  explicit DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = value ? boost::any(value->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(map<string, boost::any>) == m["Value"].type()) {
        DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Value"]));
        value = make_shared<DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue>(model1);
      }
    }
  }


  virtual ~DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData() = default;
};
class DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData>> usageData{};

  DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData() {}

  explicit DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usageData) {
      vector<boost::any> temp1;
      for(auto item1:*usageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsageData") != m.end() && !m["UsageData"].empty()) {
      if (typeid(vector<boost::any>) == m["UsageData"].type()) {
        vector<DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usageData = make_shared<vector<DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData() = default;
};
class DescribeDomainRealTimeSrcHttpCodeDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData> realTimeSrcHttpCodeData{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDomainRealTimeSrcHttpCodeDataResponseBody() {}

  explicit DescribeDomainRealTimeSrcHttpCodeDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (realTimeSrcHttpCodeData) {
      res["RealTimeSrcHttpCodeData"] = realTimeSrcHttpCodeData ? boost::any(realTimeSrcHttpCodeData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RealTimeSrcHttpCodeData") != m.end() && !m["RealTimeSrcHttpCodeData"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeSrcHttpCodeData"].type()) {
        DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeSrcHttpCodeData"]));
        realTimeSrcHttpCodeData = make_shared<DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainRealTimeSrcHttpCodeDataResponseBody() = default;
};
class DescribeDomainRealTimeSrcHttpCodeDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainRealTimeSrcHttpCodeDataResponseBody> body{};

  DescribeDomainRealTimeSrcHttpCodeDataResponse() {}

  explicit DescribeDomainRealTimeSrcHttpCodeDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainRealTimeSrcHttpCodeDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainRealTimeSrcHttpCodeDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainRealTimeSrcHttpCodeDataResponse() = default;
};
class DescribeDomainRealTimeSrcTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeDomainRealTimeSrcTrafficDataRequest() {}

  explicit DescribeDomainRealTimeSrcTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainRealTimeSrcTrafficDataRequest() = default;
};
class DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule() {}

  explicit DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule() = default;
};
class DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval() {}

  explicit DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval() = default;
};
class DescribeDomainRealTimeSrcTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval> realTimeSrcTrafficDataPerInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDomainRealTimeSrcTrafficDataResponseBody() {}

  explicit DescribeDomainRealTimeSrcTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (realTimeSrcTrafficDataPerInterval) {
      res["RealTimeSrcTrafficDataPerInterval"] = realTimeSrcTrafficDataPerInterval ? boost::any(realTimeSrcTrafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RealTimeSrcTrafficDataPerInterval") != m.end() && !m["RealTimeSrcTrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeSrcTrafficDataPerInterval"].type()) {
        DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeSrcTrafficDataPerInterval"]));
        realTimeSrcTrafficDataPerInterval = make_shared<DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainRealTimeSrcTrafficDataResponseBody() = default;
};
class DescribeDomainRealTimeSrcTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainRealTimeSrcTrafficDataResponseBody> body{};

  DescribeDomainRealTimeSrcTrafficDataResponse() {}

  explicit DescribeDomainRealTimeSrcTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainRealTimeSrcTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainRealTimeSrcTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainRealTimeSrcTrafficDataResponse() = default;
};
class DescribeDomainRealTimeTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDomainRealTimeTrafficDataRequest() {}

  explicit DescribeDomainRealTimeTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainRealTimeTrafficDataRequest() = default;
};
class DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule() {}

  explicit DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule() = default;
};
class DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval() {}

  explicit DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval() = default;
};
class DescribeDomainRealTimeTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval> realTimeTrafficDataPerInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDomainRealTimeTrafficDataResponseBody() {}

  explicit DescribeDomainRealTimeTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (realTimeTrafficDataPerInterval) {
      res["RealTimeTrafficDataPerInterval"] = realTimeTrafficDataPerInterval ? boost::any(realTimeTrafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RealTimeTrafficDataPerInterval") != m.end() && !m["RealTimeTrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeTrafficDataPerInterval"].type()) {
        DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeTrafficDataPerInterval"]));
        realTimeTrafficDataPerInterval = make_shared<DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainRealTimeTrafficDataResponseBody() = default;
};
class DescribeDomainRealTimeTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainRealTimeTrafficDataResponseBody> body{};

  DescribeDomainRealTimeTrafficDataResponse() {}

  explicit DescribeDomainRealTimeTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainRealTimeTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainRealTimeTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainRealTimeTrafficDataResponse() = default;
};
class DescribeDomainRealtimeLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};

  DescribeDomainRealtimeLogDeliveryRequest() {}

  explicit DescribeDomainRealtimeLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
  }


  virtual ~DescribeDomainRealtimeLogDeliveryRequest() = default;
};
class DescribeDomainRealtimeLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> logstore{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  DescribeDomainRealtimeLogDeliveryResponseBody() {}

  explicit DescribeDomainRealtimeLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDomainRealtimeLogDeliveryResponseBody() = default;
};
class DescribeDomainRealtimeLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainRealtimeLogDeliveryResponseBody> body{};

  DescribeDomainRealtimeLogDeliveryResponse() {}

  explicit DescribeDomainRealtimeLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainRealtimeLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainRealtimeLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainRealtimeLogDeliveryResponse() = default;
};
class DescribeDomainRegionDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeDomainRegionDataRequest() {}

  explicit DescribeDomainRegionDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainRegionDataRequest() = default;
};
class DescribeDomainRegionDataResponseBodyValueRegionProportionData : public Darabonba::Model {
public:
  shared_ptr<string> avgObjectSize{};
  shared_ptr<string> avgResponseRate{};
  shared_ptr<string> avgResponseTime{};
  shared_ptr<string> bps{};
  shared_ptr<string> bytesProportion{};
  shared_ptr<string> proportion{};
  shared_ptr<string> qps{};
  shared_ptr<string> region{};
  shared_ptr<string> regionEname{};
  shared_ptr<string> reqErrRate{};
  shared_ptr<string> totalBytes{};
  shared_ptr<string> totalQuery{};

  DescribeDomainRegionDataResponseBodyValueRegionProportionData() {}

  explicit DescribeDomainRegionDataResponseBodyValueRegionProportionData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgObjectSize) {
      res["AvgObjectSize"] = boost::any(*avgObjectSize);
    }
    if (avgResponseRate) {
      res["AvgResponseRate"] = boost::any(*avgResponseRate);
    }
    if (avgResponseTime) {
      res["AvgResponseTime"] = boost::any(*avgResponseTime);
    }
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (bytesProportion) {
      res["BytesProportion"] = boost::any(*bytesProportion);
    }
    if (proportion) {
      res["Proportion"] = boost::any(*proportion);
    }
    if (qps) {
      res["Qps"] = boost::any(*qps);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionEname) {
      res["RegionEname"] = boost::any(*regionEname);
    }
    if (reqErrRate) {
      res["ReqErrRate"] = boost::any(*reqErrRate);
    }
    if (totalBytes) {
      res["TotalBytes"] = boost::any(*totalBytes);
    }
    if (totalQuery) {
      res["TotalQuery"] = boost::any(*totalQuery);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgObjectSize") != m.end() && !m["AvgObjectSize"].empty()) {
      avgObjectSize = make_shared<string>(boost::any_cast<string>(m["AvgObjectSize"]));
    }
    if (m.find("AvgResponseRate") != m.end() && !m["AvgResponseRate"].empty()) {
      avgResponseRate = make_shared<string>(boost::any_cast<string>(m["AvgResponseRate"]));
    }
    if (m.find("AvgResponseTime") != m.end() && !m["AvgResponseTime"].empty()) {
      avgResponseTime = make_shared<string>(boost::any_cast<string>(m["AvgResponseTime"]));
    }
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<string>(boost::any_cast<string>(m["Bps"]));
    }
    if (m.find("BytesProportion") != m.end() && !m["BytesProportion"].empty()) {
      bytesProportion = make_shared<string>(boost::any_cast<string>(m["BytesProportion"]));
    }
    if (m.find("Proportion") != m.end() && !m["Proportion"].empty()) {
      proportion = make_shared<string>(boost::any_cast<string>(m["Proportion"]));
    }
    if (m.find("Qps") != m.end() && !m["Qps"].empty()) {
      qps = make_shared<string>(boost::any_cast<string>(m["Qps"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionEname") != m.end() && !m["RegionEname"].empty()) {
      regionEname = make_shared<string>(boost::any_cast<string>(m["RegionEname"]));
    }
    if (m.find("ReqErrRate") != m.end() && !m["ReqErrRate"].empty()) {
      reqErrRate = make_shared<string>(boost::any_cast<string>(m["ReqErrRate"]));
    }
    if (m.find("TotalBytes") != m.end() && !m["TotalBytes"].empty()) {
      totalBytes = make_shared<string>(boost::any_cast<string>(m["TotalBytes"]));
    }
    if (m.find("TotalQuery") != m.end() && !m["TotalQuery"].empty()) {
      totalQuery = make_shared<string>(boost::any_cast<string>(m["TotalQuery"]));
    }
  }


  virtual ~DescribeDomainRegionDataResponseBodyValueRegionProportionData() = default;
};
class DescribeDomainRegionDataResponseBodyValue : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainRegionDataResponseBodyValueRegionProportionData>> regionProportionData{};

  DescribeDomainRegionDataResponseBodyValue() {}

  explicit DescribeDomainRegionDataResponseBodyValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionProportionData) {
      vector<boost::any> temp1;
      for(auto item1:*regionProportionData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegionProportionData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionProportionData") != m.end() && !m["RegionProportionData"].empty()) {
      if (typeid(vector<boost::any>) == m["RegionProportionData"].type()) {
        vector<DescribeDomainRegionDataResponseBodyValueRegionProportionData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegionProportionData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainRegionDataResponseBodyValueRegionProportionData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regionProportionData = make_shared<vector<DescribeDomainRegionDataResponseBodyValueRegionProportionData>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainRegionDataResponseBodyValue() = default;
};
class DescribeDomainRegionDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeDomainRegionDataResponseBodyValue> value{};

  DescribeDomainRegionDataResponseBody() {}

  explicit DescribeDomainRegionDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (value) {
      res["Value"] = value ? boost::any(value->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(map<string, boost::any>) == m["Value"].type()) {
        DescribeDomainRegionDataResponseBodyValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Value"]));
        value = make_shared<DescribeDomainRegionDataResponseBodyValue>(model1);
      }
    }
  }


  virtual ~DescribeDomainRegionDataResponseBody() = default;
};
class DescribeDomainRegionDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainRegionDataResponseBody> body{};

  DescribeDomainRegionDataResponse() {}

  explicit DescribeDomainRegionDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainRegionDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainRegionDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainRegionDataResponse() = default;
};
class DescribeDomainReqHitRateDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> startTime{};

  DescribeDomainReqHitRateDataRequest() {}

  explicit DescribeDomainReqHitRateDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainReqHitRateDataRequest() = default;
};
class DescribeDomainReqHitRateDataResponseBodyReqHitRateIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> httpsValue{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDomainReqHitRateDataResponseBodyReqHitRateIntervalDataModule() {}

  explicit DescribeDomainReqHitRateDataResponseBodyReqHitRateIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpsValue) {
      res["HttpsValue"] = boost::any(*httpsValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpsValue") != m.end() && !m["HttpsValue"].empty()) {
      httpsValue = make_shared<string>(boost::any_cast<string>(m["HttpsValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainReqHitRateDataResponseBodyReqHitRateIntervalDataModule() = default;
};
class DescribeDomainReqHitRateDataResponseBodyReqHitRateInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainReqHitRateDataResponseBodyReqHitRateIntervalDataModule>> dataModule{};

  DescribeDomainReqHitRateDataResponseBodyReqHitRateInterval() {}

  explicit DescribeDomainReqHitRateDataResponseBodyReqHitRateInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDomainReqHitRateDataResponseBodyReqHitRateIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainReqHitRateDataResponseBodyReqHitRateIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDomainReqHitRateDataResponseBodyReqHitRateIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainReqHitRateDataResponseBodyReqHitRateInterval() = default;
};
class DescribeDomainReqHitRateDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeDomainReqHitRateDataResponseBodyReqHitRateInterval> reqHitRateInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDomainReqHitRateDataResponseBody() {}

  explicit DescribeDomainReqHitRateDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (reqHitRateInterval) {
      res["ReqHitRateInterval"] = reqHitRateInterval ? boost::any(reqHitRateInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ReqHitRateInterval") != m.end() && !m["ReqHitRateInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReqHitRateInterval"].type()) {
        DescribeDomainReqHitRateDataResponseBodyReqHitRateInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReqHitRateInterval"]));
        reqHitRateInterval = make_shared<DescribeDomainReqHitRateDataResponseBodyReqHitRateInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainReqHitRateDataResponseBody() = default;
};
class DescribeDomainReqHitRateDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainReqHitRateDataResponseBody> body{};

  DescribeDomainReqHitRateDataResponse() {}

  explicit DescribeDomainReqHitRateDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainReqHitRateDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainReqHitRateDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainReqHitRateDataResponse() = default;
};
class DescribeDomainSrcBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> startTime{};

  DescribeDomainSrcBpsDataRequest() {}

  explicit DescribeDomainSrcBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainSrcBpsDataRequest() = default;
};
class DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> httpsValue{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule() {}

  explicit DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpsValue) {
      res["HttpsValue"] = boost::any(*httpsValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpsValue") != m.end() && !m["HttpsValue"].empty()) {
      httpsValue = make_shared<string>(boost::any_cast<string>(m["HttpsValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule() = default;
};
class DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule>> dataModule{};

  DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerInterval() {}

  explicit DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerInterval() = default;
};
class DescribeDomainSrcBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerInterval> srcBpsDataPerInterval{};
  shared_ptr<string> startTime{};

  DescribeDomainSrcBpsDataResponseBody() {}

  explicit DescribeDomainSrcBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (srcBpsDataPerInterval) {
      res["SrcBpsDataPerInterval"] = srcBpsDataPerInterval ? boost::any(srcBpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SrcBpsDataPerInterval") != m.end() && !m["SrcBpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["SrcBpsDataPerInterval"].type()) {
        DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SrcBpsDataPerInterval"]));
        srcBpsDataPerInterval = make_shared<DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerInterval>(model1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainSrcBpsDataResponseBody() = default;
};
class DescribeDomainSrcBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainSrcBpsDataResponseBody> body{};

  DescribeDomainSrcBpsDataResponse() {}

  explicit DescribeDomainSrcBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainSrcBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainSrcBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainSrcBpsDataResponse() = default;
};
class DescribeDomainSrcHttpCodeDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> startTime{};

  DescribeDomainSrcHttpCodeDataRequest() {}

  explicit DescribeDomainSrcHttpCodeDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainSrcHttpCodeDataRequest() = default;
};
class DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> count{};
  shared_ptr<string> proportion{};

  DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData() {}

  explicit DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (proportion) {
      res["Proportion"] = boost::any(*proportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("Proportion") != m.end() && !m["Proportion"].empty()) {
      proportion = make_shared<string>(boost::any_cast<string>(m["Proportion"]));
    }
  }


  virtual ~DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData() = default;
};
class DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValue : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData>> codeProportionData{};

  DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValue() {}

  explicit DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeProportionData) {
      vector<boost::any> temp1;
      for(auto item1:*codeProportionData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CodeProportionData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodeProportionData") != m.end() && !m["CodeProportionData"].empty()) {
      if (typeid(vector<boost::any>) == m["CodeProportionData"].type()) {
        vector<DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CodeProportionData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        codeProportionData = make_shared<vector<DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValue() = default;
};
class DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageData : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValue> value{};

  DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageData() {}

  explicit DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = value ? boost::any(value->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(map<string, boost::any>) == m["Value"].type()) {
        DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Value"]));
        value = make_shared<DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValue>(model1);
      }
    }
  }


  virtual ~DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageData() = default;
};
class DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageData>> usageData{};

  DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeData() {}

  explicit DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usageData) {
      vector<boost::any> temp1;
      for(auto item1:*usageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsageData") != m.end() && !m["UsageData"].empty()) {
      if (typeid(vector<boost::any>) == m["UsageData"].type()) {
        vector<DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usageData = make_shared<vector<DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageData>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeData() = default;
};
class DescribeDomainSrcHttpCodeDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeData> httpCodeData{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDomainSrcHttpCodeDataResponseBody() {}

  explicit DescribeDomainSrcHttpCodeDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (httpCodeData) {
      res["HttpCodeData"] = httpCodeData ? boost::any(httpCodeData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("HttpCodeData") != m.end() && !m["HttpCodeData"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpCodeData"].type()) {
        DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpCodeData"]));
        httpCodeData = make_shared<DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainSrcHttpCodeDataResponseBody() = default;
};
class DescribeDomainSrcHttpCodeDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainSrcHttpCodeDataResponseBody> body{};

  DescribeDomainSrcHttpCodeDataResponse() {}

  explicit DescribeDomainSrcHttpCodeDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainSrcHttpCodeDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainSrcHttpCodeDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainSrcHttpCodeDataResponse() = default;
};
class DescribeDomainSrcQpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> startTime{};

  DescribeDomainSrcQpsDataRequest() {}

  explicit DescribeDomainSrcQpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainSrcQpsDataRequest() = default;
};
class DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerIntervalDataModule() {}

  explicit DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerIntervalDataModule() = default;
};
class DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerIntervalDataModule>> dataModule{};

  DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerInterval() {}

  explicit DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerInterval() = default;
};
class DescribeDomainSrcQpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerInterval> srcQpsDataPerInterval{};
  shared_ptr<string> startTime{};

  DescribeDomainSrcQpsDataResponseBody() {}

  explicit DescribeDomainSrcQpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (srcQpsDataPerInterval) {
      res["SrcQpsDataPerInterval"] = srcQpsDataPerInterval ? boost::any(srcQpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SrcQpsDataPerInterval") != m.end() && !m["SrcQpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["SrcQpsDataPerInterval"].type()) {
        DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SrcQpsDataPerInterval"]));
        srcQpsDataPerInterval = make_shared<DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerInterval>(model1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainSrcQpsDataResponseBody() = default;
};
class DescribeDomainSrcQpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainSrcQpsDataResponseBody> body{};

  DescribeDomainSrcQpsDataResponse() {}

  explicit DescribeDomainSrcQpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainSrcQpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainSrcQpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainSrcQpsDataResponse() = default;
};
class DescribeDomainSrcTopUrlVisitRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};

  DescribeDomainSrcTopUrlVisitRequest() {}

  explicit DescribeDomainSrcTopUrlVisitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainSrcTopUrlVisitRequest() = default;
};
class DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<double> flowProportion{};
  shared_ptr<string> urlDetail{};
  shared_ptr<string> visitData{};
  shared_ptr<double> visitProportion{};

  DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList() {}

  explicit DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (flowProportion) {
      res["FlowProportion"] = boost::any(*flowProportion);
    }
    if (urlDetail) {
      res["UrlDetail"] = boost::any(*urlDetail);
    }
    if (visitData) {
      res["VisitData"] = boost::any(*visitData);
    }
    if (visitProportion) {
      res["VisitProportion"] = boost::any(*visitProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("FlowProportion") != m.end() && !m["FlowProportion"].empty()) {
      flowProportion = make_shared<double>(boost::any_cast<double>(m["FlowProportion"]));
    }
    if (m.find("UrlDetail") != m.end() && !m["UrlDetail"].empty()) {
      urlDetail = make_shared<string>(boost::any_cast<string>(m["UrlDetail"]));
    }
    if (m.find("VisitData") != m.end() && !m["VisitData"].empty()) {
      visitData = make_shared<string>(boost::any_cast<string>(m["VisitData"]));
    }
    if (m.find("VisitProportion") != m.end() && !m["VisitProportion"].empty()) {
      visitProportion = make_shared<double>(boost::any_cast<double>(m["VisitProportion"]));
    }
  }


  virtual ~DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList() = default;
};
class DescribeDomainSrcTopUrlVisitResponseBodyAllUrlList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList>> urlList{};

  DescribeDomainSrcTopUrlVisitResponseBodyAllUrlList() {}

  explicit DescribeDomainSrcTopUrlVisitResponseBodyAllUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (urlList) {
      vector<boost::any> temp1;
      for(auto item1:*urlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UrlList") != m.end() && !m["UrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlList"].type()) {
        vector<DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlList = make_shared<vector<DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainSrcTopUrlVisitResponseBodyAllUrlList() = default;
};
class DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<double> flowProportion{};
  shared_ptr<string> urlDetail{};
  shared_ptr<string> visitData{};
  shared_ptr<double> visitProportion{};

  DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList() {}

  explicit DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (flowProportion) {
      res["FlowProportion"] = boost::any(*flowProportion);
    }
    if (urlDetail) {
      res["UrlDetail"] = boost::any(*urlDetail);
    }
    if (visitData) {
      res["VisitData"] = boost::any(*visitData);
    }
    if (visitProportion) {
      res["VisitProportion"] = boost::any(*visitProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("FlowProportion") != m.end() && !m["FlowProportion"].empty()) {
      flowProportion = make_shared<double>(boost::any_cast<double>(m["FlowProportion"]));
    }
    if (m.find("UrlDetail") != m.end() && !m["UrlDetail"].empty()) {
      urlDetail = make_shared<string>(boost::any_cast<string>(m["UrlDetail"]));
    }
    if (m.find("VisitData") != m.end() && !m["VisitData"].empty()) {
      visitData = make_shared<string>(boost::any_cast<string>(m["VisitData"]));
    }
    if (m.find("VisitProportion") != m.end() && !m["VisitProportion"].empty()) {
      visitProportion = make_shared<double>(boost::any_cast<double>(m["VisitProportion"]));
    }
  }


  virtual ~DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList() = default;
};
class DescribeDomainSrcTopUrlVisitResponseBodyUrl200List : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList>> urlList{};

  DescribeDomainSrcTopUrlVisitResponseBodyUrl200List() {}

  explicit DescribeDomainSrcTopUrlVisitResponseBodyUrl200List(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (urlList) {
      vector<boost::any> temp1;
      for(auto item1:*urlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UrlList") != m.end() && !m["UrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlList"].type()) {
        vector<DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlList = make_shared<vector<DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainSrcTopUrlVisitResponseBodyUrl200List() = default;
};
class DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<double> flowProportion{};
  shared_ptr<string> urlDetail{};
  shared_ptr<string> visitData{};
  shared_ptr<double> visitProportion{};

  DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList() {}

  explicit DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (flowProportion) {
      res["FlowProportion"] = boost::any(*flowProportion);
    }
    if (urlDetail) {
      res["UrlDetail"] = boost::any(*urlDetail);
    }
    if (visitData) {
      res["VisitData"] = boost::any(*visitData);
    }
    if (visitProportion) {
      res["VisitProportion"] = boost::any(*visitProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("FlowProportion") != m.end() && !m["FlowProportion"].empty()) {
      flowProportion = make_shared<double>(boost::any_cast<double>(m["FlowProportion"]));
    }
    if (m.find("UrlDetail") != m.end() && !m["UrlDetail"].empty()) {
      urlDetail = make_shared<string>(boost::any_cast<string>(m["UrlDetail"]));
    }
    if (m.find("VisitData") != m.end() && !m["VisitData"].empty()) {
      visitData = make_shared<string>(boost::any_cast<string>(m["VisitData"]));
    }
    if (m.find("VisitProportion") != m.end() && !m["VisitProportion"].empty()) {
      visitProportion = make_shared<double>(boost::any_cast<double>(m["VisitProportion"]));
    }
  }


  virtual ~DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList() = default;
};
class DescribeDomainSrcTopUrlVisitResponseBodyUrl300List : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList>> urlList{};

  DescribeDomainSrcTopUrlVisitResponseBodyUrl300List() {}

  explicit DescribeDomainSrcTopUrlVisitResponseBodyUrl300List(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (urlList) {
      vector<boost::any> temp1;
      for(auto item1:*urlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UrlList") != m.end() && !m["UrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlList"].type()) {
        vector<DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlList = make_shared<vector<DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainSrcTopUrlVisitResponseBodyUrl300List() = default;
};
class DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<double> flowProportion{};
  shared_ptr<string> urlDetail{};
  shared_ptr<string> visitData{};
  shared_ptr<double> visitProportion{};

  DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList() {}

  explicit DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (flowProportion) {
      res["FlowProportion"] = boost::any(*flowProportion);
    }
    if (urlDetail) {
      res["UrlDetail"] = boost::any(*urlDetail);
    }
    if (visitData) {
      res["VisitData"] = boost::any(*visitData);
    }
    if (visitProportion) {
      res["VisitProportion"] = boost::any(*visitProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("FlowProportion") != m.end() && !m["FlowProportion"].empty()) {
      flowProportion = make_shared<double>(boost::any_cast<double>(m["FlowProportion"]));
    }
    if (m.find("UrlDetail") != m.end() && !m["UrlDetail"].empty()) {
      urlDetail = make_shared<string>(boost::any_cast<string>(m["UrlDetail"]));
    }
    if (m.find("VisitData") != m.end() && !m["VisitData"].empty()) {
      visitData = make_shared<string>(boost::any_cast<string>(m["VisitData"]));
    }
    if (m.find("VisitProportion") != m.end() && !m["VisitProportion"].empty()) {
      visitProportion = make_shared<double>(boost::any_cast<double>(m["VisitProportion"]));
    }
  }


  virtual ~DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList() = default;
};
class DescribeDomainSrcTopUrlVisitResponseBodyUrl400List : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList>> urlList{};

  DescribeDomainSrcTopUrlVisitResponseBodyUrl400List() {}

  explicit DescribeDomainSrcTopUrlVisitResponseBodyUrl400List(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (urlList) {
      vector<boost::any> temp1;
      for(auto item1:*urlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UrlList") != m.end() && !m["UrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlList"].type()) {
        vector<DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlList = make_shared<vector<DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainSrcTopUrlVisitResponseBodyUrl400List() = default;
};
class DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<double> flowProportion{};
  shared_ptr<string> urlDetail{};
  shared_ptr<string> visitData{};
  shared_ptr<double> visitProportion{};

  DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList() {}

  explicit DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (flowProportion) {
      res["FlowProportion"] = boost::any(*flowProportion);
    }
    if (urlDetail) {
      res["UrlDetail"] = boost::any(*urlDetail);
    }
    if (visitData) {
      res["VisitData"] = boost::any(*visitData);
    }
    if (visitProportion) {
      res["VisitProportion"] = boost::any(*visitProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("FlowProportion") != m.end() && !m["FlowProportion"].empty()) {
      flowProportion = make_shared<double>(boost::any_cast<double>(m["FlowProportion"]));
    }
    if (m.find("UrlDetail") != m.end() && !m["UrlDetail"].empty()) {
      urlDetail = make_shared<string>(boost::any_cast<string>(m["UrlDetail"]));
    }
    if (m.find("VisitData") != m.end() && !m["VisitData"].empty()) {
      visitData = make_shared<string>(boost::any_cast<string>(m["VisitData"]));
    }
    if (m.find("VisitProportion") != m.end() && !m["VisitProportion"].empty()) {
      visitProportion = make_shared<double>(boost::any_cast<double>(m["VisitProportion"]));
    }
  }


  virtual ~DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList() = default;
};
class DescribeDomainSrcTopUrlVisitResponseBodyUrl500List : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList>> urlList{};

  DescribeDomainSrcTopUrlVisitResponseBodyUrl500List() {}

  explicit DescribeDomainSrcTopUrlVisitResponseBodyUrl500List(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (urlList) {
      vector<boost::any> temp1;
      for(auto item1:*urlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UrlList") != m.end() && !m["UrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlList"].type()) {
        vector<DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlList = make_shared<vector<DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainSrcTopUrlVisitResponseBodyUrl500List() = default;
};
class DescribeDomainSrcTopUrlVisitResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDomainSrcTopUrlVisitResponseBodyAllUrlList> allUrlList{};
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeDomainSrcTopUrlVisitResponseBodyUrl200List> url200List{};
  shared_ptr<DescribeDomainSrcTopUrlVisitResponseBodyUrl300List> url300List{};
  shared_ptr<DescribeDomainSrcTopUrlVisitResponseBodyUrl400List> url400List{};
  shared_ptr<DescribeDomainSrcTopUrlVisitResponseBodyUrl500List> url500List{};

  DescribeDomainSrcTopUrlVisitResponseBody() {}

  explicit DescribeDomainSrcTopUrlVisitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allUrlList) {
      res["AllUrlList"] = allUrlList ? boost::any(allUrlList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (url200List) {
      res["Url200List"] = url200List ? boost::any(url200List->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (url300List) {
      res["Url300List"] = url300List ? boost::any(url300List->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (url400List) {
      res["Url400List"] = url400List ? boost::any(url400List->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (url500List) {
      res["Url500List"] = url500List ? boost::any(url500List->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllUrlList") != m.end() && !m["AllUrlList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AllUrlList"].type()) {
        DescribeDomainSrcTopUrlVisitResponseBodyAllUrlList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AllUrlList"]));
        allUrlList = make_shared<DescribeDomainSrcTopUrlVisitResponseBodyAllUrlList>(model1);
      }
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Url200List") != m.end() && !m["Url200List"].empty()) {
      if (typeid(map<string, boost::any>) == m["Url200List"].type()) {
        DescribeDomainSrcTopUrlVisitResponseBodyUrl200List model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Url200List"]));
        url200List = make_shared<DescribeDomainSrcTopUrlVisitResponseBodyUrl200List>(model1);
      }
    }
    if (m.find("Url300List") != m.end() && !m["Url300List"].empty()) {
      if (typeid(map<string, boost::any>) == m["Url300List"].type()) {
        DescribeDomainSrcTopUrlVisitResponseBodyUrl300List model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Url300List"]));
        url300List = make_shared<DescribeDomainSrcTopUrlVisitResponseBodyUrl300List>(model1);
      }
    }
    if (m.find("Url400List") != m.end() && !m["Url400List"].empty()) {
      if (typeid(map<string, boost::any>) == m["Url400List"].type()) {
        DescribeDomainSrcTopUrlVisitResponseBodyUrl400List model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Url400List"]));
        url400List = make_shared<DescribeDomainSrcTopUrlVisitResponseBodyUrl400List>(model1);
      }
    }
    if (m.find("Url500List") != m.end() && !m["Url500List"].empty()) {
      if (typeid(map<string, boost::any>) == m["Url500List"].type()) {
        DescribeDomainSrcTopUrlVisitResponseBodyUrl500List model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Url500List"]));
        url500List = make_shared<DescribeDomainSrcTopUrlVisitResponseBodyUrl500List>(model1);
      }
    }
  }


  virtual ~DescribeDomainSrcTopUrlVisitResponseBody() = default;
};
class DescribeDomainSrcTopUrlVisitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainSrcTopUrlVisitResponseBody> body{};

  DescribeDomainSrcTopUrlVisitResponse() {}

  explicit DescribeDomainSrcTopUrlVisitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainSrcTopUrlVisitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainSrcTopUrlVisitResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainSrcTopUrlVisitResponse() = default;
};
class DescribeDomainSrcTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> startTime{};

  DescribeDomainSrcTrafficDataRequest() {}

  explicit DescribeDomainSrcTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainSrcTrafficDataRequest() = default;
};
class DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> httpsValue{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule() {}

  explicit DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpsValue) {
      res["HttpsValue"] = boost::any(*httpsValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpsValue") != m.end() && !m["HttpsValue"].empty()) {
      httpsValue = make_shared<string>(boost::any_cast<string>(m["HttpsValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule() = default;
};
class DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval() {}

  explicit DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval() = default;
};
class DescribeDomainSrcTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval> srcTrafficDataPerInterval{};
  shared_ptr<string> startTime{};

  DescribeDomainSrcTrafficDataResponseBody() {}

  explicit DescribeDomainSrcTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (srcTrafficDataPerInterval) {
      res["SrcTrafficDataPerInterval"] = srcTrafficDataPerInterval ? boost::any(srcTrafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SrcTrafficDataPerInterval") != m.end() && !m["SrcTrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["SrcTrafficDataPerInterval"].type()) {
        DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SrcTrafficDataPerInterval"]));
        srcTrafficDataPerInterval = make_shared<DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval>(model1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainSrcTrafficDataResponseBody() = default;
};
class DescribeDomainSrcTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainSrcTrafficDataResponseBody> body{};

  DescribeDomainSrcTrafficDataResponse() {}

  explicit DescribeDomainSrcTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainSrcTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainSrcTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainSrcTrafficDataResponse() = default;
};
class DescribeDomainTopClientIpVisitRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> limit{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};

  DescribeDomainTopClientIpVisitRequest() {}

  explicit DescribeDomainTopClientIpVisitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<string>(boost::any_cast<string>(m["Limit"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainTopClientIpVisitRequest() = default;
};
class DescribeDomainTopClientIpVisitResponseBodyClientIpList : public Darabonba::Model {
public:
  shared_ptr<long> acc{};
  shared_ptr<string> clientIp{};
  shared_ptr<long> rank{};
  shared_ptr<long> traffic{};

  DescribeDomainTopClientIpVisitResponseBodyClientIpList() {}

  explicit DescribeDomainTopClientIpVisitResponseBodyClientIpList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acc) {
      res["Acc"] = boost::any(*acc);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (rank) {
      res["Rank"] = boost::any(*rank);
    }
    if (traffic) {
      res["Traffic"] = boost::any(*traffic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Acc") != m.end() && !m["Acc"].empty()) {
      acc = make_shared<long>(boost::any_cast<long>(m["Acc"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("Rank") != m.end() && !m["Rank"].empty()) {
      rank = make_shared<long>(boost::any_cast<long>(m["Rank"]));
    }
    if (m.find("Traffic") != m.end() && !m["Traffic"].empty()) {
      traffic = make_shared<long>(boost::any_cast<long>(m["Traffic"]));
    }
  }


  virtual ~DescribeDomainTopClientIpVisitResponseBodyClientIpList() = default;
};
class DescribeDomainTopClientIpVisitResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainTopClientIpVisitResponseBodyClientIpList>> clientIpList{};
  shared_ptr<string> requestId{};

  DescribeDomainTopClientIpVisitResponseBody() {}

  explicit DescribeDomainTopClientIpVisitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientIpList) {
      vector<boost::any> temp1;
      for(auto item1:*clientIpList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClientIpList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientIpList") != m.end() && !m["ClientIpList"].empty()) {
      if (typeid(vector<boost::any>) == m["ClientIpList"].type()) {
        vector<DescribeDomainTopClientIpVisitResponseBodyClientIpList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClientIpList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainTopClientIpVisitResponseBodyClientIpList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clientIpList = make_shared<vector<DescribeDomainTopClientIpVisitResponseBodyClientIpList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDomainTopClientIpVisitResponseBody() = default;
};
class DescribeDomainTopClientIpVisitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainTopClientIpVisitResponseBody> body{};

  DescribeDomainTopClientIpVisitResponse() {}

  explicit DescribeDomainTopClientIpVisitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainTopClientIpVisitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainTopClientIpVisitResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainTopClientIpVisitResponse() = default;
};
class DescribeDomainTopReferVisitRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};

  DescribeDomainTopReferVisitRequest() {}

  explicit DescribeDomainTopReferVisitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainTopReferVisitRequest() = default;
};
class DescribeDomainTopReferVisitResponseBodyTopReferListReferList : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<double> flowProportion{};
  shared_ptr<string> referDetail{};
  shared_ptr<string> visitData{};
  shared_ptr<double> visitProportion{};

  DescribeDomainTopReferVisitResponseBodyTopReferListReferList() {}

  explicit DescribeDomainTopReferVisitResponseBodyTopReferListReferList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (flowProportion) {
      res["FlowProportion"] = boost::any(*flowProportion);
    }
    if (referDetail) {
      res["ReferDetail"] = boost::any(*referDetail);
    }
    if (visitData) {
      res["VisitData"] = boost::any(*visitData);
    }
    if (visitProportion) {
      res["VisitProportion"] = boost::any(*visitProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("FlowProportion") != m.end() && !m["FlowProportion"].empty()) {
      flowProportion = make_shared<double>(boost::any_cast<double>(m["FlowProportion"]));
    }
    if (m.find("ReferDetail") != m.end() && !m["ReferDetail"].empty()) {
      referDetail = make_shared<string>(boost::any_cast<string>(m["ReferDetail"]));
    }
    if (m.find("VisitData") != m.end() && !m["VisitData"].empty()) {
      visitData = make_shared<string>(boost::any_cast<string>(m["VisitData"]));
    }
    if (m.find("VisitProportion") != m.end() && !m["VisitProportion"].empty()) {
      visitProportion = make_shared<double>(boost::any_cast<double>(m["VisitProportion"]));
    }
  }


  virtual ~DescribeDomainTopReferVisitResponseBodyTopReferListReferList() = default;
};
class DescribeDomainTopReferVisitResponseBodyTopReferList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainTopReferVisitResponseBodyTopReferListReferList>> referList{};

  DescribeDomainTopReferVisitResponseBodyTopReferList() {}

  explicit DescribeDomainTopReferVisitResponseBodyTopReferList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referList) {
      vector<boost::any> temp1;
      for(auto item1:*referList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReferList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferList") != m.end() && !m["ReferList"].empty()) {
      if (typeid(vector<boost::any>) == m["ReferList"].type()) {
        vector<DescribeDomainTopReferVisitResponseBodyTopReferListReferList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReferList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainTopReferVisitResponseBodyTopReferListReferList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        referList = make_shared<vector<DescribeDomainTopReferVisitResponseBodyTopReferListReferList>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainTopReferVisitResponseBodyTopReferList() = default;
};
class DescribeDomainTopReferVisitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeDomainTopReferVisitResponseBodyTopReferList> topReferList{};

  DescribeDomainTopReferVisitResponseBody() {}

  explicit DescribeDomainTopReferVisitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (topReferList) {
      res["TopReferList"] = topReferList ? boost::any(topReferList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TopReferList") != m.end() && !m["TopReferList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TopReferList"].type()) {
        DescribeDomainTopReferVisitResponseBodyTopReferList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TopReferList"]));
        topReferList = make_shared<DescribeDomainTopReferVisitResponseBodyTopReferList>(model1);
      }
    }
  }


  virtual ~DescribeDomainTopReferVisitResponseBody() = default;
};
class DescribeDomainTopReferVisitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainTopReferVisitResponseBody> body{};

  DescribeDomainTopReferVisitResponse() {}

  explicit DescribeDomainTopReferVisitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainTopReferVisitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainTopReferVisitResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainTopReferVisitResponse() = default;
};
class DescribeDomainTopUrlVisitRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};

  DescribeDomainTopUrlVisitRequest() {}

  explicit DescribeDomainTopUrlVisitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainTopUrlVisitRequest() = default;
};
class DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<double> flowProportion{};
  shared_ptr<string> urlDetail{};
  shared_ptr<string> visitData{};
  shared_ptr<double> visitProportion{};

  DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList() {}

  explicit DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (flowProportion) {
      res["FlowProportion"] = boost::any(*flowProportion);
    }
    if (urlDetail) {
      res["UrlDetail"] = boost::any(*urlDetail);
    }
    if (visitData) {
      res["VisitData"] = boost::any(*visitData);
    }
    if (visitProportion) {
      res["VisitProportion"] = boost::any(*visitProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("FlowProportion") != m.end() && !m["FlowProportion"].empty()) {
      flowProportion = make_shared<double>(boost::any_cast<double>(m["FlowProportion"]));
    }
    if (m.find("UrlDetail") != m.end() && !m["UrlDetail"].empty()) {
      urlDetail = make_shared<string>(boost::any_cast<string>(m["UrlDetail"]));
    }
    if (m.find("VisitData") != m.end() && !m["VisitData"].empty()) {
      visitData = make_shared<string>(boost::any_cast<string>(m["VisitData"]));
    }
    if (m.find("VisitProportion") != m.end() && !m["VisitProportion"].empty()) {
      visitProportion = make_shared<double>(boost::any_cast<double>(m["VisitProportion"]));
    }
  }


  virtual ~DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList() = default;
};
class DescribeDomainTopUrlVisitResponseBodyAllUrlList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList>> urlList{};

  DescribeDomainTopUrlVisitResponseBodyAllUrlList() {}

  explicit DescribeDomainTopUrlVisitResponseBodyAllUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (urlList) {
      vector<boost::any> temp1;
      for(auto item1:*urlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UrlList") != m.end() && !m["UrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlList"].type()) {
        vector<DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlList = make_shared<vector<DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainTopUrlVisitResponseBodyAllUrlList() = default;
};
class DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<double> flowProportion{};
  shared_ptr<string> urlDetail{};
  shared_ptr<string> visitData{};
  shared_ptr<double> visitProportion{};

  DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList() {}

  explicit DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (flowProportion) {
      res["FlowProportion"] = boost::any(*flowProportion);
    }
    if (urlDetail) {
      res["UrlDetail"] = boost::any(*urlDetail);
    }
    if (visitData) {
      res["VisitData"] = boost::any(*visitData);
    }
    if (visitProportion) {
      res["VisitProportion"] = boost::any(*visitProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("FlowProportion") != m.end() && !m["FlowProportion"].empty()) {
      flowProportion = make_shared<double>(boost::any_cast<double>(m["FlowProportion"]));
    }
    if (m.find("UrlDetail") != m.end() && !m["UrlDetail"].empty()) {
      urlDetail = make_shared<string>(boost::any_cast<string>(m["UrlDetail"]));
    }
    if (m.find("VisitData") != m.end() && !m["VisitData"].empty()) {
      visitData = make_shared<string>(boost::any_cast<string>(m["VisitData"]));
    }
    if (m.find("VisitProportion") != m.end() && !m["VisitProportion"].empty()) {
      visitProportion = make_shared<double>(boost::any_cast<double>(m["VisitProportion"]));
    }
  }


  virtual ~DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList() = default;
};
class DescribeDomainTopUrlVisitResponseBodyUrl200List : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList>> urlList{};

  DescribeDomainTopUrlVisitResponseBodyUrl200List() {}

  explicit DescribeDomainTopUrlVisitResponseBodyUrl200List(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (urlList) {
      vector<boost::any> temp1;
      for(auto item1:*urlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UrlList") != m.end() && !m["UrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlList"].type()) {
        vector<DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlList = make_shared<vector<DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainTopUrlVisitResponseBodyUrl200List() = default;
};
class DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<double> flowProportion{};
  shared_ptr<string> urlDetail{};
  shared_ptr<string> visitData{};
  shared_ptr<double> visitProportion{};

  DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList() {}

  explicit DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (flowProportion) {
      res["FlowProportion"] = boost::any(*flowProportion);
    }
    if (urlDetail) {
      res["UrlDetail"] = boost::any(*urlDetail);
    }
    if (visitData) {
      res["VisitData"] = boost::any(*visitData);
    }
    if (visitProportion) {
      res["VisitProportion"] = boost::any(*visitProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("FlowProportion") != m.end() && !m["FlowProportion"].empty()) {
      flowProportion = make_shared<double>(boost::any_cast<double>(m["FlowProportion"]));
    }
    if (m.find("UrlDetail") != m.end() && !m["UrlDetail"].empty()) {
      urlDetail = make_shared<string>(boost::any_cast<string>(m["UrlDetail"]));
    }
    if (m.find("VisitData") != m.end() && !m["VisitData"].empty()) {
      visitData = make_shared<string>(boost::any_cast<string>(m["VisitData"]));
    }
    if (m.find("VisitProportion") != m.end() && !m["VisitProportion"].empty()) {
      visitProportion = make_shared<double>(boost::any_cast<double>(m["VisitProportion"]));
    }
  }


  virtual ~DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList() = default;
};
class DescribeDomainTopUrlVisitResponseBodyUrl300List : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList>> urlList{};

  DescribeDomainTopUrlVisitResponseBodyUrl300List() {}

  explicit DescribeDomainTopUrlVisitResponseBodyUrl300List(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (urlList) {
      vector<boost::any> temp1;
      for(auto item1:*urlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UrlList") != m.end() && !m["UrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlList"].type()) {
        vector<DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlList = make_shared<vector<DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainTopUrlVisitResponseBodyUrl300List() = default;
};
class DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<double> flowProportion{};
  shared_ptr<string> urlDetail{};
  shared_ptr<string> visitData{};
  shared_ptr<double> visitProportion{};

  DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList() {}

  explicit DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (flowProportion) {
      res["FlowProportion"] = boost::any(*flowProportion);
    }
    if (urlDetail) {
      res["UrlDetail"] = boost::any(*urlDetail);
    }
    if (visitData) {
      res["VisitData"] = boost::any(*visitData);
    }
    if (visitProportion) {
      res["VisitProportion"] = boost::any(*visitProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("FlowProportion") != m.end() && !m["FlowProportion"].empty()) {
      flowProportion = make_shared<double>(boost::any_cast<double>(m["FlowProportion"]));
    }
    if (m.find("UrlDetail") != m.end() && !m["UrlDetail"].empty()) {
      urlDetail = make_shared<string>(boost::any_cast<string>(m["UrlDetail"]));
    }
    if (m.find("VisitData") != m.end() && !m["VisitData"].empty()) {
      visitData = make_shared<string>(boost::any_cast<string>(m["VisitData"]));
    }
    if (m.find("VisitProportion") != m.end() && !m["VisitProportion"].empty()) {
      visitProportion = make_shared<double>(boost::any_cast<double>(m["VisitProportion"]));
    }
  }


  virtual ~DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList() = default;
};
class DescribeDomainTopUrlVisitResponseBodyUrl400List : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList>> urlList{};

  DescribeDomainTopUrlVisitResponseBodyUrl400List() {}

  explicit DescribeDomainTopUrlVisitResponseBodyUrl400List(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (urlList) {
      vector<boost::any> temp1;
      for(auto item1:*urlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UrlList") != m.end() && !m["UrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlList"].type()) {
        vector<DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlList = make_shared<vector<DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainTopUrlVisitResponseBodyUrl400List() = default;
};
class DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<double> flowProportion{};
  shared_ptr<string> urlDetail{};
  shared_ptr<string> visitData{};
  shared_ptr<double> visitProportion{};

  DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList() {}

  explicit DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (flowProportion) {
      res["FlowProportion"] = boost::any(*flowProportion);
    }
    if (urlDetail) {
      res["UrlDetail"] = boost::any(*urlDetail);
    }
    if (visitData) {
      res["VisitData"] = boost::any(*visitData);
    }
    if (visitProportion) {
      res["VisitProportion"] = boost::any(*visitProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("FlowProportion") != m.end() && !m["FlowProportion"].empty()) {
      flowProportion = make_shared<double>(boost::any_cast<double>(m["FlowProportion"]));
    }
    if (m.find("UrlDetail") != m.end() && !m["UrlDetail"].empty()) {
      urlDetail = make_shared<string>(boost::any_cast<string>(m["UrlDetail"]));
    }
    if (m.find("VisitData") != m.end() && !m["VisitData"].empty()) {
      visitData = make_shared<string>(boost::any_cast<string>(m["VisitData"]));
    }
    if (m.find("VisitProportion") != m.end() && !m["VisitProportion"].empty()) {
      visitProportion = make_shared<double>(boost::any_cast<double>(m["VisitProportion"]));
    }
  }


  virtual ~DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList() = default;
};
class DescribeDomainTopUrlVisitResponseBodyUrl500List : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList>> urlList{};

  DescribeDomainTopUrlVisitResponseBodyUrl500List() {}

  explicit DescribeDomainTopUrlVisitResponseBodyUrl500List(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (urlList) {
      vector<boost::any> temp1;
      for(auto item1:*urlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UrlList") != m.end() && !m["UrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlList"].type()) {
        vector<DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlList = make_shared<vector<DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainTopUrlVisitResponseBodyUrl500List() = default;
};
class DescribeDomainTopUrlVisitResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDomainTopUrlVisitResponseBodyAllUrlList> allUrlList{};
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeDomainTopUrlVisitResponseBodyUrl200List> url200List{};
  shared_ptr<DescribeDomainTopUrlVisitResponseBodyUrl300List> url300List{};
  shared_ptr<DescribeDomainTopUrlVisitResponseBodyUrl400List> url400List{};
  shared_ptr<DescribeDomainTopUrlVisitResponseBodyUrl500List> url500List{};

  DescribeDomainTopUrlVisitResponseBody() {}

  explicit DescribeDomainTopUrlVisitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allUrlList) {
      res["AllUrlList"] = allUrlList ? boost::any(allUrlList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (url200List) {
      res["Url200List"] = url200List ? boost::any(url200List->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (url300List) {
      res["Url300List"] = url300List ? boost::any(url300List->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (url400List) {
      res["Url400List"] = url400List ? boost::any(url400List->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (url500List) {
      res["Url500List"] = url500List ? boost::any(url500List->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllUrlList") != m.end() && !m["AllUrlList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AllUrlList"].type()) {
        DescribeDomainTopUrlVisitResponseBodyAllUrlList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AllUrlList"]));
        allUrlList = make_shared<DescribeDomainTopUrlVisitResponseBodyAllUrlList>(model1);
      }
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Url200List") != m.end() && !m["Url200List"].empty()) {
      if (typeid(map<string, boost::any>) == m["Url200List"].type()) {
        DescribeDomainTopUrlVisitResponseBodyUrl200List model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Url200List"]));
        url200List = make_shared<DescribeDomainTopUrlVisitResponseBodyUrl200List>(model1);
      }
    }
    if (m.find("Url300List") != m.end() && !m["Url300List"].empty()) {
      if (typeid(map<string, boost::any>) == m["Url300List"].type()) {
        DescribeDomainTopUrlVisitResponseBodyUrl300List model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Url300List"]));
        url300List = make_shared<DescribeDomainTopUrlVisitResponseBodyUrl300List>(model1);
      }
    }
    if (m.find("Url400List") != m.end() && !m["Url400List"].empty()) {
      if (typeid(map<string, boost::any>) == m["Url400List"].type()) {
        DescribeDomainTopUrlVisitResponseBodyUrl400List model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Url400List"]));
        url400List = make_shared<DescribeDomainTopUrlVisitResponseBodyUrl400List>(model1);
      }
    }
    if (m.find("Url500List") != m.end() && !m["Url500List"].empty()) {
      if (typeid(map<string, boost::any>) == m["Url500List"].type()) {
        DescribeDomainTopUrlVisitResponseBodyUrl500List model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Url500List"]));
        url500List = make_shared<DescribeDomainTopUrlVisitResponseBodyUrl500List>(model1);
      }
    }
  }


  virtual ~DescribeDomainTopUrlVisitResponseBody() = default;
};
class DescribeDomainTopUrlVisitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainTopUrlVisitResponseBody> body{};

  DescribeDomainTopUrlVisitResponse() {}

  explicit DescribeDomainTopUrlVisitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainTopUrlVisitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainTopUrlVisitResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainTopUrlVisitResponse() = default;
};
class DescribeDomainTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDomainTrafficDataRequest() {}

  explicit DescribeDomainTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainTrafficDataRequest() = default;
};
class DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> domesticValue{};
  shared_ptr<string> httpsDomesticValue{};
  shared_ptr<string> httpsOverseasValue{};
  shared_ptr<string> httpsValue{};
  shared_ptr<string> overseasValue{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule() {}

  explicit DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domesticValue) {
      res["DomesticValue"] = boost::any(*domesticValue);
    }
    if (httpsDomesticValue) {
      res["HttpsDomesticValue"] = boost::any(*httpsDomesticValue);
    }
    if (httpsOverseasValue) {
      res["HttpsOverseasValue"] = boost::any(*httpsOverseasValue);
    }
    if (httpsValue) {
      res["HttpsValue"] = boost::any(*httpsValue);
    }
    if (overseasValue) {
      res["OverseasValue"] = boost::any(*overseasValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomesticValue") != m.end() && !m["DomesticValue"].empty()) {
      domesticValue = make_shared<string>(boost::any_cast<string>(m["DomesticValue"]));
    }
    if (m.find("HttpsDomesticValue") != m.end() && !m["HttpsDomesticValue"].empty()) {
      httpsDomesticValue = make_shared<string>(boost::any_cast<string>(m["HttpsDomesticValue"]));
    }
    if (m.find("HttpsOverseasValue") != m.end() && !m["HttpsOverseasValue"].empty()) {
      httpsOverseasValue = make_shared<string>(boost::any_cast<string>(m["HttpsOverseasValue"]));
    }
    if (m.find("HttpsValue") != m.end() && !m["HttpsValue"].empty()) {
      httpsValue = make_shared<string>(boost::any_cast<string>(m["HttpsValue"]));
    }
    if (m.find("OverseasValue") != m.end() && !m["OverseasValue"].empty()) {
      overseasValue = make_shared<string>(boost::any_cast<string>(m["OverseasValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule() = default;
};
class DescribeDomainTrafficDataResponseBodyTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeDomainTrafficDataResponseBodyTrafficDataPerInterval() {}

  explicit DescribeDomainTrafficDataResponseBodyTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainTrafficDataResponseBodyTrafficDataPerInterval() = default;
};
class DescribeDomainTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeDomainTrafficDataResponseBodyTrafficDataPerInterval> trafficDataPerInterval{};

  DescribeDomainTrafficDataResponseBody() {}

  explicit DescribeDomainTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (trafficDataPerInterval) {
      res["TrafficDataPerInterval"] = trafficDataPerInterval ? boost::any(trafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TrafficDataPerInterval") != m.end() && !m["TrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficDataPerInterval"].type()) {
        DescribeDomainTrafficDataResponseBodyTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficDataPerInterval"]));
        trafficDataPerInterval = make_shared<DescribeDomainTrafficDataResponseBodyTrafficDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDomainTrafficDataResponseBody() = default;
};
class DescribeDomainTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainTrafficDataResponseBody> body{};

  DescribeDomainTrafficDataResponse() {}

  explicit DescribeDomainTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainTrafficDataResponse() = default;
};
class DescribeDomainUsageDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> dataProtocol{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> field{};
  shared_ptr<string> interval{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  DescribeDomainUsageDataRequest() {}

  explicit DescribeDomainUsageDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (dataProtocol) {
      res["DataProtocol"] = boost::any(*dataProtocol);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("DataProtocol") != m.end() && !m["DataProtocol"].empty()) {
      dataProtocol = make_shared<string>(boost::any_cast<string>(m["DataProtocol"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDomainUsageDataRequest() = default;
};
class DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> peakTime{};
  shared_ptr<string> specialValue{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule() {}

  explicit DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (peakTime) {
      res["PeakTime"] = boost::any(*peakTime);
    }
    if (specialValue) {
      res["SpecialValue"] = boost::any(*specialValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PeakTime") != m.end() && !m["PeakTime"].empty()) {
      peakTime = make_shared<string>(boost::any_cast<string>(m["PeakTime"]));
    }
    if (m.find("SpecialValue") != m.end() && !m["SpecialValue"].empty()) {
      specialValue = make_shared<string>(boost::any_cast<string>(m["SpecialValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule() = default;
};
class DescribeDomainUsageDataResponseBodyUsageDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule>> dataModule{};

  DescribeDomainUsageDataResponseBodyUsageDataPerInterval() {}

  explicit DescribeDomainUsageDataResponseBodyUsageDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainUsageDataResponseBodyUsageDataPerInterval() = default;
};
class DescribeDomainUsageDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};
  shared_ptr<DescribeDomainUsageDataResponseBodyUsageDataPerInterval> usageDataPerInterval{};

  DescribeDomainUsageDataResponseBody() {}

  explicit DescribeDomainUsageDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (usageDataPerInterval) {
      res["UsageDataPerInterval"] = usageDataPerInterval ? boost::any(usageDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UsageDataPerInterval") != m.end() && !m["UsageDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["UsageDataPerInterval"].type()) {
        DescribeDomainUsageDataResponseBodyUsageDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UsageDataPerInterval"]));
        usageDataPerInterval = make_shared<DescribeDomainUsageDataResponseBodyUsageDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDomainUsageDataResponseBody() = default;
};
class DescribeDomainUsageDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainUsageDataResponseBody> body{};

  DescribeDomainUsageDataResponse() {}

  explicit DescribeDomainUsageDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainUsageDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainUsageDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainUsageDataResponse() = default;
};
class DescribeDomainUvDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeDomainUvDataRequest() {}

  explicit DescribeDomainUvDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainUvDataRequest() = default;
};
class DescribeDomainUvDataResponseBodyUvDataIntervalUsageData : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDomainUvDataResponseBodyUvDataIntervalUsageData() {}

  explicit DescribeDomainUvDataResponseBodyUvDataIntervalUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainUvDataResponseBodyUvDataIntervalUsageData() = default;
};
class DescribeDomainUvDataResponseBodyUvDataInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainUvDataResponseBodyUvDataIntervalUsageData>> usageData{};

  DescribeDomainUvDataResponseBodyUvDataInterval() {}

  explicit DescribeDomainUvDataResponseBodyUvDataInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usageData) {
      vector<boost::any> temp1;
      for(auto item1:*usageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsageData") != m.end() && !m["UsageData"].empty()) {
      if (typeid(vector<boost::any>) == m["UsageData"].type()) {
        vector<DescribeDomainUvDataResponseBodyUvDataIntervalUsageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainUvDataResponseBodyUvDataIntervalUsageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usageData = make_shared<vector<DescribeDomainUvDataResponseBodyUvDataIntervalUsageData>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainUvDataResponseBodyUvDataInterval() = default;
};
class DescribeDomainUvDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeDomainUvDataResponseBodyUvDataInterval> uvDataInterval{};

  DescribeDomainUvDataResponseBody() {}

  explicit DescribeDomainUvDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (uvDataInterval) {
      res["UvDataInterval"] = uvDataInterval ? boost::any(uvDataInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("UvDataInterval") != m.end() && !m["UvDataInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["UvDataInterval"].type()) {
        DescribeDomainUvDataResponseBodyUvDataInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UvDataInterval"]));
        uvDataInterval = make_shared<DescribeDomainUvDataResponseBodyUvDataInterval>(model1);
      }
    }
  }


  virtual ~DescribeDomainUvDataResponseBody() = default;
};
class DescribeDomainUvDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainUvDataResponseBody> body{};

  DescribeDomainUvDataResponse() {}

  explicit DescribeDomainUvDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainUvDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainUvDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainUvDataResponse() = default;
};
class DescribeDomainsBySourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> sources{};

  DescribeDomainsBySourceRequest() {}

  explicit DescribeDomainsBySourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (sources) {
      res["Sources"] = boost::any(*sources);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sources = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
  }


  virtual ~DescribeDomainsBySourceRequest() = default;
};
class DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo : public Darabonba::Model {
public:
  shared_ptr<string> cdnType{};
  shared_ptr<string> createTime{};
  shared_ptr<string> domainCname{};
  shared_ptr<string> domainName{};
  shared_ptr<string> status{};
  shared_ptr<string> updateTime{};

  DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo() {}

  explicit DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdnType) {
      res["CdnType"] = boost::any(*cdnType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domainCname) {
      res["DomainCname"] = boost::any(*domainCname);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdnType") != m.end() && !m["CdnType"].empty()) {
      cdnType = make_shared<string>(boost::any_cast<string>(m["CdnType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DomainCname") != m.end() && !m["DomainCname"].empty()) {
      domainCname = make_shared<string>(boost::any_cast<string>(m["DomainCname"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo() = default;
};
class DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo>> domainInfo{};

  DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfos() {}

  explicit DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainInfo) {
      vector<boost::any> temp1;
      for(auto item1:*domainInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["domainInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("domainInfo") != m.end() && !m["domainInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["domainInfo"].type()) {
        vector<DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["domainInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainInfo = make_shared<vector<DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfos() = default;
};
class DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomains : public Darabonba::Model {
public:
  shared_ptr<vector<string>> domainNames{};

  DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomains() {}

  explicit DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["domainNames"] = boost::any(*domainNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("domainNames") != m.end() && !m["domainNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["domainNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["domainNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domainNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomains() = default;
};
class DescribeDomainsBySourceResponseBodyDomainsListDomainsData : public Darabonba::Model {
public:
  shared_ptr<DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfos> domainInfos{};
  shared_ptr<DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomains> domains{};
  shared_ptr<string> source{};

  DescribeDomainsBySourceResponseBodyDomainsListDomainsData() {}

  explicit DescribeDomainsBySourceResponseBodyDomainsListDomainsData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainInfos) {
      res["DomainInfos"] = domainInfos ? boost::any(domainInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domains) {
      res["Domains"] = domains ? boost::any(domains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainInfos") != m.end() && !m["DomainInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainInfos"].type()) {
        DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainInfos"]));
        domainInfos = make_shared<DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfos>(model1);
      }
    }
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(map<string, boost::any>) == m["Domains"].type()) {
        DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Domains"]));
        domains = make_shared<DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomains>(model1);
      }
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~DescribeDomainsBySourceResponseBodyDomainsListDomainsData() = default;
};
class DescribeDomainsBySourceResponseBodyDomainsList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainsBySourceResponseBodyDomainsListDomainsData>> domainsData{};

  DescribeDomainsBySourceResponseBodyDomainsList() {}

  explicit DescribeDomainsBySourceResponseBodyDomainsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainsData) {
      vector<boost::any> temp1;
      for(auto item1:*domainsData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainsData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainsData") != m.end() && !m["DomainsData"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainsData"].type()) {
        vector<DescribeDomainsBySourceResponseBodyDomainsListDomainsData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainsData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainsBySourceResponseBodyDomainsListDomainsData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainsData = make_shared<vector<DescribeDomainsBySourceResponseBodyDomainsListDomainsData>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainsBySourceResponseBodyDomainsList() = default;
};
class DescribeDomainsBySourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDomainsBySourceResponseBodyDomainsList> domainsList{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sources{};

  DescribeDomainsBySourceResponseBody() {}

  explicit DescribeDomainsBySourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainsList) {
      res["DomainsList"] = domainsList ? boost::any(domainsList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sources) {
      res["Sources"] = boost::any(*sources);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainsList") != m.end() && !m["DomainsList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainsList"].type()) {
        DescribeDomainsBySourceResponseBodyDomainsList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainsList"]));
        domainsList = make_shared<DescribeDomainsBySourceResponseBodyDomainsList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sources = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
  }


  virtual ~DescribeDomainsBySourceResponseBody() = default;
};
class DescribeDomainsBySourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainsBySourceResponseBody> body{};

  DescribeDomainsBySourceResponse() {}

  explicit DescribeDomainsBySourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainsBySourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainsBySourceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainsBySourceResponse() = default;
};
class DescribeDomainsUsageByDayRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeDomainsUsageByDayRequest() {}

  explicit DescribeDomainsUsageByDayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainsUsageByDayRequest() = default;
};
class DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay : public Darabonba::Model {
public:
  shared_ptr<string> bytesHitRate{};
  shared_ptr<string> maxBps{};
  shared_ptr<string> maxBpsTime{};
  shared_ptr<string> maxSrcBps{};
  shared_ptr<string> maxSrcBpsTime{};
  shared_ptr<string> qps{};
  shared_ptr<string> requestHitRate{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> totalAccess{};
  shared_ptr<string> totalTraffic{};

  DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay() {}

  explicit DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bytesHitRate) {
      res["BytesHitRate"] = boost::any(*bytesHitRate);
    }
    if (maxBps) {
      res["MaxBps"] = boost::any(*maxBps);
    }
    if (maxBpsTime) {
      res["MaxBpsTime"] = boost::any(*maxBpsTime);
    }
    if (maxSrcBps) {
      res["MaxSrcBps"] = boost::any(*maxSrcBps);
    }
    if (maxSrcBpsTime) {
      res["MaxSrcBpsTime"] = boost::any(*maxSrcBpsTime);
    }
    if (qps) {
      res["Qps"] = boost::any(*qps);
    }
    if (requestHitRate) {
      res["RequestHitRate"] = boost::any(*requestHitRate);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (totalAccess) {
      res["TotalAccess"] = boost::any(*totalAccess);
    }
    if (totalTraffic) {
      res["TotalTraffic"] = boost::any(*totalTraffic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BytesHitRate") != m.end() && !m["BytesHitRate"].empty()) {
      bytesHitRate = make_shared<string>(boost::any_cast<string>(m["BytesHitRate"]));
    }
    if (m.find("MaxBps") != m.end() && !m["MaxBps"].empty()) {
      maxBps = make_shared<string>(boost::any_cast<string>(m["MaxBps"]));
    }
    if (m.find("MaxBpsTime") != m.end() && !m["MaxBpsTime"].empty()) {
      maxBpsTime = make_shared<string>(boost::any_cast<string>(m["MaxBpsTime"]));
    }
    if (m.find("MaxSrcBps") != m.end() && !m["MaxSrcBps"].empty()) {
      maxSrcBps = make_shared<string>(boost::any_cast<string>(m["MaxSrcBps"]));
    }
    if (m.find("MaxSrcBpsTime") != m.end() && !m["MaxSrcBpsTime"].empty()) {
      maxSrcBpsTime = make_shared<string>(boost::any_cast<string>(m["MaxSrcBpsTime"]));
    }
    if (m.find("Qps") != m.end() && !m["Qps"].empty()) {
      qps = make_shared<string>(boost::any_cast<string>(m["Qps"]));
    }
    if (m.find("RequestHitRate") != m.end() && !m["RequestHitRate"].empty()) {
      requestHitRate = make_shared<string>(boost::any_cast<string>(m["RequestHitRate"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("TotalAccess") != m.end() && !m["TotalAccess"].empty()) {
      totalAccess = make_shared<string>(boost::any_cast<string>(m["TotalAccess"]));
    }
    if (m.find("TotalTraffic") != m.end() && !m["TotalTraffic"].empty()) {
      totalTraffic = make_shared<string>(boost::any_cast<string>(m["TotalTraffic"]));
    }
  }


  virtual ~DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay() = default;
};
class DescribeDomainsUsageByDayResponseBodyUsageByDays : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay>> usageByDay{};

  DescribeDomainsUsageByDayResponseBodyUsageByDays() {}

  explicit DescribeDomainsUsageByDayResponseBodyUsageByDays(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usageByDay) {
      vector<boost::any> temp1;
      for(auto item1:*usageByDay){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsageByDay"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsageByDay") != m.end() && !m["UsageByDay"].empty()) {
      if (typeid(vector<boost::any>) == m["UsageByDay"].type()) {
        vector<DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsageByDay"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usageByDay = make_shared<vector<DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainsUsageByDayResponseBodyUsageByDays() = default;
};
class DescribeDomainsUsageByDayResponseBodyUsageTotal : public Darabonba::Model {
public:
  shared_ptr<string> bytesHitRate{};
  shared_ptr<string> maxBps{};
  shared_ptr<string> maxBpsTime{};
  shared_ptr<string> maxSrcBps{};
  shared_ptr<string> maxSrcBpsTime{};
  shared_ptr<string> requestHitRate{};
  shared_ptr<string> totalAccess{};
  shared_ptr<string> totalTraffic{};

  DescribeDomainsUsageByDayResponseBodyUsageTotal() {}

  explicit DescribeDomainsUsageByDayResponseBodyUsageTotal(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bytesHitRate) {
      res["BytesHitRate"] = boost::any(*bytesHitRate);
    }
    if (maxBps) {
      res["MaxBps"] = boost::any(*maxBps);
    }
    if (maxBpsTime) {
      res["MaxBpsTime"] = boost::any(*maxBpsTime);
    }
    if (maxSrcBps) {
      res["MaxSrcBps"] = boost::any(*maxSrcBps);
    }
    if (maxSrcBpsTime) {
      res["MaxSrcBpsTime"] = boost::any(*maxSrcBpsTime);
    }
    if (requestHitRate) {
      res["RequestHitRate"] = boost::any(*requestHitRate);
    }
    if (totalAccess) {
      res["TotalAccess"] = boost::any(*totalAccess);
    }
    if (totalTraffic) {
      res["TotalTraffic"] = boost::any(*totalTraffic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BytesHitRate") != m.end() && !m["BytesHitRate"].empty()) {
      bytesHitRate = make_shared<string>(boost::any_cast<string>(m["BytesHitRate"]));
    }
    if (m.find("MaxBps") != m.end() && !m["MaxBps"].empty()) {
      maxBps = make_shared<string>(boost::any_cast<string>(m["MaxBps"]));
    }
    if (m.find("MaxBpsTime") != m.end() && !m["MaxBpsTime"].empty()) {
      maxBpsTime = make_shared<string>(boost::any_cast<string>(m["MaxBpsTime"]));
    }
    if (m.find("MaxSrcBps") != m.end() && !m["MaxSrcBps"].empty()) {
      maxSrcBps = make_shared<string>(boost::any_cast<string>(m["MaxSrcBps"]));
    }
    if (m.find("MaxSrcBpsTime") != m.end() && !m["MaxSrcBpsTime"].empty()) {
      maxSrcBpsTime = make_shared<string>(boost::any_cast<string>(m["MaxSrcBpsTime"]));
    }
    if (m.find("RequestHitRate") != m.end() && !m["RequestHitRate"].empty()) {
      requestHitRate = make_shared<string>(boost::any_cast<string>(m["RequestHitRate"]));
    }
    if (m.find("TotalAccess") != m.end() && !m["TotalAccess"].empty()) {
      totalAccess = make_shared<string>(boost::any_cast<string>(m["TotalAccess"]));
    }
    if (m.find("TotalTraffic") != m.end() && !m["TotalTraffic"].empty()) {
      totalTraffic = make_shared<string>(boost::any_cast<string>(m["TotalTraffic"]));
    }
  }


  virtual ~DescribeDomainsUsageByDayResponseBodyUsageTotal() = default;
};
class DescribeDomainsUsageByDayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeDomainsUsageByDayResponseBodyUsageByDays> usageByDays{};
  shared_ptr<DescribeDomainsUsageByDayResponseBodyUsageTotal> usageTotal{};

  DescribeDomainsUsageByDayResponseBody() {}

  explicit DescribeDomainsUsageByDayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (usageByDays) {
      res["UsageByDays"] = usageByDays ? boost::any(usageByDays->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usageTotal) {
      res["UsageTotal"] = usageTotal ? boost::any(usageTotal->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("UsageByDays") != m.end() && !m["UsageByDays"].empty()) {
      if (typeid(map<string, boost::any>) == m["UsageByDays"].type()) {
        DescribeDomainsUsageByDayResponseBodyUsageByDays model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UsageByDays"]));
        usageByDays = make_shared<DescribeDomainsUsageByDayResponseBodyUsageByDays>(model1);
      }
    }
    if (m.find("UsageTotal") != m.end() && !m["UsageTotal"].empty()) {
      if (typeid(map<string, boost::any>) == m["UsageTotal"].type()) {
        DescribeDomainsUsageByDayResponseBodyUsageTotal model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UsageTotal"]));
        usageTotal = make_shared<DescribeDomainsUsageByDayResponseBodyUsageTotal>(model1);
      }
    }
  }


  virtual ~DescribeDomainsUsageByDayResponseBody() = default;
};
class DescribeDomainsUsageByDayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainsUsageByDayResponseBody> body{};

  DescribeDomainsUsageByDayResponse() {}

  explicit DescribeDomainsUsageByDayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainsUsageByDayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainsUsageByDayResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainsUsageByDayResponse() = default;
};
class DescribeEsExceptionDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> startTime{};

  DescribeEsExceptionDataRequest() {}

  explicit DescribeEsExceptionDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeEsExceptionDataRequest() = default;
};
class DescribeEsExceptionDataResponseBodyContentsPoints : public Darabonba::Model {
public:
  shared_ptr<vector<string>> points{};

  DescribeEsExceptionDataResponseBodyContentsPoints() {}

  explicit DescribeEsExceptionDataResponseBodyContentsPoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (points) {
      res["Points"] = boost::any(*points);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Points"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Points"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      points = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeEsExceptionDataResponseBodyContentsPoints() = default;
};
class DescribeEsExceptionDataResponseBodyContents : public Darabonba::Model {
public:
  shared_ptr<vector<string>> columns{};
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeEsExceptionDataResponseBodyContentsPoints>> points{};

  DescribeEsExceptionDataResponseBodyContents() {}

  explicit DescribeEsExceptionDataResponseBodyContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columns) {
      res["Columns"] = boost::any(*columns);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (points) {
      vector<boost::any> temp1;
      for(auto item1:*points){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Points"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Columns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Columns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      columns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      if (typeid(vector<boost::any>) == m["Points"].type()) {
        vector<DescribeEsExceptionDataResponseBodyContentsPoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Points"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEsExceptionDataResponseBodyContentsPoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        points = make_shared<vector<DescribeEsExceptionDataResponseBodyContentsPoints>>(expect1);
      }
    }
  }


  virtual ~DescribeEsExceptionDataResponseBodyContents() = default;
};
class DescribeEsExceptionDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEsExceptionDataResponseBodyContents>> contents{};
  shared_ptr<string> requestId{};

  DescribeEsExceptionDataResponseBody() {}

  explicit DescribeEsExceptionDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contents) {
      vector<boost::any> temp1;
      for(auto item1:*contents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contents"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      if (typeid(vector<boost::any>) == m["Contents"].type()) {
        vector<DescribeEsExceptionDataResponseBodyContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEsExceptionDataResponseBodyContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contents = make_shared<vector<DescribeEsExceptionDataResponseBodyContents>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEsExceptionDataResponseBody() = default;
};
class DescribeEsExceptionDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEsExceptionDataResponseBody> body{};

  DescribeEsExceptionDataResponse() {}

  explicit DescribeEsExceptionDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEsExceptionDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEsExceptionDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEsExceptionDataResponse() = default;
};
class DescribeEsExecuteDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> startTime{};

  DescribeEsExecuteDataRequest() {}

  explicit DescribeEsExecuteDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeEsExecuteDataRequest() = default;
};
class DescribeEsExecuteDataResponseBodyContents : public Darabonba::Model {
public:
  shared_ptr<vector<string>> columns{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> points{};

  DescribeEsExecuteDataResponseBodyContents() {}

  explicit DescribeEsExecuteDataResponseBodyContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columns) {
      res["Columns"] = boost::any(*columns);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Columns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Columns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      columns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Points"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Points"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      points = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeEsExecuteDataResponseBodyContents() = default;
};
class DescribeEsExecuteDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEsExecuteDataResponseBodyContents>> contents{};
  shared_ptr<string> requestId{};

  DescribeEsExecuteDataResponseBody() {}

  explicit DescribeEsExecuteDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contents) {
      vector<boost::any> temp1;
      for(auto item1:*contents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contents"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      if (typeid(vector<boost::any>) == m["Contents"].type()) {
        vector<DescribeEsExecuteDataResponseBodyContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEsExecuteDataResponseBodyContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contents = make_shared<vector<DescribeEsExecuteDataResponseBodyContents>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEsExecuteDataResponseBody() = default;
};
class DescribeEsExecuteDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEsExecuteDataResponseBody> body{};

  DescribeEsExecuteDataResponse() {}

  explicit DescribeEsExecuteDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEsExecuteDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEsExecuteDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEsExecuteDataResponse() = default;
};
class DescribeFCTriggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> triggerARN{};

  DescribeFCTriggerRequest() {}

  explicit DescribeFCTriggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (triggerARN) {
      res["TriggerARN"] = boost::any(*triggerARN);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TriggerARN") != m.end() && !m["TriggerARN"].empty()) {
      triggerARN = make_shared<string>(boost::any_cast<string>(m["TriggerARN"]));
    }
  }


  virtual ~DescribeFCTriggerRequest() = default;
};
class DescribeFCTriggerResponseBodyFCTrigger : public Darabonba::Model {
public:
  shared_ptr<string> eventMetaName{};
  shared_ptr<string> eventMetaVersion{};
  shared_ptr<string> notes{};
  shared_ptr<string> roleARN{};
  shared_ptr<string> sourceArn{};
  shared_ptr<string> triggerARN{};

  DescribeFCTriggerResponseBodyFCTrigger() {}

  explicit DescribeFCTriggerResponseBodyFCTrigger(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventMetaName) {
      res["EventMetaName"] = boost::any(*eventMetaName);
    }
    if (eventMetaVersion) {
      res["EventMetaVersion"] = boost::any(*eventMetaVersion);
    }
    if (notes) {
      res["Notes"] = boost::any(*notes);
    }
    if (roleARN) {
      res["RoleARN"] = boost::any(*roleARN);
    }
    if (sourceArn) {
      res["SourceArn"] = boost::any(*sourceArn);
    }
    if (triggerARN) {
      res["TriggerARN"] = boost::any(*triggerARN);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventMetaName") != m.end() && !m["EventMetaName"].empty()) {
      eventMetaName = make_shared<string>(boost::any_cast<string>(m["EventMetaName"]));
    }
    if (m.find("EventMetaVersion") != m.end() && !m["EventMetaVersion"].empty()) {
      eventMetaVersion = make_shared<string>(boost::any_cast<string>(m["EventMetaVersion"]));
    }
    if (m.find("Notes") != m.end() && !m["Notes"].empty()) {
      notes = make_shared<string>(boost::any_cast<string>(m["Notes"]));
    }
    if (m.find("RoleARN") != m.end() && !m["RoleARN"].empty()) {
      roleARN = make_shared<string>(boost::any_cast<string>(m["RoleARN"]));
    }
    if (m.find("SourceArn") != m.end() && !m["SourceArn"].empty()) {
      sourceArn = make_shared<string>(boost::any_cast<string>(m["SourceArn"]));
    }
    if (m.find("TriggerARN") != m.end() && !m["TriggerARN"].empty()) {
      triggerARN = make_shared<string>(boost::any_cast<string>(m["TriggerARN"]));
    }
  }


  virtual ~DescribeFCTriggerResponseBodyFCTrigger() = default;
};
class DescribeFCTriggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeFCTriggerResponseBodyFCTrigger> FCTrigger{};
  shared_ptr<string> requestId{};

  DescribeFCTriggerResponseBody() {}

  explicit DescribeFCTriggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (FCTrigger) {
      res["FCTrigger"] = FCTrigger ? boost::any(FCTrigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FCTrigger") != m.end() && !m["FCTrigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["FCTrigger"].type()) {
        DescribeFCTriggerResponseBodyFCTrigger model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FCTrigger"]));
        FCTrigger = make_shared<DescribeFCTriggerResponseBodyFCTrigger>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeFCTriggerResponseBody() = default;
};
class DescribeFCTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFCTriggerResponseBody> body{};

  DescribeFCTriggerResponse() {}

  explicit DescribeFCTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFCTriggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFCTriggerResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFCTriggerResponse() = default;
};
class DescribeIpInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> IP{};

  DescribeIpInfoRequest() {}

  explicit DescribeIpInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
  }


  virtual ~DescribeIpInfoRequest() = default;
};
class DescribeIpInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> cdnIp{};
  shared_ptr<string> ISP{};
  shared_ptr<string> ispEname{};
  shared_ptr<string> region{};
  shared_ptr<string> regionEname{};
  shared_ptr<string> requestId{};

  DescribeIpInfoResponseBody() {}

  explicit DescribeIpInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdnIp) {
      res["CdnIp"] = boost::any(*cdnIp);
    }
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    if (ispEname) {
      res["IspEname"] = boost::any(*ispEname);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionEname) {
      res["RegionEname"] = boost::any(*regionEname);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdnIp") != m.end() && !m["CdnIp"].empty()) {
      cdnIp = make_shared<string>(boost::any_cast<string>(m["CdnIp"]));
    }
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
    if (m.find("IspEname") != m.end() && !m["IspEname"].empty()) {
      ispEname = make_shared<string>(boost::any_cast<string>(m["IspEname"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionEname") != m.end() && !m["RegionEname"].empty()) {
      regionEname = make_shared<string>(boost::any_cast<string>(m["RegionEname"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeIpInfoResponseBody() = default;
};
class DescribeIpInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIpInfoResponseBody> body{};

  DescribeIpInfoResponse() {}

  explicit DescribeIpInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIpInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIpInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIpInfoResponse() = default;
};
class DescribeIpStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> ips{};

  DescribeIpStatusRequest() {}

  explicit DescribeIpStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ips) {
      res["Ips"] = boost::any(*ips);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      ips = make_shared<string>(boost::any_cast<string>(m["Ips"]));
    }
  }


  virtual ~DescribeIpStatusRequest() = default;
};
class DescribeIpStatusResponseBodyIpStatus : public Darabonba::Model {
public:
  shared_ptr<string> ip{};
  shared_ptr<string> status{};

  DescribeIpStatusResponseBodyIpStatus() {}

  explicit DescribeIpStatusResponseBodyIpStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["ip"] = boost::any(*ip);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ip") != m.end() && !m["ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["ip"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~DescribeIpStatusResponseBodyIpStatus() = default;
};
class DescribeIpStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIpStatusResponseBodyIpStatus>> ipStatus{};
  shared_ptr<string> requestId{};

  DescribeIpStatusResponseBody() {}

  explicit DescribeIpStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipStatus) {
      vector<boost::any> temp1;
      for(auto item1:*ipStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpStatus"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpStatus") != m.end() && !m["IpStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["IpStatus"].type()) {
        vector<DescribeIpStatusResponseBodyIpStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIpStatusResponseBodyIpStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipStatus = make_shared<vector<DescribeIpStatusResponseBodyIpStatus>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeIpStatusResponseBody() = default;
};
class DescribeIpStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIpStatusResponseBody> body{};

  DescribeIpStatusResponse() {}

  explicit DescribeIpStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIpStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIpStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIpStatusResponse() = default;
};
class DescribeL2VipsByDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeL2VipsByDomainRequest() {}

  explicit DescribeL2VipsByDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeL2VipsByDomainRequest() = default;
};
class DescribeL2VipsByDomainResponseBodyVips : public Darabonba::Model {
public:
  shared_ptr<vector<string>> vip{};

  DescribeL2VipsByDomainResponseBodyVips() {}

  explicit DescribeL2VipsByDomainResponseBodyVips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vip) {
      res["Vip"] = boost::any(*vip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Vip") != m.end() && !m["Vip"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Vip"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Vip"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vip = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeL2VipsByDomainResponseBodyVips() = default;
};
class DescribeL2VipsByDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeL2VipsByDomainResponseBodyVips> vips{};

  DescribeL2VipsByDomainResponseBody() {}

  explicit DescribeL2VipsByDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vips) {
      res["Vips"] = vips ? boost::any(vips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Vips") != m.end() && !m["Vips"].empty()) {
      if (typeid(map<string, boost::any>) == m["Vips"].type()) {
        DescribeL2VipsByDomainResponseBodyVips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Vips"]));
        vips = make_shared<DescribeL2VipsByDomainResponseBodyVips>(model1);
      }
    }
  }


  virtual ~DescribeL2VipsByDomainResponseBody() = default;
};
class DescribeL2VipsByDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeL2VipsByDomainResponseBody> body{};

  DescribeL2VipsByDomainResponse() {}

  explicit DescribeL2VipsByDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeL2VipsByDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeL2VipsByDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeL2VipsByDomainResponse() = default;
};
class DescribePreloadDetailByIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  DescribePreloadDetailByIdRequest() {}

  explicit DescribePreloadDetailByIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribePreloadDetailByIdRequest() = default;
};
class DescribePreloadDetailByIdResponseBodyUrlDetailsUrls : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> success{};
  shared_ptr<string> url{};

  DescribePreloadDetailByIdResponseBodyUrlDetailsUrls() {}

  explicit DescribePreloadDetailByIdResponseBodyUrlDetailsUrls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~DescribePreloadDetailByIdResponseBodyUrlDetailsUrls() = default;
};
class DescribePreloadDetailByIdResponseBodyUrlDetails : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> domain{};
  shared_ptr<string> endTime{};
  shared_ptr<string> process{};
  shared_ptr<string> retCode{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<vector<DescribePreloadDetailByIdResponseBodyUrlDetailsUrls>> urls{};

  DescribePreloadDetailByIdResponseBodyUrlDetails() {}

  explicit DescribePreloadDetailByIdResponseBodyUrlDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (process) {
      res["Process"] = boost::any(*process);
    }
    if (retCode) {
      res["RetCode"] = boost::any(*retCode);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (urls) {
      vector<boost::any> temp1;
      for(auto item1:*urls){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Urls"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Process") != m.end() && !m["Process"].empty()) {
      process = make_shared<string>(boost::any_cast<string>(m["Process"]));
    }
    if (m.find("RetCode") != m.end() && !m["RetCode"].empty()) {
      retCode = make_shared<string>(boost::any_cast<string>(m["RetCode"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Urls") != m.end() && !m["Urls"].empty()) {
      if (typeid(vector<boost::any>) == m["Urls"].type()) {
        vector<DescribePreloadDetailByIdResponseBodyUrlDetailsUrls> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Urls"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePreloadDetailByIdResponseBodyUrlDetailsUrls model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urls = make_shared<vector<DescribePreloadDetailByIdResponseBodyUrlDetailsUrls>>(expect1);
      }
    }
  }


  virtual ~DescribePreloadDetailByIdResponseBodyUrlDetails() = default;
};
class DescribePreloadDetailByIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribePreloadDetailByIdResponseBodyUrlDetails>> urlDetails{};

  DescribePreloadDetailByIdResponseBody() {}

  explicit DescribePreloadDetailByIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (urlDetails) {
      vector<boost::any> temp1;
      for(auto item1:*urlDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlDetails"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UrlDetails") != m.end() && !m["UrlDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlDetails"].type()) {
        vector<DescribePreloadDetailByIdResponseBodyUrlDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePreloadDetailByIdResponseBodyUrlDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlDetails = make_shared<vector<DescribePreloadDetailByIdResponseBodyUrlDetails>>(expect1);
      }
    }
  }


  virtual ~DescribePreloadDetailByIdResponseBody() = default;
};
class DescribePreloadDetailByIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePreloadDetailByIdResponseBody> body{};

  DescribePreloadDetailByIdResponse() {}

  explicit DescribePreloadDetailByIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePreloadDetailByIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePreloadDetailByIdResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePreloadDetailByIdResponse() = default;
};
class DescribeRangeDataByLocateAndIspServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ispNames{};
  shared_ptr<string> locationNames{};
  shared_ptr<string> startTime{};

  DescribeRangeDataByLocateAndIspServiceRequest() {}

  explicit DescribeRangeDataByLocateAndIspServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ispNames) {
      res["IspNames"] = boost::any(*ispNames);
    }
    if (locationNames) {
      res["LocationNames"] = boost::any(*locationNames);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IspNames") != m.end() && !m["IspNames"].empty()) {
      ispNames = make_shared<string>(boost::any_cast<string>(m["IspNames"]));
    }
    if (m.find("LocationNames") != m.end() && !m["LocationNames"].empty()) {
      locationNames = make_shared<string>(boost::any_cast<string>(m["LocationNames"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRangeDataByLocateAndIspServiceRequest() = default;
};
class DescribeRangeDataByLocateAndIspServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jsonResult{};
  shared_ptr<string> requestId{};

  DescribeRangeDataByLocateAndIspServiceResponseBody() {}

  explicit DescribeRangeDataByLocateAndIspServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jsonResult) {
      res["JsonResult"] = boost::any(*jsonResult);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JsonResult") != m.end() && !m["JsonResult"].empty()) {
      jsonResult = make_shared<string>(boost::any_cast<string>(m["JsonResult"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRangeDataByLocateAndIspServiceResponseBody() = default;
};
class DescribeRangeDataByLocateAndIspServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRangeDataByLocateAndIspServiceResponseBody> body{};

  DescribeRangeDataByLocateAndIspServiceResponse() {}

  explicit DescribeRangeDataByLocateAndIspServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRangeDataByLocateAndIspServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRangeDataByLocateAndIspServiceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRangeDataByLocateAndIspServiceResponse() = default;
};
class DescribeRealtimeDeliveryAccRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> logStore{};
  shared_ptr<string> project{};
  shared_ptr<string> startTime{};

  DescribeRealtimeDeliveryAccRequest() {}

  explicit DescribeRealtimeDeliveryAccRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (logStore) {
      res["LogStore"] = boost::any(*logStore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("LogStore") != m.end() && !m["LogStore"].empty()) {
      logStore = make_shared<string>(boost::any_cast<string>(m["LogStore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeRealtimeDeliveryAccRequest() = default;
};
class DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccDataAccData : public Darabonba::Model {
public:
  shared_ptr<long> failedNum{};
  shared_ptr<long> successNum{};
  shared_ptr<string> timeStamp{};

  DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccDataAccData() {}

  explicit DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccDataAccData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedNum) {
      res["FailedNum"] = boost::any(*failedNum);
    }
    if (successNum) {
      res["SuccessNum"] = boost::any(*successNum);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedNum") != m.end() && !m["FailedNum"].empty()) {
      failedNum = make_shared<long>(boost::any_cast<long>(m["FailedNum"]));
    }
    if (m.find("SuccessNum") != m.end() && !m["SuccessNum"].empty()) {
      successNum = make_shared<long>(boost::any_cast<long>(m["SuccessNum"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccDataAccData() = default;
};
class DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccDataAccData>> accData{};

  DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccData() {}

  explicit DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accData) {
      vector<boost::any> temp1;
      for(auto item1:*accData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccData") != m.end() && !m["AccData"].empty()) {
      if (typeid(vector<boost::any>) == m["AccData"].type()) {
        vector<DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccDataAccData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccDataAccData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accData = make_shared<vector<DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccDataAccData>>(expect1);
      }
    }
  }


  virtual ~DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccData() = default;
};
class DescribeRealtimeDeliveryAccResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccData> reatTimeDeliveryAccData{};
  shared_ptr<string> requestId{};

  DescribeRealtimeDeliveryAccResponseBody() {}

  explicit DescribeRealtimeDeliveryAccResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reatTimeDeliveryAccData) {
      res["ReatTimeDeliveryAccData"] = reatTimeDeliveryAccData ? boost::any(reatTimeDeliveryAccData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReatTimeDeliveryAccData") != m.end() && !m["ReatTimeDeliveryAccData"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReatTimeDeliveryAccData"].type()) {
        DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReatTimeDeliveryAccData"]));
        reatTimeDeliveryAccData = make_shared<DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRealtimeDeliveryAccResponseBody() = default;
};
class DescribeRealtimeDeliveryAccResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRealtimeDeliveryAccResponseBody> body{};

  DescribeRealtimeDeliveryAccResponse() {}

  explicit DescribeRealtimeDeliveryAccResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRealtimeDeliveryAccResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRealtimeDeliveryAccResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRealtimeDeliveryAccResponse() = default;
};
class DescribeRefreshQuotaRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeRefreshQuotaRequest() {}

  explicit DescribeRefreshQuotaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeRefreshQuotaRequest() = default;
};
class DescribeRefreshQuotaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> blockQuota{};
  shared_ptr<string> blockRemain{};
  shared_ptr<string> dirQuota{};
  shared_ptr<string> dirRemain{};
  shared_ptr<string> ignoreParamsQuota{};
  shared_ptr<string> ignoreParamsRemain{};
  shared_ptr<string> preloadEdgeQuota{};
  shared_ptr<string> preloadEdgeRemain{};
  shared_ptr<string> preloadQuota{};
  shared_ptr<string> preloadRemain{};
  shared_ptr<string> regexQuota{};
  shared_ptr<string> regexRemain{};
  shared_ptr<string> requestId{};
  shared_ptr<string> urlQuota{};
  shared_ptr<string> urlRemain{};

  DescribeRefreshQuotaResponseBody() {}

  explicit DescribeRefreshQuotaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockQuota) {
      res["BlockQuota"] = boost::any(*blockQuota);
    }
    if (blockRemain) {
      res["BlockRemain"] = boost::any(*blockRemain);
    }
    if (dirQuota) {
      res["DirQuota"] = boost::any(*dirQuota);
    }
    if (dirRemain) {
      res["DirRemain"] = boost::any(*dirRemain);
    }
    if (ignoreParamsQuota) {
      res["IgnoreParamsQuota"] = boost::any(*ignoreParamsQuota);
    }
    if (ignoreParamsRemain) {
      res["IgnoreParamsRemain"] = boost::any(*ignoreParamsRemain);
    }
    if (preloadEdgeQuota) {
      res["PreloadEdgeQuota"] = boost::any(*preloadEdgeQuota);
    }
    if (preloadEdgeRemain) {
      res["PreloadEdgeRemain"] = boost::any(*preloadEdgeRemain);
    }
    if (preloadQuota) {
      res["PreloadQuota"] = boost::any(*preloadQuota);
    }
    if (preloadRemain) {
      res["PreloadRemain"] = boost::any(*preloadRemain);
    }
    if (regexQuota) {
      res["RegexQuota"] = boost::any(*regexQuota);
    }
    if (regexRemain) {
      res["RegexRemain"] = boost::any(*regexRemain);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (urlQuota) {
      res["UrlQuota"] = boost::any(*urlQuota);
    }
    if (urlRemain) {
      res["UrlRemain"] = boost::any(*urlRemain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockQuota") != m.end() && !m["BlockQuota"].empty()) {
      blockQuota = make_shared<string>(boost::any_cast<string>(m["BlockQuota"]));
    }
    if (m.find("BlockRemain") != m.end() && !m["BlockRemain"].empty()) {
      blockRemain = make_shared<string>(boost::any_cast<string>(m["BlockRemain"]));
    }
    if (m.find("DirQuota") != m.end() && !m["DirQuota"].empty()) {
      dirQuota = make_shared<string>(boost::any_cast<string>(m["DirQuota"]));
    }
    if (m.find("DirRemain") != m.end() && !m["DirRemain"].empty()) {
      dirRemain = make_shared<string>(boost::any_cast<string>(m["DirRemain"]));
    }
    if (m.find("IgnoreParamsQuota") != m.end() && !m["IgnoreParamsQuota"].empty()) {
      ignoreParamsQuota = make_shared<string>(boost::any_cast<string>(m["IgnoreParamsQuota"]));
    }
    if (m.find("IgnoreParamsRemain") != m.end() && !m["IgnoreParamsRemain"].empty()) {
      ignoreParamsRemain = make_shared<string>(boost::any_cast<string>(m["IgnoreParamsRemain"]));
    }
    if (m.find("PreloadEdgeQuota") != m.end() && !m["PreloadEdgeQuota"].empty()) {
      preloadEdgeQuota = make_shared<string>(boost::any_cast<string>(m["PreloadEdgeQuota"]));
    }
    if (m.find("PreloadEdgeRemain") != m.end() && !m["PreloadEdgeRemain"].empty()) {
      preloadEdgeRemain = make_shared<string>(boost::any_cast<string>(m["PreloadEdgeRemain"]));
    }
    if (m.find("PreloadQuota") != m.end() && !m["PreloadQuota"].empty()) {
      preloadQuota = make_shared<string>(boost::any_cast<string>(m["PreloadQuota"]));
    }
    if (m.find("PreloadRemain") != m.end() && !m["PreloadRemain"].empty()) {
      preloadRemain = make_shared<string>(boost::any_cast<string>(m["PreloadRemain"]));
    }
    if (m.find("RegexQuota") != m.end() && !m["RegexQuota"].empty()) {
      regexQuota = make_shared<string>(boost::any_cast<string>(m["RegexQuota"]));
    }
    if (m.find("RegexRemain") != m.end() && !m["RegexRemain"].empty()) {
      regexRemain = make_shared<string>(boost::any_cast<string>(m["RegexRemain"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UrlQuota") != m.end() && !m["UrlQuota"].empty()) {
      urlQuota = make_shared<string>(boost::any_cast<string>(m["UrlQuota"]));
    }
    if (m.find("UrlRemain") != m.end() && !m["UrlRemain"].empty()) {
      urlRemain = make_shared<string>(boost::any_cast<string>(m["UrlRemain"]));
    }
  }


  virtual ~DescribeRefreshQuotaResponseBody() = default;
};
class DescribeRefreshQuotaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRefreshQuotaResponseBody> body{};

  DescribeRefreshQuotaResponse() {}

  explicit DescribeRefreshQuotaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRefreshQuotaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRefreshQuotaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRefreshQuotaResponse() = default;
};
class DescribeRefreshTaskByIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  DescribeRefreshTaskByIdRequest() {}

  explicit DescribeRefreshTaskByIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeRefreshTaskByIdRequest() = default;
};
class DescribeRefreshTaskByIdResponseBodyTasks : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> objectPath{};
  shared_ptr<string> objectType{};
  shared_ptr<string> process{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};

  DescribeRefreshTaskByIdResponseBodyTasks() {}

  explicit DescribeRefreshTaskByIdResponseBodyTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (objectPath) {
      res["ObjectPath"] = boost::any(*objectPath);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (process) {
      res["Process"] = boost::any(*process);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ObjectPath") != m.end() && !m["ObjectPath"].empty()) {
      objectPath = make_shared<string>(boost::any_cast<string>(m["ObjectPath"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("Process") != m.end() && !m["Process"].empty()) {
      process = make_shared<string>(boost::any_cast<string>(m["Process"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeRefreshTaskByIdResponseBodyTasks() = default;
};
class DescribeRefreshTaskByIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRefreshTaskByIdResponseBodyTasks>> tasks{};
  shared_ptr<long> totalCount{};

  DescribeRefreshTaskByIdResponseBody() {}

  explicit DescribeRefreshTaskByIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<DescribeRefreshTaskByIdResponseBodyTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRefreshTaskByIdResponseBodyTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<DescribeRefreshTaskByIdResponseBodyTasks>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeRefreshTaskByIdResponseBody() = default;
};
class DescribeRefreshTaskByIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRefreshTaskByIdResponseBody> body{};

  DescribeRefreshTaskByIdResponse() {}

  explicit DescribeRefreshTaskByIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRefreshTaskByIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRefreshTaskByIdResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRefreshTaskByIdResponse() = default;
};
class DescribeRefreshTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> objectPath{};
  shared_ptr<string> objectType{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};

  DescribeRefreshTasksRequest() {}

  explicit DescribeRefreshTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (objectPath) {
      res["ObjectPath"] = boost::any(*objectPath);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ObjectPath") != m.end() && !m["ObjectPath"].empty()) {
      objectPath = make_shared<string>(boost::any_cast<string>(m["ObjectPath"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeRefreshTasksRequest() = default;
};
class DescribeRefreshTasksResponseBodyTasksCDNTask : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> objectPath{};
  shared_ptr<string> objectType{};
  shared_ptr<string> process{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};

  DescribeRefreshTasksResponseBodyTasksCDNTask() {}

  explicit DescribeRefreshTasksResponseBodyTasksCDNTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (objectPath) {
      res["ObjectPath"] = boost::any(*objectPath);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (process) {
      res["Process"] = boost::any(*process);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ObjectPath") != m.end() && !m["ObjectPath"].empty()) {
      objectPath = make_shared<string>(boost::any_cast<string>(m["ObjectPath"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("Process") != m.end() && !m["Process"].empty()) {
      process = make_shared<string>(boost::any_cast<string>(m["Process"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeRefreshTasksResponseBodyTasksCDNTask() = default;
};
class DescribeRefreshTasksResponseBodyTasks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRefreshTasksResponseBodyTasksCDNTask>> CDNTask{};

  DescribeRefreshTasksResponseBodyTasks() {}

  explicit DescribeRefreshTasksResponseBodyTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (CDNTask) {
      vector<boost::any> temp1;
      for(auto item1:*CDNTask){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CDNTask"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CDNTask") != m.end() && !m["CDNTask"].empty()) {
      if (typeid(vector<boost::any>) == m["CDNTask"].type()) {
        vector<DescribeRefreshTasksResponseBodyTasksCDNTask> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CDNTask"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRefreshTasksResponseBodyTasksCDNTask model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        CDNTask = make_shared<vector<DescribeRefreshTasksResponseBodyTasksCDNTask>>(expect1);
      }
    }
  }


  virtual ~DescribeRefreshTasksResponseBodyTasks() = default;
};
class DescribeRefreshTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRefreshTasksResponseBodyTasks> tasks{};
  shared_ptr<long> totalCount{};

  DescribeRefreshTasksResponseBody() {}

  explicit DescribeRefreshTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tasks) {
      res["Tasks"] = tasks ? boost::any(tasks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tasks"].type()) {
        DescribeRefreshTasksResponseBodyTasks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tasks"]));
        tasks = make_shared<DescribeRefreshTasksResponseBodyTasks>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeRefreshTasksResponseBody() = default;
};
class DescribeRefreshTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRefreshTasksResponseBody> body{};

  DescribeRefreshTasksResponse() {}

  explicit DescribeRefreshTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRefreshTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRefreshTasksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRefreshTasksResponse() = default;
};
class DescribeStagingIpResponseBodyIPV4s : public Darabonba::Model {
public:
  shared_ptr<vector<string>> IPV4{};

  DescribeStagingIpResponseBodyIPV4s() {}

  explicit DescribeStagingIpResponseBodyIPV4s(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IPV4) {
      res["IPV4"] = boost::any(*IPV4);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IPV4") != m.end() && !m["IPV4"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IPV4"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IPV4"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      IPV4 = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeStagingIpResponseBodyIPV4s() = default;
};
class DescribeStagingIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeStagingIpResponseBodyIPV4s> IPV4s{};
  shared_ptr<string> requestId{};

  DescribeStagingIpResponseBody() {}

  explicit DescribeStagingIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IPV4s) {
      res["IPV4s"] = IPV4s ? boost::any(IPV4s->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IPV4s") != m.end() && !m["IPV4s"].empty()) {
      if (typeid(map<string, boost::any>) == m["IPV4s"].type()) {
        DescribeStagingIpResponseBodyIPV4s model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IPV4s"]));
        IPV4s = make_shared<DescribeStagingIpResponseBodyIPV4s>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeStagingIpResponseBody() = default;
};
class DescribeStagingIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeStagingIpResponseBody> body{};

  DescribeStagingIpResponse() {}

  explicit DescribeStagingIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStagingIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStagingIpResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStagingIpResponse() = default;
};
class DescribeTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeTagResourcesRequestTag() {}

  explicit DescribeTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeTagResourcesRequestTag() = default;
};
class DescribeTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<DescribeTagResourcesRequestTag>> tag{};

  DescribeTagResourcesRequest() {}

  explicit DescribeTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeTagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeTagResourcesRequest() = default;
};
class DescribeTagResourcesResponseBodyTagResourcesTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeTagResourcesResponseBodyTagResourcesTag() {}

  explicit DescribeTagResourcesResponseBodyTagResourcesTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeTagResourcesResponseBodyTagResourcesTag() = default;
};
class DescribeTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<vector<DescribeTagResourcesResponseBodyTagResourcesTag>> tag{};

  DescribeTagResourcesResponseBodyTagResources() {}

  explicit DescribeTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeTagResourcesResponseBodyTagResourcesTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTagResourcesResponseBodyTagResourcesTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeTagResourcesResponseBodyTagResourcesTag>>(expect1);
      }
    }
  }


  virtual ~DescribeTagResourcesResponseBodyTagResources() = default;
};
class DescribeTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeTagResourcesResponseBodyTagResources>> tagResources{};

  DescribeTagResourcesResponseBody() {}

  explicit DescribeTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      vector<boost::any> temp1;
      for(auto item1:*tagResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResources"].type()) {
        vector<DescribeTagResourcesResponseBodyTagResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTagResourcesResponseBodyTagResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResources = make_shared<vector<DescribeTagResourcesResponseBodyTagResources>>(expect1);
      }
    }
  }


  virtual ~DescribeTagResourcesResponseBody() = default;
};
class DescribeTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTagResourcesResponseBody> body{};

  DescribeTagResourcesResponse() {}

  explicit DescribeTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTagResourcesResponse() = default;
};
class DescribeTopDomainsByFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> limit{};
  shared_ptr<string> startTime{};

  DescribeTopDomainsByFlowRequest() {}

  explicit DescribeTopDomainsByFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeTopDomainsByFlowRequest() = default;
};
class DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<double> maxBps{};
  shared_ptr<string> maxBpsTime{};
  shared_ptr<long> rank{};
  shared_ptr<long> totalAccess{};
  shared_ptr<string> totalTraffic{};
  shared_ptr<string> trafficPercent{};

  DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain() {}

  explicit DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (maxBps) {
      res["MaxBps"] = boost::any(*maxBps);
    }
    if (maxBpsTime) {
      res["MaxBpsTime"] = boost::any(*maxBpsTime);
    }
    if (rank) {
      res["Rank"] = boost::any(*rank);
    }
    if (totalAccess) {
      res["TotalAccess"] = boost::any(*totalAccess);
    }
    if (totalTraffic) {
      res["TotalTraffic"] = boost::any(*totalTraffic);
    }
    if (trafficPercent) {
      res["TrafficPercent"] = boost::any(*trafficPercent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("MaxBps") != m.end() && !m["MaxBps"].empty()) {
      maxBps = make_shared<double>(boost::any_cast<double>(m["MaxBps"]));
    }
    if (m.find("MaxBpsTime") != m.end() && !m["MaxBpsTime"].empty()) {
      maxBpsTime = make_shared<string>(boost::any_cast<string>(m["MaxBpsTime"]));
    }
    if (m.find("Rank") != m.end() && !m["Rank"].empty()) {
      rank = make_shared<long>(boost::any_cast<long>(m["Rank"]));
    }
    if (m.find("TotalAccess") != m.end() && !m["TotalAccess"].empty()) {
      totalAccess = make_shared<long>(boost::any_cast<long>(m["TotalAccess"]));
    }
    if (m.find("TotalTraffic") != m.end() && !m["TotalTraffic"].empty()) {
      totalTraffic = make_shared<string>(boost::any_cast<string>(m["TotalTraffic"]));
    }
    if (m.find("TrafficPercent") != m.end() && !m["TrafficPercent"].empty()) {
      trafficPercent = make_shared<string>(boost::any_cast<string>(m["TrafficPercent"]));
    }
  }


  virtual ~DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain() = default;
};
class DescribeTopDomainsByFlowResponseBodyTopDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain>> topDomain{};

  DescribeTopDomainsByFlowResponseBodyTopDomains() {}

  explicit DescribeTopDomainsByFlowResponseBodyTopDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topDomain) {
      vector<boost::any> temp1;
      for(auto item1:*topDomain){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopDomain"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TopDomain") != m.end() && !m["TopDomain"].empty()) {
      if (typeid(vector<boost::any>) == m["TopDomain"].type()) {
        vector<DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopDomain"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topDomain = make_shared<vector<DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain>>(expect1);
      }
    }
  }


  virtual ~DescribeTopDomainsByFlowResponseBodyTopDomains() = default;
};
class DescribeTopDomainsByFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> domainCount{};
  shared_ptr<long> domainOnlineCount{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeTopDomainsByFlowResponseBodyTopDomains> topDomains{};

  DescribeTopDomainsByFlowResponseBody() {}

  explicit DescribeTopDomainsByFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainCount) {
      res["DomainCount"] = boost::any(*domainCount);
    }
    if (domainOnlineCount) {
      res["DomainOnlineCount"] = boost::any(*domainOnlineCount);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (topDomains) {
      res["TopDomains"] = topDomains ? boost::any(topDomains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainCount") != m.end() && !m["DomainCount"].empty()) {
      domainCount = make_shared<long>(boost::any_cast<long>(m["DomainCount"]));
    }
    if (m.find("DomainOnlineCount") != m.end() && !m["DomainOnlineCount"].empty()) {
      domainOnlineCount = make_shared<long>(boost::any_cast<long>(m["DomainOnlineCount"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TopDomains") != m.end() && !m["TopDomains"].empty()) {
      if (typeid(map<string, boost::any>) == m["TopDomains"].type()) {
        DescribeTopDomainsByFlowResponseBodyTopDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TopDomains"]));
        topDomains = make_shared<DescribeTopDomainsByFlowResponseBodyTopDomains>(model1);
      }
    }
  }


  virtual ~DescribeTopDomainsByFlowResponseBody() = default;
};
class DescribeTopDomainsByFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTopDomainsByFlowResponseBody> body{};

  DescribeTopDomainsByFlowResponse() {}

  explicit DescribeTopDomainsByFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTopDomainsByFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTopDomainsByFlowResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTopDomainsByFlowResponse() = default;
};
class DescribeUserCertificateExpireCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> expireWithin30DaysCount{};
  shared_ptr<long> expiredCount{};
  shared_ptr<string> requestId{};

  DescribeUserCertificateExpireCountResponseBody() {}

  explicit DescribeUserCertificateExpireCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expireWithin30DaysCount) {
      res["ExpireWithin30DaysCount"] = boost::any(*expireWithin30DaysCount);
    }
    if (expiredCount) {
      res["ExpiredCount"] = boost::any(*expiredCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpireWithin30DaysCount") != m.end() && !m["ExpireWithin30DaysCount"].empty()) {
      expireWithin30DaysCount = make_shared<long>(boost::any_cast<long>(m["ExpireWithin30DaysCount"]));
    }
    if (m.find("ExpiredCount") != m.end() && !m["ExpiredCount"].empty()) {
      expiredCount = make_shared<long>(boost::any_cast<long>(m["ExpiredCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUserCertificateExpireCountResponseBody() = default;
};
class DescribeUserCertificateExpireCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserCertificateExpireCountResponseBody> body{};

  DescribeUserCertificateExpireCountResponse() {}

  explicit DescribeUserCertificateExpireCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserCertificateExpireCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserCertificateExpireCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserCertificateExpireCountResponse() = default;
};
class DescribeUserConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeUserConfigsRequest() {}

  explicit DescribeUserConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeUserConfigsRequest() = default;
};
class DescribeUserConfigsResponseBodyConfigsOssLogConfig : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> enable{};
  shared_ptr<string> prefix{};

  DescribeUserConfigsResponseBodyConfigsOssLogConfig() {}

  explicit DescribeUserConfigsResponseBodyConfigsOssLogConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (prefix) {
      res["Prefix"] = boost::any(*prefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("Prefix") != m.end() && !m["Prefix"].empty()) {
      prefix = make_shared<string>(boost::any_cast<string>(m["Prefix"]));
    }
  }


  virtual ~DescribeUserConfigsResponseBodyConfigsOssLogConfig() = default;
};
class DescribeUserConfigsResponseBodyConfigsWafConfig : public Darabonba::Model {
public:
  shared_ptr<string> enable{};

  DescribeUserConfigsResponseBodyConfigsWafConfig() {}

  explicit DescribeUserConfigsResponseBodyConfigsWafConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
  }


  virtual ~DescribeUserConfigsResponseBodyConfigsWafConfig() = default;
};
class DescribeUserConfigsResponseBodyConfigs : public Darabonba::Model {
public:
  shared_ptr<DescribeUserConfigsResponseBodyConfigsOssLogConfig> ossLogConfig{};
  shared_ptr<DescribeUserConfigsResponseBodyConfigsWafConfig> wafConfig{};

  DescribeUserConfigsResponseBodyConfigs() {}

  explicit DescribeUserConfigsResponseBodyConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ossLogConfig) {
      res["OssLogConfig"] = ossLogConfig ? boost::any(ossLogConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (wafConfig) {
      res["WafConfig"] = wafConfig ? boost::any(wafConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OssLogConfig") != m.end() && !m["OssLogConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OssLogConfig"].type()) {
        DescribeUserConfigsResponseBodyConfigsOssLogConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OssLogConfig"]));
        ossLogConfig = make_shared<DescribeUserConfigsResponseBodyConfigsOssLogConfig>(model1);
      }
    }
    if (m.find("WafConfig") != m.end() && !m["WafConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WafConfig"].type()) {
        DescribeUserConfigsResponseBodyConfigsWafConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WafConfig"]));
        wafConfig = make_shared<DescribeUserConfigsResponseBodyConfigsWafConfig>(model1);
      }
    }
  }


  virtual ~DescribeUserConfigsResponseBodyConfigs() = default;
};
class DescribeUserConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeUserConfigsResponseBodyConfigs> configs{};
  shared_ptr<string> requestId{};

  DescribeUserConfigsResponseBody() {}

  explicit DescribeUserConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configs) {
      res["Configs"] = configs ? boost::any(configs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Configs"].type()) {
        DescribeUserConfigsResponseBodyConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Configs"]));
        configs = make_shared<DescribeUserConfigsResponseBodyConfigs>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUserConfigsResponseBody() = default;
};
class DescribeUserConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserConfigsResponseBody> body{};

  DescribeUserConfigsResponse() {}

  explicit DescribeUserConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserConfigsResponse() = default;
};
class DescribeUserDomainsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeUserDomainsRequestTag() {}

  explicit DescribeUserDomainsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeUserDomainsRequestTag() = default;
};
class DescribeUserDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> cdnType{};
  shared_ptr<string> changeEndTime{};
  shared_ptr<string> changeStartTime{};
  shared_ptr<bool> checkDomainShow{};
  shared_ptr<string> coverage{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainSearchType{};
  shared_ptr<string> domainStatus{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> source{};
  shared_ptr<vector<DescribeUserDomainsRequestTag>> tag{};

  DescribeUserDomainsRequest() {}

  explicit DescribeUserDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdnType) {
      res["CdnType"] = boost::any(*cdnType);
    }
    if (changeEndTime) {
      res["ChangeEndTime"] = boost::any(*changeEndTime);
    }
    if (changeStartTime) {
      res["ChangeStartTime"] = boost::any(*changeStartTime);
    }
    if (checkDomainShow) {
      res["CheckDomainShow"] = boost::any(*checkDomainShow);
    }
    if (coverage) {
      res["Coverage"] = boost::any(*coverage);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainSearchType) {
      res["DomainSearchType"] = boost::any(*domainSearchType);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdnType") != m.end() && !m["CdnType"].empty()) {
      cdnType = make_shared<string>(boost::any_cast<string>(m["CdnType"]));
    }
    if (m.find("ChangeEndTime") != m.end() && !m["ChangeEndTime"].empty()) {
      changeEndTime = make_shared<string>(boost::any_cast<string>(m["ChangeEndTime"]));
    }
    if (m.find("ChangeStartTime") != m.end() && !m["ChangeStartTime"].empty()) {
      changeStartTime = make_shared<string>(boost::any_cast<string>(m["ChangeStartTime"]));
    }
    if (m.find("CheckDomainShow") != m.end() && !m["CheckDomainShow"].empty()) {
      checkDomainShow = make_shared<bool>(boost::any_cast<bool>(m["CheckDomainShow"]));
    }
    if (m.find("Coverage") != m.end() && !m["Coverage"].empty()) {
      coverage = make_shared<string>(boost::any_cast<string>(m["Coverage"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainSearchType") != m.end() && !m["DomainSearchType"].empty()) {
      domainSearchType = make_shared<string>(boost::any_cast<string>(m["DomainSearchType"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeUserDomainsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserDomainsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeUserDomainsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeUserDomainsRequest() = default;
};
class DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> port{};
  shared_ptr<string> priority{};
  shared_ptr<string> type{};
  shared_ptr<string> weight{};

  DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource() {}

  explicit DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<string>(boost::any_cast<string>(m["Weight"]));
    }
  }


  virtual ~DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource() = default;
};
class DescribeUserDomainsResponseBodyDomainsPageDataSources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource>> source{};

  DescribeUserDomainsResponseBodyDomainsPageDataSources() {}

  explicit DescribeUserDomainsResponseBodyDomainsPageDataSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      vector<boost::any> temp1;
      for(auto item1:*source){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Source"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      if (typeid(vector<boost::any>) == m["Source"].type()) {
        vector<DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Source"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        source = make_shared<vector<DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource>>(expect1);
      }
    }
  }


  virtual ~DescribeUserDomainsResponseBodyDomainsPageDataSources() = default;
};
class DescribeUserDomainsResponseBodyDomainsPageData : public Darabonba::Model {
public:
  shared_ptr<string> cdnType{};
  shared_ptr<string> cname{};
  shared_ptr<string> coverage{};
  shared_ptr<string> description{};
  shared_ptr<long> domainId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> gmtCreated{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> sandbox{};
  shared_ptr<DescribeUserDomainsResponseBodyDomainsPageDataSources> sources{};
  shared_ptr<string> sslProtocol{};

  DescribeUserDomainsResponseBodyDomainsPageData() {}

  explicit DescribeUserDomainsResponseBodyDomainsPageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cdnType) {
      res["CdnType"] = boost::any(*cdnType);
    }
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (coverage) {
      res["Coverage"] = boost::any(*coverage);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (sandbox) {
      res["Sandbox"] = boost::any(*sandbox);
    }
    if (sources) {
      res["Sources"] = sources ? boost::any(sources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sslProtocol) {
      res["SslProtocol"] = boost::any(*sslProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CdnType") != m.end() && !m["CdnType"].empty()) {
      cdnType = make_shared<string>(boost::any_cast<string>(m["CdnType"]));
    }
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Coverage") != m.end() && !m["Coverage"].empty()) {
      coverage = make_shared<string>(boost::any_cast<string>(m["Coverage"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<long>(boost::any_cast<long>(m["DomainId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<string>(boost::any_cast<string>(m["GmtCreated"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Sandbox") != m.end() && !m["Sandbox"].empty()) {
      sandbox = make_shared<string>(boost::any_cast<string>(m["Sandbox"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Sources"].type()) {
        DescribeUserDomainsResponseBodyDomainsPageDataSources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Sources"]));
        sources = make_shared<DescribeUserDomainsResponseBodyDomainsPageDataSources>(model1);
      }
    }
    if (m.find("SslProtocol") != m.end() && !m["SslProtocol"].empty()) {
      sslProtocol = make_shared<string>(boost::any_cast<string>(m["SslProtocol"]));
    }
  }


  virtual ~DescribeUserDomainsResponseBodyDomainsPageData() = default;
};
class DescribeUserDomainsResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUserDomainsResponseBodyDomainsPageData>> pageData{};

  DescribeUserDomainsResponseBodyDomains() {}

  explicit DescribeUserDomainsResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageData) {
      vector<boost::any> temp1;
      for(auto item1:*pageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageData") != m.end() && !m["PageData"].empty()) {
      if (typeid(vector<boost::any>) == m["PageData"].type()) {
        vector<DescribeUserDomainsResponseBodyDomainsPageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserDomainsResponseBodyDomainsPageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pageData = make_shared<vector<DescribeUserDomainsResponseBodyDomainsPageData>>(expect1);
      }
    }
  }


  virtual ~DescribeUserDomainsResponseBodyDomains() = default;
};
class DescribeUserDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeUserDomainsResponseBodyDomains> domains{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeUserDomainsResponseBody() {}

  explicit DescribeUserDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = domains ? boost::any(domains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(map<string, boost::any>) == m["Domains"].type()) {
        DescribeUserDomainsResponseBodyDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Domains"]));
        domains = make_shared<DescribeUserDomainsResponseBodyDomains>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeUserDomainsResponseBody() = default;
};
class DescribeUserDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserDomainsResponseBody> body{};

  DescribeUserDomainsResponse() {}

  explicit DescribeUserDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserDomainsResponse() = default;
};
class DescribeUserTagsResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> value{};

  DescribeUserTagsResponseBodyTags() {}

  explicit DescribeUserTagsResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Value"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      value = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeUserTagsResponseBodyTags() = default;
};
class DescribeUserTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeUserTagsResponseBodyTags>> tags{};

  DescribeUserTagsResponseBody() {}

  explicit DescribeUserTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeUserTagsResponseBodyTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserTagsResponseBodyTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeUserTagsResponseBodyTags>>(expect1);
      }
    }
  }


  virtual ~DescribeUserTagsResponseBody() = default;
};
class DescribeUserTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserTagsResponseBody> body{};

  DescribeUserTagsResponse() {}

  explicit DescribeUserTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserTagsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserTagsResponse() = default;
};
class DescribeUserUsageDataExportTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};

  DescribeUserUsageDataExportTaskRequest() {}

  explicit DescribeUserUsageDataExportTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
  }


  virtual ~DescribeUserUsageDataExportTaskRequest() = default;
};
class DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig() {}

  explicit DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig() = default;
};
class DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> status{};
  shared_ptr<DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig> taskConfig{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> updateTime{};

  DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem() {}

  explicit DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskConfig) {
      res["TaskConfig"] = taskConfig ? boost::any(taskConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskConfig") != m.end() && !m["TaskConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskConfig"].type()) {
        DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskConfig"]));
        taskConfig = make_shared<DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig>(model1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem() = default;
};
class DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem>> dataItem{};

  DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageData() {}

  explicit DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataItem) {
      vector<boost::any> temp1;
      for(auto item1:*dataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataItem") != m.end() && !m["DataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["DataItem"].type()) {
        vector<DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataItem = make_shared<vector<DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageData() = default;
};
class DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage : public Darabonba::Model {
public:
  shared_ptr<DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageData> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage() {}

  explicit DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageData>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage() = default;
};
class DescribeUserUsageDataExportTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage> usageDataPerPage{};

  DescribeUserUsageDataExportTaskResponseBody() {}

  explicit DescribeUserUsageDataExportTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (usageDataPerPage) {
      res["UsageDataPerPage"] = usageDataPerPage ? boost::any(usageDataPerPage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UsageDataPerPage") != m.end() && !m["UsageDataPerPage"].empty()) {
      if (typeid(map<string, boost::any>) == m["UsageDataPerPage"].type()) {
        DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UsageDataPerPage"]));
        usageDataPerPage = make_shared<DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage>(model1);
      }
    }
  }


  virtual ~DescribeUserUsageDataExportTaskResponseBody() = default;
};
class DescribeUserUsageDataExportTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserUsageDataExportTaskResponseBody> body{};

  DescribeUserUsageDataExportTaskResponse() {}

  explicit DescribeUserUsageDataExportTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserUsageDataExportTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserUsageDataExportTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserUsageDataExportTaskResponse() = default;
};
class DescribeUserUsageDetailDataExportTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};

  DescribeUserUsageDetailDataExportTaskRequest() {}

  explicit DescribeUserUsageDetailDataExportTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
  }


  virtual ~DescribeUserUsageDetailDataExportTaskRequest() = default;
};
class DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig() {}

  explicit DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig() = default;
};
class DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> status{};
  shared_ptr<DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig> taskConfig{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> updateTime{};

  DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem() {}

  explicit DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskConfig) {
      res["TaskConfig"] = taskConfig ? boost::any(taskConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskConfig") != m.end() && !m["TaskConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskConfig"].type()) {
        DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskConfig"]));
        taskConfig = make_shared<DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig>(model1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem() = default;
};
class DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem>> dataItem{};

  DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageData() {}

  explicit DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataItem) {
      vector<boost::any> temp1;
      for(auto item1:*dataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataItem") != m.end() && !m["DataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["DataItem"].type()) {
        vector<DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataItem = make_shared<vector<DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageData() = default;
};
class DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage : public Darabonba::Model {
public:
  shared_ptr<DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageData> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage() {}

  explicit DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageData>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage() = default;
};
class DescribeUserUsageDetailDataExportTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage> usageDataPerPage{};

  DescribeUserUsageDetailDataExportTaskResponseBody() {}

  explicit DescribeUserUsageDetailDataExportTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (usageDataPerPage) {
      res["UsageDataPerPage"] = usageDataPerPage ? boost::any(usageDataPerPage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UsageDataPerPage") != m.end() && !m["UsageDataPerPage"].empty()) {
      if (typeid(map<string, boost::any>) == m["UsageDataPerPage"].type()) {
        DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UsageDataPerPage"]));
        usageDataPerPage = make_shared<DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage>(model1);
      }
    }
  }


  virtual ~DescribeUserUsageDetailDataExportTaskResponseBody() = default;
};
class DescribeUserUsageDetailDataExportTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserUsageDetailDataExportTaskResponseBody> body{};

  DescribeUserUsageDetailDataExportTaskResponse() {}

  explicit DescribeUserUsageDetailDataExportTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserUsageDetailDataExportTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserUsageDetailDataExportTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserUsageDetailDataExportTaskResponse() = default;
};
class DescribeUserVipsByDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> available{};
  shared_ptr<string> domainName{};

  DescribeUserVipsByDomainRequest() {}

  explicit DescribeUserVipsByDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (available) {
      res["Available"] = boost::any(*available);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Available") != m.end() && !m["Available"].empty()) {
      available = make_shared<string>(boost::any_cast<string>(m["Available"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeUserVipsByDomainRequest() = default;
};
class DescribeUserVipsByDomainResponseBodyVips : public Darabonba::Model {
public:
  shared_ptr<vector<string>> vip{};

  DescribeUserVipsByDomainResponseBodyVips() {}

  explicit DescribeUserVipsByDomainResponseBodyVips(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vip) {
      res["Vip"] = boost::any(*vip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Vip") != m.end() && !m["Vip"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Vip"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Vip"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vip = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeUserVipsByDomainResponseBodyVips() = default;
};
class DescribeUserVipsByDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeUserVipsByDomainResponseBodyVips> vips{};

  DescribeUserVipsByDomainResponseBody() {}

  explicit DescribeUserVipsByDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vips) {
      res["Vips"] = vips ? boost::any(vips->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Vips") != m.end() && !m["Vips"].empty()) {
      if (typeid(map<string, boost::any>) == m["Vips"].type()) {
        DescribeUserVipsByDomainResponseBodyVips model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Vips"]));
        vips = make_shared<DescribeUserVipsByDomainResponseBodyVips>(model1);
      }
    }
  }


  virtual ~DescribeUserVipsByDomainResponseBody() = default;
};
class DescribeUserVipsByDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserVipsByDomainResponseBody> body{};

  DescribeUserVipsByDomainResponse() {}

  explicit DescribeUserVipsByDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserVipsByDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserVipsByDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserVipsByDomainResponse() = default;
};
class DescribeVerifyContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};

  DescribeVerifyContentRequest() {}

  explicit DescribeVerifyContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeVerifyContentRequest() = default;
};
class DescribeVerifyContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  DescribeVerifyContentResponseBody() {}

  explicit DescribeVerifyContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVerifyContentResponseBody() = default;
};
class DescribeVerifyContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVerifyContentResponseBody> body{};

  DescribeVerifyContentResponse() {}

  explicit DescribeVerifyContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVerifyContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVerifyContentResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVerifyContentResponse() = default;
};
class DisableRealtimeLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};

  DisableRealtimeLogDeliveryRequest() {}

  explicit DisableRealtimeLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
  }


  virtual ~DisableRealtimeLogDeliveryRequest() = default;
};
class DisableRealtimeLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableRealtimeLogDeliveryResponseBody() {}

  explicit DisableRealtimeLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableRealtimeLogDeliveryResponseBody() = default;
};
class DisableRealtimeLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableRealtimeLogDeliveryResponseBody> body{};

  DisableRealtimeLogDeliveryResponse() {}

  explicit DisableRealtimeLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableRealtimeLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableRealtimeLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~DisableRealtimeLogDeliveryResponse() = default;
};
class EnableRealtimeLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};

  EnableRealtimeLogDeliveryRequest() {}

  explicit EnableRealtimeLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
  }


  virtual ~EnableRealtimeLogDeliveryRequest() = default;
};
class EnableRealtimeLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableRealtimeLogDeliveryResponseBody() {}

  explicit EnableRealtimeLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableRealtimeLogDeliveryResponseBody() = default;
};
class EnableRealtimeLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableRealtimeLogDeliveryResponseBody> body{};

  EnableRealtimeLogDeliveryResponse() {}

  explicit EnableRealtimeLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableRealtimeLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableRealtimeLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~EnableRealtimeLogDeliveryResponse() = default;
};
class ListDomainsByLogConfigIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> configId{};

  ListDomainsByLogConfigIdRequest() {}

  explicit ListDomainsByLogConfigIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
  }


  virtual ~ListDomainsByLogConfigIdRequest() = default;
};
class ListDomainsByLogConfigIdResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<vector<string>> domain{};

  ListDomainsByLogConfigIdResponseBodyDomains() {}

  explicit ListDomainsByLogConfigIdResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Domain"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Domain"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domain = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDomainsByLogConfigIdResponseBodyDomains() = default;
};
class ListDomainsByLogConfigIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDomainsByLogConfigIdResponseBodyDomains> domains{};
  shared_ptr<string> requestId{};

  ListDomainsByLogConfigIdResponseBody() {}

  explicit ListDomainsByLogConfigIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = domains ? boost::any(domains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(map<string, boost::any>) == m["Domains"].type()) {
        ListDomainsByLogConfigIdResponseBodyDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Domains"]));
        domains = make_shared<ListDomainsByLogConfigIdResponseBodyDomains>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDomainsByLogConfigIdResponseBody() = default;
};
class ListDomainsByLogConfigIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDomainsByLogConfigIdResponseBody> body{};

  ListDomainsByLogConfigIdResponse() {}

  explicit ListDomainsByLogConfigIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDomainsByLogConfigIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDomainsByLogConfigIdResponseBody>(model1);
      }
    }
  }


  virtual ~ListDomainsByLogConfigIdResponse() = default;
};
class ListFCTriggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> eventMetaName{};
  shared_ptr<string> eventMetaVersion{};

  ListFCTriggerRequest() {}

  explicit ListFCTriggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventMetaName) {
      res["EventMetaName"] = boost::any(*eventMetaName);
    }
    if (eventMetaVersion) {
      res["EventMetaVersion"] = boost::any(*eventMetaVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventMetaName") != m.end() && !m["EventMetaName"].empty()) {
      eventMetaName = make_shared<string>(boost::any_cast<string>(m["EventMetaName"]));
    }
    if (m.find("EventMetaVersion") != m.end() && !m["EventMetaVersion"].empty()) {
      eventMetaVersion = make_shared<string>(boost::any_cast<string>(m["EventMetaVersion"]));
    }
  }


  virtual ~ListFCTriggerRequest() = default;
};
class ListFCTriggerResponseBodyFCTriggers : public Darabonba::Model {
public:
  shared_ptr<string> eventMetaName{};
  shared_ptr<string> eventMetaVersion{};
  shared_ptr<string> notes{};
  shared_ptr<string> roleARN{};
  shared_ptr<string> sourceArn{};
  shared_ptr<string> triggerARN{};

  ListFCTriggerResponseBodyFCTriggers() {}

  explicit ListFCTriggerResponseBodyFCTriggers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventMetaName) {
      res["EventMetaName"] = boost::any(*eventMetaName);
    }
    if (eventMetaVersion) {
      res["EventMetaVersion"] = boost::any(*eventMetaVersion);
    }
    if (notes) {
      res["Notes"] = boost::any(*notes);
    }
    if (roleARN) {
      res["RoleARN"] = boost::any(*roleARN);
    }
    if (sourceArn) {
      res["SourceArn"] = boost::any(*sourceArn);
    }
    if (triggerARN) {
      res["TriggerARN"] = boost::any(*triggerARN);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventMetaName") != m.end() && !m["EventMetaName"].empty()) {
      eventMetaName = make_shared<string>(boost::any_cast<string>(m["EventMetaName"]));
    }
    if (m.find("EventMetaVersion") != m.end() && !m["EventMetaVersion"].empty()) {
      eventMetaVersion = make_shared<string>(boost::any_cast<string>(m["EventMetaVersion"]));
    }
    if (m.find("Notes") != m.end() && !m["Notes"].empty()) {
      notes = make_shared<string>(boost::any_cast<string>(m["Notes"]));
    }
    if (m.find("RoleARN") != m.end() && !m["RoleARN"].empty()) {
      roleARN = make_shared<string>(boost::any_cast<string>(m["RoleARN"]));
    }
    if (m.find("SourceArn") != m.end() && !m["SourceArn"].empty()) {
      sourceArn = make_shared<string>(boost::any_cast<string>(m["SourceArn"]));
    }
    if (m.find("TriggerARN") != m.end() && !m["TriggerARN"].empty()) {
      triggerARN = make_shared<string>(boost::any_cast<string>(m["TriggerARN"]));
    }
  }


  virtual ~ListFCTriggerResponseBodyFCTriggers() = default;
};
class ListFCTriggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListFCTriggerResponseBodyFCTriggers>> FCTriggers{};
  shared_ptr<string> requestId{};

  ListFCTriggerResponseBody() {}

  explicit ListFCTriggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (FCTriggers) {
      vector<boost::any> temp1;
      for(auto item1:*FCTriggers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FCTriggers"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FCTriggers") != m.end() && !m["FCTriggers"].empty()) {
      if (typeid(vector<boost::any>) == m["FCTriggers"].type()) {
        vector<ListFCTriggerResponseBodyFCTriggers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FCTriggers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFCTriggerResponseBodyFCTriggers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        FCTriggers = make_shared<vector<ListFCTriggerResponseBodyFCTriggers>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListFCTriggerResponseBody() = default;
};
class ListFCTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFCTriggerResponseBody> body{};

  ListFCTriggerResponse() {}

  explicit ListFCTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFCTriggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFCTriggerResponseBody>(model1);
      }
    }
  }


  virtual ~ListFCTriggerResponse() = default;
};
class ListRealtimeLogDeliveryDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> logstore{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};

  ListRealtimeLogDeliveryDomainsRequest() {}

  explicit ListRealtimeLogDeliveryDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~ListRealtimeLogDeliveryDomainsRequest() = default;
};
class ListRealtimeLogDeliveryDomainsResponseBodyContentDomains : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> status{};

  ListRealtimeLogDeliveryDomainsResponseBodyContentDomains() {}

  explicit ListRealtimeLogDeliveryDomainsResponseBodyContentDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListRealtimeLogDeliveryDomainsResponseBodyContentDomains() = default;
};
class ListRealtimeLogDeliveryDomainsResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<vector<ListRealtimeLogDeliveryDomainsResponseBodyContentDomains>> domains{};

  ListRealtimeLogDeliveryDomainsResponseBodyContent() {}

  explicit ListRealtimeLogDeliveryDomainsResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      vector<boost::any> temp1;
      for(auto item1:*domains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Domains"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<ListRealtimeLogDeliveryDomainsResponseBodyContentDomains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Domains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRealtimeLogDeliveryDomainsResponseBodyContentDomains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domains = make_shared<vector<ListRealtimeLogDeliveryDomainsResponseBodyContentDomains>>(expect1);
      }
    }
  }


  virtual ~ListRealtimeLogDeliveryDomainsResponseBodyContent() = default;
};
class ListRealtimeLogDeliveryDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListRealtimeLogDeliveryDomainsResponseBodyContent> content{};
  shared_ptr<string> requestId{};

  ListRealtimeLogDeliveryDomainsResponseBody() {}

  explicit ListRealtimeLogDeliveryDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        ListRealtimeLogDeliveryDomainsResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<ListRealtimeLogDeliveryDomainsResponseBodyContent>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListRealtimeLogDeliveryDomainsResponseBody() = default;
};
class ListRealtimeLogDeliveryDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRealtimeLogDeliveryDomainsResponseBody> body{};

  ListRealtimeLogDeliveryDomainsResponse() {}

  explicit ListRealtimeLogDeliveryDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRealtimeLogDeliveryDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRealtimeLogDeliveryDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~ListRealtimeLogDeliveryDomainsResponse() = default;
};
class ListRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos : public Darabonba::Model {
public:
  shared_ptr<string> logstore{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};

  ListRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos() {}

  explicit ListRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~ListRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos() = default;
};
class ListRealtimeLogDeliveryInfosResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<vector<ListRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos>> realtimeLogDeliveryInfos{};

  ListRealtimeLogDeliveryInfosResponseBodyContent() {}

  explicit ListRealtimeLogDeliveryInfosResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (realtimeLogDeliveryInfos) {
      vector<boost::any> temp1;
      for(auto item1:*realtimeLogDeliveryInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RealtimeLogDeliveryInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RealtimeLogDeliveryInfos") != m.end() && !m["RealtimeLogDeliveryInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["RealtimeLogDeliveryInfos"].type()) {
        vector<ListRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RealtimeLogDeliveryInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        realtimeLogDeliveryInfos = make_shared<vector<ListRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos>>(expect1);
      }
    }
  }


  virtual ~ListRealtimeLogDeliveryInfosResponseBodyContent() = default;
};
class ListRealtimeLogDeliveryInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListRealtimeLogDeliveryInfosResponseBodyContent> content{};
  shared_ptr<string> requestId{};

  ListRealtimeLogDeliveryInfosResponseBody() {}

  explicit ListRealtimeLogDeliveryInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        ListRealtimeLogDeliveryInfosResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<ListRealtimeLogDeliveryInfosResponseBodyContent>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListRealtimeLogDeliveryInfosResponseBody() = default;
};
class ListRealtimeLogDeliveryInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRealtimeLogDeliveryInfosResponseBody> body{};

  ListRealtimeLogDeliveryInfosResponse() {}

  explicit ListRealtimeLogDeliveryInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRealtimeLogDeliveryInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRealtimeLogDeliveryInfosResponseBody>(model1);
      }
    }
  }


  virtual ~ListRealtimeLogDeliveryInfosResponse() = default;
};
class ListTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesRequestTag() {}

  explicit ListTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesRequestTag() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<ListTagResourcesRequestTag>> tag{};
  shared_ptr<string> tagOwnerBid{};
  shared_ptr<string> tagOwnerUid{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (tagOwnerBid) {
      res["TagOwnerBid"] = boost::any(*tagOwnerBid);
    }
    if (tagOwnerUid) {
      res["TagOwnerUid"] = boost::any(*tagOwnerUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListTagResourcesRequestTag>>(expect1);
      }
    }
    if (m.find("TagOwnerBid") != m.end() && !m["TagOwnerBid"].empty()) {
      tagOwnerBid = make_shared<string>(boost::any_cast<string>(m["TagOwnerBid"]));
    }
    if (m.find("TagOwnerUid") != m.end() && !m["TagOwnerUid"].empty()) {
      tagOwnerUid = make_shared<string>(boost::any_cast<string>(m["TagOwnerUid"]));
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResourcesTagResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResourcesTagResource() {}

  explicit ListTagResourcesResponseBodyTagResourcesTagResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResourcesTagResource() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<vector<ListTagResourcesResponseBodyTagResourcesTagResource>> tagResource{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagResource) {
      vector<boost::any> temp1;
      for(auto item1:*tagResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagResource") != m.end() && !m["TagResource"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResource"].type()) {
        vector<ListTagResourcesResponseBodyTagResourcesTagResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResourcesTagResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResource = make_shared<vector<ListTagResourcesResponseBodyTagResourcesTagResource>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<ListTagResourcesResponseBodyTagResources> tagResources{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      res["TagResources"] = tagResources ? boost::any(tagResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagResources"].type()) {
        ListTagResourcesResponseBodyTagResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagResources"]));
        tagResources = make_shared<ListTagResourcesResponseBodyTagResources>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ListUserCustomLogConfigResponseBodyConfigIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> configId{};

  ListUserCustomLogConfigResponseBodyConfigIds() {}

  explicit ListUserCustomLogConfigResponseBodyConfigIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ConfigId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ConfigId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      configId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListUserCustomLogConfigResponseBodyConfigIds() = default;
};
class ListUserCustomLogConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListUserCustomLogConfigResponseBodyConfigIds> configIds{};
  shared_ptr<string> requestId{};

  ListUserCustomLogConfigResponseBody() {}

  explicit ListUserCustomLogConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configIds) {
      res["ConfigIds"] = configIds ? boost::any(configIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigIds") != m.end() && !m["ConfigIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigIds"].type()) {
        ListUserCustomLogConfigResponseBodyConfigIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigIds"]));
        configIds = make_shared<ListUserCustomLogConfigResponseBodyConfigIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListUserCustomLogConfigResponseBody() = default;
};
class ListUserCustomLogConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUserCustomLogConfigResponseBody> body{};

  ListUserCustomLogConfigResponse() {}

  explicit ListUserCustomLogConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUserCustomLogConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUserCustomLogConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ListUserCustomLogConfigResponse() = default;
};
class ModifyCdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> sources{};
  shared_ptr<string> topLevelDomain{};

  ModifyCdnDomainRequest() {}

  explicit ModifyCdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (sources) {
      res["Sources"] = boost::any(*sources);
    }
    if (topLevelDomain) {
      res["TopLevelDomain"] = boost::any(*topLevelDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sources = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
    if (m.find("TopLevelDomain") != m.end() && !m["TopLevelDomain"].empty()) {
      topLevelDomain = make_shared<string>(boost::any_cast<string>(m["TopLevelDomain"]));
    }
  }


  virtual ~ModifyCdnDomainRequest() = default;
};
class ModifyCdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyCdnDomainResponseBody() {}

  explicit ModifyCdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCdnDomainResponseBody() = default;
};
class ModifyCdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCdnDomainResponseBody> body{};

  ModifyCdnDomainResponse() {}

  explicit ModifyCdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCdnDomainResponse() = default;
};
class ModifyCdnDomainOwnerRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  ModifyCdnDomainOwnerRequest() {}

  explicit ModifyCdnDomainOwnerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ModifyCdnDomainOwnerRequest() = default;
};
class ModifyCdnDomainOwnerResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  ModifyCdnDomainOwnerResponseBody() {}

  explicit ModifyCdnDomainOwnerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCdnDomainOwnerResponseBody() = default;
};
class ModifyCdnDomainOwnerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCdnDomainOwnerResponseBody> body{};

  ModifyCdnDomainOwnerResponse() {}

  explicit ModifyCdnDomainOwnerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCdnDomainOwnerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCdnDomainOwnerResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCdnDomainOwnerResponse() = default;
};
class ModifyCdnDomainSchdmByPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> property{};

  ModifyCdnDomainSchdmByPropertyRequest() {}

  explicit ModifyCdnDomainSchdmByPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (property) {
      res["Property"] = boost::any(*property);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      property = make_shared<string>(boost::any_cast<string>(m["Property"]));
    }
  }


  virtual ~ModifyCdnDomainSchdmByPropertyRequest() = default;
};
class ModifyCdnDomainSchdmByPropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyCdnDomainSchdmByPropertyResponseBody() {}

  explicit ModifyCdnDomainSchdmByPropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCdnDomainSchdmByPropertyResponseBody() = default;
};
class ModifyCdnDomainSchdmByPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCdnDomainSchdmByPropertyResponseBody> body{};

  ModifyCdnDomainSchdmByPropertyResponse() {}

  explicit ModifyCdnDomainSchdmByPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCdnDomainSchdmByPropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCdnDomainSchdmByPropertyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCdnDomainSchdmByPropertyResponse() = default;
};
class ModifyRealtimeLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> logstore{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};

  ModifyRealtimeLogDeliveryRequest() {}

  explicit ModifyRealtimeLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~ModifyRealtimeLogDeliveryRequest() = default;
};
class ModifyRealtimeLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyRealtimeLogDeliveryResponseBody() {}

  explicit ModifyRealtimeLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyRealtimeLogDeliveryResponseBody() = default;
};
class ModifyRealtimeLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyRealtimeLogDeliveryResponseBody> body{};

  ModifyRealtimeLogDeliveryResponse() {}

  explicit ModifyRealtimeLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyRealtimeLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyRealtimeLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyRealtimeLogDeliveryResponse() = default;
};
class OpenCdnServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> internetChargeType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  OpenCdnServiceRequest() {}

  explicit OpenCdnServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~OpenCdnServiceRequest() = default;
};
class OpenCdnServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  OpenCdnServiceResponseBody() {}

  explicit OpenCdnServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OpenCdnServiceResponseBody() = default;
};
class OpenCdnServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenCdnServiceResponseBody> body{};

  OpenCdnServiceResponse() {}

  explicit OpenCdnServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenCdnServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenCdnServiceResponseBody>(model1);
      }
    }
  }


  virtual ~OpenCdnServiceResponse() = default;
};
class PublishStagingConfigToProductionRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};

  PublishStagingConfigToProductionRequest() {}

  explicit PublishStagingConfigToProductionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~PublishStagingConfigToProductionRequest() = default;
};
class PublishStagingConfigToProductionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  PublishStagingConfigToProductionResponseBody() {}

  explicit PublishStagingConfigToProductionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PublishStagingConfigToProductionResponseBody() = default;
};
class PublishStagingConfigToProductionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PublishStagingConfigToProductionResponseBody> body{};

  PublishStagingConfigToProductionResponse() {}

  explicit PublishStagingConfigToProductionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishStagingConfigToProductionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishStagingConfigToProductionResponseBody>(model1);
      }
    }
  }


  virtual ~PublishStagingConfigToProductionResponse() = default;
};
class PushObjectCacheRequest : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<bool> l2Preload{};
  shared_ptr<string> objectPath{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> withHeader{};

  PushObjectCacheRequest() {}

  explicit PushObjectCacheRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (l2Preload) {
      res["L2Preload"] = boost::any(*l2Preload);
    }
    if (objectPath) {
      res["ObjectPath"] = boost::any(*objectPath);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (withHeader) {
      res["WithHeader"] = boost::any(*withHeader);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("L2Preload") != m.end() && !m["L2Preload"].empty()) {
      l2Preload = make_shared<bool>(boost::any_cast<bool>(m["L2Preload"]));
    }
    if (m.find("ObjectPath") != m.end() && !m["ObjectPath"].empty()) {
      objectPath = make_shared<string>(boost::any_cast<string>(m["ObjectPath"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("WithHeader") != m.end() && !m["WithHeader"].empty()) {
      withHeader = make_shared<string>(boost::any_cast<string>(m["WithHeader"]));
    }
  }


  virtual ~PushObjectCacheRequest() = default;
};
class PushObjectCacheResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> pushTaskId{};
  shared_ptr<string> requestId{};

  PushObjectCacheResponseBody() {}

  explicit PushObjectCacheResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pushTaskId) {
      res["PushTaskId"] = boost::any(*pushTaskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PushTaskId") != m.end() && !m["PushTaskId"].empty()) {
      pushTaskId = make_shared<string>(boost::any_cast<string>(m["PushTaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PushObjectCacheResponseBody() = default;
};
class PushObjectCacheResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PushObjectCacheResponseBody> body{};

  PushObjectCacheResponse() {}

  explicit PushObjectCacheResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PushObjectCacheResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PushObjectCacheResponseBody>(model1);
      }
    }
  }


  virtual ~PushObjectCacheResponse() = default;
};
class RefreshObjectCachesRequest : public Darabonba::Model {
public:
  shared_ptr<string> objectPath{};
  shared_ptr<string> objectType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  RefreshObjectCachesRequest() {}

  explicit RefreshObjectCachesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (objectPath) {
      res["ObjectPath"] = boost::any(*objectPath);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ObjectPath") != m.end() && !m["ObjectPath"].empty()) {
      objectPath = make_shared<string>(boost::any_cast<string>(m["ObjectPath"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~RefreshObjectCachesRequest() = default;
};
class RefreshObjectCachesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> refreshTaskId{};
  shared_ptr<string> requestId{};

  RefreshObjectCachesResponseBody() {}

  explicit RefreshObjectCachesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (refreshTaskId) {
      res["RefreshTaskId"] = boost::any(*refreshTaskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RefreshTaskId") != m.end() && !m["RefreshTaskId"].empty()) {
      refreshTaskId = make_shared<string>(boost::any_cast<string>(m["RefreshTaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RefreshObjectCachesResponseBody() = default;
};
class RefreshObjectCachesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefreshObjectCachesResponseBody> body{};

  RefreshObjectCachesResponse() {}

  explicit RefreshObjectCachesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefreshObjectCachesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefreshObjectCachesResponseBody>(model1);
      }
    }
  }


  virtual ~RefreshObjectCachesResponse() = default;
};
class RollbackStagingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};

  RollbackStagingConfigRequest() {}

  explicit RollbackStagingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~RollbackStagingConfigRequest() = default;
};
class RollbackStagingConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RollbackStagingConfigResponseBody() {}

  explicit RollbackStagingConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RollbackStagingConfigResponseBody() = default;
};
class RollbackStagingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RollbackStagingConfigResponseBody> body{};

  RollbackStagingConfigResponse() {}

  explicit RollbackStagingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RollbackStagingConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RollbackStagingConfigResponseBody>(model1);
      }
    }
  }


  virtual ~RollbackStagingConfigResponse() = default;
};
class SetCdnDomainCSRCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> serverCertificate{};

  SetCdnDomainCSRCertificateRequest() {}

  explicit SetCdnDomainCSRCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (serverCertificate) {
      res["ServerCertificate"] = boost::any(*serverCertificate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ServerCertificate") != m.end() && !m["ServerCertificate"].empty()) {
      serverCertificate = make_shared<string>(boost::any_cast<string>(m["ServerCertificate"]));
    }
  }


  virtual ~SetCdnDomainCSRCertificateRequest() = default;
};
class SetCdnDomainCSRCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetCdnDomainCSRCertificateResponseBody() {}

  explicit SetCdnDomainCSRCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetCdnDomainCSRCertificateResponseBody() = default;
};
class SetCdnDomainCSRCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetCdnDomainCSRCertificateResponseBody> body{};

  SetCdnDomainCSRCertificateResponse() {}

  explicit SetCdnDomainCSRCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetCdnDomainCSRCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetCdnDomainCSRCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~SetCdnDomainCSRCertificateResponse() = default;
};
class SetCdnDomainSMCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> certIdentifier{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> securityToken{};

  SetCdnDomainSMCertificateRequest() {}

  explicit SetCdnDomainSMCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certIdentifier) {
      res["CertIdentifier"] = boost::any(*certIdentifier);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertIdentifier") != m.end() && !m["CertIdentifier"].empty()) {
      certIdentifier = make_shared<string>(boost::any_cast<string>(m["CertIdentifier"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SetCdnDomainSMCertificateRequest() = default;
};
class SetCdnDomainSMCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetCdnDomainSMCertificateResponseBody() {}

  explicit SetCdnDomainSMCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetCdnDomainSMCertificateResponseBody() = default;
};
class SetCdnDomainSMCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetCdnDomainSMCertificateResponseBody> body{};

  SetCdnDomainSMCertificateResponse() {}

  explicit SetCdnDomainSMCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetCdnDomainSMCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetCdnDomainSMCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~SetCdnDomainSMCertificateResponse() = default;
};
class SetCdnDomainSSLCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<long> certId{};
  shared_ptr<string> certName{};
  shared_ptr<string> certRegion{};
  shared_ptr<string> certType{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> SSLPri{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> SSLPub{};
  shared_ptr<string> securityToken{};

  SetCdnDomainSSLCertificateRequest() {}

  explicit SetCdnDomainSSLCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certRegion) {
      res["CertRegion"] = boost::any(*certRegion);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (SSLPri) {
      res["SSLPri"] = boost::any(*SSLPri);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<long>(boost::any_cast<long>(m["CertId"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertRegion") != m.end() && !m["CertRegion"].empty()) {
      certRegion = make_shared<string>(boost::any_cast<string>(m["CertRegion"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SSLPri") != m.end() && !m["SSLPri"].empty()) {
      SSLPri = make_shared<string>(boost::any_cast<string>(m["SSLPri"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SetCdnDomainSSLCertificateRequest() = default;
};
class SetCdnDomainSSLCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetCdnDomainSSLCertificateResponseBody() {}

  explicit SetCdnDomainSSLCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetCdnDomainSSLCertificateResponseBody() = default;
};
class SetCdnDomainSSLCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetCdnDomainSSLCertificateResponseBody> body{};

  SetCdnDomainSSLCertificateResponse() {}

  explicit SetCdnDomainSSLCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetCdnDomainSSLCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetCdnDomainSSLCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~SetCdnDomainSSLCertificateResponse() = default;
};
class SetCdnDomainStagingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> functions{};

  SetCdnDomainStagingConfigRequest() {}

  explicit SetCdnDomainStagingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functions) {
      res["Functions"] = boost::any(*functions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Functions") != m.end() && !m["Functions"].empty()) {
      functions = make_shared<string>(boost::any_cast<string>(m["Functions"]));
    }
  }


  virtual ~SetCdnDomainStagingConfigRequest() = default;
};
class SetCdnDomainStagingConfigResponseBodyDomainConfigList : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> functionName{};

  SetCdnDomainStagingConfigResponseBodyDomainConfigList() {}

  explicit SetCdnDomainStagingConfigResponseBodyDomainConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
  }


  virtual ~SetCdnDomainStagingConfigResponseBodyDomainConfigList() = default;
};
class SetCdnDomainStagingConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<SetCdnDomainStagingConfigResponseBodyDomainConfigList>> domainConfigList{};
  shared_ptr<string> requestId{};

  SetCdnDomainStagingConfigResponseBody() {}

  explicit SetCdnDomainStagingConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*domainConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainConfigList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfigList") != m.end() && !m["DomainConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainConfigList"].type()) {
        vector<SetCdnDomainStagingConfigResponseBodyDomainConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SetCdnDomainStagingConfigResponseBodyDomainConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainConfigList = make_shared<vector<SetCdnDomainStagingConfigResponseBodyDomainConfigList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetCdnDomainStagingConfigResponseBody() = default;
};
class SetCdnDomainStagingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetCdnDomainStagingConfigResponseBody> body{};

  SetCdnDomainStagingConfigResponse() {}

  explicit SetCdnDomainStagingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetCdnDomainStagingConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetCdnDomainStagingConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetCdnDomainStagingConfigResponse() = default;
};
class SetDomainServerCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> certName{};
  shared_ptr<string> certType{};
  shared_ptr<string> domainName{};
  shared_ptr<string> forceSet{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> privateKey{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> serverCertificate{};
  shared_ptr<string> serverCertificateStatus{};

  SetDomainServerCertificateRequest() {}

  explicit SetDomainServerCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (forceSet) {
      res["ForceSet"] = boost::any(*forceSet);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (privateKey) {
      res["PrivateKey"] = boost::any(*privateKey);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (serverCertificate) {
      res["ServerCertificate"] = boost::any(*serverCertificate);
    }
    if (serverCertificateStatus) {
      res["ServerCertificateStatus"] = boost::any(*serverCertificateStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ForceSet") != m.end() && !m["ForceSet"].empty()) {
      forceSet = make_shared<string>(boost::any_cast<string>(m["ForceSet"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PrivateKey") != m.end() && !m["PrivateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["PrivateKey"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("ServerCertificate") != m.end() && !m["ServerCertificate"].empty()) {
      serverCertificate = make_shared<string>(boost::any_cast<string>(m["ServerCertificate"]));
    }
    if (m.find("ServerCertificateStatus") != m.end() && !m["ServerCertificateStatus"].empty()) {
      serverCertificateStatus = make_shared<string>(boost::any_cast<string>(m["ServerCertificateStatus"]));
    }
  }


  virtual ~SetDomainServerCertificateRequest() = default;
};
class SetDomainServerCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDomainServerCertificateResponseBody() {}

  explicit SetDomainServerCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDomainServerCertificateResponseBody() = default;
};
class SetDomainServerCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDomainServerCertificateResponseBody> body{};

  SetDomainServerCertificateResponse() {}

  explicit SetDomainServerCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDomainServerCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDomainServerCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~SetDomainServerCertificateResponse() = default;
};
class SetReqHeaderConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> key{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> value{};

  SetReqHeaderConfigRequest() {}

  explicit SetReqHeaderConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SetReqHeaderConfigRequest() = default;
};
class SetReqHeaderConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetReqHeaderConfigResponseBody() {}

  explicit SetReqHeaderConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetReqHeaderConfigResponseBody() = default;
};
class SetReqHeaderConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetReqHeaderConfigResponseBody> body{};

  SetReqHeaderConfigResponse() {}

  explicit SetReqHeaderConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetReqHeaderConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetReqHeaderConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetReqHeaderConfigResponse() = default;
};
class SetWaitingRoomConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> allowPct{};
  shared_ptr<string> domainName{};
  shared_ptr<long> gapTime{};
  shared_ptr<long> maxTimeWait{};
  shared_ptr<string> waitUri{};
  shared_ptr<string> waitUrl{};

  SetWaitingRoomConfigRequest() {}

  explicit SetWaitingRoomConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowPct) {
      res["AllowPct"] = boost::any(*allowPct);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (gapTime) {
      res["GapTime"] = boost::any(*gapTime);
    }
    if (maxTimeWait) {
      res["MaxTimeWait"] = boost::any(*maxTimeWait);
    }
    if (waitUri) {
      res["WaitUri"] = boost::any(*waitUri);
    }
    if (waitUrl) {
      res["WaitUrl"] = boost::any(*waitUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowPct") != m.end() && !m["AllowPct"].empty()) {
      allowPct = make_shared<long>(boost::any_cast<long>(m["AllowPct"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GapTime") != m.end() && !m["GapTime"].empty()) {
      gapTime = make_shared<long>(boost::any_cast<long>(m["GapTime"]));
    }
    if (m.find("MaxTimeWait") != m.end() && !m["MaxTimeWait"].empty()) {
      maxTimeWait = make_shared<long>(boost::any_cast<long>(m["MaxTimeWait"]));
    }
    if (m.find("WaitUri") != m.end() && !m["WaitUri"].empty()) {
      waitUri = make_shared<string>(boost::any_cast<string>(m["WaitUri"]));
    }
    if (m.find("WaitUrl") != m.end() && !m["WaitUrl"].empty()) {
      waitUrl = make_shared<string>(boost::any_cast<string>(m["WaitUrl"]));
    }
  }


  virtual ~SetWaitingRoomConfigRequest() = default;
};
class SetWaitingRoomConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetWaitingRoomConfigResponseBody() {}

  explicit SetWaitingRoomConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetWaitingRoomConfigResponseBody() = default;
};
class SetWaitingRoomConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetWaitingRoomConfigResponseBody> body{};

  SetWaitingRoomConfigResponse() {}

  explicit SetWaitingRoomConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetWaitingRoomConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetWaitingRoomConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetWaitingRoomConfigResponse() = default;
};
class StartCdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  StartCdnDomainRequest() {}

  explicit StartCdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~StartCdnDomainRequest() = default;
};
class StartCdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartCdnDomainResponseBody() {}

  explicit StartCdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartCdnDomainResponseBody() = default;
};
class StartCdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartCdnDomainResponseBody> body{};

  StartCdnDomainResponse() {}

  explicit StartCdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartCdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartCdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~StartCdnDomainResponse() = default;
};
class StopCdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  StopCdnDomainRequest() {}

  explicit StopCdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~StopCdnDomainRequest() = default;
};
class StopCdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopCdnDomainResponseBody() {}

  explicit StopCdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopCdnDomainResponseBody() = default;
};
class StopCdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopCdnDomainResponseBody> body{};

  StopCdnDomainResponse() {}

  explicit StopCdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopCdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopCdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~StopCdnDomainResponse() = default;
};
class TagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTag() {}

  explicit TagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTag() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagResourcesRequestTag>> tag{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKey{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class UpdateCdnDeliverTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> deliver{};
  shared_ptr<long> deliverId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> name{};
  shared_ptr<string> reports{};
  shared_ptr<string> schedule{};

  UpdateCdnDeliverTaskRequest() {}

  explicit UpdateCdnDeliverTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliver) {
      res["Deliver"] = boost::any(*deliver);
    }
    if (deliverId) {
      res["DeliverId"] = boost::any(*deliverId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (reports) {
      res["Reports"] = boost::any(*reports);
    }
    if (schedule) {
      res["Schedule"] = boost::any(*schedule);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Deliver") != m.end() && !m["Deliver"].empty()) {
      deliver = make_shared<string>(boost::any_cast<string>(m["Deliver"]));
    }
    if (m.find("DeliverId") != m.end() && !m["DeliverId"].empty()) {
      deliverId = make_shared<long>(boost::any_cast<long>(m["DeliverId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Reports") != m.end() && !m["Reports"].empty()) {
      reports = make_shared<string>(boost::any_cast<string>(m["Reports"]));
    }
    if (m.find("Schedule") != m.end() && !m["Schedule"].empty()) {
      schedule = make_shared<string>(boost::any_cast<string>(m["Schedule"]));
    }
  }


  virtual ~UpdateCdnDeliverTaskRequest() = default;
};
class UpdateCdnDeliverTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateCdnDeliverTaskResponseBody() {}

  explicit UpdateCdnDeliverTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateCdnDeliverTaskResponseBody() = default;
};
class UpdateCdnDeliverTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCdnDeliverTaskResponseBody> body{};

  UpdateCdnDeliverTaskResponse() {}

  explicit UpdateCdnDeliverTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCdnDeliverTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCdnDeliverTaskResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCdnDeliverTaskResponse() = default;
};
class UpdateCdnSubTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> reportIds{};
  shared_ptr<string> startTime{};

  UpdateCdnSubTaskRequest() {}

  explicit UpdateCdnSubTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (reportIds) {
      res["ReportIds"] = boost::any(*reportIds);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ReportIds") != m.end() && !m["ReportIds"].empty()) {
      reportIds = make_shared<string>(boost::any_cast<string>(m["ReportIds"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~UpdateCdnSubTaskRequest() = default;
};
class UpdateCdnSubTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateCdnSubTaskResponseBody() {}

  explicit UpdateCdnSubTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateCdnSubTaskResponseBody() = default;
};
class UpdateCdnSubTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCdnSubTaskResponseBody> body{};

  UpdateCdnSubTaskResponse() {}

  explicit UpdateCdnSubTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCdnSubTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCdnSubTaskResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCdnSubTaskResponse() = default;
};
class UpdateFCTriggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> functionARN{};
  shared_ptr<string> notes{};
  shared_ptr<string> roleARN{};
  shared_ptr<string> sourceARN{};
  shared_ptr<string> triggerARN{};

  UpdateFCTriggerRequest() {}

  explicit UpdateFCTriggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionARN) {
      res["FunctionARN"] = boost::any(*functionARN);
    }
    if (notes) {
      res["Notes"] = boost::any(*notes);
    }
    if (roleARN) {
      res["RoleARN"] = boost::any(*roleARN);
    }
    if (sourceARN) {
      res["SourceARN"] = boost::any(*sourceARN);
    }
    if (triggerARN) {
      res["TriggerARN"] = boost::any(*triggerARN);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionARN") != m.end() && !m["FunctionARN"].empty()) {
      functionARN = make_shared<string>(boost::any_cast<string>(m["FunctionARN"]));
    }
    if (m.find("Notes") != m.end() && !m["Notes"].empty()) {
      notes = make_shared<string>(boost::any_cast<string>(m["Notes"]));
    }
    if (m.find("RoleARN") != m.end() && !m["RoleARN"].empty()) {
      roleARN = make_shared<string>(boost::any_cast<string>(m["RoleARN"]));
    }
    if (m.find("SourceARN") != m.end() && !m["SourceARN"].empty()) {
      sourceARN = make_shared<string>(boost::any_cast<string>(m["SourceARN"]));
    }
    if (m.find("TriggerARN") != m.end() && !m["TriggerARN"].empty()) {
      triggerARN = make_shared<string>(boost::any_cast<string>(m["TriggerARN"]));
    }
  }


  virtual ~UpdateFCTriggerRequest() = default;
};
class UpdateFCTriggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateFCTriggerResponseBody() {}

  explicit UpdateFCTriggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateFCTriggerResponseBody() = default;
};
class UpdateFCTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateFCTriggerResponseBody> body{};

  UpdateFCTriggerResponse() {}

  explicit UpdateFCTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateFCTriggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateFCTriggerResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateFCTriggerResponse() = default;
};
class VerifyDomainOwnerRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> verifyType{};

  VerifyDomainOwnerRequest() {}

  explicit VerifyDomainOwnerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (verifyType) {
      res["VerifyType"] = boost::any(*verifyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("VerifyType") != m.end() && !m["VerifyType"].empty()) {
      verifyType = make_shared<string>(boost::any_cast<string>(m["VerifyType"]));
    }
  }


  virtual ~VerifyDomainOwnerRequest() = default;
};
class VerifyDomainOwnerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  VerifyDomainOwnerResponseBody() {}

  explicit VerifyDomainOwnerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~VerifyDomainOwnerResponseBody() = default;
};
class VerifyDomainOwnerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<VerifyDomainOwnerResponseBody> body{};

  VerifyDomainOwnerResponse() {}

  explicit VerifyDomainOwnerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        VerifyDomainOwnerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<VerifyDomainOwnerResponseBody>(model1);
      }
    }
  }


  virtual ~VerifyDomainOwnerResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddCdnDomainResponse addCdnDomainWithOptions(shared_ptr<AddCdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCdnDomainResponse addCdnDomain(shared_ptr<AddCdnDomainRequest> request);
  AddFCTriggerResponse addFCTriggerWithOptions(shared_ptr<AddFCTriggerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddFCTriggerResponse addFCTrigger(shared_ptr<AddFCTriggerRequest> request);
  BatchAddCdnDomainResponse batchAddCdnDomainWithOptions(shared_ptr<BatchAddCdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchAddCdnDomainResponse batchAddCdnDomain(shared_ptr<BatchAddCdnDomainRequest> request);
  BatchDeleteCdnDomainConfigResponse batchDeleteCdnDomainConfigWithOptions(shared_ptr<BatchDeleteCdnDomainConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchDeleteCdnDomainConfigResponse batchDeleteCdnDomainConfig(shared_ptr<BatchDeleteCdnDomainConfigRequest> request);
  BatchSetCdnDomainConfigResponse batchSetCdnDomainConfigWithOptions(shared_ptr<BatchSetCdnDomainConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchSetCdnDomainConfigResponse batchSetCdnDomainConfig(shared_ptr<BatchSetCdnDomainConfigRequest> request);
  BatchSetCdnDomainServerCertificateResponse batchSetCdnDomainServerCertificateWithOptions(shared_ptr<BatchSetCdnDomainServerCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchSetCdnDomainServerCertificateResponse batchSetCdnDomainServerCertificate(shared_ptr<BatchSetCdnDomainServerCertificateRequest> request);
  BatchStartCdnDomainResponse batchStartCdnDomainWithOptions(shared_ptr<BatchStartCdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchStartCdnDomainResponse batchStartCdnDomain(shared_ptr<BatchStartCdnDomainRequest> request);
  BatchStopCdnDomainResponse batchStopCdnDomainWithOptions(shared_ptr<BatchStopCdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchStopCdnDomainResponse batchStopCdnDomain(shared_ptr<BatchStopCdnDomainRequest> request);
  BatchUpdateCdnDomainResponse batchUpdateCdnDomainWithOptions(shared_ptr<BatchUpdateCdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUpdateCdnDomainResponse batchUpdateCdnDomain(shared_ptr<BatchUpdateCdnDomainRequest> request);
  ChangeCdnDomainToDcdnResponse changeCdnDomainToDcdnWithOptions(shared_ptr<ChangeCdnDomainToDcdnRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeCdnDomainToDcdnResponse changeCdnDomainToDcdn(shared_ptr<ChangeCdnDomainToDcdnRequest> request);
  CreateCdnCertificateSigningRequestResponse createCdnCertificateSigningRequestWithOptions(shared_ptr<CreateCdnCertificateSigningRequestRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCdnCertificateSigningRequestResponse createCdnCertificateSigningRequest(shared_ptr<CreateCdnCertificateSigningRequestRequest> request);
  CreateCdnDeliverTaskResponse createCdnDeliverTaskWithOptions(shared_ptr<CreateCdnDeliverTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCdnDeliverTaskResponse createCdnDeliverTask(shared_ptr<CreateCdnDeliverTaskRequest> request);
  CreateCdnSubTaskResponse createCdnSubTaskWithOptions(shared_ptr<CreateCdnSubTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCdnSubTaskResponse createCdnSubTask(shared_ptr<CreateCdnSubTaskRequest> request);
  CreateRealTimeLogDeliveryResponse createRealTimeLogDeliveryWithOptions(shared_ptr<CreateRealTimeLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRealTimeLogDeliveryResponse createRealTimeLogDelivery(shared_ptr<CreateRealTimeLogDeliveryRequest> request);
  CreateUsageDetailDataExportTaskResponse createUsageDetailDataExportTaskWithOptions(shared_ptr<CreateUsageDetailDataExportTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUsageDetailDataExportTaskResponse createUsageDetailDataExportTask(shared_ptr<CreateUsageDetailDataExportTaskRequest> request);
  CreateUserUsageDataExportTaskResponse createUserUsageDataExportTaskWithOptions(shared_ptr<CreateUserUsageDataExportTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUserUsageDataExportTaskResponse createUserUsageDataExportTask(shared_ptr<CreateUserUsageDataExportTaskRequest> request);
  DeleteCdnDeliverTaskResponse deleteCdnDeliverTaskWithOptions(shared_ptr<DeleteCdnDeliverTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCdnDeliverTaskResponse deleteCdnDeliverTask(shared_ptr<DeleteCdnDeliverTaskRequest> request);
  DeleteCdnDomainResponse deleteCdnDomainWithOptions(shared_ptr<DeleteCdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCdnDomainResponse deleteCdnDomain(shared_ptr<DeleteCdnDomainRequest> request);
  DeleteCdnSubTaskResponse deleteCdnSubTaskWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCdnSubTaskResponse deleteCdnSubTask();
  DeleteFCTriggerResponse deleteFCTriggerWithOptions(shared_ptr<DeleteFCTriggerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFCTriggerResponse deleteFCTrigger(shared_ptr<DeleteFCTriggerRequest> request);
  DeleteRealTimeLogLogstoreResponse deleteRealTimeLogLogstoreWithOptions(shared_ptr<DeleteRealTimeLogLogstoreRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRealTimeLogLogstoreResponse deleteRealTimeLogLogstore(shared_ptr<DeleteRealTimeLogLogstoreRequest> request);
  DeleteRealtimeLogDeliveryResponse deleteRealtimeLogDeliveryWithOptions(shared_ptr<DeleteRealtimeLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRealtimeLogDeliveryResponse deleteRealtimeLogDelivery(shared_ptr<DeleteRealtimeLogDeliveryRequest> request);
  DeleteSpecificConfigResponse deleteSpecificConfigWithOptions(shared_ptr<DeleteSpecificConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSpecificConfigResponse deleteSpecificConfig(shared_ptr<DeleteSpecificConfigRequest> request);
  DeleteSpecificStagingConfigResponse deleteSpecificStagingConfigWithOptions(shared_ptr<DeleteSpecificStagingConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSpecificStagingConfigResponse deleteSpecificStagingConfig(shared_ptr<DeleteSpecificStagingConfigRequest> request);
  DeleteUsageDetailDataExportTaskResponse deleteUsageDetailDataExportTaskWithOptions(shared_ptr<DeleteUsageDetailDataExportTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteUsageDetailDataExportTaskResponse deleteUsageDetailDataExportTask(shared_ptr<DeleteUsageDetailDataExportTaskRequest> request);
  DeleteUserUsageDataExportTaskResponse deleteUserUsageDataExportTaskWithOptions(shared_ptr<DeleteUserUsageDataExportTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteUserUsageDataExportTaskResponse deleteUserUsageDataExportTask(shared_ptr<DeleteUserUsageDataExportTaskRequest> request);
  DescribeBlockedRegionsResponse describeBlockedRegionsWithOptions(shared_ptr<DescribeBlockedRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBlockedRegionsResponse describeBlockedRegions(shared_ptr<DescribeBlockedRegionsRequest> request);
  DescribeCdnCertificateDetailResponse describeCdnCertificateDetailWithOptions(shared_ptr<DescribeCdnCertificateDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnCertificateDetailResponse describeCdnCertificateDetail(shared_ptr<DescribeCdnCertificateDetailRequest> request);
  DescribeCdnCertificateDetailByIdResponse describeCdnCertificateDetailByIdWithOptions(shared_ptr<DescribeCdnCertificateDetailByIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnCertificateDetailByIdResponse describeCdnCertificateDetailById(shared_ptr<DescribeCdnCertificateDetailByIdRequest> request);
  DescribeCdnCertificateListResponse describeCdnCertificateListWithOptions(shared_ptr<DescribeCdnCertificateListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnCertificateListResponse describeCdnCertificateList(shared_ptr<DescribeCdnCertificateListRequest> request);
  DescribeCdnConditionIPBInfoResponse describeCdnConditionIPBInfoWithOptions(shared_ptr<DescribeCdnConditionIPBInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnConditionIPBInfoResponse describeCdnConditionIPBInfo(shared_ptr<DescribeCdnConditionIPBInfoRequest> request);
  DescribeCdnDeletedDomainsResponse describeCdnDeletedDomainsWithOptions(shared_ptr<DescribeCdnDeletedDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnDeletedDomainsResponse describeCdnDeletedDomains(shared_ptr<DescribeCdnDeletedDomainsRequest> request);
  DescribeCdnDeliverListResponse describeCdnDeliverListWithOptions(shared_ptr<DescribeCdnDeliverListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnDeliverListResponse describeCdnDeliverList(shared_ptr<DescribeCdnDeliverListRequest> request);
  DescribeCdnDomainByCertificateResponse describeCdnDomainByCertificateWithOptions(shared_ptr<DescribeCdnDomainByCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnDomainByCertificateResponse describeCdnDomainByCertificate(shared_ptr<DescribeCdnDomainByCertificateRequest> request);
  DescribeCdnDomainConfigsResponse describeCdnDomainConfigsWithOptions(shared_ptr<DescribeCdnDomainConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnDomainConfigsResponse describeCdnDomainConfigs(shared_ptr<DescribeCdnDomainConfigsRequest> request);
  DescribeCdnDomainDetailResponse describeCdnDomainDetailWithOptions(shared_ptr<DescribeCdnDomainDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnDomainDetailResponse describeCdnDomainDetail(shared_ptr<DescribeCdnDomainDetailRequest> request);
  DescribeCdnDomainLogsResponse describeCdnDomainLogsWithOptions(shared_ptr<DescribeCdnDomainLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnDomainLogsResponse describeCdnDomainLogs(shared_ptr<DescribeCdnDomainLogsRequest> request);
  DescribeCdnDomainStagingConfigResponse describeCdnDomainStagingConfigWithOptions(shared_ptr<DescribeCdnDomainStagingConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnDomainStagingConfigResponse describeCdnDomainStagingConfig(shared_ptr<DescribeCdnDomainStagingConfigRequest> request);
  DescribeCdnHttpsDomainListResponse describeCdnHttpsDomainListWithOptions(shared_ptr<DescribeCdnHttpsDomainListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnHttpsDomainListResponse describeCdnHttpsDomainList(shared_ptr<DescribeCdnHttpsDomainListRequest> request);
  DescribeCdnOrderCommodityCodeResponse describeCdnOrderCommodityCodeWithOptions(shared_ptr<DescribeCdnOrderCommodityCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnOrderCommodityCodeResponse describeCdnOrderCommodityCode(shared_ptr<DescribeCdnOrderCommodityCodeRequest> request);
  DescribeCdnRegionAndIspResponse describeCdnRegionAndIspWithOptions(shared_ptr<DescribeCdnRegionAndIspRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnRegionAndIspResponse describeCdnRegionAndIsp(shared_ptr<DescribeCdnRegionAndIspRequest> request);
  DescribeCdnReportResponse describeCdnReportWithOptions(shared_ptr<DescribeCdnReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnReportResponse describeCdnReport(shared_ptr<DescribeCdnReportRequest> request);
  DescribeCdnReportListResponse describeCdnReportListWithOptions(shared_ptr<DescribeCdnReportListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnReportListResponse describeCdnReportList(shared_ptr<DescribeCdnReportListRequest> request);
  DescribeCdnSMCertificateDetailResponse describeCdnSMCertificateDetailWithOptions(shared_ptr<DescribeCdnSMCertificateDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnSMCertificateDetailResponse describeCdnSMCertificateDetail(shared_ptr<DescribeCdnSMCertificateDetailRequest> request);
  DescribeCdnSMCertificateListResponse describeCdnSMCertificateListWithOptions(shared_ptr<DescribeCdnSMCertificateListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnSMCertificateListResponse describeCdnSMCertificateList(shared_ptr<DescribeCdnSMCertificateListRequest> request);
  DescribeCdnSSLCertificateListResponse describeCdnSSLCertificateListWithOptions(shared_ptr<DescribeCdnSSLCertificateListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnSSLCertificateListResponse describeCdnSSLCertificateList(shared_ptr<DescribeCdnSSLCertificateListRequest> request);
  DescribeCdnServiceResponse describeCdnServiceWithOptions(shared_ptr<DescribeCdnServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnServiceResponse describeCdnService(shared_ptr<DescribeCdnServiceRequest> request);
  DescribeCdnSubListResponse describeCdnSubListWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnSubListResponse describeCdnSubList();
  DescribeCdnUserBillHistoryResponse describeCdnUserBillHistoryWithOptions(shared_ptr<DescribeCdnUserBillHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnUserBillHistoryResponse describeCdnUserBillHistory(shared_ptr<DescribeCdnUserBillHistoryRequest> request);
  DescribeCdnUserBillPredictionResponse describeCdnUserBillPredictionWithOptions(shared_ptr<DescribeCdnUserBillPredictionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnUserBillPredictionResponse describeCdnUserBillPrediction(shared_ptr<DescribeCdnUserBillPredictionRequest> request);
  DescribeCdnUserBillTypeResponse describeCdnUserBillTypeWithOptions(shared_ptr<DescribeCdnUserBillTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnUserBillTypeResponse describeCdnUserBillType(shared_ptr<DescribeCdnUserBillTypeRequest> request);
  DescribeCdnUserConfigsResponse describeCdnUserConfigsWithOptions(shared_ptr<DescribeCdnUserConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnUserConfigsResponse describeCdnUserConfigs(shared_ptr<DescribeCdnUserConfigsRequest> request);
  DescribeCdnUserDomainsByFuncResponse describeCdnUserDomainsByFuncWithOptions(shared_ptr<DescribeCdnUserDomainsByFuncRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnUserDomainsByFuncResponse describeCdnUserDomainsByFunc(shared_ptr<DescribeCdnUserDomainsByFuncRequest> request);
  DescribeCdnUserQuotaResponse describeCdnUserQuotaWithOptions(shared_ptr<DescribeCdnUserQuotaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnUserQuotaResponse describeCdnUserQuota(shared_ptr<DescribeCdnUserQuotaRequest> request);
  DescribeCdnUserResourcePackageResponse describeCdnUserResourcePackageWithOptions(shared_ptr<DescribeCdnUserResourcePackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnUserResourcePackageResponse describeCdnUserResourcePackage(shared_ptr<DescribeCdnUserResourcePackageRequest> request);
  DescribeCdnWafDomainResponse describeCdnWafDomainWithOptions(shared_ptr<DescribeCdnWafDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCdnWafDomainResponse describeCdnWafDomain(shared_ptr<DescribeCdnWafDomainRequest> request);
  DescribeCertificateInfoByIDResponse describeCertificateInfoByIDWithOptions(shared_ptr<DescribeCertificateInfoByIDRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCertificateInfoByIDResponse describeCertificateInfoByID(shared_ptr<DescribeCertificateInfoByIDRequest> request);
  DescribeCustomLogConfigResponse describeCustomLogConfigWithOptions(shared_ptr<DescribeCustomLogConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCustomLogConfigResponse describeCustomLogConfig(shared_ptr<DescribeCustomLogConfigRequest> request);
  DescribeDomainAverageResponseTimeResponse describeDomainAverageResponseTimeWithOptions(shared_ptr<DescribeDomainAverageResponseTimeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainAverageResponseTimeResponse describeDomainAverageResponseTime(shared_ptr<DescribeDomainAverageResponseTimeRequest> request);
  DescribeDomainBpsDataResponse describeDomainBpsDataWithOptions(shared_ptr<DescribeDomainBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainBpsDataResponse describeDomainBpsData(shared_ptr<DescribeDomainBpsDataRequest> request);
  DescribeDomainBpsDataByLayerResponse describeDomainBpsDataByLayerWithOptions(shared_ptr<DescribeDomainBpsDataByLayerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainBpsDataByLayerResponse describeDomainBpsDataByLayer(shared_ptr<DescribeDomainBpsDataByLayerRequest> request);
  DescribeDomainBpsDataByTimeStampResponse describeDomainBpsDataByTimeStampWithOptions(shared_ptr<DescribeDomainBpsDataByTimeStampRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainBpsDataByTimeStampResponse describeDomainBpsDataByTimeStamp(shared_ptr<DescribeDomainBpsDataByTimeStampRequest> request);
  DescribeDomainCcActivityLogResponse describeDomainCcActivityLogWithOptions(shared_ptr<DescribeDomainCcActivityLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainCcActivityLogResponse describeDomainCcActivityLog(shared_ptr<DescribeDomainCcActivityLogRequest> request);
  DescribeDomainCertificateInfoResponse describeDomainCertificateInfoWithOptions(shared_ptr<DescribeDomainCertificateInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainCertificateInfoResponse describeDomainCertificateInfo(shared_ptr<DescribeDomainCertificateInfoRequest> request);
  DescribeDomainCnameResponse describeDomainCnameWithOptions(shared_ptr<DescribeDomainCnameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainCnameResponse describeDomainCname(shared_ptr<DescribeDomainCnameRequest> request);
  DescribeDomainCustomLogConfigResponse describeDomainCustomLogConfigWithOptions(shared_ptr<DescribeDomainCustomLogConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainCustomLogConfigResponse describeDomainCustomLogConfig(shared_ptr<DescribeDomainCustomLogConfigRequest> request);
  DescribeDomainDetailDataByLayerResponse describeDomainDetailDataByLayerWithOptions(shared_ptr<DescribeDomainDetailDataByLayerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainDetailDataByLayerResponse describeDomainDetailDataByLayer(shared_ptr<DescribeDomainDetailDataByLayerRequest> request);
  DescribeDomainHitRateDataResponse describeDomainHitRateDataWithOptions(shared_ptr<DescribeDomainHitRateDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainHitRateDataResponse describeDomainHitRateData(shared_ptr<DescribeDomainHitRateDataRequest> request);
  DescribeDomainHttpCodeDataResponse describeDomainHttpCodeDataWithOptions(shared_ptr<DescribeDomainHttpCodeDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainHttpCodeDataResponse describeDomainHttpCodeData(shared_ptr<DescribeDomainHttpCodeDataRequest> request);
  DescribeDomainHttpCodeDataByLayerResponse describeDomainHttpCodeDataByLayerWithOptions(shared_ptr<DescribeDomainHttpCodeDataByLayerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainHttpCodeDataByLayerResponse describeDomainHttpCodeDataByLayer(shared_ptr<DescribeDomainHttpCodeDataByLayerRequest> request);
  DescribeDomainISPDataResponse describeDomainISPDataWithOptions(shared_ptr<DescribeDomainISPDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainISPDataResponse describeDomainISPData(shared_ptr<DescribeDomainISPDataRequest> request);
  DescribeDomainMax95BpsDataResponse describeDomainMax95BpsDataWithOptions(shared_ptr<DescribeDomainMax95BpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainMax95BpsDataResponse describeDomainMax95BpsData(shared_ptr<DescribeDomainMax95BpsDataRequest> request);
  DescribeDomainMultiUsageDataResponse describeDomainMultiUsageDataWithOptions(shared_ptr<DescribeDomainMultiUsageDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainMultiUsageDataResponse describeDomainMultiUsageData(shared_ptr<DescribeDomainMultiUsageDataRequest> request);
  DescribeDomainPathDataResponse describeDomainPathDataWithOptions(shared_ptr<DescribeDomainPathDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainPathDataResponse describeDomainPathData(shared_ptr<DescribeDomainPathDataRequest> request);
  DescribeDomainPvDataResponse describeDomainPvDataWithOptions(shared_ptr<DescribeDomainPvDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainPvDataResponse describeDomainPvData(shared_ptr<DescribeDomainPvDataRequest> request);
  DescribeDomainQpsDataResponse describeDomainQpsDataWithOptions(shared_ptr<DescribeDomainQpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainQpsDataResponse describeDomainQpsData(shared_ptr<DescribeDomainQpsDataRequest> request);
  DescribeDomainQpsDataByLayerResponse describeDomainQpsDataByLayerWithOptions(shared_ptr<DescribeDomainQpsDataByLayerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainQpsDataByLayerResponse describeDomainQpsDataByLayer(shared_ptr<DescribeDomainQpsDataByLayerRequest> request);
  DescribeDomainRealTimeBpsDataResponse describeDomainRealTimeBpsDataWithOptions(shared_ptr<DescribeDomainRealTimeBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainRealTimeBpsDataResponse describeDomainRealTimeBpsData(shared_ptr<DescribeDomainRealTimeBpsDataRequest> request);
  DescribeDomainRealTimeByteHitRateDataResponse describeDomainRealTimeByteHitRateDataWithOptions(shared_ptr<DescribeDomainRealTimeByteHitRateDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainRealTimeByteHitRateDataResponse describeDomainRealTimeByteHitRateData(shared_ptr<DescribeDomainRealTimeByteHitRateDataRequest> request);
  DescribeDomainRealTimeDetailDataResponse describeDomainRealTimeDetailDataWithOptions(shared_ptr<DescribeDomainRealTimeDetailDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainRealTimeDetailDataResponse describeDomainRealTimeDetailData(shared_ptr<DescribeDomainRealTimeDetailDataRequest> request);
  DescribeDomainRealTimeHttpCodeDataResponse describeDomainRealTimeHttpCodeDataWithOptions(shared_ptr<DescribeDomainRealTimeHttpCodeDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainRealTimeHttpCodeDataResponse describeDomainRealTimeHttpCodeData(shared_ptr<DescribeDomainRealTimeHttpCodeDataRequest> request);
  DescribeDomainRealTimeQpsDataResponse describeDomainRealTimeQpsDataWithOptions(shared_ptr<DescribeDomainRealTimeQpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainRealTimeQpsDataResponse describeDomainRealTimeQpsData(shared_ptr<DescribeDomainRealTimeQpsDataRequest> request);
  DescribeDomainRealTimeReqHitRateDataResponse describeDomainRealTimeReqHitRateDataWithOptions(shared_ptr<DescribeDomainRealTimeReqHitRateDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainRealTimeReqHitRateDataResponse describeDomainRealTimeReqHitRateData(shared_ptr<DescribeDomainRealTimeReqHitRateDataRequest> request);
  DescribeDomainRealTimeSrcBpsDataResponse describeDomainRealTimeSrcBpsDataWithOptions(shared_ptr<DescribeDomainRealTimeSrcBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainRealTimeSrcBpsDataResponse describeDomainRealTimeSrcBpsData(shared_ptr<DescribeDomainRealTimeSrcBpsDataRequest> request);
  DescribeDomainRealTimeSrcHttpCodeDataResponse describeDomainRealTimeSrcHttpCodeDataWithOptions(shared_ptr<DescribeDomainRealTimeSrcHttpCodeDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainRealTimeSrcHttpCodeDataResponse describeDomainRealTimeSrcHttpCodeData(shared_ptr<DescribeDomainRealTimeSrcHttpCodeDataRequest> request);
  DescribeDomainRealTimeSrcTrafficDataResponse describeDomainRealTimeSrcTrafficDataWithOptions(shared_ptr<DescribeDomainRealTimeSrcTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainRealTimeSrcTrafficDataResponse describeDomainRealTimeSrcTrafficData(shared_ptr<DescribeDomainRealTimeSrcTrafficDataRequest> request);
  DescribeDomainRealTimeTrafficDataResponse describeDomainRealTimeTrafficDataWithOptions(shared_ptr<DescribeDomainRealTimeTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainRealTimeTrafficDataResponse describeDomainRealTimeTrafficData(shared_ptr<DescribeDomainRealTimeTrafficDataRequest> request);
  DescribeDomainRealtimeLogDeliveryResponse describeDomainRealtimeLogDeliveryWithOptions(shared_ptr<DescribeDomainRealtimeLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainRealtimeLogDeliveryResponse describeDomainRealtimeLogDelivery(shared_ptr<DescribeDomainRealtimeLogDeliveryRequest> request);
  DescribeDomainRegionDataResponse describeDomainRegionDataWithOptions(shared_ptr<DescribeDomainRegionDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainRegionDataResponse describeDomainRegionData(shared_ptr<DescribeDomainRegionDataRequest> request);
  DescribeDomainReqHitRateDataResponse describeDomainReqHitRateDataWithOptions(shared_ptr<DescribeDomainReqHitRateDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainReqHitRateDataResponse describeDomainReqHitRateData(shared_ptr<DescribeDomainReqHitRateDataRequest> request);
  DescribeDomainSrcBpsDataResponse describeDomainSrcBpsDataWithOptions(shared_ptr<DescribeDomainSrcBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainSrcBpsDataResponse describeDomainSrcBpsData(shared_ptr<DescribeDomainSrcBpsDataRequest> request);
  DescribeDomainSrcHttpCodeDataResponse describeDomainSrcHttpCodeDataWithOptions(shared_ptr<DescribeDomainSrcHttpCodeDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainSrcHttpCodeDataResponse describeDomainSrcHttpCodeData(shared_ptr<DescribeDomainSrcHttpCodeDataRequest> request);
  DescribeDomainSrcQpsDataResponse describeDomainSrcQpsDataWithOptions(shared_ptr<DescribeDomainSrcQpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainSrcQpsDataResponse describeDomainSrcQpsData(shared_ptr<DescribeDomainSrcQpsDataRequest> request);
  DescribeDomainSrcTopUrlVisitResponse describeDomainSrcTopUrlVisitWithOptions(shared_ptr<DescribeDomainSrcTopUrlVisitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainSrcTopUrlVisitResponse describeDomainSrcTopUrlVisit(shared_ptr<DescribeDomainSrcTopUrlVisitRequest> request);
  DescribeDomainSrcTrafficDataResponse describeDomainSrcTrafficDataWithOptions(shared_ptr<DescribeDomainSrcTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainSrcTrafficDataResponse describeDomainSrcTrafficData(shared_ptr<DescribeDomainSrcTrafficDataRequest> request);
  DescribeDomainTopClientIpVisitResponse describeDomainTopClientIpVisitWithOptions(shared_ptr<DescribeDomainTopClientIpVisitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainTopClientIpVisitResponse describeDomainTopClientIpVisit(shared_ptr<DescribeDomainTopClientIpVisitRequest> request);
  DescribeDomainTopReferVisitResponse describeDomainTopReferVisitWithOptions(shared_ptr<DescribeDomainTopReferVisitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainTopReferVisitResponse describeDomainTopReferVisit(shared_ptr<DescribeDomainTopReferVisitRequest> request);
  DescribeDomainTopUrlVisitResponse describeDomainTopUrlVisitWithOptions(shared_ptr<DescribeDomainTopUrlVisitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainTopUrlVisitResponse describeDomainTopUrlVisit(shared_ptr<DescribeDomainTopUrlVisitRequest> request);
  DescribeDomainTrafficDataResponse describeDomainTrafficDataWithOptions(shared_ptr<DescribeDomainTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainTrafficDataResponse describeDomainTrafficData(shared_ptr<DescribeDomainTrafficDataRequest> request);
  DescribeDomainUsageDataResponse describeDomainUsageDataWithOptions(shared_ptr<DescribeDomainUsageDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainUsageDataResponse describeDomainUsageData(shared_ptr<DescribeDomainUsageDataRequest> request);
  DescribeDomainUvDataResponse describeDomainUvDataWithOptions(shared_ptr<DescribeDomainUvDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainUvDataResponse describeDomainUvData(shared_ptr<DescribeDomainUvDataRequest> request);
  DescribeDomainsBySourceResponse describeDomainsBySourceWithOptions(shared_ptr<DescribeDomainsBySourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainsBySourceResponse describeDomainsBySource(shared_ptr<DescribeDomainsBySourceRequest> request);
  DescribeDomainsUsageByDayResponse describeDomainsUsageByDayWithOptions(shared_ptr<DescribeDomainsUsageByDayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainsUsageByDayResponse describeDomainsUsageByDay(shared_ptr<DescribeDomainsUsageByDayRequest> request);
  DescribeEsExceptionDataResponse describeEsExceptionDataWithOptions(shared_ptr<DescribeEsExceptionDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEsExceptionDataResponse describeEsExceptionData(shared_ptr<DescribeEsExceptionDataRequest> request);
  DescribeEsExecuteDataResponse describeEsExecuteDataWithOptions(shared_ptr<DescribeEsExecuteDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEsExecuteDataResponse describeEsExecuteData(shared_ptr<DescribeEsExecuteDataRequest> request);
  DescribeFCTriggerResponse describeFCTriggerWithOptions(shared_ptr<DescribeFCTriggerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFCTriggerResponse describeFCTrigger(shared_ptr<DescribeFCTriggerRequest> request);
  DescribeIpInfoResponse describeIpInfoWithOptions(shared_ptr<DescribeIpInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIpInfoResponse describeIpInfo(shared_ptr<DescribeIpInfoRequest> request);
  DescribeIpStatusResponse describeIpStatusWithOptions(shared_ptr<DescribeIpStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIpStatusResponse describeIpStatus(shared_ptr<DescribeIpStatusRequest> request);
  DescribeL2VipsByDomainResponse describeL2VipsByDomainWithOptions(shared_ptr<DescribeL2VipsByDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeL2VipsByDomainResponse describeL2VipsByDomain(shared_ptr<DescribeL2VipsByDomainRequest> request);
  DescribePreloadDetailByIdResponse describePreloadDetailByIdWithOptions(shared_ptr<DescribePreloadDetailByIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePreloadDetailByIdResponse describePreloadDetailById(shared_ptr<DescribePreloadDetailByIdRequest> request);
  DescribeRangeDataByLocateAndIspServiceResponse describeRangeDataByLocateAndIspServiceWithOptions(shared_ptr<DescribeRangeDataByLocateAndIspServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRangeDataByLocateAndIspServiceResponse describeRangeDataByLocateAndIspService(shared_ptr<DescribeRangeDataByLocateAndIspServiceRequest> request);
  DescribeRealtimeDeliveryAccResponse describeRealtimeDeliveryAccWithOptions(shared_ptr<DescribeRealtimeDeliveryAccRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRealtimeDeliveryAccResponse describeRealtimeDeliveryAcc(shared_ptr<DescribeRealtimeDeliveryAccRequest> request);
  DescribeRefreshQuotaResponse describeRefreshQuotaWithOptions(shared_ptr<DescribeRefreshQuotaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRefreshQuotaResponse describeRefreshQuota(shared_ptr<DescribeRefreshQuotaRequest> request);
  DescribeRefreshTaskByIdResponse describeRefreshTaskByIdWithOptions(shared_ptr<DescribeRefreshTaskByIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRefreshTaskByIdResponse describeRefreshTaskById(shared_ptr<DescribeRefreshTaskByIdRequest> request);
  DescribeRefreshTasksResponse describeRefreshTasksWithOptions(shared_ptr<DescribeRefreshTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRefreshTasksResponse describeRefreshTasks(shared_ptr<DescribeRefreshTasksRequest> request);
  DescribeStagingIpResponse describeStagingIpWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStagingIpResponse describeStagingIp();
  DescribeTagResourcesResponse describeTagResourcesWithOptions(shared_ptr<DescribeTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTagResourcesResponse describeTagResources(shared_ptr<DescribeTagResourcesRequest> request);
  DescribeTopDomainsByFlowResponse describeTopDomainsByFlowWithOptions(shared_ptr<DescribeTopDomainsByFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTopDomainsByFlowResponse describeTopDomainsByFlow(shared_ptr<DescribeTopDomainsByFlowRequest> request);
  DescribeUserCertificateExpireCountResponse describeUserCertificateExpireCountWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserCertificateExpireCountResponse describeUserCertificateExpireCount();
  DescribeUserConfigsResponse describeUserConfigsWithOptions(shared_ptr<DescribeUserConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserConfigsResponse describeUserConfigs(shared_ptr<DescribeUserConfigsRequest> request);
  DescribeUserDomainsResponse describeUserDomainsWithOptions(shared_ptr<DescribeUserDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserDomainsResponse describeUserDomains(shared_ptr<DescribeUserDomainsRequest> request);
  DescribeUserTagsResponse describeUserTagsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserTagsResponse describeUserTags();
  DescribeUserUsageDataExportTaskResponse describeUserUsageDataExportTaskWithOptions(shared_ptr<DescribeUserUsageDataExportTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserUsageDataExportTaskResponse describeUserUsageDataExportTask(shared_ptr<DescribeUserUsageDataExportTaskRequest> request);
  DescribeUserUsageDetailDataExportTaskResponse describeUserUsageDetailDataExportTaskWithOptions(shared_ptr<DescribeUserUsageDetailDataExportTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserUsageDetailDataExportTaskResponse describeUserUsageDetailDataExportTask(shared_ptr<DescribeUserUsageDetailDataExportTaskRequest> request);
  DescribeUserVipsByDomainResponse describeUserVipsByDomainWithOptions(shared_ptr<DescribeUserVipsByDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserVipsByDomainResponse describeUserVipsByDomain(shared_ptr<DescribeUserVipsByDomainRequest> request);
  DescribeVerifyContentResponse describeVerifyContentWithOptions(shared_ptr<DescribeVerifyContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVerifyContentResponse describeVerifyContent(shared_ptr<DescribeVerifyContentRequest> request);
  DisableRealtimeLogDeliveryResponse disableRealtimeLogDeliveryWithOptions(shared_ptr<DisableRealtimeLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableRealtimeLogDeliveryResponse disableRealtimeLogDelivery(shared_ptr<DisableRealtimeLogDeliveryRequest> request);
  EnableRealtimeLogDeliveryResponse enableRealtimeLogDeliveryWithOptions(shared_ptr<EnableRealtimeLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableRealtimeLogDeliveryResponse enableRealtimeLogDelivery(shared_ptr<EnableRealtimeLogDeliveryRequest> request);
  ListDomainsByLogConfigIdResponse listDomainsByLogConfigIdWithOptions(shared_ptr<ListDomainsByLogConfigIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDomainsByLogConfigIdResponse listDomainsByLogConfigId(shared_ptr<ListDomainsByLogConfigIdRequest> request);
  ListFCTriggerResponse listFCTriggerWithOptions(shared_ptr<ListFCTriggerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFCTriggerResponse listFCTrigger(shared_ptr<ListFCTriggerRequest> request);
  ListRealtimeLogDeliveryDomainsResponse listRealtimeLogDeliveryDomainsWithOptions(shared_ptr<ListRealtimeLogDeliveryDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRealtimeLogDeliveryDomainsResponse listRealtimeLogDeliveryDomains(shared_ptr<ListRealtimeLogDeliveryDomainsRequest> request);
  ListRealtimeLogDeliveryInfosResponse listRealtimeLogDeliveryInfosWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRealtimeLogDeliveryInfosResponse listRealtimeLogDeliveryInfos();
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ListUserCustomLogConfigResponse listUserCustomLogConfigWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUserCustomLogConfigResponse listUserCustomLogConfig();
  ModifyCdnDomainResponse modifyCdnDomainWithOptions(shared_ptr<ModifyCdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCdnDomainResponse modifyCdnDomain(shared_ptr<ModifyCdnDomainRequest> request);
  ModifyCdnDomainOwnerResponse modifyCdnDomainOwnerWithOptions(shared_ptr<ModifyCdnDomainOwnerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCdnDomainOwnerResponse modifyCdnDomainOwner(shared_ptr<ModifyCdnDomainOwnerRequest> request);
  ModifyCdnDomainSchdmByPropertyResponse modifyCdnDomainSchdmByPropertyWithOptions(shared_ptr<ModifyCdnDomainSchdmByPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCdnDomainSchdmByPropertyResponse modifyCdnDomainSchdmByProperty(shared_ptr<ModifyCdnDomainSchdmByPropertyRequest> request);
  ModifyRealtimeLogDeliveryResponse modifyRealtimeLogDeliveryWithOptions(shared_ptr<ModifyRealtimeLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyRealtimeLogDeliveryResponse modifyRealtimeLogDelivery(shared_ptr<ModifyRealtimeLogDeliveryRequest> request);
  OpenCdnServiceResponse openCdnServiceWithOptions(shared_ptr<OpenCdnServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenCdnServiceResponse openCdnService(shared_ptr<OpenCdnServiceRequest> request);
  PublishStagingConfigToProductionResponse publishStagingConfigToProductionWithOptions(shared_ptr<PublishStagingConfigToProductionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishStagingConfigToProductionResponse publishStagingConfigToProduction(shared_ptr<PublishStagingConfigToProductionRequest> request);
  PushObjectCacheResponse pushObjectCacheWithOptions(shared_ptr<PushObjectCacheRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PushObjectCacheResponse pushObjectCache(shared_ptr<PushObjectCacheRequest> request);
  RefreshObjectCachesResponse refreshObjectCachesWithOptions(shared_ptr<RefreshObjectCachesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefreshObjectCachesResponse refreshObjectCaches(shared_ptr<RefreshObjectCachesRequest> request);
  RollbackStagingConfigResponse rollbackStagingConfigWithOptions(shared_ptr<RollbackStagingConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RollbackStagingConfigResponse rollbackStagingConfig(shared_ptr<RollbackStagingConfigRequest> request);
  SetCdnDomainCSRCertificateResponse setCdnDomainCSRCertificateWithOptions(shared_ptr<SetCdnDomainCSRCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetCdnDomainCSRCertificateResponse setCdnDomainCSRCertificate(shared_ptr<SetCdnDomainCSRCertificateRequest> request);
  SetCdnDomainSMCertificateResponse setCdnDomainSMCertificateWithOptions(shared_ptr<SetCdnDomainSMCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetCdnDomainSMCertificateResponse setCdnDomainSMCertificate(shared_ptr<SetCdnDomainSMCertificateRequest> request);
  SetCdnDomainSSLCertificateResponse setCdnDomainSSLCertificateWithOptions(shared_ptr<SetCdnDomainSSLCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetCdnDomainSSLCertificateResponse setCdnDomainSSLCertificate(shared_ptr<SetCdnDomainSSLCertificateRequest> request);
  SetCdnDomainStagingConfigResponse setCdnDomainStagingConfigWithOptions(shared_ptr<SetCdnDomainStagingConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetCdnDomainStagingConfigResponse setCdnDomainStagingConfig(shared_ptr<SetCdnDomainStagingConfigRequest> request);
  SetDomainServerCertificateResponse setDomainServerCertificateWithOptions(shared_ptr<SetDomainServerCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDomainServerCertificateResponse setDomainServerCertificate(shared_ptr<SetDomainServerCertificateRequest> request);
  SetReqHeaderConfigResponse setReqHeaderConfigWithOptions(shared_ptr<SetReqHeaderConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetReqHeaderConfigResponse setReqHeaderConfig(shared_ptr<SetReqHeaderConfigRequest> request);
  SetWaitingRoomConfigResponse setWaitingRoomConfigWithOptions(shared_ptr<SetWaitingRoomConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetWaitingRoomConfigResponse setWaitingRoomConfig(shared_ptr<SetWaitingRoomConfigRequest> request);
  StartCdnDomainResponse startCdnDomainWithOptions(shared_ptr<StartCdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartCdnDomainResponse startCdnDomain(shared_ptr<StartCdnDomainRequest> request);
  StopCdnDomainResponse stopCdnDomainWithOptions(shared_ptr<StopCdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopCdnDomainResponse stopCdnDomain(shared_ptr<StopCdnDomainRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  UpdateCdnDeliverTaskResponse updateCdnDeliverTaskWithOptions(shared_ptr<UpdateCdnDeliverTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCdnDeliverTaskResponse updateCdnDeliverTask(shared_ptr<UpdateCdnDeliverTaskRequest> request);
  UpdateCdnSubTaskResponse updateCdnSubTaskWithOptions(shared_ptr<UpdateCdnSubTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCdnSubTaskResponse updateCdnSubTask(shared_ptr<UpdateCdnSubTaskRequest> request);
  UpdateFCTriggerResponse updateFCTriggerWithOptions(shared_ptr<UpdateFCTriggerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateFCTriggerResponse updateFCTrigger(shared_ptr<UpdateFCTriggerRequest> request);
  VerifyDomainOwnerResponse verifyDomainOwnerWithOptions(shared_ptr<VerifyDomainOwnerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VerifyDomainOwnerResponse verifyDomainOwner(shared_ptr<VerifyDomainOwnerRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Cdn20180510

#endif
