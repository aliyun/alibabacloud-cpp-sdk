// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_SAS20181203_H_
#define ALIBABACLOUD_SAS20181203_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Sas20181203 {
class AddVpcHoneyPotRequest : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcSwitchId{};

  AddVpcHoneyPotRequest() {}

  explicit AddVpcHoneyPotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcSwitchId) {
      res["VpcSwitchId"] = boost::any(*vpcSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcSwitchId") != m.end() && !m["VpcSwitchId"].empty()) {
      vpcSwitchId = make_shared<string>(boost::any_cast<string>(m["VpcSwitchId"]));
    }
  }


  virtual ~AddVpcHoneyPotRequest() = default;
};
class AddVpcHoneyPotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddVpcHoneyPotResponseBody() {}

  explicit AddVpcHoneyPotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddVpcHoneyPotResponseBody() = default;
};
class AddVpcHoneyPotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddVpcHoneyPotResponseBody> body{};

  AddVpcHoneyPotResponse() {}

  explicit AddVpcHoneyPotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddVpcHoneyPotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddVpcHoneyPotResponseBody>(model1);
      }
    }
  }


  virtual ~AddVpcHoneyPotResponse() = default;
};
class CheckQuaraFileIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> uuid{};
  shared_ptr<vector<string>> quaraFileIds{};

  CheckQuaraFileIdRequest() {}

  explicit CheckQuaraFileIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (quaraFileIds) {
      res["QuaraFileIds"] = boost::any(*quaraFileIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("QuaraFileIds") != m.end() && !m["QuaraFileIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["QuaraFileIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["QuaraFileIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      quaraFileIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CheckQuaraFileIdRequest() = default;
};
class CheckQuaraFileIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  CheckQuaraFileIdResponseBody() {}

  explicit CheckQuaraFileIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CheckQuaraFileIdResponseBody() = default;
};
class CheckQuaraFileIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CheckQuaraFileIdResponseBody> body{};

  CheckQuaraFileIdResponse() {}

  explicit CheckQuaraFileIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckQuaraFileIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckQuaraFileIdResponseBody>(model1);
      }
    }
  }


  virtual ~CheckQuaraFileIdResponse() = default;
};
class CheckSecurityEventIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> uuid{};
  shared_ptr<vector<string>> securityEventIds{};

  CheckSecurityEventIdRequest() {}

  explicit CheckSecurityEventIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (securityEventIds) {
      res["SecurityEventIds"] = boost::any(*securityEventIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("SecurityEventIds") != m.end() && !m["SecurityEventIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityEventIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityEventIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityEventIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CheckSecurityEventIdRequest() = default;
};
class CheckSecurityEventIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  CheckSecurityEventIdResponseBody() {}

  explicit CheckSecurityEventIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CheckSecurityEventIdResponseBody() = default;
};
class CheckSecurityEventIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CheckSecurityEventIdResponseBody> body{};

  CheckSecurityEventIdResponse() {}

  explicit CheckSecurityEventIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckSecurityEventIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckSecurityEventIdResponseBody>(model1);
      }
    }
  }


  virtual ~CheckSecurityEventIdResponse() = default;
};
class CreateAntiBruteForceRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> name{};
  shared_ptr<long> span{};
  shared_ptr<long> failCount{};
  shared_ptr<long> forbiddenTime{};
  shared_ptr<bool> defaultRule{};
  shared_ptr<vector<string>> uuidList{};

  CreateAntiBruteForceRuleRequest() {}

  explicit CreateAntiBruteForceRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (span) {
      res["Span"] = boost::any(*span);
    }
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (forbiddenTime) {
      res["ForbiddenTime"] = boost::any(*forbiddenTime);
    }
    if (defaultRule) {
      res["DefaultRule"] = boost::any(*defaultRule);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Span") != m.end() && !m["Span"].empty()) {
      span = make_shared<long>(boost::any_cast<long>(m["Span"]));
    }
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<long>(boost::any_cast<long>(m["FailCount"]));
    }
    if (m.find("ForbiddenTime") != m.end() && !m["ForbiddenTime"].empty()) {
      forbiddenTime = make_shared<long>(boost::any_cast<long>(m["ForbiddenTime"]));
    }
    if (m.find("DefaultRule") != m.end() && !m["DefaultRule"].empty()) {
      defaultRule = make_shared<bool>(boost::any_cast<bool>(m["DefaultRule"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateAntiBruteForceRuleRequest() = default;
};
class CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule : public Darabonba::Model {
public:
  shared_ptr<long> ruleId{};

  CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule() {}

  explicit CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule() = default;
};
class CreateAntiBruteForceRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule> createAntiBruteForceRule{};

  CreateAntiBruteForceRuleResponseBody() {}

  explicit CreateAntiBruteForceRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (createAntiBruteForceRule) {
      res["CreateAntiBruteForceRule"] = createAntiBruteForceRule ? boost::any(createAntiBruteForceRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CreateAntiBruteForceRule") != m.end() && !m["CreateAntiBruteForceRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateAntiBruteForceRule"].type()) {
        CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateAntiBruteForceRule"]));
        createAntiBruteForceRule = make_shared<CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule>(model1);
      }
    }
  }


  virtual ~CreateAntiBruteForceRuleResponseBody() = default;
};
class CreateAntiBruteForceRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateAntiBruteForceRuleResponseBody> body{};

  CreateAntiBruteForceRuleResponse() {}

  explicit CreateAntiBruteForceRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAntiBruteForceRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAntiBruteForceRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAntiBruteForceRuleResponse() = default;
};
class CreateAssetRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> os{};
  shared_ptr<string> status{};
  shared_ptr<string> osName{};

  CreateAssetRequest() {}

  explicit CreateAssetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (osName) {
      res["OsName"] = boost::any(*osName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("OsName") != m.end() && !m["OsName"].empty()) {
      osName = make_shared<string>(boost::any_cast<string>(m["OsName"]));
    }
  }


  virtual ~CreateAssetRequest() = default;
};
class CreateAssetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> uuid{};
  shared_ptr<string> requestId{};

  CreateAssetResponseBody() {}

  explicit CreateAssetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAssetResponseBody() = default;
};
class CreateAssetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateAssetResponseBody> body{};

  CreateAssetResponse() {}

  explicit CreateAssetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAssetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAssetResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAssetResponse() = default;
};
class CreateBackupPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> name{};
  shared_ptr<map<string, boost::any>> policy{};
  shared_ptr<string> policyVersion{};
  shared_ptr<string> policyRegionId{};
  shared_ptr<vector<string>> uuidList{};

  CreateBackupPolicyRequest() {}

  explicit CreateBackupPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    if (policyRegionId) {
      res["PolicyRegionId"] = boost::any(*policyRegionId);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Policy"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      policy = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
    if (m.find("PolicyRegionId") != m.end() && !m["PolicyRegionId"].empty()) {
      policyRegionId = make_shared<string>(boost::any_cast<string>(m["PolicyRegionId"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateBackupPolicyRequest() = default;
};
class CreateBackupPolicyShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> name{};
  shared_ptr<string> policyShrink{};
  shared_ptr<string> policyVersion{};
  shared_ptr<string> policyRegionId{};
  shared_ptr<vector<string>> uuidList{};

  CreateBackupPolicyShrinkRequest() {}

  explicit CreateBackupPolicyShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (policyShrink) {
      res["Policy"] = boost::any(*policyShrink);
    }
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    if (policyRegionId) {
      res["PolicyRegionId"] = boost::any(*policyRegionId);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policyShrink = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
    if (m.find("PolicyRegionId") != m.end() && !m["PolicyRegionId"].empty()) {
      policyRegionId = make_shared<string>(boost::any_cast<string>(m["PolicyRegionId"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateBackupPolicyShrinkRequest() = default;
};
class CreateBackupPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateBackupPolicyResponseBody() {}

  explicit CreateBackupPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateBackupPolicyResponseBody() = default;
};
class CreateBackupPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateBackupPolicyResponseBody> body{};

  CreateBackupPolicyResponse() {}

  explicit CreateBackupPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBackupPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBackupPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBackupPolicyResponse() = default;
};
class CreateOrUpdateAssetGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> uuids{};
  shared_ptr<string> groupName{};
  shared_ptr<long> groupId{};

  CreateOrUpdateAssetGroupRequest() {}

  explicit CreateOrUpdateAssetGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
  }


  virtual ~CreateOrUpdateAssetGroupRequest() = default;
};
class CreateOrUpdateAssetGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> requestId{};

  CreateOrUpdateAssetGroupResponseBody() {}

  explicit CreateOrUpdateAssetGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateOrUpdateAssetGroupResponseBody() = default;
};
class CreateOrUpdateAssetGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateOrUpdateAssetGroupResponseBody> body{};

  CreateOrUpdateAssetGroupResponse() {}

  explicit CreateOrUpdateAssetGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrUpdateAssetGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrUpdateAssetGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateAssetGroupResponse() = default;
};
class CreateRestoreJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> uuid{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> snapshotHash{};
  shared_ptr<string> target{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> vaultId{};
  shared_ptr<string> snapshotVersion{};
  shared_ptr<string> includes{};

  CreateRestoreJobRequest() {}

  explicit CreateRestoreJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (snapshotHash) {
      res["SnapshotHash"] = boost::any(*snapshotHash);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (vaultId) {
      res["VaultId"] = boost::any(*vaultId);
    }
    if (snapshotVersion) {
      res["SnapshotVersion"] = boost::any(*snapshotVersion);
    }
    if (includes) {
      res["Includes"] = boost::any(*includes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("SnapshotHash") != m.end() && !m["SnapshotHash"].empty()) {
      snapshotHash = make_shared<string>(boost::any_cast<string>(m["SnapshotHash"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("VaultId") != m.end() && !m["VaultId"].empty()) {
      vaultId = make_shared<string>(boost::any_cast<string>(m["VaultId"]));
    }
    if (m.find("SnapshotVersion") != m.end() && !m["SnapshotVersion"].empty()) {
      snapshotVersion = make_shared<string>(boost::any_cast<string>(m["SnapshotVersion"]));
    }
    if (m.find("Includes") != m.end() && !m["Includes"].empty()) {
      includes = make_shared<string>(boost::any_cast<string>(m["Includes"]));
    }
  }


  virtual ~CreateRestoreJobRequest() = default;
};
class CreateRestoreJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateRestoreJobResponseBody() {}

  explicit CreateRestoreJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateRestoreJobResponseBody() = default;
};
class CreateRestoreJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateRestoreJobResponseBody> body{};

  CreateRestoreJobResponse() {}

  explicit CreateRestoreJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRestoreJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRestoreJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRestoreJobResponse() = default;
};
class CreateSasOrderRequest : public Darabonba::Model {
public:
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<long> autoRenewPeriod{};
  shared_ptr<bool> autoPay{};
  shared_ptr<bool> autoUseCoupon{};
  shared_ptr<string> spec{};
  shared_ptr<string> instanceCount{};
  shared_ptr<string> sasSlsStorage{};
  shared_ptr<string> sasAntiRansomware{};
  shared_ptr<string> sasWebguardBoolean{};
  shared_ptr<string> sasSc{};
  shared_ptr<string> sasProductService{};
  shared_ptr<string> sasWebguardOrderNum{};
  shared_ptr<string> vcore{};
  shared_ptr<string> containerImageScan{};

  CreateSasOrderRequest() {}

  explicit CreateSasOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (autoRenewPeriod) {
      res["AutoRenewPeriod"] = boost::any(*autoRenewPeriod);
    }
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (autoUseCoupon) {
      res["AutoUseCoupon"] = boost::any(*autoUseCoupon);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (sasSlsStorage) {
      res["SasSlsStorage"] = boost::any(*sasSlsStorage);
    }
    if (sasAntiRansomware) {
      res["SasAntiRansomware"] = boost::any(*sasAntiRansomware);
    }
    if (sasWebguardBoolean) {
      res["SasWebguardBoolean"] = boost::any(*sasWebguardBoolean);
    }
    if (sasSc) {
      res["SasSc"] = boost::any(*sasSc);
    }
    if (sasProductService) {
      res["SasProductService"] = boost::any(*sasProductService);
    }
    if (sasWebguardOrderNum) {
      res["SasWebguardOrderNum"] = boost::any(*sasWebguardOrderNum);
    }
    if (vcore) {
      res["Vcore"] = boost::any(*vcore);
    }
    if (containerImageScan) {
      res["ContainerImageScan"] = boost::any(*containerImageScan);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("AutoRenewPeriod") != m.end() && !m["AutoRenewPeriod"].empty()) {
      autoRenewPeriod = make_shared<long>(boost::any_cast<long>(m["AutoRenewPeriod"]));
    }
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("AutoUseCoupon") != m.end() && !m["AutoUseCoupon"].empty()) {
      autoUseCoupon = make_shared<bool>(boost::any_cast<bool>(m["AutoUseCoupon"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<string>(boost::any_cast<string>(m["InstanceCount"]));
    }
    if (m.find("SasSlsStorage") != m.end() && !m["SasSlsStorage"].empty()) {
      sasSlsStorage = make_shared<string>(boost::any_cast<string>(m["SasSlsStorage"]));
    }
    if (m.find("SasAntiRansomware") != m.end() && !m["SasAntiRansomware"].empty()) {
      sasAntiRansomware = make_shared<string>(boost::any_cast<string>(m["SasAntiRansomware"]));
    }
    if (m.find("SasWebguardBoolean") != m.end() && !m["SasWebguardBoolean"].empty()) {
      sasWebguardBoolean = make_shared<string>(boost::any_cast<string>(m["SasWebguardBoolean"]));
    }
    if (m.find("SasSc") != m.end() && !m["SasSc"].empty()) {
      sasSc = make_shared<string>(boost::any_cast<string>(m["SasSc"]));
    }
    if (m.find("SasProductService") != m.end() && !m["SasProductService"].empty()) {
      sasProductService = make_shared<string>(boost::any_cast<string>(m["SasProductService"]));
    }
    if (m.find("SasWebguardOrderNum") != m.end() && !m["SasWebguardOrderNum"].empty()) {
      sasWebguardOrderNum = make_shared<string>(boost::any_cast<string>(m["SasWebguardOrderNum"]));
    }
    if (m.find("Vcore") != m.end() && !m["Vcore"].empty()) {
      vcore = make_shared<string>(boost::any_cast<string>(m["Vcore"]));
    }
    if (m.find("ContainerImageScan") != m.end() && !m["ContainerImageScan"].empty()) {
      containerImageScan = make_shared<string>(boost::any_cast<string>(m["ContainerImageScan"]));
    }
  }


  virtual ~CreateSasOrderRequest() = default;
};
class CreateSasOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  CreateSasOrderResponseBody() {}

  explicit CreateSasOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateSasOrderResponseBody() = default;
};
class CreateSasOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateSasOrderResponseBody> body{};

  CreateSasOrderResponse() {}

  explicit CreateSasOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSasOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSasOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSasOrderResponse() = default;
};
class CreateServiceLinkedRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateServiceLinkedRoleResponseBody() {}

  explicit CreateServiceLinkedRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateServiceLinkedRoleResponseBody() = default;
};
class CreateServiceLinkedRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateServiceLinkedRoleResponseBody> body{};

  CreateServiceLinkedRoleResponse() {}

  explicit CreateServiceLinkedRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateServiceLinkedRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateServiceLinkedRoleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateServiceLinkedRoleResponse() = default;
};
class CreateSimilarSecurityEventsQueryTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> securityEventId{};
  shared_ptr<string> similarEventScenarioCode{};

  CreateSimilarSecurityEventsQueryTaskRequest() {}

  explicit CreateSimilarSecurityEventsQueryTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityEventId) {
      res["SecurityEventId"] = boost::any(*securityEventId);
    }
    if (similarEventScenarioCode) {
      res["SimilarEventScenarioCode"] = boost::any(*similarEventScenarioCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityEventId") != m.end() && !m["SecurityEventId"].empty()) {
      securityEventId = make_shared<long>(boost::any_cast<long>(m["SecurityEventId"]));
    }
    if (m.find("SimilarEventScenarioCode") != m.end() && !m["SimilarEventScenarioCode"].empty()) {
      similarEventScenarioCode = make_shared<string>(boost::any_cast<string>(m["SimilarEventScenarioCode"]));
    }
  }


  virtual ~CreateSimilarSecurityEventsQueryTaskRequest() = default;
};
class CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};

  CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse() {}

  explicit CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse() = default;
};
class CreateSimilarSecurityEventsQueryTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse> createSimilarSecurityEventsQueryTaskResponse{};

  CreateSimilarSecurityEventsQueryTaskResponseBody() {}

  explicit CreateSimilarSecurityEventsQueryTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (createSimilarSecurityEventsQueryTaskResponse) {
      res["CreateSimilarSecurityEventsQueryTaskResponse"] = createSimilarSecurityEventsQueryTaskResponse ? boost::any(createSimilarSecurityEventsQueryTaskResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CreateSimilarSecurityEventsQueryTaskResponse") != m.end() && !m["CreateSimilarSecurityEventsQueryTaskResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateSimilarSecurityEventsQueryTaskResponse"].type()) {
        CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateSimilarSecurityEventsQueryTaskResponse"]));
        createSimilarSecurityEventsQueryTaskResponse = make_shared<CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse>(model1);
      }
    }
  }


  virtual ~CreateSimilarSecurityEventsQueryTaskResponseBody() = default;
};
class CreateSimilarSecurityEventsQueryTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateSimilarSecurityEventsQueryTaskResponseBody> body{};

  CreateSimilarSecurityEventsQueryTaskResponse() {}

  explicit CreateSimilarSecurityEventsQueryTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSimilarSecurityEventsQueryTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSimilarSecurityEventsQueryTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSimilarSecurityEventsQueryTaskResponse() = default;
};
class DeleteAssetRequest : public Darabonba::Model {
public:
  shared_ptr<string> uuid{};

  DeleteAssetRequest() {}

  explicit DeleteAssetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DeleteAssetRequest() = default;
};
class DeleteAssetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAssetResponseBody() {}

  explicit DeleteAssetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAssetResponseBody() = default;
};
class DeleteAssetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteAssetResponseBody> body{};

  DeleteAssetResponse() {}

  explicit DeleteAssetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAssetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAssetResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAssetResponse() = default;
};
class DeleteBackupPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> id{};
  shared_ptr<string> policyVersion{};

  DeleteBackupPolicyRequest() {}

  explicit DeleteBackupPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
  }


  virtual ~DeleteBackupPolicyRequest() = default;
};
class DeleteBackupPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteBackupPolicyResponseBody() {}

  explicit DeleteBackupPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteBackupPolicyResponseBody() = default;
};
class DeleteBackupPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteBackupPolicyResponseBody> body{};

  DeleteBackupPolicyResponse() {}

  explicit DeleteBackupPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBackupPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBackupPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBackupPolicyResponse() = default;
};
class DeleteBackupPolicyMachineRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> uuid{};
  shared_ptr<long> policyId{};
  shared_ptr<string> policyVersion{};
  shared_ptr<vector<string>> uuidList{};

  DeleteBackupPolicyMachineRequest() {}

  explicit DeleteBackupPolicyMachineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteBackupPolicyMachineRequest() = default;
};
class DeleteBackupPolicyMachineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteBackupPolicyMachineResponseBody() {}

  explicit DeleteBackupPolicyMachineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteBackupPolicyMachineResponseBody() = default;
};
class DeleteBackupPolicyMachineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteBackupPolicyMachineResponseBody> body{};

  DeleteBackupPolicyMachineResponse() {}

  explicit DeleteBackupPolicyMachineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBackupPolicyMachineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBackupPolicyMachineResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBackupPolicyMachineResponse() = default;
};
class DeleteGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> groupId{};

  DeleteGroupRequest() {}

  explicit DeleteGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
  }


  virtual ~DeleteGroupRequest() = default;
};
class DeleteGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteGroupResponseBody() {}

  explicit DeleteGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteGroupResponseBody() = default;
};
class DeleteGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteGroupResponseBody> body{};

  DeleteGroupResponse() {}

  explicit DeleteGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGroupResponse() = default;
};
class DeleteLoginBaseConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> config{};
  shared_ptr<string> target{};

  DeleteLoginBaseConfigRequest() {}

  explicit DeleteLoginBaseConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
  }


  virtual ~DeleteLoginBaseConfigRequest() = default;
};
class DeleteLoginBaseConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLoginBaseConfigResponseBody() {}

  explicit DeleteLoginBaseConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLoginBaseConfigResponseBody() = default;
};
class DeleteLoginBaseConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteLoginBaseConfigResponseBody> body{};

  DeleteLoginBaseConfigResponse() {}

  explicit DeleteLoginBaseConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLoginBaseConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLoginBaseConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLoginBaseConfigResponse() = default;
};
class DeleteStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> id{};
  shared_ptr<string> lang{};

  DeleteStrategyRequest() {}

  explicit DeleteStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DeleteStrategyRequest() = default;
};
class DeleteStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteStrategyResponseBody() {}

  explicit DeleteStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteStrategyResponseBody() = default;
};
class DeleteStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteStrategyResponseBody> body{};

  DeleteStrategyResponse() {}

  explicit DeleteStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteStrategyResponse() = default;
};
class DeleteTagWithUuidRequest : public Darabonba::Model {
public:
  shared_ptr<string> tagName{};
  shared_ptr<string> uuidList{};

  DeleteTagWithUuidRequest() {}

  explicit DeleteTagWithUuidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      uuidList = make_shared<string>(boost::any_cast<string>(m["UuidList"]));
    }
  }


  virtual ~DeleteTagWithUuidRequest() = default;
};
class DeleteTagWithUuidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteTagWithUuidResponseBody() {}

  explicit DeleteTagWithUuidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteTagWithUuidResponseBody() = default;
};
class DeleteTagWithUuidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteTagWithUuidResponseBody> body{};

  DeleteTagWithUuidResponse() {}

  explicit DeleteTagWithUuidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTagWithUuidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTagWithUuidResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTagWithUuidResponse() = default;
};
class DeleteVpcHoneyPotRequest : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};

  DeleteVpcHoneyPotRequest() {}

  explicit DeleteVpcHoneyPotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DeleteVpcHoneyPotRequest() = default;
};
class DeleteVpcHoneyPotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVpcHoneyPotResponseBody() {}

  explicit DeleteVpcHoneyPotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVpcHoneyPotResponseBody() = default;
};
class DeleteVpcHoneyPotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteVpcHoneyPotResponseBody> body{};

  DeleteVpcHoneyPotResponse() {}

  explicit DeleteVpcHoneyPotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVpcHoneyPotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVpcHoneyPotResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVpcHoneyPotResponse() = default;
};
class DescribeAccesskeyLeakListRequest : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> query{};
  shared_ptr<long> startTs{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};

  DescribeAccesskeyLeakListRequest() {}

  explicit DescribeAccesskeyLeakListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~DescribeAccesskeyLeakListRequest() = default;
};
class DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList : public Darabonba::Model {
public:
  shared_ptr<string> dealTime{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> userType{};
  shared_ptr<string> accesskeyId{};
  shared_ptr<string> aliUserName{};
  shared_ptr<string> dealType{};
  shared_ptr<string> url{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> asset{};
  shared_ptr<long> id{};

  DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList() {}

  explicit DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dealTime) {
      res["DealTime"] = boost::any(*dealTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (userType) {
      res["UserType"] = boost::any(*userType);
    }
    if (accesskeyId) {
      res["AccesskeyId"] = boost::any(*accesskeyId);
    }
    if (aliUserName) {
      res["AliUserName"] = boost::any(*aliUserName);
    }
    if (dealType) {
      res["DealType"] = boost::any(*dealType);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (asset) {
      res["Asset"] = boost::any(*asset);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DealTime") != m.end() && !m["DealTime"].empty()) {
      dealTime = make_shared<string>(boost::any_cast<string>(m["DealTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UserType") != m.end() && !m["UserType"].empty()) {
      userType = make_shared<string>(boost::any_cast<string>(m["UserType"]));
    }
    if (m.find("AccesskeyId") != m.end() && !m["AccesskeyId"].empty()) {
      accesskeyId = make_shared<string>(boost::any_cast<string>(m["AccesskeyId"]));
    }
    if (m.find("AliUserName") != m.end() && !m["AliUserName"].empty()) {
      aliUserName = make_shared<string>(boost::any_cast<string>(m["AliUserName"]));
    }
    if (m.find("DealType") != m.end() && !m["DealType"].empty()) {
      dealType = make_shared<string>(boost::any_cast<string>(m["DealType"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Asset") != m.end() && !m["Asset"].empty()) {
      asset = make_shared<string>(boost::any_cast<string>(m["Asset"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList() = default;
};
class DescribeAccesskeyLeakListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> requestId{};
  shared_ptr<long> gmtLast{};
  shared_ptr<long> akLeakCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList>> accessKeyLeakList{};

  DescribeAccesskeyLeakListResponseBody() {}

  explicit DescribeAccesskeyLeakListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (gmtLast) {
      res["GmtLast"] = boost::any(*gmtLast);
    }
    if (akLeakCount) {
      res["AkLeakCount"] = boost::any(*akLeakCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (accessKeyLeakList) {
      vector<boost::any> temp1;
      for(auto item1:*accessKeyLeakList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccessKeyLeakList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("GmtLast") != m.end() && !m["GmtLast"].empty()) {
      gmtLast = make_shared<long>(boost::any_cast<long>(m["GmtLast"]));
    }
    if (m.find("AkLeakCount") != m.end() && !m["AkLeakCount"].empty()) {
      akLeakCount = make_shared<long>(boost::any_cast<long>(m["AkLeakCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("AccessKeyLeakList") != m.end() && !m["AccessKeyLeakList"].empty()) {
      if (typeid(vector<boost::any>) == m["AccessKeyLeakList"].type()) {
        vector<DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccessKeyLeakList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accessKeyLeakList = make_shared<vector<DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList>>(expect1);
      }
    }
  }


  virtual ~DescribeAccesskeyLeakListResponseBody() = default;
};
class DescribeAccesskeyLeakListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAccesskeyLeakListResponseBody> body{};

  DescribeAccesskeyLeakListResponse() {}

  explicit DescribeAccesskeyLeakListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAccesskeyLeakListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAccesskeyLeakListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAccesskeyLeakListResponse() = default;
};
class DescribeAffectedMaliciousFileImagesRequest : public Darabonba::Model {
public:
  shared_ptr<string> maliciousMd5{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> lang{};
  shared_ptr<string> repoRegionId{};
  shared_ptr<string> repoInstanceId{};
  shared_ptr<string> repoId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> imageTag{};
  shared_ptr<string> imageDigest{};
  shared_ptr<string> imageLayer{};

  DescribeAffectedMaliciousFileImagesRequest() {}

  explicit DescribeAffectedMaliciousFileImagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maliciousMd5) {
      res["MaliciousMd5"] = boost::any(*maliciousMd5);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (repoRegionId) {
      res["RepoRegionId"] = boost::any(*repoRegionId);
    }
    if (repoInstanceId) {
      res["RepoInstanceId"] = boost::any(*repoInstanceId);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (imageTag) {
      res["ImageTag"] = boost::any(*imageTag);
    }
    if (imageDigest) {
      res["ImageDigest"] = boost::any(*imageDigest);
    }
    if (imageLayer) {
      res["ImageLayer"] = boost::any(*imageLayer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaliciousMd5") != m.end() && !m["MaliciousMd5"].empty()) {
      maliciousMd5 = make_shared<string>(boost::any_cast<string>(m["MaliciousMd5"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RepoRegionId") != m.end() && !m["RepoRegionId"].empty()) {
      repoRegionId = make_shared<string>(boost::any_cast<string>(m["RepoRegionId"]));
    }
    if (m.find("RepoInstanceId") != m.end() && !m["RepoInstanceId"].empty()) {
      repoInstanceId = make_shared<string>(boost::any_cast<string>(m["RepoInstanceId"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("ImageTag") != m.end() && !m["ImageTag"].empty()) {
      imageTag = make_shared<string>(boost::any_cast<string>(m["ImageTag"]));
    }
    if (m.find("ImageDigest") != m.end() && !m["ImageDigest"].empty()) {
      imageDigest = make_shared<string>(boost::any_cast<string>(m["ImageDigest"]));
    }
    if (m.find("ImageLayer") != m.end() && !m["ImageLayer"].empty()) {
      imageLayer = make_shared<string>(boost::any_cast<string>(m["ImageLayer"]));
    }
  }


  virtual ~DescribeAffectedMaliciousFileImagesRequest() = default;
};
class DescribeAffectedMaliciousFileImagesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribeAffectedMaliciousFileImagesResponseBodyPageInfo() {}

  explicit DescribeAffectedMaliciousFileImagesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeAffectedMaliciousFileImagesResponseBodyPageInfo() = default;
};
class DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<string> digest{};
  shared_ptr<long> latestVerifyTimestamp{};
  shared_ptr<string> repoInstanceId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> tag{};
  shared_ptr<string> repoRegionId{};
  shared_ptr<string> imageUuid{};
  shared_ptr<long> firstScanTimestamp{};
  shared_ptr<string> maliciousMd5{};
  shared_ptr<string> filePath{};
  shared_ptr<string> repoId{};
  shared_ptr<string> layer{};
  shared_ptr<long> latestScanTimestamp{};
  shared_ptr<string> repoName{};
  shared_ptr<string> level{};

  DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse() {}

  explicit DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (digest) {
      res["Digest"] = boost::any(*digest);
    }
    if (latestVerifyTimestamp) {
      res["LatestVerifyTimestamp"] = boost::any(*latestVerifyTimestamp);
    }
    if (repoInstanceId) {
      res["RepoInstanceId"] = boost::any(*repoInstanceId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (repoRegionId) {
      res["RepoRegionId"] = boost::any(*repoRegionId);
    }
    if (imageUuid) {
      res["ImageUuid"] = boost::any(*imageUuid);
    }
    if (firstScanTimestamp) {
      res["FirstScanTimestamp"] = boost::any(*firstScanTimestamp);
    }
    if (maliciousMd5) {
      res["MaliciousMd5"] = boost::any(*maliciousMd5);
    }
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    if (layer) {
      res["Layer"] = boost::any(*layer);
    }
    if (latestScanTimestamp) {
      res["LatestScanTimestamp"] = boost::any(*latestScanTimestamp);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Digest") != m.end() && !m["Digest"].empty()) {
      digest = make_shared<string>(boost::any_cast<string>(m["Digest"]));
    }
    if (m.find("LatestVerifyTimestamp") != m.end() && !m["LatestVerifyTimestamp"].empty()) {
      latestVerifyTimestamp = make_shared<long>(boost::any_cast<long>(m["LatestVerifyTimestamp"]));
    }
    if (m.find("RepoInstanceId") != m.end() && !m["RepoInstanceId"].empty()) {
      repoInstanceId = make_shared<string>(boost::any_cast<string>(m["RepoInstanceId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("RepoRegionId") != m.end() && !m["RepoRegionId"].empty()) {
      repoRegionId = make_shared<string>(boost::any_cast<string>(m["RepoRegionId"]));
    }
    if (m.find("ImageUuid") != m.end() && !m["ImageUuid"].empty()) {
      imageUuid = make_shared<string>(boost::any_cast<string>(m["ImageUuid"]));
    }
    if (m.find("FirstScanTimestamp") != m.end() && !m["FirstScanTimestamp"].empty()) {
      firstScanTimestamp = make_shared<long>(boost::any_cast<long>(m["FirstScanTimestamp"]));
    }
    if (m.find("MaliciousMd5") != m.end() && !m["MaliciousMd5"].empty()) {
      maliciousMd5 = make_shared<string>(boost::any_cast<string>(m["MaliciousMd5"]));
    }
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
    if (m.find("Layer") != m.end() && !m["Layer"].empty()) {
      layer = make_shared<string>(boost::any_cast<string>(m["Layer"]));
    }
    if (m.find("LatestScanTimestamp") != m.end() && !m["LatestScanTimestamp"].empty()) {
      latestScanTimestamp = make_shared<long>(boost::any_cast<long>(m["LatestScanTimestamp"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse() = default;
};
class DescribeAffectedMaliciousFileImagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAffectedMaliciousFileImagesResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse>> affectedMaliciousFileImagesResponse{};

  DescribeAffectedMaliciousFileImagesResponseBody() {}

  explicit DescribeAffectedMaliciousFileImagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (affectedMaliciousFileImagesResponse) {
      vector<boost::any> temp1;
      for(auto item1:*affectedMaliciousFileImagesResponse){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AffectedMaliciousFileImagesResponse"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeAffectedMaliciousFileImagesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeAffectedMaliciousFileImagesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("AffectedMaliciousFileImagesResponse") != m.end() && !m["AffectedMaliciousFileImagesResponse"].empty()) {
      if (typeid(vector<boost::any>) == m["AffectedMaliciousFileImagesResponse"].type()) {
        vector<DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AffectedMaliciousFileImagesResponse"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        affectedMaliciousFileImagesResponse = make_shared<vector<DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse>>(expect1);
      }
    }
  }


  virtual ~DescribeAffectedMaliciousFileImagesResponseBody() = default;
};
class DescribeAffectedMaliciousFileImagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAffectedMaliciousFileImagesResponseBody> body{};

  DescribeAffectedMaliciousFileImagesResponse() {}

  explicit DescribeAffectedMaliciousFileImagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAffectedMaliciousFileImagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAffectedMaliciousFileImagesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAffectedMaliciousFileImagesResponse() = default;
};
class DescribeAlarmEventDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};
  shared_ptr<string> alarmUniqueInfo{};
  shared_ptr<string> from{};

  DescribeAlarmEventDetailRequest() {}

  explicit DescribeAlarmEventDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (alarmUniqueInfo) {
      res["AlarmUniqueInfo"] = boost::any(*alarmUniqueInfo);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("AlarmUniqueInfo") != m.end() && !m["AlarmUniqueInfo"].empty()) {
      alarmUniqueInfo = make_shared<string>(boost::any_cast<string>(m["AlarmUniqueInfo"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
  }


  virtual ~DescribeAlarmEventDetailRequest() = default;
};
class DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> value{};
  shared_ptr<string> name{};

  DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue() {}

  explicit DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue() = default;
};
class DescribeAlarmEventDetailResponseBodyDataCauseDetails : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue>> value{};

  DescribeAlarmEventDetailResponseBodyDataCauseDetails() {}

  explicit DescribeAlarmEventDetailResponseBodyDataCauseDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      vector<boost::any> temp1;
      for(auto item1:*value){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Value"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Value"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        value = make_shared<vector<DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue>>(expect1);
      }
    }
  }


  virtual ~DescribeAlarmEventDetailResponseBodyDataCauseDetails() = default;
};
class DescribeAlarmEventDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> k8sClusterName{};
  shared_ptr<string> containerImageId{};
  shared_ptr<string> alarmEventDesc{};
  shared_ptr<string> alarmUniqueInfo{};
  shared_ptr<bool> canCancelFault{};
  shared_ptr<string> appName{};
  shared_ptr<bool> canBeDealOnLine{};
  shared_ptr<string> containerImageName{};
  shared_ptr<string> k8sClusterId{};
  shared_ptr<bool> containHwMode{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> k8sNodeId{};
  shared_ptr<string> solution{};
  shared_ptr<string> dataSource{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> alarmEventAliasName{};
  shared_ptr<long> endTime{};
  shared_ptr<string> uuid{};
  shared_ptr<long> startTime{};
  shared_ptr<string> containerId{};
  shared_ptr<string> k8sPodName{};
  shared_ptr<string> k8sNamespace{};
  shared_ptr<string> k8sNodeName{};
  shared_ptr<string> level{};
  shared_ptr<vector<DescribeAlarmEventDetailResponseBodyDataCauseDetails>> causeDetails{};

  DescribeAlarmEventDetailResponseBodyData() {}

  explicit DescribeAlarmEventDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (k8sClusterName) {
      res["K8sClusterName"] = boost::any(*k8sClusterName);
    }
    if (containerImageId) {
      res["ContainerImageId"] = boost::any(*containerImageId);
    }
    if (alarmEventDesc) {
      res["AlarmEventDesc"] = boost::any(*alarmEventDesc);
    }
    if (alarmUniqueInfo) {
      res["AlarmUniqueInfo"] = boost::any(*alarmUniqueInfo);
    }
    if (canCancelFault) {
      res["CanCancelFault"] = boost::any(*canCancelFault);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (canBeDealOnLine) {
      res["CanBeDealOnLine"] = boost::any(*canBeDealOnLine);
    }
    if (containerImageName) {
      res["ContainerImageName"] = boost::any(*containerImageName);
    }
    if (k8sClusterId) {
      res["K8sClusterId"] = boost::any(*k8sClusterId);
    }
    if (containHwMode) {
      res["ContainHwMode"] = boost::any(*containHwMode);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (k8sNodeId) {
      res["K8sNodeId"] = boost::any(*k8sNodeId);
    }
    if (solution) {
      res["Solution"] = boost::any(*solution);
    }
    if (dataSource) {
      res["DataSource"] = boost::any(*dataSource);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (alarmEventAliasName) {
      res["AlarmEventAliasName"] = boost::any(*alarmEventAliasName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (k8sPodName) {
      res["K8sPodName"] = boost::any(*k8sPodName);
    }
    if (k8sNamespace) {
      res["K8sNamespace"] = boost::any(*k8sNamespace);
    }
    if (k8sNodeName) {
      res["K8sNodeName"] = boost::any(*k8sNodeName);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (causeDetails) {
      vector<boost::any> temp1;
      for(auto item1:*causeDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CauseDetails"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("K8sClusterName") != m.end() && !m["K8sClusterName"].empty()) {
      k8sClusterName = make_shared<string>(boost::any_cast<string>(m["K8sClusterName"]));
    }
    if (m.find("ContainerImageId") != m.end() && !m["ContainerImageId"].empty()) {
      containerImageId = make_shared<string>(boost::any_cast<string>(m["ContainerImageId"]));
    }
    if (m.find("AlarmEventDesc") != m.end() && !m["AlarmEventDesc"].empty()) {
      alarmEventDesc = make_shared<string>(boost::any_cast<string>(m["AlarmEventDesc"]));
    }
    if (m.find("AlarmUniqueInfo") != m.end() && !m["AlarmUniqueInfo"].empty()) {
      alarmUniqueInfo = make_shared<string>(boost::any_cast<string>(m["AlarmUniqueInfo"]));
    }
    if (m.find("CanCancelFault") != m.end() && !m["CanCancelFault"].empty()) {
      canCancelFault = make_shared<bool>(boost::any_cast<bool>(m["CanCancelFault"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CanBeDealOnLine") != m.end() && !m["CanBeDealOnLine"].empty()) {
      canBeDealOnLine = make_shared<bool>(boost::any_cast<bool>(m["CanBeDealOnLine"]));
    }
    if (m.find("ContainerImageName") != m.end() && !m["ContainerImageName"].empty()) {
      containerImageName = make_shared<string>(boost::any_cast<string>(m["ContainerImageName"]));
    }
    if (m.find("K8sClusterId") != m.end() && !m["K8sClusterId"].empty()) {
      k8sClusterId = make_shared<string>(boost::any_cast<string>(m["K8sClusterId"]));
    }
    if (m.find("ContainHwMode") != m.end() && !m["ContainHwMode"].empty()) {
      containHwMode = make_shared<bool>(boost::any_cast<bool>(m["ContainHwMode"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("K8sNodeId") != m.end() && !m["K8sNodeId"].empty()) {
      k8sNodeId = make_shared<string>(boost::any_cast<string>(m["K8sNodeId"]));
    }
    if (m.find("Solution") != m.end() && !m["Solution"].empty()) {
      solution = make_shared<string>(boost::any_cast<string>(m["Solution"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      dataSource = make_shared<string>(boost::any_cast<string>(m["DataSource"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("AlarmEventAliasName") != m.end() && !m["AlarmEventAliasName"].empty()) {
      alarmEventAliasName = make_shared<string>(boost::any_cast<string>(m["AlarmEventAliasName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<string>(boost::any_cast<string>(m["ContainerId"]));
    }
    if (m.find("K8sPodName") != m.end() && !m["K8sPodName"].empty()) {
      k8sPodName = make_shared<string>(boost::any_cast<string>(m["K8sPodName"]));
    }
    if (m.find("K8sNamespace") != m.end() && !m["K8sNamespace"].empty()) {
      k8sNamespace = make_shared<string>(boost::any_cast<string>(m["K8sNamespace"]));
    }
    if (m.find("K8sNodeName") != m.end() && !m["K8sNodeName"].empty()) {
      k8sNodeName = make_shared<string>(boost::any_cast<string>(m["K8sNodeName"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("CauseDetails") != m.end() && !m["CauseDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["CauseDetails"].type()) {
        vector<DescribeAlarmEventDetailResponseBodyDataCauseDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CauseDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlarmEventDetailResponseBodyDataCauseDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        causeDetails = make_shared<vector<DescribeAlarmEventDetailResponseBodyDataCauseDetails>>(expect1);
      }
    }
  }


  virtual ~DescribeAlarmEventDetailResponseBodyData() = default;
};
class DescribeAlarmEventDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAlarmEventDetailResponseBodyData> data{};

  DescribeAlarmEventDetailResponseBody() {}

  explicit DescribeAlarmEventDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeAlarmEventDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeAlarmEventDetailResponseBodyData>(model1);
      }
    }
  }


  virtual ~DescribeAlarmEventDetailResponseBody() = default;
};
class DescribeAlarmEventDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAlarmEventDetailResponseBody> body{};

  DescribeAlarmEventDetailResponse() {}

  explicit DescribeAlarmEventDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAlarmEventDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAlarmEventDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAlarmEventDetailResponse() = default;
};
class DescribeAlarmEventListRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};
  shared_ptr<string> dealed{};
  shared_ptr<string> from{};
  shared_ptr<string> levels{};
  shared_ptr<string> remark{};
  shared_ptr<string> groupId{};
  shared_ptr<string> alarmEventName{};
  shared_ptr<string> alarmEventType{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> containerFieldName{};
  shared_ptr<string> containerFieldValue{};
  shared_ptr<string> targetType{};
  shared_ptr<vector<string>> operateErrorCodeList{};

  DescribeAlarmEventListRequest() {}

  explicit DescribeAlarmEventListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (dealed) {
      res["Dealed"] = boost::any(*dealed);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (levels) {
      res["Levels"] = boost::any(*levels);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (alarmEventName) {
      res["AlarmEventName"] = boost::any(*alarmEventName);
    }
    if (alarmEventType) {
      res["AlarmEventType"] = boost::any(*alarmEventType);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (containerFieldName) {
      res["ContainerFieldName"] = boost::any(*containerFieldName);
    }
    if (containerFieldValue) {
      res["ContainerFieldValue"] = boost::any(*containerFieldValue);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (operateErrorCodeList) {
      res["OperateErrorCodeList"] = boost::any(*operateErrorCodeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Dealed") != m.end() && !m["Dealed"].empty()) {
      dealed = make_shared<string>(boost::any_cast<string>(m["Dealed"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Levels") != m.end() && !m["Levels"].empty()) {
      levels = make_shared<string>(boost::any_cast<string>(m["Levels"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("AlarmEventName") != m.end() && !m["AlarmEventName"].empty()) {
      alarmEventName = make_shared<string>(boost::any_cast<string>(m["AlarmEventName"]));
    }
    if (m.find("AlarmEventType") != m.end() && !m["AlarmEventType"].empty()) {
      alarmEventType = make_shared<string>(boost::any_cast<string>(m["AlarmEventType"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ContainerFieldName") != m.end() && !m["ContainerFieldName"].empty()) {
      containerFieldName = make_shared<string>(boost::any_cast<string>(m["ContainerFieldName"]));
    }
    if (m.find("ContainerFieldValue") != m.end() && !m["ContainerFieldValue"].empty()) {
      containerFieldValue = make_shared<string>(boost::any_cast<string>(m["ContainerFieldValue"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("OperateErrorCodeList") != m.end() && !m["OperateErrorCodeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OperateErrorCodeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OperateErrorCodeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      operateErrorCodeList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAlarmEventListRequest() = default;
};
class DescribeAlarmEventListResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribeAlarmEventListResponseBodyPageInfo() {}

  explicit DescribeAlarmEventListResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeAlarmEventListResponseBodyPageInfo() = default;
};
class DescribeAlarmEventListResponseBodySuspEvents : public Darabonba::Model {
public:
  shared_ptr<bool> dealed{};
  shared_ptr<string> stages{};
  shared_ptr<string> internetIp{};
  shared_ptr<long> suspiciousEventCount{};
  shared_ptr<string> k8sClusterName{};
  shared_ptr<string> containerImageId{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> alarmEventNameOriginal{};
  shared_ptr<string> alarmUniqueInfo{};
  shared_ptr<bool> canCancelFault{};
  shared_ptr<string> appName{};
  shared_ptr<string> securityEventIds{};
  shared_ptr<string> k8sClusterId{};
  shared_ptr<string> containerImageName{};
  shared_ptr<bool> canBeDealOnLine{};
  shared_ptr<string> description{};
  shared_ptr<bool> containHwMode{};
  shared_ptr<string> k8sNodeId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> saleVersion{};
  shared_ptr<string> operateErrorCode{};
  shared_ptr<string> solution{};
  shared_ptr<bool> hasTraceInfo{};
  shared_ptr<string> dataSource{};
  shared_ptr<long> operateTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> intranetIp{};
  shared_ptr<long> endTime{};
  shared_ptr<string> uuid{};
  shared_ptr<long> startTime{};
  shared_ptr<string> k8sPodName{};
  shared_ptr<string> containerId{};
  shared_ptr<string> alarmEventType{};
  shared_ptr<string> k8sNamespace{};
  shared_ptr<string> k8sNodeName{};
  shared_ptr<string> alarmEventName{};
  shared_ptr<string> level{};

  DescribeAlarmEventListResponseBodySuspEvents() {}

  explicit DescribeAlarmEventListResponseBodySuspEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dealed) {
      res["Dealed"] = boost::any(*dealed);
    }
    if (stages) {
      res["Stages"] = boost::any(*stages);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (suspiciousEventCount) {
      res["SuspiciousEventCount"] = boost::any(*suspiciousEventCount);
    }
    if (k8sClusterName) {
      res["K8sClusterName"] = boost::any(*k8sClusterName);
    }
    if (containerImageId) {
      res["ContainerImageId"] = boost::any(*containerImageId);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (alarmEventNameOriginal) {
      res["AlarmEventNameOriginal"] = boost::any(*alarmEventNameOriginal);
    }
    if (alarmUniqueInfo) {
      res["AlarmUniqueInfo"] = boost::any(*alarmUniqueInfo);
    }
    if (canCancelFault) {
      res["CanCancelFault"] = boost::any(*canCancelFault);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (securityEventIds) {
      res["SecurityEventIds"] = boost::any(*securityEventIds);
    }
    if (k8sClusterId) {
      res["K8sClusterId"] = boost::any(*k8sClusterId);
    }
    if (containerImageName) {
      res["ContainerImageName"] = boost::any(*containerImageName);
    }
    if (canBeDealOnLine) {
      res["CanBeDealOnLine"] = boost::any(*canBeDealOnLine);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (containHwMode) {
      res["ContainHwMode"] = boost::any(*containHwMode);
    }
    if (k8sNodeId) {
      res["K8sNodeId"] = boost::any(*k8sNodeId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (saleVersion) {
      res["SaleVersion"] = boost::any(*saleVersion);
    }
    if (operateErrorCode) {
      res["OperateErrorCode"] = boost::any(*operateErrorCode);
    }
    if (solution) {
      res["Solution"] = boost::any(*solution);
    }
    if (hasTraceInfo) {
      res["HasTraceInfo"] = boost::any(*hasTraceInfo);
    }
    if (dataSource) {
      res["DataSource"] = boost::any(*dataSource);
    }
    if (operateTime) {
      res["OperateTime"] = boost::any(*operateTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (k8sPodName) {
      res["K8sPodName"] = boost::any(*k8sPodName);
    }
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (alarmEventType) {
      res["AlarmEventType"] = boost::any(*alarmEventType);
    }
    if (k8sNamespace) {
      res["K8sNamespace"] = boost::any(*k8sNamespace);
    }
    if (k8sNodeName) {
      res["K8sNodeName"] = boost::any(*k8sNodeName);
    }
    if (alarmEventName) {
      res["AlarmEventName"] = boost::any(*alarmEventName);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dealed") != m.end() && !m["Dealed"].empty()) {
      dealed = make_shared<bool>(boost::any_cast<bool>(m["Dealed"]));
    }
    if (m.find("Stages") != m.end() && !m["Stages"].empty()) {
      stages = make_shared<string>(boost::any_cast<string>(m["Stages"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("SuspiciousEventCount") != m.end() && !m["SuspiciousEventCount"].empty()) {
      suspiciousEventCount = make_shared<long>(boost::any_cast<long>(m["SuspiciousEventCount"]));
    }
    if (m.find("K8sClusterName") != m.end() && !m["K8sClusterName"].empty()) {
      k8sClusterName = make_shared<string>(boost::any_cast<string>(m["K8sClusterName"]));
    }
    if (m.find("ContainerImageId") != m.end() && !m["ContainerImageId"].empty()) {
      containerImageId = make_shared<string>(boost::any_cast<string>(m["ContainerImageId"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("AlarmEventNameOriginal") != m.end() && !m["AlarmEventNameOriginal"].empty()) {
      alarmEventNameOriginal = make_shared<string>(boost::any_cast<string>(m["AlarmEventNameOriginal"]));
    }
    if (m.find("AlarmUniqueInfo") != m.end() && !m["AlarmUniqueInfo"].empty()) {
      alarmUniqueInfo = make_shared<string>(boost::any_cast<string>(m["AlarmUniqueInfo"]));
    }
    if (m.find("CanCancelFault") != m.end() && !m["CanCancelFault"].empty()) {
      canCancelFault = make_shared<bool>(boost::any_cast<bool>(m["CanCancelFault"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("SecurityEventIds") != m.end() && !m["SecurityEventIds"].empty()) {
      securityEventIds = make_shared<string>(boost::any_cast<string>(m["SecurityEventIds"]));
    }
    if (m.find("K8sClusterId") != m.end() && !m["K8sClusterId"].empty()) {
      k8sClusterId = make_shared<string>(boost::any_cast<string>(m["K8sClusterId"]));
    }
    if (m.find("ContainerImageName") != m.end() && !m["ContainerImageName"].empty()) {
      containerImageName = make_shared<string>(boost::any_cast<string>(m["ContainerImageName"]));
    }
    if (m.find("CanBeDealOnLine") != m.end() && !m["CanBeDealOnLine"].empty()) {
      canBeDealOnLine = make_shared<bool>(boost::any_cast<bool>(m["CanBeDealOnLine"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ContainHwMode") != m.end() && !m["ContainHwMode"].empty()) {
      containHwMode = make_shared<bool>(boost::any_cast<bool>(m["ContainHwMode"]));
    }
    if (m.find("K8sNodeId") != m.end() && !m["K8sNodeId"].empty()) {
      k8sNodeId = make_shared<string>(boost::any_cast<string>(m["K8sNodeId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("SaleVersion") != m.end() && !m["SaleVersion"].empty()) {
      saleVersion = make_shared<string>(boost::any_cast<string>(m["SaleVersion"]));
    }
    if (m.find("OperateErrorCode") != m.end() && !m["OperateErrorCode"].empty()) {
      operateErrorCode = make_shared<string>(boost::any_cast<string>(m["OperateErrorCode"]));
    }
    if (m.find("Solution") != m.end() && !m["Solution"].empty()) {
      solution = make_shared<string>(boost::any_cast<string>(m["Solution"]));
    }
    if (m.find("HasTraceInfo") != m.end() && !m["HasTraceInfo"].empty()) {
      hasTraceInfo = make_shared<bool>(boost::any_cast<bool>(m["HasTraceInfo"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      dataSource = make_shared<string>(boost::any_cast<string>(m["DataSource"]));
    }
    if (m.find("OperateTime") != m.end() && !m["OperateTime"].empty()) {
      operateTime = make_shared<long>(boost::any_cast<long>(m["OperateTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("K8sPodName") != m.end() && !m["K8sPodName"].empty()) {
      k8sPodName = make_shared<string>(boost::any_cast<string>(m["K8sPodName"]));
    }
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<string>(boost::any_cast<string>(m["ContainerId"]));
    }
    if (m.find("AlarmEventType") != m.end() && !m["AlarmEventType"].empty()) {
      alarmEventType = make_shared<string>(boost::any_cast<string>(m["AlarmEventType"]));
    }
    if (m.find("K8sNamespace") != m.end() && !m["K8sNamespace"].empty()) {
      k8sNamespace = make_shared<string>(boost::any_cast<string>(m["K8sNamespace"]));
    }
    if (m.find("K8sNodeName") != m.end() && !m["K8sNodeName"].empty()) {
      k8sNodeName = make_shared<string>(boost::any_cast<string>(m["K8sNodeName"]));
    }
    if (m.find("AlarmEventName") != m.end() && !m["AlarmEventName"].empty()) {
      alarmEventName = make_shared<string>(boost::any_cast<string>(m["AlarmEventName"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~DescribeAlarmEventListResponseBodySuspEvents() = default;
};
class DescribeAlarmEventListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAlarmEventListResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribeAlarmEventListResponseBodySuspEvents>> suspEvents{};

  DescribeAlarmEventListResponseBody() {}

  explicit DescribeAlarmEventListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (suspEvents) {
      vector<boost::any> temp1;
      for(auto item1:*suspEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SuspEvents"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeAlarmEventListResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeAlarmEventListResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("SuspEvents") != m.end() && !m["SuspEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["SuspEvents"].type()) {
        vector<DescribeAlarmEventListResponseBodySuspEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SuspEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlarmEventListResponseBodySuspEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        suspEvents = make_shared<vector<DescribeAlarmEventListResponseBodySuspEvents>>(expect1);
      }
    }
  }


  virtual ~DescribeAlarmEventListResponseBody() = default;
};
class DescribeAlarmEventListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAlarmEventListResponseBody> body{};

  DescribeAlarmEventListResponse() {}

  explicit DescribeAlarmEventListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAlarmEventListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAlarmEventListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAlarmEventListResponse() = default;
};
class DescribeAlarmEventStackInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};
  shared_ptr<string> uuid{};
  shared_ptr<string> eventName{};
  shared_ptr<string> uniqueInfo{};

  DescribeAlarmEventStackInfoRequest() {}

  explicit DescribeAlarmEventStackInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (uniqueInfo) {
      res["UniqueInfo"] = boost::any(*uniqueInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("UniqueInfo") != m.end() && !m["UniqueInfo"].empty()) {
      uniqueInfo = make_shared<string>(boost::any_cast<string>(m["UniqueInfo"]));
    }
  }


  virtual ~DescribeAlarmEventStackInfoRequest() = default;
};
class DescribeAlarmEventStackInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> stackInfo{};
  shared_ptr<string> requestId{};

  DescribeAlarmEventStackInfoResponseBody() {}

  explicit DescribeAlarmEventStackInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stackInfo) {
      res["StackInfo"] = boost::any(*stackInfo);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StackInfo") != m.end() && !m["StackInfo"].empty()) {
      stackInfo = make_shared<string>(boost::any_cast<string>(m["StackInfo"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAlarmEventStackInfoResponseBody() = default;
};
class DescribeAlarmEventStackInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAlarmEventStackInfoResponseBody> body{};

  DescribeAlarmEventStackInfoResponse() {}

  explicit DescribeAlarmEventStackInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAlarmEventStackInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAlarmEventStackInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAlarmEventStackInfoResponse() = default;
};
class DescribeAllEntityResponseBodyEntityList : public Darabonba::Model {
public:
  shared_ptr<string> uuid{};
  shared_ptr<long> groupId{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> ip{};
  shared_ptr<string> os{};
  shared_ptr<string> intranetIp{};

  DescribeAllEntityResponseBodyEntityList() {}

  explicit DescribeAllEntityResponseBodyEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
  }


  virtual ~DescribeAllEntityResponseBodyEntityList() = default;
};
class DescribeAllEntityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAllEntityResponseBodyEntityList>> entityList{};

  DescribeAllEntityResponseBody() {}

  explicit DescribeAllEntityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (entityList) {
      vector<boost::any> temp1;
      for(auto item1:*entityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EntityList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("EntityList") != m.end() && !m["EntityList"].empty()) {
      if (typeid(vector<boost::any>) == m["EntityList"].type()) {
        vector<DescribeAllEntityResponseBodyEntityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EntityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAllEntityResponseBodyEntityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entityList = make_shared<vector<DescribeAllEntityResponseBodyEntityList>>(expect1);
      }
    }
  }


  virtual ~DescribeAllEntityResponseBody() = default;
};
class DescribeAllEntityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAllEntityResponseBody> body{};

  DescribeAllEntityResponse() {}

  explicit DescribeAllEntityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAllEntityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAllEntityResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAllEntityResponse() = default;
};
class DescribeAllGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  DescribeAllGroupsRequest() {}

  explicit DescribeAllGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeAllGroupsRequest() = default;
};
class DescribeAllGroupsResponseBodyGroups : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<long> groupId{};
  shared_ptr<long> groupFlag{};

  DescribeAllGroupsResponseBodyGroups() {}

  explicit DescribeAllGroupsResponseBodyGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupFlag) {
      res["GroupFlag"] = boost::any(*groupFlag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupFlag") != m.end() && !m["GroupFlag"].empty()) {
      groupFlag = make_shared<long>(boost::any_cast<long>(m["GroupFlag"]));
    }
  }


  virtual ~DescribeAllGroupsResponseBodyGroups() = default;
};
class DescribeAllGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAllGroupsResponseBodyGroups>> groups{};

  DescribeAllGroupsResponseBody() {}

  explicit DescribeAllGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (groups) {
      vector<boost::any> temp1;
      for(auto item1:*groups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Groups"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      if (typeid(vector<boost::any>) == m["Groups"].type()) {
        vector<DescribeAllGroupsResponseBodyGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Groups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAllGroupsResponseBodyGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groups = make_shared<vector<DescribeAllGroupsResponseBodyGroups>>(expect1);
      }
    }
  }


  virtual ~DescribeAllGroupsResponseBody() = default;
};
class DescribeAllGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAllGroupsResponseBody> body{};

  DescribeAllGroupsResponse() {}

  explicit DescribeAllGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAllGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAllGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAllGroupsResponse() = default;
};
class DescribeAllRegionsStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> from{};
  shared_ptr<long> groupId{};
  shared_ptr<string> remark{};
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};
  shared_ptr<long> status{};
  shared_ptr<string> statusList{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> webGroupId{};
  shared_ptr<long> ruleType{};
  shared_ptr<long> action1{};
  shared_ptr<long> flow{};
  shared_ptr<string> saleId{};
  shared_ptr<string> dealed{};
  shared_ptr<string> tag{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> secureToken{};
  shared_ptr<bool> allRegion{};

  DescribeAllRegionsStatisticsRequest() {}

  explicit DescribeAllRegionsStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (webGroupId) {
      res["WebGroupId"] = boost::any(*webGroupId);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (action1) {
      res["Action1"] = boost::any(*action1);
    }
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (saleId) {
      res["SaleId"] = boost::any(*saleId);
    }
    if (dealed) {
      res["Dealed"] = boost::any(*dealed);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (secureToken) {
      res["SecureToken"] = boost::any(*secureToken);
    }
    if (allRegion) {
      res["AllRegion"] = boost::any(*allRegion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      statusList = make_shared<string>(boost::any_cast<string>(m["StatusList"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("WebGroupId") != m.end() && !m["WebGroupId"].empty()) {
      webGroupId = make_shared<long>(boost::any_cast<long>(m["WebGroupId"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<long>(boost::any_cast<long>(m["RuleType"]));
    }
    if (m.find("Action1") != m.end() && !m["Action1"].empty()) {
      action1 = make_shared<long>(boost::any_cast<long>(m["Action1"]));
    }
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<long>(boost::any_cast<long>(m["Flow"]));
    }
    if (m.find("SaleId") != m.end() && !m["SaleId"].empty()) {
      saleId = make_shared<string>(boost::any_cast<string>(m["SaleId"]));
    }
    if (m.find("Dealed") != m.end() && !m["Dealed"].empty()) {
      dealed = make_shared<string>(boost::any_cast<string>(m["Dealed"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecureToken") != m.end() && !m["SecureToken"].empty()) {
      secureToken = make_shared<string>(boost::any_cast<string>(m["SecureToken"]));
    }
    if (m.find("AllRegion") != m.end() && !m["AllRegion"].empty()) {
      allRegion = make_shared<bool>(boost::any_cast<bool>(m["AllRegion"]));
    }
  }


  virtual ~DescribeAllRegionsStatisticsRequest() = default;
};
class DescribeAllRegionsStatisticsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> account{};
  shared_ptr<long> vul{};
  shared_ptr<long> health{};
  shared_ptr<long> trojan{};
  shared_ptr<long> newSuspicious{};
  shared_ptr<long> suspicious{};

  DescribeAllRegionsStatisticsResponseBodyData() {}

  explicit DescribeAllRegionsStatisticsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (vul) {
      res["Vul"] = boost::any(*vul);
    }
    if (health) {
      res["Health"] = boost::any(*health);
    }
    if (trojan) {
      res["Trojan"] = boost::any(*trojan);
    }
    if (newSuspicious) {
      res["NewSuspicious"] = boost::any(*newSuspicious);
    }
    if (suspicious) {
      res["Suspicious"] = boost::any(*suspicious);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<long>(boost::any_cast<long>(m["Account"]));
    }
    if (m.find("Vul") != m.end() && !m["Vul"].empty()) {
      vul = make_shared<long>(boost::any_cast<long>(m["Vul"]));
    }
    if (m.find("Health") != m.end() && !m["Health"].empty()) {
      health = make_shared<long>(boost::any_cast<long>(m["Health"]));
    }
    if (m.find("Trojan") != m.end() && !m["Trojan"].empty()) {
      trojan = make_shared<long>(boost::any_cast<long>(m["Trojan"]));
    }
    if (m.find("NewSuspicious") != m.end() && !m["NewSuspicious"].empty()) {
      newSuspicious = make_shared<long>(boost::any_cast<long>(m["NewSuspicious"]));
    }
    if (m.find("Suspicious") != m.end() && !m["Suspicious"].empty()) {
      suspicious = make_shared<long>(boost::any_cast<long>(m["Suspicious"]));
    }
  }


  virtual ~DescribeAllRegionsStatisticsResponseBodyData() = default;
};
class DescribeAllRegionsStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAllRegionsStatisticsResponseBodyData> data{};

  DescribeAllRegionsStatisticsResponseBody() {}

  explicit DescribeAllRegionsStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeAllRegionsStatisticsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeAllRegionsStatisticsResponseBodyData>(model1);
      }
    }
  }


  virtual ~DescribeAllRegionsStatisticsResponseBody() = default;
};
class DescribeAllRegionsStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAllRegionsStatisticsResponseBody> body{};

  DescribeAllRegionsStatisticsResponse() {}

  explicit DescribeAllRegionsStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAllRegionsStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAllRegionsStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAllRegionsStatisticsResponse() = default;
};
class DescribeAntiBruteForceRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};

  DescribeAntiBruteForceRulesRequest() {}

  explicit DescribeAntiBruteForceRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeAntiBruteForceRulesRequest() = default;
};
class DescribeAntiBruteForceRulesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribeAntiBruteForceRulesResponseBodyPageInfo() {}

  explicit DescribeAntiBruteForceRulesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeAntiBruteForceRulesResponseBodyPageInfo() = default;
};
class DescribeAntiBruteForceRulesResponseBodyRules : public Darabonba::Model {
public:
  shared_ptr<long> machineCount{};
  shared_ptr<bool> enableSmartRule{};
  shared_ptr<long> failCount{};
  shared_ptr<long> forbiddenTime{};
  shared_ptr<long> span{};
  shared_ptr<bool> defaultRule{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};
  shared_ptr<vector<string>> uuidList{};

  DescribeAntiBruteForceRulesResponseBodyRules() {}

  explicit DescribeAntiBruteForceRulesResponseBodyRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (machineCount) {
      res["MachineCount"] = boost::any(*machineCount);
    }
    if (enableSmartRule) {
      res["EnableSmartRule"] = boost::any(*enableSmartRule);
    }
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (forbiddenTime) {
      res["ForbiddenTime"] = boost::any(*forbiddenTime);
    }
    if (span) {
      res["Span"] = boost::any(*span);
    }
    if (defaultRule) {
      res["DefaultRule"] = boost::any(*defaultRule);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MachineCount") != m.end() && !m["MachineCount"].empty()) {
      machineCount = make_shared<long>(boost::any_cast<long>(m["MachineCount"]));
    }
    if (m.find("EnableSmartRule") != m.end() && !m["EnableSmartRule"].empty()) {
      enableSmartRule = make_shared<bool>(boost::any_cast<bool>(m["EnableSmartRule"]));
    }
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<long>(boost::any_cast<long>(m["FailCount"]));
    }
    if (m.find("ForbiddenTime") != m.end() && !m["ForbiddenTime"].empty()) {
      forbiddenTime = make_shared<long>(boost::any_cast<long>(m["ForbiddenTime"]));
    }
    if (m.find("Span") != m.end() && !m["Span"].empty()) {
      span = make_shared<long>(boost::any_cast<long>(m["Span"]));
    }
    if (m.find("DefaultRule") != m.end() && !m["DefaultRule"].empty()) {
      defaultRule = make_shared<bool>(boost::any_cast<bool>(m["DefaultRule"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAntiBruteForceRulesResponseBodyRules() = default;
};
class DescribeAntiBruteForceRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntiBruteForceRulesResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribeAntiBruteForceRulesResponseBodyRules>> rules{};

  DescribeAntiBruteForceRulesResponseBody() {}

  explicit DescribeAntiBruteForceRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeAntiBruteForceRulesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeAntiBruteForceRulesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<DescribeAntiBruteForceRulesResponseBodyRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntiBruteForceRulesResponseBodyRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<DescribeAntiBruteForceRulesResponseBodyRules>>(expect1);
      }
    }
  }


  virtual ~DescribeAntiBruteForceRulesResponseBody() = default;
};
class DescribeAntiBruteForceRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAntiBruteForceRulesResponseBody> body{};

  DescribeAntiBruteForceRulesResponse() {}

  explicit DescribeAntiBruteForceRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntiBruteForceRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntiBruteForceRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntiBruteForceRulesResponse() = default;
};
class DescribeAssetDetailByUuidRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> uuid{};
  shared_ptr<string> lang{};

  DescribeAssetDetailByUuidRequest() {}

  explicit DescribeAssetDetailByUuidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeAssetDetailByUuidRequest() = default;
};
class DescribeAssetDetailByUuidResponseBodyAssetDetail : public Darabonba::Model {
public:
  shared_ptr<string> cpuInfo{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> osDetail{};
  shared_ptr<long> createTime{};
  shared_ptr<string> kernel{};
  shared_ptr<bool> bind{};
  shared_ptr<string> osName{};
  shared_ptr<string> tag{};
  shared_ptr<string> clientStatus{};
  shared_ptr<long> mem{};
  shared_ptr<string> vpcInstanceId{};
  shared_ptr<long> authVersion{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> region{};
  shared_ptr<string> groupTrace{};
  shared_ptr<string> ip{};
  shared_ptr<string> hostName{};
  shared_ptr<string> os{};
  shared_ptr<long> authModifyTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> assetType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sysInfo{};
  shared_ptr<string> uuid{};
  shared_ptr<long> cpu{};
  shared_ptr<string> regionName{};
  shared_ptr<vector<string>> ipList{};
  shared_ptr<vector<string>> macList{};
  shared_ptr<vector<string>> diskInfoList{};

  DescribeAssetDetailByUuidResponseBodyAssetDetail() {}

  explicit DescribeAssetDetailByUuidResponseBodyAssetDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpuInfo) {
      res["CpuInfo"] = boost::any(*cpuInfo);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (osDetail) {
      res["OsDetail"] = boost::any(*osDetail);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (kernel) {
      res["Kernel"] = boost::any(*kernel);
    }
    if (bind) {
      res["Bind"] = boost::any(*bind);
    }
    if (osName) {
      res["OsName"] = boost::any(*osName);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (clientStatus) {
      res["ClientStatus"] = boost::any(*clientStatus);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (vpcInstanceId) {
      res["VpcInstanceId"] = boost::any(*vpcInstanceId);
    }
    if (authVersion) {
      res["AuthVersion"] = boost::any(*authVersion);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (groupTrace) {
      res["GroupTrace"] = boost::any(*groupTrace);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (authModifyTime) {
      res["AuthModifyTime"] = boost::any(*authModifyTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (assetType) {
      res["AssetType"] = boost::any(*assetType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sysInfo) {
      res["SysInfo"] = boost::any(*sysInfo);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (ipList) {
      res["IpList"] = boost::any(*ipList);
    }
    if (macList) {
      res["MacList"] = boost::any(*macList);
    }
    if (diskInfoList) {
      res["DiskInfoList"] = boost::any(*diskInfoList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CpuInfo") != m.end() && !m["CpuInfo"].empty()) {
      cpuInfo = make_shared<string>(boost::any_cast<string>(m["CpuInfo"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("OsDetail") != m.end() && !m["OsDetail"].empty()) {
      osDetail = make_shared<string>(boost::any_cast<string>(m["OsDetail"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Kernel") != m.end() && !m["Kernel"].empty()) {
      kernel = make_shared<string>(boost::any_cast<string>(m["Kernel"]));
    }
    if (m.find("Bind") != m.end() && !m["Bind"].empty()) {
      bind = make_shared<bool>(boost::any_cast<bool>(m["Bind"]));
    }
    if (m.find("OsName") != m.end() && !m["OsName"].empty()) {
      osName = make_shared<string>(boost::any_cast<string>(m["OsName"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("ClientStatus") != m.end() && !m["ClientStatus"].empty()) {
      clientStatus = make_shared<string>(boost::any_cast<string>(m["ClientStatus"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("VpcInstanceId") != m.end() && !m["VpcInstanceId"].empty()) {
      vpcInstanceId = make_shared<string>(boost::any_cast<string>(m["VpcInstanceId"]));
    }
    if (m.find("AuthVersion") != m.end() && !m["AuthVersion"].empty()) {
      authVersion = make_shared<long>(boost::any_cast<long>(m["AuthVersion"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("GroupTrace") != m.end() && !m["GroupTrace"].empty()) {
      groupTrace = make_shared<string>(boost::any_cast<string>(m["GroupTrace"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("AuthModifyTime") != m.end() && !m["AuthModifyTime"].empty()) {
      authModifyTime = make_shared<long>(boost::any_cast<long>(m["AuthModifyTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("AssetType") != m.end() && !m["AssetType"].empty()) {
      assetType = make_shared<string>(boost::any_cast<string>(m["AssetType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SysInfo") != m.end() && !m["SysInfo"].empty()) {
      sysInfo = make_shared<string>(boost::any_cast<string>(m["SysInfo"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("IpList") != m.end() && !m["IpList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MacList") != m.end() && !m["MacList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MacList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MacList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      macList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DiskInfoList") != m.end() && !m["DiskInfoList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DiskInfoList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DiskInfoList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      diskInfoList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAssetDetailByUuidResponseBodyAssetDetail() = default;
};
class DescribeAssetDetailByUuidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAssetDetailByUuidResponseBodyAssetDetail> assetDetail{};

  DescribeAssetDetailByUuidResponseBody() {}

  explicit DescribeAssetDetailByUuidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (assetDetail) {
      res["AssetDetail"] = assetDetail ? boost::any(assetDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("AssetDetail") != m.end() && !m["AssetDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["AssetDetail"].type()) {
        DescribeAssetDetailByUuidResponseBodyAssetDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AssetDetail"]));
        assetDetail = make_shared<DescribeAssetDetailByUuidResponseBodyAssetDetail>(model1);
      }
    }
  }


  virtual ~DescribeAssetDetailByUuidResponseBody() = default;
};
class DescribeAssetDetailByUuidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAssetDetailByUuidResponseBody> body{};

  DescribeAssetDetailByUuidResponse() {}

  explicit DescribeAssetDetailByUuidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAssetDetailByUuidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAssetDetailByUuidResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAssetDetailByUuidResponse() = default;
};
class DescribeAssetDetailByUuidsRequest : public Darabonba::Model {
public:
  shared_ptr<string> uuids{};

  DescribeAssetDetailByUuidsRequest() {}

  explicit DescribeAssetDetailByUuidsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~DescribeAssetDetailByUuidsRequest() = default;
};
class DescribeAssetDetailByUuidsResponseBodyAssetList : public Darabonba::Model {
public:
  shared_ptr<string> internetIp{};
  shared_ptr<string> osName{};
  shared_ptr<string> ip{};
  shared_ptr<string> os{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> clientStatus{};
  shared_ptr<string> vpcInstanceId{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> assetType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> uuid{};
  shared_ptr<long> flag{};
  shared_ptr<string> regionName{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> region{};

  DescribeAssetDetailByUuidsResponseBodyAssetList() {}

  explicit DescribeAssetDetailByUuidsResponseBodyAssetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (osName) {
      res["OsName"] = boost::any(*osName);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (clientStatus) {
      res["ClientStatus"] = boost::any(*clientStatus);
    }
    if (vpcInstanceId) {
      res["VpcInstanceId"] = boost::any(*vpcInstanceId);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (assetType) {
      res["AssetType"] = boost::any(*assetType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("OsName") != m.end() && !m["OsName"].empty()) {
      osName = make_shared<string>(boost::any_cast<string>(m["OsName"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ClientStatus") != m.end() && !m["ClientStatus"].empty()) {
      clientStatus = make_shared<string>(boost::any_cast<string>(m["ClientStatus"]));
    }
    if (m.find("VpcInstanceId") != m.end() && !m["VpcInstanceId"].empty()) {
      vpcInstanceId = make_shared<string>(boost::any_cast<string>(m["VpcInstanceId"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("AssetType") != m.end() && !m["AssetType"].empty()) {
      assetType = make_shared<string>(boost::any_cast<string>(m["AssetType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<long>(boost::any_cast<long>(m["Flag"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~DescribeAssetDetailByUuidsResponseBodyAssetList() = default;
};
class DescribeAssetDetailByUuidsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAssetDetailByUuidsResponseBodyAssetList>> assetList{};

  DescribeAssetDetailByUuidsResponseBody() {}

  explicit DescribeAssetDetailByUuidsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (assetList) {
      vector<boost::any> temp1;
      for(auto item1:*assetList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AssetList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("AssetList") != m.end() && !m["AssetList"].empty()) {
      if (typeid(vector<boost::any>) == m["AssetList"].type()) {
        vector<DescribeAssetDetailByUuidsResponseBodyAssetList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AssetList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAssetDetailByUuidsResponseBodyAssetList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        assetList = make_shared<vector<DescribeAssetDetailByUuidsResponseBodyAssetList>>(expect1);
      }
    }
  }


  virtual ~DescribeAssetDetailByUuidsResponseBody() = default;
};
class DescribeAssetDetailByUuidsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAssetDetailByUuidsResponseBody> body{};

  DescribeAssetDetailByUuidsResponse() {}

  explicit DescribeAssetDetailByUuidsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAssetDetailByUuidsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAssetDetailByUuidsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAssetDetailByUuidsResponse() = default;
};
class DescribeAutoDelConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> days{};
  shared_ptr<string> requestId{};

  DescribeAutoDelConfigResponseBody() {}

  explicit DescribeAutoDelConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (days) {
      res["Days"] = boost::any(*days);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Days") != m.end() && !m["Days"].empty()) {
      days = make_shared<long>(boost::any_cast<long>(m["Days"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAutoDelConfigResponseBody() = default;
};
class DescribeAutoDelConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAutoDelConfigResponseBody> body{};

  DescribeAutoDelConfigResponse() {}

  explicit DescribeAutoDelConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAutoDelConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAutoDelConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAutoDelConfigResponse() = default;
};
class DescribeBackupClientsRequest : public Darabonba::Model {
public:
  shared_ptr<string> supportRegionId{};

  DescribeBackupClientsRequest() {}

  explicit DescribeBackupClientsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportRegionId) {
      res["SupportRegionId"] = boost::any(*supportRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportRegionId") != m.end() && !m["SupportRegionId"].empty()) {
      supportRegionId = make_shared<string>(boost::any_cast<string>(m["SupportRegionId"]));
    }
  }


  virtual ~DescribeBackupClientsRequest() = default;
};
class DescribeBackupClientsResponseBodyClients : public Darabonba::Model {
public:
  shared_ptr<string> uuid{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> clientStatus{};
  shared_ptr<string> clientId{};

  DescribeBackupClientsResponseBodyClients() {}

  explicit DescribeBackupClientsResponseBodyClients(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (clientStatus) {
      res["ClientStatus"] = boost::any(*clientStatus);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ClientStatus") != m.end() && !m["ClientStatus"].empty()) {
      clientStatus = make_shared<string>(boost::any_cast<string>(m["ClientStatus"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
  }


  virtual ~DescribeBackupClientsResponseBodyClients() = default;
};
class DescribeBackupClientsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeBackupClientsResponseBodyClients>> clients{};

  DescribeBackupClientsResponseBody() {}

  explicit DescribeBackupClientsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (clients) {
      vector<boost::any> temp1;
      for(auto item1:*clients){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Clients"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Clients") != m.end() && !m["Clients"].empty()) {
      if (typeid(vector<boost::any>) == m["Clients"].type()) {
        vector<DescribeBackupClientsResponseBodyClients> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Clients"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBackupClientsResponseBodyClients model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clients = make_shared<vector<DescribeBackupClientsResponseBodyClients>>(expect1);
      }
    }
  }


  virtual ~DescribeBackupClientsResponseBody() = default;
};
class DescribeBackupClientsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeBackupClientsResponseBody> body{};

  DescribeBackupClientsResponse() {}

  explicit DescribeBackupClientsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBackupClientsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBackupClientsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBackupClientsResponse() = default;
};
class DescribeBackupDirsRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> policyId{};
  shared_ptr<string> uuid{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};

  DescribeBackupDirsRequest() {}

  explicit DescribeBackupDirsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~DescribeBackupDirsRequest() = default;
};
class DescribeBackupDirsResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribeBackupDirsResponseBodyPageInfo() {}

  explicit DescribeBackupDirsResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeBackupDirsResponseBodyPageInfo() = default;
};
class DescribeBackupDirsResponseBodyBackupDirs : public Darabonba::Model {
public:
  shared_ptr<string> source{};
  shared_ptr<long> backupJobId{};

  DescribeBackupDirsResponseBodyBackupDirs() {}

  explicit DescribeBackupDirsResponseBodyBackupDirs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (backupJobId) {
      res["BackupJobId"] = boost::any(*backupJobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("BackupJobId") != m.end() && !m["BackupJobId"].empty()) {
      backupJobId = make_shared<long>(boost::any_cast<long>(m["BackupJobId"]));
    }
  }


  virtual ~DescribeBackupDirsResponseBodyBackupDirs() = default;
};
class DescribeBackupDirsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeBackupDirsResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribeBackupDirsResponseBodyBackupDirs>> backupDirs{};

  DescribeBackupDirsResponseBody() {}

  explicit DescribeBackupDirsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (backupDirs) {
      vector<boost::any> temp1;
      for(auto item1:*backupDirs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackupDirs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeBackupDirsResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeBackupDirsResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("BackupDirs") != m.end() && !m["BackupDirs"].empty()) {
      if (typeid(vector<boost::any>) == m["BackupDirs"].type()) {
        vector<DescribeBackupDirsResponseBodyBackupDirs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackupDirs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBackupDirsResponseBodyBackupDirs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backupDirs = make_shared<vector<DescribeBackupDirsResponseBodyBackupDirs>>(expect1);
      }
    }
  }


  virtual ~DescribeBackupDirsResponseBody() = default;
};
class DescribeBackupDirsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeBackupDirsResponseBody> body{};

  DescribeBackupDirsResponse() {}

  explicit DescribeBackupDirsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBackupDirsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBackupDirsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBackupDirsResponse() = default;
};
class DescribeBackupFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> uuid{};
  shared_ptr<string> path{};
  shared_ptr<string> snapshotHash{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> pageSize{};

  DescribeBackupFilesRequest() {}

  explicit DescribeBackupFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (snapshotHash) {
      res["SnapshotHash"] = boost::any(*snapshotHash);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("SnapshotHash") != m.end() && !m["SnapshotHash"].empty()) {
      snapshotHash = make_shared<string>(boost::any_cast<string>(m["SnapshotHash"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
  }


  virtual ~DescribeBackupFilesRequest() = default;
};
class DescribeBackupFilesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribeBackupFilesResponseBodyPageInfo() {}

  explicit DescribeBackupFilesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeBackupFilesResponseBodyPageInfo() = default;
};
class DescribeBackupFilesResponseBodyBackupFiles : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> name{};
  shared_ptr<string> subtree{};
  shared_ptr<long> size{};

  DescribeBackupFilesResponseBodyBackupFiles() {}

  explicit DescribeBackupFilesResponseBodyBackupFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (subtree) {
      res["Subtree"] = boost::any(*subtree);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Subtree") != m.end() && !m["Subtree"].empty()) {
      subtree = make_shared<string>(boost::any_cast<string>(m["Subtree"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DescribeBackupFilesResponseBodyBackupFiles() = default;
};
class DescribeBackupFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeBackupFilesResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribeBackupFilesResponseBodyBackupFiles>> backupFiles{};

  DescribeBackupFilesResponseBody() {}

  explicit DescribeBackupFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (backupFiles) {
      vector<boost::any> temp1;
      for(auto item1:*backupFiles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackupFiles"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeBackupFilesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeBackupFilesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("BackupFiles") != m.end() && !m["BackupFiles"].empty()) {
      if (typeid(vector<boost::any>) == m["BackupFiles"].type()) {
        vector<DescribeBackupFilesResponseBodyBackupFiles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackupFiles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBackupFilesResponseBodyBackupFiles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backupFiles = make_shared<vector<DescribeBackupFilesResponseBodyBackupFiles>>(expect1);
      }
    }
  }


  virtual ~DescribeBackupFilesResponseBody() = default;
};
class DescribeBackupFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeBackupFilesResponseBody> body{};

  DescribeBackupFilesResponse() {}

  explicit DescribeBackupFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBackupFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBackupFilesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBackupFilesResponse() = default;
};
class DescribeBackupMachineStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> policyId{};
  shared_ptr<string> uuid{};
  shared_ptr<string> policyVersion{};

  DescribeBackupMachineStatusRequest() {}

  explicit DescribeBackupMachineStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
  }


  virtual ~DescribeBackupMachineStatusRequest() = default;
};
class DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> errorFile{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorFileUrl{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorStatus{};
  shared_ptr<string> path{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> errorType{};
  shared_ptr<long> errorTime{};

  DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList() {}

  explicit DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (errorFile) {
      res["ErrorFile"] = boost::any(*errorFile);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorFileUrl) {
      res["ErrorFileUrl"] = boost::any(*errorFileUrl);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorStatus) {
      res["ErrorStatus"] = boost::any(*errorStatus);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (errorType) {
      res["ErrorType"] = boost::any(*errorType);
    }
    if (errorTime) {
      res["ErrorTime"] = boost::any(*errorTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("ErrorFile") != m.end() && !m["ErrorFile"].empty()) {
      errorFile = make_shared<string>(boost::any_cast<string>(m["ErrorFile"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorFileUrl") != m.end() && !m["ErrorFileUrl"].empty()) {
      errorFileUrl = make_shared<string>(boost::any_cast<string>(m["ErrorFileUrl"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorStatus") != m.end() && !m["ErrorStatus"].empty()) {
      errorStatus = make_shared<string>(boost::any_cast<string>(m["ErrorStatus"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("ErrorType") != m.end() && !m["ErrorType"].empty()) {
      errorType = make_shared<string>(boost::any_cast<string>(m["ErrorType"]));
    }
    if (m.find("ErrorTime") != m.end() && !m["ErrorTime"].empty()) {
      errorTime = make_shared<long>(boost::any_cast<long>(m["ErrorTime"]));
    }
  }


  virtual ~DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList() = default;
};
class DescribeBackupMachineStatusResponseBodyBackupMachineStatus : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> vaultId{};
  shared_ptr<string> jobs{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> clientStatus{};
  shared_ptr<string> clientId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> uuid{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> savedBackupCount{};
  shared_ptr<string> clientVersion{};
  shared_ptr<vector<DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList>> errorList{};

  DescribeBackupMachineStatusResponseBodyBackupMachineStatus() {}

  explicit DescribeBackupMachineStatusResponseBodyBackupMachineStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vaultId) {
      res["VaultId"] = boost::any(*vaultId);
    }
    if (jobs) {
      res["Jobs"] = boost::any(*jobs);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (clientStatus) {
      res["ClientStatus"] = boost::any(*clientStatus);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (savedBackupCount) {
      res["SavedBackupCount"] = boost::any(*savedBackupCount);
    }
    if (clientVersion) {
      res["ClientVersion"] = boost::any(*clientVersion);
    }
    if (errorList) {
      vector<boost::any> temp1;
      for(auto item1:*errorList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VaultId") != m.end() && !m["VaultId"].empty()) {
      vaultId = make_shared<string>(boost::any_cast<string>(m["VaultId"]));
    }
    if (m.find("Jobs") != m.end() && !m["Jobs"].empty()) {
      jobs = make_shared<string>(boost::any_cast<string>(m["Jobs"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ClientStatus") != m.end() && !m["ClientStatus"].empty()) {
      clientStatus = make_shared<string>(boost::any_cast<string>(m["ClientStatus"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("SavedBackupCount") != m.end() && !m["SavedBackupCount"].empty()) {
      savedBackupCount = make_shared<long>(boost::any_cast<long>(m["SavedBackupCount"]));
    }
    if (m.find("ClientVersion") != m.end() && !m["ClientVersion"].empty()) {
      clientVersion = make_shared<string>(boost::any_cast<string>(m["ClientVersion"]));
    }
    if (m.find("ErrorList") != m.end() && !m["ErrorList"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorList"].type()) {
        vector<DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorList = make_shared<vector<DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList>>(expect1);
      }
    }
  }


  virtual ~DescribeBackupMachineStatusResponseBodyBackupMachineStatus() = default;
};
class DescribeBackupMachineStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeBackupMachineStatusResponseBodyBackupMachineStatus> backupMachineStatus{};

  DescribeBackupMachineStatusResponseBody() {}

  explicit DescribeBackupMachineStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (backupMachineStatus) {
      res["BackupMachineStatus"] = backupMachineStatus ? boost::any(backupMachineStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("BackupMachineStatus") != m.end() && !m["BackupMachineStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["BackupMachineStatus"].type()) {
        DescribeBackupMachineStatusResponseBodyBackupMachineStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BackupMachineStatus"]));
        backupMachineStatus = make_shared<DescribeBackupMachineStatusResponseBodyBackupMachineStatus>(model1);
      }
    }
  }


  virtual ~DescribeBackupMachineStatusResponseBody() = default;
};
class DescribeBackupMachineStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeBackupMachineStatusResponseBody> body{};

  DescribeBackupMachineStatusResponse() {}

  explicit DescribeBackupMachineStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBackupMachineStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBackupMachineStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBackupMachineStatusResponse() = default;
};
class DescribeBackupPoliciesRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> name{};
  shared_ptr<string> machineRemark{};
  shared_ptr<string> status{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};

  DescribeBackupPoliciesRequest() {}

  explicit DescribeBackupPoliciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (machineRemark) {
      res["MachineRemark"] = boost::any(*machineRemark);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("MachineRemark") != m.end() && !m["MachineRemark"].empty()) {
      machineRemark = make_shared<string>(boost::any_cast<string>(m["MachineRemark"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~DescribeBackupPoliciesRequest() = default;
};
class DescribeBackupPoliciesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribeBackupPoliciesResponseBodyPageInfo() {}

  explicit DescribeBackupPoliciesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeBackupPoliciesResponseBodyPageInfo() = default;
};
class DescribeBackupPoliciesResponseBodyPolicies : public Darabonba::Model {
public:
  shared_ptr<long> clientErrorCount{};
  shared_ptr<string> status{};
  shared_ptr<string> policyVersion{};
  shared_ptr<string> policy{};
  shared_ptr<long> serviceErrorCount{};
  shared_ptr<string> policyRegionId{};
  shared_ptr<string> clientStatus{};
  shared_ptr<string> name{};
  shared_ptr<long> healthClientCount{};
  shared_ptr<long> id{};
  shared_ptr<vector<string>> clientErrorUuidList{};
  shared_ptr<vector<string>> remarkedUuidList{};
  shared_ptr<vector<string>> uuidList{};
  shared_ptr<vector<string>> serviceErrorUuidList{};
  shared_ptr<vector<string>> healthClientUuidList{};

  DescribeBackupPoliciesResponseBodyPolicies() {}

  explicit DescribeBackupPoliciesResponseBodyPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientErrorCount) {
      res["ClientErrorCount"] = boost::any(*clientErrorCount);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (serviceErrorCount) {
      res["ServiceErrorCount"] = boost::any(*serviceErrorCount);
    }
    if (policyRegionId) {
      res["PolicyRegionId"] = boost::any(*policyRegionId);
    }
    if (clientStatus) {
      res["ClientStatus"] = boost::any(*clientStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (healthClientCount) {
      res["HealthClientCount"] = boost::any(*healthClientCount);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (clientErrorUuidList) {
      res["ClientErrorUuidList"] = boost::any(*clientErrorUuidList);
    }
    if (remarkedUuidList) {
      res["RemarkedUuidList"] = boost::any(*remarkedUuidList);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    if (serviceErrorUuidList) {
      res["ServiceErrorUuidList"] = boost::any(*serviceErrorUuidList);
    }
    if (healthClientUuidList) {
      res["HealthClientUuidList"] = boost::any(*healthClientUuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientErrorCount") != m.end() && !m["ClientErrorCount"].empty()) {
      clientErrorCount = make_shared<long>(boost::any_cast<long>(m["ClientErrorCount"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("ServiceErrorCount") != m.end() && !m["ServiceErrorCount"].empty()) {
      serviceErrorCount = make_shared<long>(boost::any_cast<long>(m["ServiceErrorCount"]));
    }
    if (m.find("PolicyRegionId") != m.end() && !m["PolicyRegionId"].empty()) {
      policyRegionId = make_shared<string>(boost::any_cast<string>(m["PolicyRegionId"]));
    }
    if (m.find("ClientStatus") != m.end() && !m["ClientStatus"].empty()) {
      clientStatus = make_shared<string>(boost::any_cast<string>(m["ClientStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("HealthClientCount") != m.end() && !m["HealthClientCount"].empty()) {
      healthClientCount = make_shared<long>(boost::any_cast<long>(m["HealthClientCount"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ClientErrorUuidList") != m.end() && !m["ClientErrorUuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ClientErrorUuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ClientErrorUuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      clientErrorUuidList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RemarkedUuidList") != m.end() && !m["RemarkedUuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RemarkedUuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RemarkedUuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      remarkedUuidList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ServiceErrorUuidList") != m.end() && !m["ServiceErrorUuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ServiceErrorUuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ServiceErrorUuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      serviceErrorUuidList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HealthClientUuidList") != m.end() && !m["HealthClientUuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HealthClientUuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HealthClientUuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      healthClientUuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeBackupPoliciesResponseBodyPolicies() = default;
};
class DescribeBackupPoliciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeBackupPoliciesResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribeBackupPoliciesResponseBodyPolicies>> policies{};

  DescribeBackupPoliciesResponseBody() {}

  explicit DescribeBackupPoliciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (policies) {
      vector<boost::any> temp1;
      for(auto item1:*policies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Policies"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeBackupPoliciesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeBackupPoliciesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("Policies") != m.end() && !m["Policies"].empty()) {
      if (typeid(vector<boost::any>) == m["Policies"].type()) {
        vector<DescribeBackupPoliciesResponseBodyPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Policies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBackupPoliciesResponseBodyPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        policies = make_shared<vector<DescribeBackupPoliciesResponseBodyPolicies>>(expect1);
      }
    }
  }


  virtual ~DescribeBackupPoliciesResponseBody() = default;
};
class DescribeBackupPoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeBackupPoliciesResponseBody> body{};

  DescribeBackupPoliciesResponse() {}

  explicit DescribeBackupPoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBackupPoliciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBackupPoliciesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBackupPoliciesResponse() = default;
};
class DescribeBackupPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> id{};
  shared_ptr<string> policyVersion{};

  DescribeBackupPolicyRequest() {}

  explicit DescribeBackupPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
  }


  virtual ~DescribeBackupPolicyRequest() = default;
};
class DescribeBackupPolicyResponseBodyBackupPolicyDetail : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> policyVersion{};
  shared_ptr<string> policy{};
  shared_ptr<string> clientStatus{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> uuidList{};

  DescribeBackupPolicyResponseBodyBackupPolicyDetail() {}

  explicit DescribeBackupPolicyResponseBodyBackupPolicyDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (clientStatus) {
      res["ClientStatus"] = boost::any(*clientStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("ClientStatus") != m.end() && !m["ClientStatus"].empty()) {
      clientStatus = make_shared<string>(boost::any_cast<string>(m["ClientStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeBackupPolicyResponseBodyBackupPolicyDetail() = default;
};
class DescribeBackupPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeBackupPolicyResponseBodyBackupPolicyDetail> backupPolicyDetail{};

  DescribeBackupPolicyResponseBody() {}

  explicit DescribeBackupPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (backupPolicyDetail) {
      res["BackupPolicyDetail"] = backupPolicyDetail ? boost::any(backupPolicyDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("BackupPolicyDetail") != m.end() && !m["BackupPolicyDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["BackupPolicyDetail"].type()) {
        DescribeBackupPolicyResponseBodyBackupPolicyDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BackupPolicyDetail"]));
        backupPolicyDetail = make_shared<DescribeBackupPolicyResponseBodyBackupPolicyDetail>(model1);
      }
    }
  }


  virtual ~DescribeBackupPolicyResponseBody() = default;
};
class DescribeBackupPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeBackupPolicyResponseBody> body{};

  DescribeBackupPolicyResponse() {}

  explicit DescribeBackupPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBackupPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBackupPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBackupPolicyResponse() = default;
};
class DescribeBackupRestoreCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};

  DescribeBackupRestoreCountRequest() {}

  explicit DescribeBackupRestoreCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeBackupRestoreCountRequest() = default;
};
class DescribeBackupRestoreCountResponseBodyBackupRestoreCount : public Darabonba::Model {
public:
  shared_ptr<long> total{};
  shared_ptr<long> recovering{};

  DescribeBackupRestoreCountResponseBodyBackupRestoreCount() {}

  explicit DescribeBackupRestoreCountResponseBodyBackupRestoreCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (recovering) {
      res["Recovering"] = boost::any(*recovering);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Recovering") != m.end() && !m["Recovering"].empty()) {
      recovering = make_shared<long>(boost::any_cast<long>(m["Recovering"]));
    }
  }


  virtual ~DescribeBackupRestoreCountResponseBodyBackupRestoreCount() = default;
};
class DescribeBackupRestoreCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeBackupRestoreCountResponseBodyBackupRestoreCount> backupRestoreCount{};

  DescribeBackupRestoreCountResponseBody() {}

  explicit DescribeBackupRestoreCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (backupRestoreCount) {
      res["BackupRestoreCount"] = backupRestoreCount ? boost::any(backupRestoreCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("BackupRestoreCount") != m.end() && !m["BackupRestoreCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["BackupRestoreCount"].type()) {
        DescribeBackupRestoreCountResponseBodyBackupRestoreCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BackupRestoreCount"]));
        backupRestoreCount = make_shared<DescribeBackupRestoreCountResponseBodyBackupRestoreCount>(model1);
      }
    }
  }


  virtual ~DescribeBackupRestoreCountResponseBody() = default;
};
class DescribeBackupRestoreCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeBackupRestoreCountResponseBody> body{};

  DescribeBackupRestoreCountResponse() {}

  explicit DescribeBackupRestoreCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBackupRestoreCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBackupRestoreCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBackupRestoreCountResponse() = default;
};
class DescribeBruteForceSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};

  DescribeBruteForceSummaryRequest() {}

  explicit DescribeBruteForceSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeBruteForceSummaryRequest() = default;
};
class DescribeBruteForceSummaryResponseBodyBruteForceSummary : public Darabonba::Model {
public:
  shared_ptr<long> allStrategyCount{};
  shared_ptr<long> effectiveCount{};

  DescribeBruteForceSummaryResponseBodyBruteForceSummary() {}

  explicit DescribeBruteForceSummaryResponseBodyBruteForceSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allStrategyCount) {
      res["AllStrategyCount"] = boost::any(*allStrategyCount);
    }
    if (effectiveCount) {
      res["EffectiveCount"] = boost::any(*effectiveCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllStrategyCount") != m.end() && !m["AllStrategyCount"].empty()) {
      allStrategyCount = make_shared<long>(boost::any_cast<long>(m["AllStrategyCount"]));
    }
    if (m.find("EffectiveCount") != m.end() && !m["EffectiveCount"].empty()) {
      effectiveCount = make_shared<long>(boost::any_cast<long>(m["EffectiveCount"]));
    }
  }


  virtual ~DescribeBruteForceSummaryResponseBodyBruteForceSummary() = default;
};
class DescribeBruteForceSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeBruteForceSummaryResponseBodyBruteForceSummary> bruteForceSummary{};

  DescribeBruteForceSummaryResponseBody() {}

  explicit DescribeBruteForceSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (bruteForceSummary) {
      res["BruteForceSummary"] = bruteForceSummary ? boost::any(bruteForceSummary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("BruteForceSummary") != m.end() && !m["BruteForceSummary"].empty()) {
      if (typeid(map<string, boost::any>) == m["BruteForceSummary"].type()) {
        DescribeBruteForceSummaryResponseBodyBruteForceSummary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BruteForceSummary"]));
        bruteForceSummary = make_shared<DescribeBruteForceSummaryResponseBodyBruteForceSummary>(model1);
      }
    }
  }


  virtual ~DescribeBruteForceSummaryResponseBody() = default;
};
class DescribeBruteForceSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeBruteForceSummaryResponseBody> body{};

  DescribeBruteForceSummaryResponse() {}

  explicit DescribeBruteForceSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBruteForceSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBruteForceSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBruteForceSummaryResponse() = default;
};
class DescribeCheckEcsWarningsRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};

  DescribeCheckEcsWarningsRequest() {}

  explicit DescribeCheckEcsWarningsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeCheckEcsWarningsRequest() = default;
};
class DescribeCheckEcsWarningsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> sasVersion{};
  shared_ptr<string> canTry{};
  shared_ptr<string> weakPasswordCount{};
  shared_ptr<string> requestId{};

  DescribeCheckEcsWarningsResponseBody() {}

  explicit DescribeCheckEcsWarningsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sasVersion) {
      res["SasVersion"] = boost::any(*sasVersion);
    }
    if (canTry) {
      res["CanTry"] = boost::any(*canTry);
    }
    if (weakPasswordCount) {
      res["WeakPasswordCount"] = boost::any(*weakPasswordCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SasVersion") != m.end() && !m["SasVersion"].empty()) {
      sasVersion = make_shared<string>(boost::any_cast<string>(m["SasVersion"]));
    }
    if (m.find("CanTry") != m.end() && !m["CanTry"].empty()) {
      canTry = make_shared<string>(boost::any_cast<string>(m["CanTry"]));
    }
    if (m.find("WeakPasswordCount") != m.end() && !m["WeakPasswordCount"].empty()) {
      weakPasswordCount = make_shared<string>(boost::any_cast<string>(m["WeakPasswordCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCheckEcsWarningsResponseBody() = default;
};
class DescribeCheckEcsWarningsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeCheckEcsWarningsResponseBody> body{};

  DescribeCheckEcsWarningsResponse() {}

  explicit DescribeCheckEcsWarningsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCheckEcsWarningsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCheckEcsWarningsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCheckEcsWarningsResponse() = default;
};
class DescribeCheckWarningDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};
  shared_ptr<long> checkWarningId{};

  DescribeCheckWarningDetailRequest() {}

  explicit DescribeCheckWarningDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (checkWarningId) {
      res["CheckWarningId"] = boost::any(*checkWarningId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("CheckWarningId") != m.end() && !m["CheckWarningId"].empty()) {
      checkWarningId = make_shared<long>(boost::any_cast<long>(m["CheckWarningId"]));
    }
  }


  virtual ~DescribeCheckWarningDetailRequest() = default;
};
class DescribeCheckWarningDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> type{};
  shared_ptr<string> requestId{};
  shared_ptr<string> description{};
  shared_ptr<string> item{};
  shared_ptr<long> checkId{};
  shared_ptr<string> level{};
  shared_ptr<string> prompt{};

  DescribeCheckWarningDetailResponseBody() {}

  explicit DescribeCheckWarningDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<long>(boost::any_cast<long>(m["CheckId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
  }


  virtual ~DescribeCheckWarningDetailResponseBody() = default;
};
class DescribeCheckWarningDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeCheckWarningDetailResponseBody> body{};

  DescribeCheckWarningDetailResponse() {}

  explicit DescribeCheckWarningDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCheckWarningDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCheckWarningDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCheckWarningDetailResponse() = default;
};
class DescribeCheckWarningsRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};
  shared_ptr<string> uuid{};
  shared_ptr<long> riskId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};

  DescribeCheckWarningsRequest() {}

  explicit DescribeCheckWarningsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (riskId) {
      res["RiskId"] = boost::any(*riskId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("RiskId") != m.end() && !m["RiskId"].empty()) {
      riskId = make_shared<long>(boost::any_cast<long>(m["RiskId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~DescribeCheckWarningsRequest() = default;
};
class DescribeCheckWarningsResponseBodyCheckWarnings : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<long> checkWarningId{};
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};
  shared_ptr<string> item{};
  shared_ptr<long> checkId{};
  shared_ptr<string> level{};

  DescribeCheckWarningsResponseBodyCheckWarnings() {}

  explicit DescribeCheckWarningsResponseBodyCheckWarnings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (checkWarningId) {
      res["CheckWarningId"] = boost::any(*checkWarningId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("CheckWarningId") != m.end() && !m["CheckWarningId"].empty()) {
      checkWarningId = make_shared<long>(boost::any_cast<long>(m["CheckWarningId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<long>(boost::any_cast<long>(m["CheckId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~DescribeCheckWarningsResponseBodyCheckWarnings() = default;
};
class DescribeCheckWarningsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeCheckWarningsResponseBodyCheckWarnings>> checkWarnings{};

  DescribeCheckWarningsResponseBody() {}

  explicit DescribeCheckWarningsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (checkWarnings) {
      vector<boost::any> temp1;
      for(auto item1:*checkWarnings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CheckWarnings"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CheckWarnings") != m.end() && !m["CheckWarnings"].empty()) {
      if (typeid(vector<boost::any>) == m["CheckWarnings"].type()) {
        vector<DescribeCheckWarningsResponseBodyCheckWarnings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CheckWarnings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCheckWarningsResponseBodyCheckWarnings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        checkWarnings = make_shared<vector<DescribeCheckWarningsResponseBodyCheckWarnings>>(expect1);
      }
    }
  }


  virtual ~DescribeCheckWarningsResponseBody() = default;
};
class DescribeCheckWarningsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeCheckWarningsResponseBody> body{};

  DescribeCheckWarningsResponse() {}

  explicit DescribeCheckWarningsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCheckWarningsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCheckWarningsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCheckWarningsResponse() = default;
};
class DescribeCheckWarningSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};
  shared_ptr<string> typeName_{};
  shared_ptr<string> status{};
  shared_ptr<long> riskStatus{};
  shared_ptr<string> riskName{};
  shared_ptr<long> strategyId{};
  shared_ptr<string> uuids{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};

  DescribeCheckWarningSummaryRequest() {}

  explicit DescribeCheckWarningSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (typeName_) {
      res["TypeName"] = boost::any(*typeName_);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (riskStatus) {
      res["RiskStatus"] = boost::any(*riskStatus);
    }
    if (riskName) {
      res["RiskName"] = boost::any(*riskName);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("TypeName") != m.end() && !m["TypeName"].empty()) {
      typeName_ = make_shared<string>(boost::any_cast<string>(m["TypeName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("RiskStatus") != m.end() && !m["RiskStatus"].empty()) {
      riskStatus = make_shared<long>(boost::any_cast<long>(m["RiskStatus"]));
    }
    if (m.find("RiskName") != m.end() && !m["RiskName"].empty()) {
      riskName = make_shared<string>(boost::any_cast<string>(m["RiskName"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<long>(boost::any_cast<long>(m["StrategyId"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~DescribeCheckWarningSummaryRequest() = default;
};
class DescribeCheckWarningSummaryResponseBodyWarningSummarys : public Darabonba::Model {
public:
  shared_ptr<long> lowWarningCount{};
  shared_ptr<long> checkCount{};
  shared_ptr<long> mediumWarningCount{};
  shared_ptr<string> lastFoundTime{};
  shared_ptr<long> riskId{};
  shared_ptr<string> subTypeAlias{};
  shared_ptr<long> warningMachineCount{};
  shared_ptr<long> highWarningCount{};
  shared_ptr<string> typeAlias{};
  shared_ptr<string> riskName{};
  shared_ptr<string> level{};

  DescribeCheckWarningSummaryResponseBodyWarningSummarys() {}

  explicit DescribeCheckWarningSummaryResponseBodyWarningSummarys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lowWarningCount) {
      res["LowWarningCount"] = boost::any(*lowWarningCount);
    }
    if (checkCount) {
      res["CheckCount"] = boost::any(*checkCount);
    }
    if (mediumWarningCount) {
      res["MediumWarningCount"] = boost::any(*mediumWarningCount);
    }
    if (lastFoundTime) {
      res["LastFoundTime"] = boost::any(*lastFoundTime);
    }
    if (riskId) {
      res["RiskId"] = boost::any(*riskId);
    }
    if (subTypeAlias) {
      res["SubTypeAlias"] = boost::any(*subTypeAlias);
    }
    if (warningMachineCount) {
      res["WarningMachineCount"] = boost::any(*warningMachineCount);
    }
    if (highWarningCount) {
      res["HighWarningCount"] = boost::any(*highWarningCount);
    }
    if (typeAlias) {
      res["TypeAlias"] = boost::any(*typeAlias);
    }
    if (riskName) {
      res["RiskName"] = boost::any(*riskName);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LowWarningCount") != m.end() && !m["LowWarningCount"].empty()) {
      lowWarningCount = make_shared<long>(boost::any_cast<long>(m["LowWarningCount"]));
    }
    if (m.find("CheckCount") != m.end() && !m["CheckCount"].empty()) {
      checkCount = make_shared<long>(boost::any_cast<long>(m["CheckCount"]));
    }
    if (m.find("MediumWarningCount") != m.end() && !m["MediumWarningCount"].empty()) {
      mediumWarningCount = make_shared<long>(boost::any_cast<long>(m["MediumWarningCount"]));
    }
    if (m.find("LastFoundTime") != m.end() && !m["LastFoundTime"].empty()) {
      lastFoundTime = make_shared<string>(boost::any_cast<string>(m["LastFoundTime"]));
    }
    if (m.find("RiskId") != m.end() && !m["RiskId"].empty()) {
      riskId = make_shared<long>(boost::any_cast<long>(m["RiskId"]));
    }
    if (m.find("SubTypeAlias") != m.end() && !m["SubTypeAlias"].empty()) {
      subTypeAlias = make_shared<string>(boost::any_cast<string>(m["SubTypeAlias"]));
    }
    if (m.find("WarningMachineCount") != m.end() && !m["WarningMachineCount"].empty()) {
      warningMachineCount = make_shared<long>(boost::any_cast<long>(m["WarningMachineCount"]));
    }
    if (m.find("HighWarningCount") != m.end() && !m["HighWarningCount"].empty()) {
      highWarningCount = make_shared<long>(boost::any_cast<long>(m["HighWarningCount"]));
    }
    if (m.find("TypeAlias") != m.end() && !m["TypeAlias"].empty()) {
      typeAlias = make_shared<string>(boost::any_cast<string>(m["TypeAlias"]));
    }
    if (m.find("RiskName") != m.end() && !m["RiskName"].empty()) {
      riskName = make_shared<string>(boost::any_cast<string>(m["RiskName"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~DescribeCheckWarningSummaryResponseBodyWarningSummarys() = default;
};
class DescribeCheckWarningSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeCheckWarningSummaryResponseBodyWarningSummarys>> warningSummarys{};

  DescribeCheckWarningSummaryResponseBody() {}

  explicit DescribeCheckWarningSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (warningSummarys) {
      vector<boost::any> temp1;
      for(auto item1:*warningSummarys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WarningSummarys"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("WarningSummarys") != m.end() && !m["WarningSummarys"].empty()) {
      if (typeid(vector<boost::any>) == m["WarningSummarys"].type()) {
        vector<DescribeCheckWarningSummaryResponseBodyWarningSummarys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WarningSummarys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCheckWarningSummaryResponseBodyWarningSummarys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        warningSummarys = make_shared<vector<DescribeCheckWarningSummaryResponseBodyWarningSummarys>>(expect1);
      }
    }
  }


  virtual ~DescribeCheckWarningSummaryResponseBody() = default;
};
class DescribeCheckWarningSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeCheckWarningSummaryResponseBody> body{};

  DescribeCheckWarningSummaryResponse() {}

  explicit DescribeCheckWarningSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCheckWarningSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCheckWarningSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCheckWarningSummaryResponse() = default;
};
class DescribeCloudCenterInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> criteria{};
  shared_ptr<string> machineTypes{};
  shared_ptr<string> logicalExp{};
  shared_ptr<bool> noPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> importance{};

  DescribeCloudCenterInstancesRequest() {}

  explicit DescribeCloudCenterInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (machineTypes) {
      res["MachineTypes"] = boost::any(*machineTypes);
    }
    if (logicalExp) {
      res["LogicalExp"] = boost::any(*logicalExp);
    }
    if (noPage) {
      res["NoPage"] = boost::any(*noPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (importance) {
      res["Importance"] = boost::any(*importance);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("MachineTypes") != m.end() && !m["MachineTypes"].empty()) {
      machineTypes = make_shared<string>(boost::any_cast<string>(m["MachineTypes"]));
    }
    if (m.find("LogicalExp") != m.end() && !m["LogicalExp"].empty()) {
      logicalExp = make_shared<string>(boost::any_cast<string>(m["LogicalExp"]));
    }
    if (m.find("NoPage") != m.end() && !m["NoPage"].empty()) {
      noPage = make_shared<bool>(boost::any_cast<bool>(m["NoPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Importance") != m.end() && !m["Importance"].empty()) {
      importance = make_shared<long>(boost::any_cast<long>(m["Importance"]));
    }
  }


  virtual ~DescribeCloudCenterInstancesRequest() = default;
};
class DescribeCloudCenterInstancesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribeCloudCenterInstancesResponseBodyPageInfo() {}

  explicit DescribeCloudCenterInstancesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeCloudCenterInstancesResponseBodyPageInfo() = default;
};
class DescribeCloudCenterInstancesResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> internetIp{};
  shared_ptr<bool> bind{};
  shared_ptr<string> osName{};
  shared_ptr<string> tag{};
  shared_ptr<string> clientStatus{};
  shared_ptr<string> vpcInstanceId{};
  shared_ptr<long> flag{};
  shared_ptr<long> authVersion{};
  shared_ptr<string> region{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> podCount{};
  shared_ptr<long> vulCount{};
  shared_ptr<string> hcStatus{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> riskStatus{};
  shared_ptr<long> cores{};
  shared_ptr<string> vulStatus{};
  shared_ptr<string> alarmStatus{};
  shared_ptr<long> importance{};
  shared_ptr<long> healthCheckCount{};
  shared_ptr<string> ip{};
  shared_ptr<string> os{};
  shared_ptr<long> authModifyTime{};
  shared_ptr<long> exposedCount{};
  shared_ptr<long> safeEventCount{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> assetType{};
  shared_ptr<string> intranetIp{};
  shared_ptr<long> vendor{};
  shared_ptr<string> regionId{};
  shared_ptr<string> uuid{};
  shared_ptr<long> autoSnapshotsLevel{};
  shared_ptr<string> groupId{};
  shared_ptr<string> regionName{};
  shared_ptr<string> vendorName{};
  shared_ptr<string> clusterName{};
  shared_ptr<long> exposedStatus{};
  shared_ptr<string> riskCount{};
  shared_ptr<string> clientVersion{};

  DescribeCloudCenterInstancesResponseBodyInstances() {}

  explicit DescribeCloudCenterInstancesResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (bind) {
      res["Bind"] = boost::any(*bind);
    }
    if (osName) {
      res["OsName"] = boost::any(*osName);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (clientStatus) {
      res["ClientStatus"] = boost::any(*clientStatus);
    }
    if (vpcInstanceId) {
      res["VpcInstanceId"] = boost::any(*vpcInstanceId);
    }
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (authVersion) {
      res["AuthVersion"] = boost::any(*authVersion);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (podCount) {
      res["PodCount"] = boost::any(*podCount);
    }
    if (vulCount) {
      res["VulCount"] = boost::any(*vulCount);
    }
    if (hcStatus) {
      res["HcStatus"] = boost::any(*hcStatus);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (riskStatus) {
      res["RiskStatus"] = boost::any(*riskStatus);
    }
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (vulStatus) {
      res["VulStatus"] = boost::any(*vulStatus);
    }
    if (alarmStatus) {
      res["AlarmStatus"] = boost::any(*alarmStatus);
    }
    if (importance) {
      res["Importance"] = boost::any(*importance);
    }
    if (healthCheckCount) {
      res["HealthCheckCount"] = boost::any(*healthCheckCount);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (authModifyTime) {
      res["AuthModifyTime"] = boost::any(*authModifyTime);
    }
    if (exposedCount) {
      res["ExposedCount"] = boost::any(*exposedCount);
    }
    if (safeEventCount) {
      res["SafeEventCount"] = boost::any(*safeEventCount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (assetType) {
      res["AssetType"] = boost::any(*assetType);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (autoSnapshotsLevel) {
      res["AutoSnapshotsLevel"] = boost::any(*autoSnapshotsLevel);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (vendorName) {
      res["VendorName"] = boost::any(*vendorName);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (exposedStatus) {
      res["ExposedStatus"] = boost::any(*exposedStatus);
    }
    if (riskCount) {
      res["RiskCount"] = boost::any(*riskCount);
    }
    if (clientVersion) {
      res["ClientVersion"] = boost::any(*clientVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("Bind") != m.end() && !m["Bind"].empty()) {
      bind = make_shared<bool>(boost::any_cast<bool>(m["Bind"]));
    }
    if (m.find("OsName") != m.end() && !m["OsName"].empty()) {
      osName = make_shared<string>(boost::any_cast<string>(m["OsName"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("ClientStatus") != m.end() && !m["ClientStatus"].empty()) {
      clientStatus = make_shared<string>(boost::any_cast<string>(m["ClientStatus"]));
    }
    if (m.find("VpcInstanceId") != m.end() && !m["VpcInstanceId"].empty()) {
      vpcInstanceId = make_shared<string>(boost::any_cast<string>(m["VpcInstanceId"]));
    }
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<long>(boost::any_cast<long>(m["Flag"]));
    }
    if (m.find("AuthVersion") != m.end() && !m["AuthVersion"].empty()) {
      authVersion = make_shared<long>(boost::any_cast<long>(m["AuthVersion"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("PodCount") != m.end() && !m["PodCount"].empty()) {
      podCount = make_shared<long>(boost::any_cast<long>(m["PodCount"]));
    }
    if (m.find("VulCount") != m.end() && !m["VulCount"].empty()) {
      vulCount = make_shared<long>(boost::any_cast<long>(m["VulCount"]));
    }
    if (m.find("HcStatus") != m.end() && !m["HcStatus"].empty()) {
      hcStatus = make_shared<string>(boost::any_cast<string>(m["HcStatus"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RiskStatus") != m.end() && !m["RiskStatus"].empty()) {
      riskStatus = make_shared<string>(boost::any_cast<string>(m["RiskStatus"]));
    }
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("VulStatus") != m.end() && !m["VulStatus"].empty()) {
      vulStatus = make_shared<string>(boost::any_cast<string>(m["VulStatus"]));
    }
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      alarmStatus = make_shared<string>(boost::any_cast<string>(m["AlarmStatus"]));
    }
    if (m.find("Importance") != m.end() && !m["Importance"].empty()) {
      importance = make_shared<long>(boost::any_cast<long>(m["Importance"]));
    }
    if (m.find("HealthCheckCount") != m.end() && !m["HealthCheckCount"].empty()) {
      healthCheckCount = make_shared<long>(boost::any_cast<long>(m["HealthCheckCount"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("AuthModifyTime") != m.end() && !m["AuthModifyTime"].empty()) {
      authModifyTime = make_shared<long>(boost::any_cast<long>(m["AuthModifyTime"]));
    }
    if (m.find("ExposedCount") != m.end() && !m["ExposedCount"].empty()) {
      exposedCount = make_shared<long>(boost::any_cast<long>(m["ExposedCount"]));
    }
    if (m.find("SafeEventCount") != m.end() && !m["SafeEventCount"].empty()) {
      safeEventCount = make_shared<long>(boost::any_cast<long>(m["SafeEventCount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("AssetType") != m.end() && !m["AssetType"].empty()) {
      assetType = make_shared<string>(boost::any_cast<string>(m["AssetType"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<long>(boost::any_cast<long>(m["Vendor"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("AutoSnapshotsLevel") != m.end() && !m["AutoSnapshotsLevel"].empty()) {
      autoSnapshotsLevel = make_shared<long>(boost::any_cast<long>(m["AutoSnapshotsLevel"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("VendorName") != m.end() && !m["VendorName"].empty()) {
      vendorName = make_shared<string>(boost::any_cast<string>(m["VendorName"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ExposedStatus") != m.end() && !m["ExposedStatus"].empty()) {
      exposedStatus = make_shared<long>(boost::any_cast<long>(m["ExposedStatus"]));
    }
    if (m.find("RiskCount") != m.end() && !m["RiskCount"].empty()) {
      riskCount = make_shared<string>(boost::any_cast<string>(m["RiskCount"]));
    }
    if (m.find("ClientVersion") != m.end() && !m["ClientVersion"].empty()) {
      clientVersion = make_shared<string>(boost::any_cast<string>(m["ClientVersion"]));
    }
  }


  virtual ~DescribeCloudCenterInstancesResponseBodyInstances() = default;
};
class DescribeCloudCenterInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeCloudCenterInstancesResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribeCloudCenterInstancesResponseBodyInstances>> instances{};

  DescribeCloudCenterInstancesResponseBody() {}

  explicit DescribeCloudCenterInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeCloudCenterInstancesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeCloudCenterInstancesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<DescribeCloudCenterInstancesResponseBodyInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudCenterInstancesResponseBodyInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<DescribeCloudCenterInstancesResponseBodyInstances>>(expect1);
      }
    }
  }


  virtual ~DescribeCloudCenterInstancesResponseBody() = default;
};
class DescribeCloudCenterInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeCloudCenterInstancesResponseBody> body{};

  DescribeCloudCenterInstancesResponse() {}

  explicit DescribeCloudCenterInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudCenterInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudCenterInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudCenterInstancesResponse() = default;
};
class DescribeCloudProductFieldStatisticsResponseBodyGroupedFields : public Darabonba::Model {
public:
  shared_ptr<string> categoryCount{};
  shared_ptr<long> instanceCount{};
  shared_ptr<long> riskInstanceCount{};

  DescribeCloudProductFieldStatisticsResponseBodyGroupedFields() {}

  explicit DescribeCloudProductFieldStatisticsResponseBodyGroupedFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryCount) {
      res["CategoryCount"] = boost::any(*categoryCount);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (riskInstanceCount) {
      res["RiskInstanceCount"] = boost::any(*riskInstanceCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryCount") != m.end() && !m["CategoryCount"].empty()) {
      categoryCount = make_shared<string>(boost::any_cast<string>(m["CategoryCount"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("RiskInstanceCount") != m.end() && !m["RiskInstanceCount"].empty()) {
      riskInstanceCount = make_shared<long>(boost::any_cast<long>(m["RiskInstanceCount"]));
    }
  }


  virtual ~DescribeCloudProductFieldStatisticsResponseBodyGroupedFields() = default;
};
class DescribeCloudProductFieldStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeCloudProductFieldStatisticsResponseBodyGroupedFields> groupedFields{};

  DescribeCloudProductFieldStatisticsResponseBody() {}

  explicit DescribeCloudProductFieldStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (groupedFields) {
      res["GroupedFields"] = groupedFields ? boost::any(groupedFields->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("GroupedFields") != m.end() && !m["GroupedFields"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupedFields"].type()) {
        DescribeCloudProductFieldStatisticsResponseBodyGroupedFields model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupedFields"]));
        groupedFields = make_shared<DescribeCloudProductFieldStatisticsResponseBodyGroupedFields>(model1);
      }
    }
  }


  virtual ~DescribeCloudProductFieldStatisticsResponseBody() = default;
};
class DescribeCloudProductFieldStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeCloudProductFieldStatisticsResponseBody> body{};

  DescribeCloudProductFieldStatisticsResponse() {}

  explicit DescribeCloudProductFieldStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudProductFieldStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudProductFieldStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudProductFieldStatisticsResponse() = default;
};
class DescribeConcernNecessityRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  DescribeConcernNecessityRequest() {}

  explicit DescribeConcernNecessityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeConcernNecessityRequest() = default;
};
class DescribeConcernNecessityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> concernNecessity{};

  DescribeConcernNecessityResponseBody() {}

  explicit DescribeConcernNecessityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (concernNecessity) {
      res["ConcernNecessity"] = boost::any(*concernNecessity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ConcernNecessity") != m.end() && !m["ConcernNecessity"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ConcernNecessity"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ConcernNecessity"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      concernNecessity = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeConcernNecessityResponseBody() = default;
};
class DescribeConcernNecessityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeConcernNecessityResponseBody> body{};

  DescribeConcernNecessityResponse() {}

  explicit DescribeConcernNecessityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeConcernNecessityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeConcernNecessityResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeConcernNecessityResponse() = default;
};
class DescribeContainerStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};

  DescribeContainerStatisticsRequest() {}

  explicit DescribeContainerStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~DescribeContainerStatisticsRequest() = default;
};
class DescribeContainerStatisticsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> totalNode{};
  shared_ptr<long> remindAlarmCount{};
  shared_ptr<long> totalAlarmCount{};
  shared_ptr<long> suspiciousAlarmCount{};
  shared_ptr<long> seriousAlarmCount{};
  shared_ptr<long> hasRiskNode{};

  DescribeContainerStatisticsResponseBodyData() {}

  explicit DescribeContainerStatisticsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalNode) {
      res["TotalNode"] = boost::any(*totalNode);
    }
    if (remindAlarmCount) {
      res["RemindAlarmCount"] = boost::any(*remindAlarmCount);
    }
    if (totalAlarmCount) {
      res["TotalAlarmCount"] = boost::any(*totalAlarmCount);
    }
    if (suspiciousAlarmCount) {
      res["SuspiciousAlarmCount"] = boost::any(*suspiciousAlarmCount);
    }
    if (seriousAlarmCount) {
      res["SeriousAlarmCount"] = boost::any(*seriousAlarmCount);
    }
    if (hasRiskNode) {
      res["hasRiskNode"] = boost::any(*hasRiskNode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalNode") != m.end() && !m["TotalNode"].empty()) {
      totalNode = make_shared<long>(boost::any_cast<long>(m["TotalNode"]));
    }
    if (m.find("RemindAlarmCount") != m.end() && !m["RemindAlarmCount"].empty()) {
      remindAlarmCount = make_shared<long>(boost::any_cast<long>(m["RemindAlarmCount"]));
    }
    if (m.find("TotalAlarmCount") != m.end() && !m["TotalAlarmCount"].empty()) {
      totalAlarmCount = make_shared<long>(boost::any_cast<long>(m["TotalAlarmCount"]));
    }
    if (m.find("SuspiciousAlarmCount") != m.end() && !m["SuspiciousAlarmCount"].empty()) {
      suspiciousAlarmCount = make_shared<long>(boost::any_cast<long>(m["SuspiciousAlarmCount"]));
    }
    if (m.find("SeriousAlarmCount") != m.end() && !m["SeriousAlarmCount"].empty()) {
      seriousAlarmCount = make_shared<long>(boost::any_cast<long>(m["SeriousAlarmCount"]));
    }
    if (m.find("hasRiskNode") != m.end() && !m["hasRiskNode"].empty()) {
      hasRiskNode = make_shared<long>(boost::any_cast<long>(m["hasRiskNode"]));
    }
  }


  virtual ~DescribeContainerStatisticsResponseBodyData() = default;
};
class DescribeContainerStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeContainerStatisticsResponseBodyData> data{};

  DescribeContainerStatisticsResponseBody() {}

  explicit DescribeContainerStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeContainerStatisticsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeContainerStatisticsResponseBodyData>(model1);
      }
    }
  }


  virtual ~DescribeContainerStatisticsResponseBody() = default;
};
class DescribeContainerStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeContainerStatisticsResponseBody> body{};

  DescribeContainerStatisticsResponse() {}

  explicit DescribeContainerStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeContainerStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeContainerStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeContainerStatisticsResponse() = default;
};
class DescribeCriteriaRequest : public Darabonba::Model {
public:
  shared_ptr<string> machineTypes{};
  shared_ptr<string> value{};

  DescribeCriteriaRequest() {}

  explicit DescribeCriteriaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (machineTypes) {
      res["MachineTypes"] = boost::any(*machineTypes);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MachineTypes") != m.end() && !m["MachineTypes"].empty()) {
      machineTypes = make_shared<string>(boost::any_cast<string>(m["MachineTypes"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeCriteriaRequest() = default;
};
class DescribeCriteriaResponseBodyCriteriaList : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> name{};
  shared_ptr<string> values{};

  DescribeCriteriaResponseBodyCriteriaList() {}

  explicit DescribeCriteriaResponseBodyCriteriaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      values = make_shared<string>(boost::any_cast<string>(m["Values"]));
    }
  }


  virtual ~DescribeCriteriaResponseBodyCriteriaList() = default;
};
class DescribeCriteriaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeCriteriaResponseBodyCriteriaList>> criteriaList{};

  DescribeCriteriaResponseBody() {}

  explicit DescribeCriteriaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (criteriaList) {
      vector<boost::any> temp1;
      for(auto item1:*criteriaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CriteriaList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CriteriaList") != m.end() && !m["CriteriaList"].empty()) {
      if (typeid(vector<boost::any>) == m["CriteriaList"].type()) {
        vector<DescribeCriteriaResponseBodyCriteriaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CriteriaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCriteriaResponseBodyCriteriaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        criteriaList = make_shared<vector<DescribeCriteriaResponseBodyCriteriaList>>(expect1);
      }
    }
  }


  virtual ~DescribeCriteriaResponseBody() = default;
};
class DescribeCriteriaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeCriteriaResponseBody> body{};

  DescribeCriteriaResponse() {}

  explicit DescribeCriteriaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCriteriaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCriteriaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCriteriaResponse() = default;
};
class DescribeDialogMessagesRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};

  DescribeDialogMessagesRequest() {}

  explicit DescribeDialogMessagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeDialogMessagesRequest() = default;
};
class DescribeDialogMessagesResponseBodyDialogList : public Darabonba::Model {
public:
  shared_ptr<string> dialogKey{};
  shared_ptr<string> params{};
  shared_ptr<long> ID{};

  DescribeDialogMessagesResponseBodyDialogList() {}

  explicit DescribeDialogMessagesResponseBodyDialogList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dialogKey) {
      res["DialogKey"] = boost::any(*dialogKey);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (ID) {
      res["ID"] = boost::any(*ID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DialogKey") != m.end() && !m["DialogKey"].empty()) {
      dialogKey = make_shared<string>(boost::any_cast<string>(m["DialogKey"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("ID") != m.end() && !m["ID"].empty()) {
      ID = make_shared<long>(boost::any_cast<long>(m["ID"]));
    }
  }


  virtual ~DescribeDialogMessagesResponseBodyDialogList() = default;
};
class DescribeDialogMessagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDialogMessagesResponseBodyDialogList>> dialogList{};

  DescribeDialogMessagesResponseBody() {}

  explicit DescribeDialogMessagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (dialogList) {
      vector<boost::any> temp1;
      for(auto item1:*dialogList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DialogList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DialogList") != m.end() && !m["DialogList"].empty()) {
      if (typeid(vector<boost::any>) == m["DialogList"].type()) {
        vector<DescribeDialogMessagesResponseBodyDialogList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DialogList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDialogMessagesResponseBodyDialogList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dialogList = make_shared<vector<DescribeDialogMessagesResponseBodyDialogList>>(expect1);
      }
    }
  }


  virtual ~DescribeDialogMessagesResponseBody() = default;
};
class DescribeDialogMessagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDialogMessagesResponseBody> body{};

  DescribeDialogMessagesResponse() {}

  explicit DescribeDialogMessagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDialogMessagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDialogMessagesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDialogMessagesResponse() = default;
};
class DescribeDingTalkRequest : public Darabonba::Model {
public:
  shared_ptr<string> ruleActionName{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};

  DescribeDingTalkRequest() {}

  explicit DescribeDingTalkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleActionName) {
      res["RuleActionName"] = boost::any(*ruleActionName);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleActionName") != m.end() && !m["RuleActionName"].empty()) {
      ruleActionName = make_shared<string>(boost::any_cast<string>(m["RuleActionName"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~DescribeDingTalkRequest() = default;
};
class DescribeDingTalkResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeDingTalkResponseBodyPageInfo() {}

  explicit DescribeDingTalkResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDingTalkResponseBodyPageInfo() = default;
};
class DescribeDingTalkResponseBodyActionList : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<string> configList{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> actionName{};
  shared_ptr<string> url{};
  shared_ptr<long> aliUid{};
  shared_ptr<string> dingTalkLang{};
  shared_ptr<long> intervalTime{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> groupIdList{};
  shared_ptr<long> id{};

  DescribeDingTalkResponseBodyActionList() {}

  explicit DescribeDingTalkResponseBodyActionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (configList) {
      res["ConfigList"] = boost::any(*configList);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (actionName) {
      res["ActionName"] = boost::any(*actionName);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (dingTalkLang) {
      res["DingTalkLang"] = boost::any(*dingTalkLang);
    }
    if (intervalTime) {
      res["IntervalTime"] = boost::any(*intervalTime);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (groupIdList) {
      res["GroupIdList"] = boost::any(*groupIdList);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("ConfigList") != m.end() && !m["ConfigList"].empty()) {
      configList = make_shared<string>(boost::any_cast<string>(m["ConfigList"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("ActionName") != m.end() && !m["ActionName"].empty()) {
      actionName = make_shared<string>(boost::any_cast<string>(m["ActionName"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<long>(boost::any_cast<long>(m["AliUid"]));
    }
    if (m.find("DingTalkLang") != m.end() && !m["DingTalkLang"].empty()) {
      dingTalkLang = make_shared<string>(boost::any_cast<string>(m["DingTalkLang"]));
    }
    if (m.find("IntervalTime") != m.end() && !m["IntervalTime"].empty()) {
      intervalTime = make_shared<long>(boost::any_cast<long>(m["IntervalTime"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("GroupIdList") != m.end() && !m["GroupIdList"].empty()) {
      groupIdList = make_shared<string>(boost::any_cast<string>(m["GroupIdList"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DescribeDingTalkResponseBodyActionList() = default;
};
class DescribeDingTalkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDingTalkResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribeDingTalkResponseBodyActionList>> actionList{};

  DescribeDingTalkResponseBody() {}

  explicit DescribeDingTalkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (actionList) {
      vector<boost::any> temp1;
      for(auto item1:*actionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ActionList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeDingTalkResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeDingTalkResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("ActionList") != m.end() && !m["ActionList"].empty()) {
      if (typeid(vector<boost::any>) == m["ActionList"].type()) {
        vector<DescribeDingTalkResponseBodyActionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ActionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDingTalkResponseBodyActionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        actionList = make_shared<vector<DescribeDingTalkResponseBodyActionList>>(expect1);
      }
    }
  }


  virtual ~DescribeDingTalkResponseBody() = default;
};
class DescribeDingTalkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDingTalkResponseBody> body{};

  DescribeDingTalkResponse() {}

  explicit DescribeDingTalkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDingTalkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDingTalkResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDingTalkResponse() = default;
};
class DescribeDomainCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};

  DescribeDomainCountRequest() {}

  explicit DescribeDomainCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeDomainCountRequest() = default;
};
class DescribeDomainCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> rootDomainsCount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> subDomainsCount{};
  shared_ptr<long> totalDomainsCount{};

  DescribeDomainCountResponseBody() {}

  explicit DescribeDomainCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rootDomainsCount) {
      res["RootDomainsCount"] = boost::any(*rootDomainsCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subDomainsCount) {
      res["SubDomainsCount"] = boost::any(*subDomainsCount);
    }
    if (totalDomainsCount) {
      res["TotalDomainsCount"] = boost::any(*totalDomainsCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RootDomainsCount") != m.end() && !m["RootDomainsCount"].empty()) {
      rootDomainsCount = make_shared<long>(boost::any_cast<long>(m["RootDomainsCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubDomainsCount") != m.end() && !m["SubDomainsCount"].empty()) {
      subDomainsCount = make_shared<long>(boost::any_cast<long>(m["SubDomainsCount"]));
    }
    if (m.find("TotalDomainsCount") != m.end() && !m["TotalDomainsCount"].empty()) {
      totalDomainsCount = make_shared<long>(boost::any_cast<long>(m["TotalDomainsCount"]));
    }
  }


  virtual ~DescribeDomainCountResponseBody() = default;
};
class DescribeDomainCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDomainCountResponseBody> body{};

  DescribeDomainCountResponse() {}

  explicit DescribeDomainCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainCountResponse() = default;
};
class DescribeDomainDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> domainName{};

  DescribeDomainDetailRequest() {}

  explicit DescribeDomainDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeDomainDetailRequest() = default;
};
class DescribeDomainDetailResponseBodyDomainDetailItems : public Darabonba::Model {
public:
  shared_ptr<string> uuid{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> assetType{};

  DescribeDomainDetailResponseBodyDomainDetailItems() {}

  explicit DescribeDomainDetailResponseBodyDomainDetailItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (assetType) {
      res["AssetType"] = boost::any(*assetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("AssetType") != m.end() && !m["AssetType"].empty()) {
      assetType = make_shared<string>(boost::any_cast<string>(m["AssetType"]));
    }
  }


  virtual ~DescribeDomainDetailResponseBodyDomainDetailItems() = default;
};
class DescribeDomainDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> requestId{};
  shared_ptr<long> vulCount{};
  shared_ptr<long> alarmCount{};
  shared_ptr<string> rootDomain{};
  shared_ptr<vector<DescribeDomainDetailResponseBodyDomainDetailItems>> domainDetailItems{};

  DescribeDomainDetailResponseBody() {}

  explicit DescribeDomainDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vulCount) {
      res["VulCount"] = boost::any(*vulCount);
    }
    if (alarmCount) {
      res["AlarmCount"] = boost::any(*alarmCount);
    }
    if (rootDomain) {
      res["RootDomain"] = boost::any(*rootDomain);
    }
    if (domainDetailItems) {
      vector<boost::any> temp1;
      for(auto item1:*domainDetailItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainDetailItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VulCount") != m.end() && !m["VulCount"].empty()) {
      vulCount = make_shared<long>(boost::any_cast<long>(m["VulCount"]));
    }
    if (m.find("AlarmCount") != m.end() && !m["AlarmCount"].empty()) {
      alarmCount = make_shared<long>(boost::any_cast<long>(m["AlarmCount"]));
    }
    if (m.find("RootDomain") != m.end() && !m["RootDomain"].empty()) {
      rootDomain = make_shared<string>(boost::any_cast<string>(m["RootDomain"]));
    }
    if (m.find("DomainDetailItems") != m.end() && !m["DomainDetailItems"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainDetailItems"].type()) {
        vector<DescribeDomainDetailResponseBodyDomainDetailItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainDetailItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainDetailResponseBodyDomainDetailItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainDetailItems = make_shared<vector<DescribeDomainDetailResponseBodyDomainDetailItems>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainDetailResponseBody() = default;
};
class DescribeDomainDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDomainDetailResponseBody> body{};

  DescribeDomainDetailResponse() {}

  explicit DescribeDomainDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainDetailResponse() = default;
};
class DescribeDomainListRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> fuzzyDomain{};
  shared_ptr<string> domainType{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};

  DescribeDomainListRequest() {}

  explicit DescribeDomainListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (fuzzyDomain) {
      res["FuzzyDomain"] = boost::any(*fuzzyDomain);
    }
    if (domainType) {
      res["DomainType"] = boost::any(*domainType);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("FuzzyDomain") != m.end() && !m["FuzzyDomain"].empty()) {
      fuzzyDomain = make_shared<string>(boost::any_cast<string>(m["FuzzyDomain"]));
    }
    if (m.find("DomainType") != m.end() && !m["DomainType"].empty()) {
      domainType = make_shared<string>(boost::any_cast<string>(m["DomainType"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~DescribeDomainListRequest() = default;
};
class DescribeDomainListResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribeDomainListResponseBodyPageInfo() {}

  explicit DescribeDomainListResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeDomainListResponseBodyPageInfo() = default;
};
class DescribeDomainListResponseBodyDomainListResponseList : public Darabonba::Model {
public:
  shared_ptr<string> ipList{};
  shared_ptr<string> domain{};

  DescribeDomainListResponseBodyDomainListResponseList() {}

  explicit DescribeDomainListResponseBodyDomainListResponseList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipList) {
      res["IpList"] = boost::any(*ipList);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpList") != m.end() && !m["IpList"].empty()) {
      ipList = make_shared<string>(boost::any_cast<string>(m["IpList"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
  }


  virtual ~DescribeDomainListResponseBodyDomainListResponseList() = default;
};
class DescribeDomainListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDomainListResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribeDomainListResponseBodyDomainListResponseList>> domainListResponseList{};

  DescribeDomainListResponseBody() {}

  explicit DescribeDomainListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainListResponseList) {
      vector<boost::any> temp1;
      for(auto item1:*domainListResponseList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainListResponseList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeDomainListResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeDomainListResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("DomainListResponseList") != m.end() && !m["DomainListResponseList"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainListResponseList"].type()) {
        vector<DescribeDomainListResponseBodyDomainListResponseList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainListResponseList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainListResponseBodyDomainListResponseList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainListResponseList = make_shared<vector<DescribeDomainListResponseBodyDomainListResponseList>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainListResponseBody() = default;
};
class DescribeDomainListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDomainListResponseBody> body{};

  DescribeDomainListResponse() {}

  explicit DescribeDomainListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainListResponse() = default;
};
class DescribeEmgVulItemRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> riskStatus{};
  shared_ptr<string> scanType{};
  shared_ptr<string> vulName{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  DescribeEmgVulItemRequest() {}

  explicit DescribeEmgVulItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (riskStatus) {
      res["RiskStatus"] = boost::any(*riskStatus);
    }
    if (scanType) {
      res["ScanType"] = boost::any(*scanType);
    }
    if (vulName) {
      res["VulName"] = boost::any(*vulName);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RiskStatus") != m.end() && !m["RiskStatus"].empty()) {
      riskStatus = make_shared<string>(boost::any_cast<string>(m["RiskStatus"]));
    }
    if (m.find("ScanType") != m.end() && !m["ScanType"].empty()) {
      scanType = make_shared<string>(boost::any_cast<string>(m["ScanType"]));
    }
    if (m.find("VulName") != m.end() && !m["VulName"].empty()) {
      vulName = make_shared<string>(boost::any_cast<string>(m["VulName"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeEmgVulItemRequest() = default;
};
class DescribeEmgVulItemResponseBodyGroupedVulItems : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<string> type{};
  shared_ptr<long> gmtLastCheck{};
  shared_ptr<long> progress{};
  shared_ptr<long> gmtPublish{};
  shared_ptr<long> pendingCount{};
  shared_ptr<string> aliasName{};
  shared_ptr<string> name{};

  DescribeEmgVulItemResponseBodyGroupedVulItems() {}

  explicit DescribeEmgVulItemResponseBodyGroupedVulItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (gmtLastCheck) {
      res["GmtLastCheck"] = boost::any(*gmtLastCheck);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (gmtPublish) {
      res["GmtPublish"] = boost::any(*gmtPublish);
    }
    if (pendingCount) {
      res["PendingCount"] = boost::any(*pendingCount);
    }
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("GmtLastCheck") != m.end() && !m["GmtLastCheck"].empty()) {
      gmtLastCheck = make_shared<long>(boost::any_cast<long>(m["GmtLastCheck"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("GmtPublish") != m.end() && !m["GmtPublish"].empty()) {
      gmtPublish = make_shared<long>(boost::any_cast<long>(m["GmtPublish"]));
    }
    if (m.find("PendingCount") != m.end() && !m["PendingCount"].empty()) {
      pendingCount = make_shared<long>(boost::any_cast<long>(m["PendingCount"]));
    }
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeEmgVulItemResponseBodyGroupedVulItems() = default;
};
class DescribeEmgVulItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribeEmgVulItemResponseBodyGroupedVulItems>> groupedVulItems{};

  DescribeEmgVulItemResponseBody() {}

  explicit DescribeEmgVulItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (groupedVulItems) {
      vector<boost::any> temp1;
      for(auto item1:*groupedVulItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupedVulItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("GroupedVulItems") != m.end() && !m["GroupedVulItems"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupedVulItems"].type()) {
        vector<DescribeEmgVulItemResponseBodyGroupedVulItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupedVulItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEmgVulItemResponseBodyGroupedVulItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupedVulItems = make_shared<vector<DescribeEmgVulItemResponseBodyGroupedVulItems>>(expect1);
      }
    }
  }


  virtual ~DescribeEmgVulItemResponseBody() = default;
};
class DescribeEmgVulItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeEmgVulItemResponseBody> body{};

  DescribeEmgVulItemResponse() {}

  explicit DescribeEmgVulItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEmgVulItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEmgVulItemResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEmgVulItemResponse() = default;
};
class DescribeExcludeSystemPathRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};

  DescribeExcludeSystemPathRequest() {}

  explicit DescribeExcludeSystemPathRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~DescribeExcludeSystemPathRequest() = default;
};
class DescribeExcludeSystemPathResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribeExcludeSystemPathResponseBodyPageInfo() {}

  explicit DescribeExcludeSystemPathResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeExcludeSystemPathResponseBodyPageInfo() = default;
};
class DescribeExcludeSystemPathResponseBodyExcludePaths : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<string> os{};
  shared_ptr<long> id{};

  DescribeExcludeSystemPathResponseBodyExcludePaths() {}

  explicit DescribeExcludeSystemPathResponseBodyExcludePaths(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DescribeExcludeSystemPathResponseBodyExcludePaths() = default;
};
class DescribeExcludeSystemPathResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeExcludeSystemPathResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribeExcludeSystemPathResponseBodyExcludePaths>> excludePaths{};

  DescribeExcludeSystemPathResponseBody() {}

  explicit DescribeExcludeSystemPathResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (excludePaths) {
      vector<boost::any> temp1;
      for(auto item1:*excludePaths){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExcludePaths"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeExcludeSystemPathResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeExcludeSystemPathResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("ExcludePaths") != m.end() && !m["ExcludePaths"].empty()) {
      if (typeid(vector<boost::any>) == m["ExcludePaths"].type()) {
        vector<DescribeExcludeSystemPathResponseBodyExcludePaths> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExcludePaths"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExcludeSystemPathResponseBodyExcludePaths model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        excludePaths = make_shared<vector<DescribeExcludeSystemPathResponseBodyExcludePaths>>(expect1);
      }
    }
  }


  virtual ~DescribeExcludeSystemPathResponseBody() = default;
};
class DescribeExcludeSystemPathResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeExcludeSystemPathResponseBody> body{};

  DescribeExcludeSystemPathResponse() {}

  explicit DescribeExcludeSystemPathResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExcludeSystemPathResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExcludeSystemPathResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExcludeSystemPathResponse() = default;
};
class DescribeExportInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> exportId{};

  DescribeExportInfoRequest() {}

  explicit DescribeExportInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exportId) {
      res["ExportId"] = boost::any(*exportId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExportId") != m.end() && !m["ExportId"].empty()) {
      exportId = make_shared<long>(boost::any_cast<long>(m["ExportId"]));
    }
  }


  virtual ~DescribeExportInfoRequest() = default;
};
class DescribeExportInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> link{};
  shared_ptr<long> progress{};
  shared_ptr<string> requestId{};
  shared_ptr<long> currentCount{};
  shared_ptr<string> message{};
  shared_ptr<string> fileName{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> exportStatus{};
  shared_ptr<long> id{};

  DescribeExportInfoResponseBody() {}

  explicit DescribeExportInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (link) {
      res["Link"] = boost::any(*link);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (currentCount) {
      res["CurrentCount"] = boost::any(*currentCount);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (exportStatus) {
      res["ExportStatus"] = boost::any(*exportStatus);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Link") != m.end() && !m["Link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["Link"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CurrentCount") != m.end() && !m["CurrentCount"].empty()) {
      currentCount = make_shared<long>(boost::any_cast<long>(m["CurrentCount"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("ExportStatus") != m.end() && !m["ExportStatus"].empty()) {
      exportStatus = make_shared<string>(boost::any_cast<string>(m["ExportStatus"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DescribeExportInfoResponseBody() = default;
};
class DescribeExportInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeExportInfoResponseBody> body{};

  DescribeExportInfoResponse() {}

  explicit DescribeExportInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExportInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExportInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExportInfoResponse() = default;
};
class DescribeExposedInstanceCriteriaRequest : public Darabonba::Model {
public:
  shared_ptr<string> value{};

  DescribeExposedInstanceCriteriaRequest() {}

  explicit DescribeExposedInstanceCriteriaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeExposedInstanceCriteriaRequest() = default;
};
class DescribeExposedInstanceCriteriaResponseBodyCriteriaList : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> name{};
  shared_ptr<string> values{};

  DescribeExposedInstanceCriteriaResponseBodyCriteriaList() {}

  explicit DescribeExposedInstanceCriteriaResponseBodyCriteriaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      values = make_shared<string>(boost::any_cast<string>(m["Values"]));
    }
  }


  virtual ~DescribeExposedInstanceCriteriaResponseBodyCriteriaList() = default;
};
class DescribeExposedInstanceCriteriaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeExposedInstanceCriteriaResponseBodyCriteriaList>> criteriaList{};

  DescribeExposedInstanceCriteriaResponseBody() {}

  explicit DescribeExposedInstanceCriteriaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (criteriaList) {
      vector<boost::any> temp1;
      for(auto item1:*criteriaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CriteriaList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CriteriaList") != m.end() && !m["CriteriaList"].empty()) {
      if (typeid(vector<boost::any>) == m["CriteriaList"].type()) {
        vector<DescribeExposedInstanceCriteriaResponseBodyCriteriaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CriteriaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExposedInstanceCriteriaResponseBodyCriteriaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        criteriaList = make_shared<vector<DescribeExposedInstanceCriteriaResponseBodyCriteriaList>>(expect1);
      }
    }
  }


  virtual ~DescribeExposedInstanceCriteriaResponseBody() = default;
};
class DescribeExposedInstanceCriteriaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeExposedInstanceCriteriaResponseBody> body{};

  DescribeExposedInstanceCriteriaResponse() {}

  explicit DescribeExposedInstanceCriteriaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExposedInstanceCriteriaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExposedInstanceCriteriaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExposedInstanceCriteriaResponse() = default;
};
class DescribeExposedInstanceDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> uuid{};

  DescribeExposedInstanceDetailRequest() {}

  explicit DescribeExposedInstanceDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeExposedInstanceDetailRequest() = default;
};
class DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> necessity{};
  shared_ptr<string> uuid{};
  shared_ptr<string> aliasName{};
  shared_ptr<string> name{};

  DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList() {}

  explicit DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (necessity) {
      res["Necessity"] = boost::any(*necessity);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Necessity") != m.end() && !m["Necessity"].empty()) {
      necessity = make_shared<string>(boost::any_cast<string>(m["Necessity"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList() = default;
};
class DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> necessity{};
  shared_ptr<string> uuid{};
  shared_ptr<string> aliasName{};
  shared_ptr<string> name{};

  DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList() {}

  explicit DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (necessity) {
      res["Necessity"] = boost::any(*necessity);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Necessity") != m.end() && !m["Necessity"].empty()) {
      necessity = make_shared<string>(boost::any_cast<string>(m["Necessity"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList() = default;
};
class DescribeExposedInstanceDetailResponseBodyExposedChains : public Darabonba::Model {
public:
  shared_ptr<string> exposureIp{};
  shared_ptr<string> groupNo{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> exposureType{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> exposureTypeId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> uuid{};
  shared_ptr<string> exposurePort{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> exposureComponent{};
  shared_ptr<vector<DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList>> realVulList{};
  shared_ptr<vector<DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList>> allVulList{};

  DescribeExposedInstanceDetailResponseBodyExposedChains() {}

  explicit DescribeExposedInstanceDetailResponseBodyExposedChains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exposureIp) {
      res["ExposureIp"] = boost::any(*exposureIp);
    }
    if (groupNo) {
      res["GroupNo"] = boost::any(*groupNo);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (exposureType) {
      res["ExposureType"] = boost::any(*exposureType);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (exposureTypeId) {
      res["ExposureTypeId"] = boost::any(*exposureTypeId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (exposurePort) {
      res["ExposurePort"] = boost::any(*exposurePort);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (exposureComponent) {
      res["ExposureComponent"] = boost::any(*exposureComponent);
    }
    if (realVulList) {
      vector<boost::any> temp1;
      for(auto item1:*realVulList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RealVulList"] = boost::any(temp1);
    }
    if (allVulList) {
      vector<boost::any> temp1;
      for(auto item1:*allVulList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AllVulList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExposureIp") != m.end() && !m["ExposureIp"].empty()) {
      exposureIp = make_shared<string>(boost::any_cast<string>(m["ExposureIp"]));
    }
    if (m.find("GroupNo") != m.end() && !m["GroupNo"].empty()) {
      groupNo = make_shared<string>(boost::any_cast<string>(m["GroupNo"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ExposureType") != m.end() && !m["ExposureType"].empty()) {
      exposureType = make_shared<string>(boost::any_cast<string>(m["ExposureType"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("ExposureTypeId") != m.end() && !m["ExposureTypeId"].empty()) {
      exposureTypeId = make_shared<string>(boost::any_cast<string>(m["ExposureTypeId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("ExposurePort") != m.end() && !m["ExposurePort"].empty()) {
      exposurePort = make_shared<string>(boost::any_cast<string>(m["ExposurePort"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("ExposureComponent") != m.end() && !m["ExposureComponent"].empty()) {
      exposureComponent = make_shared<string>(boost::any_cast<string>(m["ExposureComponent"]));
    }
    if (m.find("RealVulList") != m.end() && !m["RealVulList"].empty()) {
      if (typeid(vector<boost::any>) == m["RealVulList"].type()) {
        vector<DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RealVulList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        realVulList = make_shared<vector<DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList>>(expect1);
      }
    }
    if (m.find("AllVulList") != m.end() && !m["AllVulList"].empty()) {
      if (typeid(vector<boost::any>) == m["AllVulList"].type()) {
        vector<DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AllVulList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        allVulList = make_shared<vector<DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList>>(expect1);
      }
    }
  }


  virtual ~DescribeExposedInstanceDetailResponseBodyExposedChains() = default;
};
class DescribeExposedInstanceDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeExposedInstanceDetailResponseBodyExposedChains>> exposedChains{};

  DescribeExposedInstanceDetailResponseBody() {}

  explicit DescribeExposedInstanceDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (exposedChains) {
      vector<boost::any> temp1;
      for(auto item1:*exposedChains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExposedChains"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ExposedChains") != m.end() && !m["ExposedChains"].empty()) {
      if (typeid(vector<boost::any>) == m["ExposedChains"].type()) {
        vector<DescribeExposedInstanceDetailResponseBodyExposedChains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExposedChains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExposedInstanceDetailResponseBodyExposedChains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        exposedChains = make_shared<vector<DescribeExposedInstanceDetailResponseBodyExposedChains>>(expect1);
      }
    }
  }


  virtual ~DescribeExposedInstanceDetailResponseBody() = default;
};
class DescribeExposedInstanceDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeExposedInstanceDetailResponseBody> body{};

  DescribeExposedInstanceDetailResponse() {}

  explicit DescribeExposedInstanceDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExposedInstanceDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExposedInstanceDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExposedInstanceDetailResponse() = default;
};
class DescribeExposedInstanceListRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> groupId{};
  shared_ptr<bool> vulStatus{};
  shared_ptr<bool> healthStatus{};
  shared_ptr<string> exposureComponent{};
  shared_ptr<string> exposurePort{};
  shared_ptr<string> exposureIp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};

  DescribeExposedInstanceListRequest() {}

  explicit DescribeExposedInstanceListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (vulStatus) {
      res["VulStatus"] = boost::any(*vulStatus);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (exposureComponent) {
      res["ExposureComponent"] = boost::any(*exposureComponent);
    }
    if (exposurePort) {
      res["ExposurePort"] = boost::any(*exposurePort);
    }
    if (exposureIp) {
      res["ExposureIp"] = boost::any(*exposureIp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("VulStatus") != m.end() && !m["VulStatus"].empty()) {
      vulStatus = make_shared<bool>(boost::any_cast<bool>(m["VulStatus"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<bool>(boost::any_cast<bool>(m["HealthStatus"]));
    }
    if (m.find("ExposureComponent") != m.end() && !m["ExposureComponent"].empty()) {
      exposureComponent = make_shared<string>(boost::any_cast<string>(m["ExposureComponent"]));
    }
    if (m.find("ExposurePort") != m.end() && !m["ExposurePort"].empty()) {
      exposurePort = make_shared<string>(boost::any_cast<string>(m["ExposurePort"]));
    }
    if (m.find("ExposureIp") != m.end() && !m["ExposureIp"].empty()) {
      exposureIp = make_shared<string>(boost::any_cast<string>(m["ExposureIp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
  }


  virtual ~DescribeExposedInstanceListRequest() = default;
};
class DescribeExposedInstanceListResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribeExposedInstanceListResponseBodyPageInfo() {}

  explicit DescribeExposedInstanceListResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeExposedInstanceListResponseBodyPageInfo() = default;
};
class DescribeExposedInstanceListResponseBodyExposedInstances : public Darabonba::Model {
public:
  shared_ptr<string> exposureIp{};
  shared_ptr<long> totalVulCount{};
  shared_ptr<string> internetIp{};
  shared_ptr<long> nntfVulCount{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> exposureType{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> regionId{};
  shared_ptr<string> exposureTypeId{};
  shared_ptr<long> asapVulCount{};
  shared_ptr<string> exposurePort{};
  shared_ptr<string> uuid{};
  shared_ptr<string> groupName{};
  shared_ptr<long> groupId{};
  shared_ptr<long> exploitHealthCount{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> exposureComponent{};
  shared_ptr<long> laterVulCount{};

  DescribeExposedInstanceListResponseBodyExposedInstances() {}

  explicit DescribeExposedInstanceListResponseBodyExposedInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exposureIp) {
      res["ExposureIp"] = boost::any(*exposureIp);
    }
    if (totalVulCount) {
      res["TotalVulCount"] = boost::any(*totalVulCount);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (nntfVulCount) {
      res["NntfVulCount"] = boost::any(*nntfVulCount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (exposureType) {
      res["ExposureType"] = boost::any(*exposureType);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (exposureTypeId) {
      res["ExposureTypeId"] = boost::any(*exposureTypeId);
    }
    if (asapVulCount) {
      res["AsapVulCount"] = boost::any(*asapVulCount);
    }
    if (exposurePort) {
      res["ExposurePort"] = boost::any(*exposurePort);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (exploitHealthCount) {
      res["ExploitHealthCount"] = boost::any(*exploitHealthCount);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (exposureComponent) {
      res["ExposureComponent"] = boost::any(*exposureComponent);
    }
    if (laterVulCount) {
      res["LaterVulCount"] = boost::any(*laterVulCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExposureIp") != m.end() && !m["ExposureIp"].empty()) {
      exposureIp = make_shared<string>(boost::any_cast<string>(m["ExposureIp"]));
    }
    if (m.find("TotalVulCount") != m.end() && !m["TotalVulCount"].empty()) {
      totalVulCount = make_shared<long>(boost::any_cast<long>(m["TotalVulCount"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("NntfVulCount") != m.end() && !m["NntfVulCount"].empty()) {
      nntfVulCount = make_shared<long>(boost::any_cast<long>(m["NntfVulCount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ExposureType") != m.end() && !m["ExposureType"].empty()) {
      exposureType = make_shared<string>(boost::any_cast<string>(m["ExposureType"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ExposureTypeId") != m.end() && !m["ExposureTypeId"].empty()) {
      exposureTypeId = make_shared<string>(boost::any_cast<string>(m["ExposureTypeId"]));
    }
    if (m.find("AsapVulCount") != m.end() && !m["AsapVulCount"].empty()) {
      asapVulCount = make_shared<long>(boost::any_cast<long>(m["AsapVulCount"]));
    }
    if (m.find("ExposurePort") != m.end() && !m["ExposurePort"].empty()) {
      exposurePort = make_shared<string>(boost::any_cast<string>(m["ExposurePort"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("ExploitHealthCount") != m.end() && !m["ExploitHealthCount"].empty()) {
      exploitHealthCount = make_shared<long>(boost::any_cast<long>(m["ExploitHealthCount"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("ExposureComponent") != m.end() && !m["ExposureComponent"].empty()) {
      exposureComponent = make_shared<string>(boost::any_cast<string>(m["ExposureComponent"]));
    }
    if (m.find("LaterVulCount") != m.end() && !m["LaterVulCount"].empty()) {
      laterVulCount = make_shared<long>(boost::any_cast<long>(m["LaterVulCount"]));
    }
  }


  virtual ~DescribeExposedInstanceListResponseBodyExposedInstances() = default;
};
class DescribeExposedInstanceListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeExposedInstanceListResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribeExposedInstanceListResponseBodyExposedInstances>> exposedInstances{};

  DescribeExposedInstanceListResponseBody() {}

  explicit DescribeExposedInstanceListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (exposedInstances) {
      vector<boost::any> temp1;
      for(auto item1:*exposedInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExposedInstances"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeExposedInstanceListResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeExposedInstanceListResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("ExposedInstances") != m.end() && !m["ExposedInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["ExposedInstances"].type()) {
        vector<DescribeExposedInstanceListResponseBodyExposedInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExposedInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExposedInstanceListResponseBodyExposedInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        exposedInstances = make_shared<vector<DescribeExposedInstanceListResponseBodyExposedInstances>>(expect1);
      }
    }
  }


  virtual ~DescribeExposedInstanceListResponseBody() = default;
};
class DescribeExposedInstanceListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeExposedInstanceListResponseBody> body{};

  DescribeExposedInstanceListResponse() {}

  explicit DescribeExposedInstanceListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExposedInstanceListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExposedInstanceListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExposedInstanceListResponse() = default;
};
class DescribeExposedStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> exposedLaterVulCount{};
  shared_ptr<long> exposedComponentCount{};
  shared_ptr<long> exposedPortCount{};
  shared_ptr<long> exposedInstanceCount{};
  shared_ptr<long> exposedWeekPasswordMachineCount{};
  shared_ptr<long> exposedNntfVulCount{};
  shared_ptr<long> gatewayAssetCount{};
  shared_ptr<long> exposedIpCount{};
  shared_ptr<long> exposedAsapVulCount{};

  DescribeExposedStatisticsResponseBody() {}

  explicit DescribeExposedStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (exposedLaterVulCount) {
      res["ExposedLaterVulCount"] = boost::any(*exposedLaterVulCount);
    }
    if (exposedComponentCount) {
      res["ExposedComponentCount"] = boost::any(*exposedComponentCount);
    }
    if (exposedPortCount) {
      res["ExposedPortCount"] = boost::any(*exposedPortCount);
    }
    if (exposedInstanceCount) {
      res["ExposedInstanceCount"] = boost::any(*exposedInstanceCount);
    }
    if (exposedWeekPasswordMachineCount) {
      res["ExposedWeekPasswordMachineCount"] = boost::any(*exposedWeekPasswordMachineCount);
    }
    if (exposedNntfVulCount) {
      res["ExposedNntfVulCount"] = boost::any(*exposedNntfVulCount);
    }
    if (gatewayAssetCount) {
      res["GatewayAssetCount"] = boost::any(*gatewayAssetCount);
    }
    if (exposedIpCount) {
      res["ExposedIpCount"] = boost::any(*exposedIpCount);
    }
    if (exposedAsapVulCount) {
      res["ExposedAsapVulCount"] = boost::any(*exposedAsapVulCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ExposedLaterVulCount") != m.end() && !m["ExposedLaterVulCount"].empty()) {
      exposedLaterVulCount = make_shared<long>(boost::any_cast<long>(m["ExposedLaterVulCount"]));
    }
    if (m.find("ExposedComponentCount") != m.end() && !m["ExposedComponentCount"].empty()) {
      exposedComponentCount = make_shared<long>(boost::any_cast<long>(m["ExposedComponentCount"]));
    }
    if (m.find("ExposedPortCount") != m.end() && !m["ExposedPortCount"].empty()) {
      exposedPortCount = make_shared<long>(boost::any_cast<long>(m["ExposedPortCount"]));
    }
    if (m.find("ExposedInstanceCount") != m.end() && !m["ExposedInstanceCount"].empty()) {
      exposedInstanceCount = make_shared<long>(boost::any_cast<long>(m["ExposedInstanceCount"]));
    }
    if (m.find("ExposedWeekPasswordMachineCount") != m.end() && !m["ExposedWeekPasswordMachineCount"].empty()) {
      exposedWeekPasswordMachineCount = make_shared<long>(boost::any_cast<long>(m["ExposedWeekPasswordMachineCount"]));
    }
    if (m.find("ExposedNntfVulCount") != m.end() && !m["ExposedNntfVulCount"].empty()) {
      exposedNntfVulCount = make_shared<long>(boost::any_cast<long>(m["ExposedNntfVulCount"]));
    }
    if (m.find("GatewayAssetCount") != m.end() && !m["GatewayAssetCount"].empty()) {
      gatewayAssetCount = make_shared<long>(boost::any_cast<long>(m["GatewayAssetCount"]));
    }
    if (m.find("ExposedIpCount") != m.end() && !m["ExposedIpCount"].empty()) {
      exposedIpCount = make_shared<long>(boost::any_cast<long>(m["ExposedIpCount"]));
    }
    if (m.find("ExposedAsapVulCount") != m.end() && !m["ExposedAsapVulCount"].empty()) {
      exposedAsapVulCount = make_shared<long>(boost::any_cast<long>(m["ExposedAsapVulCount"]));
    }
  }


  virtual ~DescribeExposedStatisticsResponseBody() = default;
};
class DescribeExposedStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeExposedStatisticsResponseBody> body{};

  DescribeExposedStatisticsResponse() {}

  explicit DescribeExposedStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExposedStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExposedStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExposedStatisticsResponse() = default;
};
class DescribeExposedStatisticsDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> statisticsType{};
  shared_ptr<string> statisticsTypeInstanceValue{};
  shared_ptr<string> statisticsTypeGatewayType{};

  DescribeExposedStatisticsDetailRequest() {}

  explicit DescribeExposedStatisticsDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (statisticsType) {
      res["StatisticsType"] = boost::any(*statisticsType);
    }
    if (statisticsTypeInstanceValue) {
      res["StatisticsTypeInstanceValue"] = boost::any(*statisticsTypeInstanceValue);
    }
    if (statisticsTypeGatewayType) {
      res["StatisticsTypeGatewayType"] = boost::any(*statisticsTypeGatewayType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("StatisticsType") != m.end() && !m["StatisticsType"].empty()) {
      statisticsType = make_shared<string>(boost::any_cast<string>(m["StatisticsType"]));
    }
    if (m.find("StatisticsTypeInstanceValue") != m.end() && !m["StatisticsTypeInstanceValue"].empty()) {
      statisticsTypeInstanceValue = make_shared<string>(boost::any_cast<string>(m["StatisticsTypeInstanceValue"]));
    }
    if (m.find("StatisticsTypeGatewayType") != m.end() && !m["StatisticsTypeGatewayType"].empty()) {
      statisticsTypeGatewayType = make_shared<string>(boost::any_cast<string>(m["StatisticsTypeGatewayType"]));
    }
  }


  virtual ~DescribeExposedStatisticsDetailRequest() = default;
};
class DescribeExposedStatisticsDetailResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribeExposedStatisticsDetailResponseBodyPageInfo() {}

  explicit DescribeExposedStatisticsDetailResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeExposedStatisticsDetailResponseBodyPageInfo() = default;
};
class DescribeExposedStatisticsDetailResponseBodyStatisticsDetails : public Darabonba::Model {
public:
  shared_ptr<string> exposureIp{};
  shared_ptr<string> exposurePort{};
  shared_ptr<string> exposureTypeInstanceName{};
  shared_ptr<long> exposedCount{};
  shared_ptr<string> exposureType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> exposureComponent{};
  shared_ptr<string> exposureTypeId{};

  DescribeExposedStatisticsDetailResponseBodyStatisticsDetails() {}

  explicit DescribeExposedStatisticsDetailResponseBodyStatisticsDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exposureIp) {
      res["ExposureIp"] = boost::any(*exposureIp);
    }
    if (exposurePort) {
      res["ExposurePort"] = boost::any(*exposurePort);
    }
    if (exposureTypeInstanceName) {
      res["ExposureTypeInstanceName"] = boost::any(*exposureTypeInstanceName);
    }
    if (exposedCount) {
      res["ExposedCount"] = boost::any(*exposedCount);
    }
    if (exposureType) {
      res["ExposureType"] = boost::any(*exposureType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (exposureComponent) {
      res["ExposureComponent"] = boost::any(*exposureComponent);
    }
    if (exposureTypeId) {
      res["ExposureTypeId"] = boost::any(*exposureTypeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExposureIp") != m.end() && !m["ExposureIp"].empty()) {
      exposureIp = make_shared<string>(boost::any_cast<string>(m["ExposureIp"]));
    }
    if (m.find("ExposurePort") != m.end() && !m["ExposurePort"].empty()) {
      exposurePort = make_shared<string>(boost::any_cast<string>(m["ExposurePort"]));
    }
    if (m.find("ExposureTypeInstanceName") != m.end() && !m["ExposureTypeInstanceName"].empty()) {
      exposureTypeInstanceName = make_shared<string>(boost::any_cast<string>(m["ExposureTypeInstanceName"]));
    }
    if (m.find("ExposedCount") != m.end() && !m["ExposedCount"].empty()) {
      exposedCount = make_shared<long>(boost::any_cast<long>(m["ExposedCount"]));
    }
    if (m.find("ExposureType") != m.end() && !m["ExposureType"].empty()) {
      exposureType = make_shared<string>(boost::any_cast<string>(m["ExposureType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ExposureComponent") != m.end() && !m["ExposureComponent"].empty()) {
      exposureComponent = make_shared<string>(boost::any_cast<string>(m["ExposureComponent"]));
    }
    if (m.find("ExposureTypeId") != m.end() && !m["ExposureTypeId"].empty()) {
      exposureTypeId = make_shared<string>(boost::any_cast<string>(m["ExposureTypeId"]));
    }
  }


  virtual ~DescribeExposedStatisticsDetailResponseBodyStatisticsDetails() = default;
};
class DescribeExposedStatisticsDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeExposedStatisticsDetailResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribeExposedStatisticsDetailResponseBodyStatisticsDetails>> statisticsDetails{};

  DescribeExposedStatisticsDetailResponseBody() {}

  explicit DescribeExposedStatisticsDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (statisticsDetails) {
      vector<boost::any> temp1;
      for(auto item1:*statisticsDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StatisticsDetails"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeExposedStatisticsDetailResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeExposedStatisticsDetailResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("StatisticsDetails") != m.end() && !m["StatisticsDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["StatisticsDetails"].type()) {
        vector<DescribeExposedStatisticsDetailResponseBodyStatisticsDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StatisticsDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExposedStatisticsDetailResponseBodyStatisticsDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statisticsDetails = make_shared<vector<DescribeExposedStatisticsDetailResponseBodyStatisticsDetails>>(expect1);
      }
    }
  }


  virtual ~DescribeExposedStatisticsDetailResponseBody() = default;
};
class DescribeExposedStatisticsDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeExposedStatisticsDetailResponseBody> body{};

  DescribeExposedStatisticsDetailResponse() {}

  explicit DescribeExposedStatisticsDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExposedStatisticsDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExposedStatisticsDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExposedStatisticsDetailResponse() = default;
};
class DescribeFieldStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> machineTypes{};

  DescribeFieldStatisticsRequest() {}

  explicit DescribeFieldStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (machineTypes) {
      res["MachineTypes"] = boost::any(*machineTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("MachineTypes") != m.end() && !m["MachineTypes"].empty()) {
      machineTypes = make_shared<string>(boost::any_cast<string>(m["MachineTypes"]));
    }
  }


  virtual ~DescribeFieldStatisticsRequest() = default;
};
class DescribeFieldStatisticsResponseBodyGroupedFields : public Darabonba::Model {
public:
  shared_ptr<long> offlineInstanceCount{};
  shared_ptr<long> regionCount{};
  shared_ptr<long> newInstanceCount{};
  shared_ptr<long> exposedInstanceCount{};
  shared_ptr<long> groupCount{};
  shared_ptr<long> tencentInstanceCount{};
  shared_ptr<long> generalAssetCount{};
  shared_ptr<long> instanceSyncTaskCount{};
  shared_ptr<long> unprotectedInstanceCount{};
  shared_ptr<long> importantAssetCount{};
  shared_ptr<long> testAssetCount{};
  shared_ptr<long> vpcCount{};
  shared_ptr<long> instanceCount{};
  shared_ptr<long> idcInstanceCount{};
  shared_ptr<long> notRunningStatusCount{};
  shared_ptr<long> aliYunInstanceCount{};
  shared_ptr<long> riskInstanceCount{};

  DescribeFieldStatisticsResponseBodyGroupedFields() {}

  explicit DescribeFieldStatisticsResponseBodyGroupedFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offlineInstanceCount) {
      res["OfflineInstanceCount"] = boost::any(*offlineInstanceCount);
    }
    if (regionCount) {
      res["RegionCount"] = boost::any(*regionCount);
    }
    if (newInstanceCount) {
      res["NewInstanceCount"] = boost::any(*newInstanceCount);
    }
    if (exposedInstanceCount) {
      res["ExposedInstanceCount"] = boost::any(*exposedInstanceCount);
    }
    if (groupCount) {
      res["GroupCount"] = boost::any(*groupCount);
    }
    if (tencentInstanceCount) {
      res["TencentInstanceCount"] = boost::any(*tencentInstanceCount);
    }
    if (generalAssetCount) {
      res["GeneralAssetCount"] = boost::any(*generalAssetCount);
    }
    if (instanceSyncTaskCount) {
      res["InstanceSyncTaskCount"] = boost::any(*instanceSyncTaskCount);
    }
    if (unprotectedInstanceCount) {
      res["UnprotectedInstanceCount"] = boost::any(*unprotectedInstanceCount);
    }
    if (importantAssetCount) {
      res["ImportantAssetCount"] = boost::any(*importantAssetCount);
    }
    if (testAssetCount) {
      res["TestAssetCount"] = boost::any(*testAssetCount);
    }
    if (vpcCount) {
      res["VpcCount"] = boost::any(*vpcCount);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (idcInstanceCount) {
      res["IdcInstanceCount"] = boost::any(*idcInstanceCount);
    }
    if (notRunningStatusCount) {
      res["NotRunningStatusCount"] = boost::any(*notRunningStatusCount);
    }
    if (aliYunInstanceCount) {
      res["AliYunInstanceCount"] = boost::any(*aliYunInstanceCount);
    }
    if (riskInstanceCount) {
      res["RiskInstanceCount"] = boost::any(*riskInstanceCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OfflineInstanceCount") != m.end() && !m["OfflineInstanceCount"].empty()) {
      offlineInstanceCount = make_shared<long>(boost::any_cast<long>(m["OfflineInstanceCount"]));
    }
    if (m.find("RegionCount") != m.end() && !m["RegionCount"].empty()) {
      regionCount = make_shared<long>(boost::any_cast<long>(m["RegionCount"]));
    }
    if (m.find("NewInstanceCount") != m.end() && !m["NewInstanceCount"].empty()) {
      newInstanceCount = make_shared<long>(boost::any_cast<long>(m["NewInstanceCount"]));
    }
    if (m.find("ExposedInstanceCount") != m.end() && !m["ExposedInstanceCount"].empty()) {
      exposedInstanceCount = make_shared<long>(boost::any_cast<long>(m["ExposedInstanceCount"]));
    }
    if (m.find("GroupCount") != m.end() && !m["GroupCount"].empty()) {
      groupCount = make_shared<long>(boost::any_cast<long>(m["GroupCount"]));
    }
    if (m.find("TencentInstanceCount") != m.end() && !m["TencentInstanceCount"].empty()) {
      tencentInstanceCount = make_shared<long>(boost::any_cast<long>(m["TencentInstanceCount"]));
    }
    if (m.find("GeneralAssetCount") != m.end() && !m["GeneralAssetCount"].empty()) {
      generalAssetCount = make_shared<long>(boost::any_cast<long>(m["GeneralAssetCount"]));
    }
    if (m.find("InstanceSyncTaskCount") != m.end() && !m["InstanceSyncTaskCount"].empty()) {
      instanceSyncTaskCount = make_shared<long>(boost::any_cast<long>(m["InstanceSyncTaskCount"]));
    }
    if (m.find("UnprotectedInstanceCount") != m.end() && !m["UnprotectedInstanceCount"].empty()) {
      unprotectedInstanceCount = make_shared<long>(boost::any_cast<long>(m["UnprotectedInstanceCount"]));
    }
    if (m.find("ImportantAssetCount") != m.end() && !m["ImportantAssetCount"].empty()) {
      importantAssetCount = make_shared<long>(boost::any_cast<long>(m["ImportantAssetCount"]));
    }
    if (m.find("TestAssetCount") != m.end() && !m["TestAssetCount"].empty()) {
      testAssetCount = make_shared<long>(boost::any_cast<long>(m["TestAssetCount"]));
    }
    if (m.find("VpcCount") != m.end() && !m["VpcCount"].empty()) {
      vpcCount = make_shared<long>(boost::any_cast<long>(m["VpcCount"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("IdcInstanceCount") != m.end() && !m["IdcInstanceCount"].empty()) {
      idcInstanceCount = make_shared<long>(boost::any_cast<long>(m["IdcInstanceCount"]));
    }
    if (m.find("NotRunningStatusCount") != m.end() && !m["NotRunningStatusCount"].empty()) {
      notRunningStatusCount = make_shared<long>(boost::any_cast<long>(m["NotRunningStatusCount"]));
    }
    if (m.find("AliYunInstanceCount") != m.end() && !m["AliYunInstanceCount"].empty()) {
      aliYunInstanceCount = make_shared<long>(boost::any_cast<long>(m["AliYunInstanceCount"]));
    }
    if (m.find("RiskInstanceCount") != m.end() && !m["RiskInstanceCount"].empty()) {
      riskInstanceCount = make_shared<long>(boost::any_cast<long>(m["RiskInstanceCount"]));
    }
  }


  virtual ~DescribeFieldStatisticsResponseBodyGroupedFields() = default;
};
class DescribeFieldStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeFieldStatisticsResponseBodyGroupedFields> groupedFields{};

  DescribeFieldStatisticsResponseBody() {}

  explicit DescribeFieldStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (groupedFields) {
      res["GroupedFields"] = groupedFields ? boost::any(groupedFields->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("GroupedFields") != m.end() && !m["GroupedFields"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupedFields"].type()) {
        DescribeFieldStatisticsResponseBodyGroupedFields model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupedFields"]));
        groupedFields = make_shared<DescribeFieldStatisticsResponseBodyGroupedFields>(model1);
      }
    }
  }


  virtual ~DescribeFieldStatisticsResponseBody() = default;
};
class DescribeFieldStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeFieldStatisticsResponseBody> body{};

  DescribeFieldStatisticsResponse() {}

  explicit DescribeFieldStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFieldStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFieldStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFieldStatisticsResponse() = default;
};
class DescribeFrontVulPatchListRequest : public Darabonba::Model {
public:
  shared_ptr<string> info{};
  shared_ptr<string> operateType{};
  shared_ptr<string> type{};

  DescribeFrontVulPatchListRequest() {}

  explicit DescribeFrontVulPatchListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<string>(boost::any_cast<string>(m["Info"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<string>(boost::any_cast<string>(m["OperateType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeFrontVulPatchListRequest() = default;
};
class DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> aliasName{};

  DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList() {}

  explicit DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
  }


  virtual ~DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList() = default;
};
class DescribeFrontVulPatchListResponseBodyFrontPatchList : public Darabonba::Model {
public:
  shared_ptr<string> uuid{};
  shared_ptr<vector<DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList>> patchList{};

  DescribeFrontVulPatchListResponseBodyFrontPatchList() {}

  explicit DescribeFrontVulPatchListResponseBodyFrontPatchList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (patchList) {
      vector<boost::any> temp1;
      for(auto item1:*patchList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PatchList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("PatchList") != m.end() && !m["PatchList"].empty()) {
      if (typeid(vector<boost::any>) == m["PatchList"].type()) {
        vector<DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PatchList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        patchList = make_shared<vector<DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList>>(expect1);
      }
    }
  }


  virtual ~DescribeFrontVulPatchListResponseBodyFrontPatchList() = default;
};
class DescribeFrontVulPatchListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeFrontVulPatchListResponseBodyFrontPatchList>> frontPatchList{};

  DescribeFrontVulPatchListResponseBody() {}

  explicit DescribeFrontVulPatchListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (frontPatchList) {
      vector<boost::any> temp1;
      for(auto item1:*frontPatchList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FrontPatchList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("FrontPatchList") != m.end() && !m["FrontPatchList"].empty()) {
      if (typeid(vector<boost::any>) == m["FrontPatchList"].type()) {
        vector<DescribeFrontVulPatchListResponseBodyFrontPatchList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FrontPatchList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFrontVulPatchListResponseBodyFrontPatchList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        frontPatchList = make_shared<vector<DescribeFrontVulPatchListResponseBodyFrontPatchList>>(expect1);
      }
    }
  }


  virtual ~DescribeFrontVulPatchListResponseBody() = default;
};
class DescribeFrontVulPatchListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeFrontVulPatchListResponseBody> body{};

  DescribeFrontVulPatchListResponse() {}

  explicit DescribeFrontVulPatchListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFrontVulPatchListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFrontVulPatchListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFrontVulPatchListResponse() = default;
};
class DescribeGraph4InvestigationOnlineRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> vertexId{};
  shared_ptr<string> anomalyUuid{};
  shared_ptr<string> anomalyId{};
  shared_ptr<long> pathLength{};
  shared_ptr<string> direction{};

  DescribeGraph4InvestigationOnlineRequest() {}

  explicit DescribeGraph4InvestigationOnlineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (vertexId) {
      res["VertexId"] = boost::any(*vertexId);
    }
    if (anomalyUuid) {
      res["AnomalyUuid"] = boost::any(*anomalyUuid);
    }
    if (anomalyId) {
      res["AnomalyId"] = boost::any(*anomalyId);
    }
    if (pathLength) {
      res["PathLength"] = boost::any(*pathLength);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("VertexId") != m.end() && !m["VertexId"].empty()) {
      vertexId = make_shared<string>(boost::any_cast<string>(m["VertexId"]));
    }
    if (m.find("AnomalyUuid") != m.end() && !m["AnomalyUuid"].empty()) {
      anomalyUuid = make_shared<string>(boost::any_cast<string>(m["AnomalyUuid"]));
    }
    if (m.find("AnomalyId") != m.end() && !m["AnomalyId"].empty()) {
      anomalyId = make_shared<string>(boost::any_cast<string>(m["AnomalyId"]));
    }
    if (m.find("PathLength") != m.end() && !m["PathLength"].empty()) {
      pathLength = make_shared<long>(boost::any_cast<long>(m["PathLength"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
  }


  virtual ~DescribeGraph4InvestigationOnlineRequest() = default;
};
class DescribeGraph4InvestigationOnlineResponseBodyDataVertexListNeighborList : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<bool> hasMore{};
  shared_ptr<long> count{};

  DescribeGraph4InvestigationOnlineResponseBodyDataVertexListNeighborList() {}

  explicit DescribeGraph4InvestigationOnlineResponseBodyDataVertexListNeighborList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeGraph4InvestigationOnlineResponseBodyDataVertexListNeighborList() = default;
};
class DescribeGraph4InvestigationOnlineResponseBodyDataVertexList : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};
  shared_ptr<string> time{};
  shared_ptr<string> aliuid{};
  shared_ptr<string> position{};
  shared_ptr<string> positionId{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};
  shared_ptr<string> properties{};
  shared_ptr<vector<DescribeGraph4InvestigationOnlineResponseBodyDataVertexListNeighborList>> neighborList{};

  DescribeGraph4InvestigationOnlineResponseBodyDataVertexList() {}

  explicit DescribeGraph4InvestigationOnlineResponseBodyDataVertexList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (aliuid) {
      res["Aliuid"] = boost::any(*aliuid);
    }
    if (position) {
      res["Position"] = boost::any(*position);
    }
    if (positionId) {
      res["PositionId"] = boost::any(*positionId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (properties) {
      res["Properties"] = boost::any(*properties);
    }
    if (neighborList) {
      vector<boost::any> temp1;
      for(auto item1:*neighborList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NeighborList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Aliuid") != m.end() && !m["Aliuid"].empty()) {
      aliuid = make_shared<string>(boost::any_cast<string>(m["Aliuid"]));
    }
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      position = make_shared<string>(boost::any_cast<string>(m["Position"]));
    }
    if (m.find("PositionId") != m.end() && !m["PositionId"].empty()) {
      positionId = make_shared<string>(boost::any_cast<string>(m["PositionId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      properties = make_shared<string>(boost::any_cast<string>(m["Properties"]));
    }
    if (m.find("NeighborList") != m.end() && !m["NeighborList"].empty()) {
      if (typeid(vector<boost::any>) == m["NeighborList"].type()) {
        vector<DescribeGraph4InvestigationOnlineResponseBodyDataVertexListNeighborList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NeighborList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGraph4InvestigationOnlineResponseBodyDataVertexListNeighborList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        neighborList = make_shared<vector<DescribeGraph4InvestigationOnlineResponseBodyDataVertexListNeighborList>>(expect1);
      }
    }
  }


  virtual ~DescribeGraph4InvestigationOnlineResponseBodyDataVertexList() = default;
};
class DescribeGraph4InvestigationOnlineResponseBodyDataEdgeList : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> time{};
  shared_ptr<string> endId{};
  shared_ptr<string> startType{};
  shared_ptr<string> endType{};
  shared_ptr<string> name{};
  shared_ptr<string> startId{};
  shared_ptr<long> id{};

  DescribeGraph4InvestigationOnlineResponseBodyDataEdgeList() {}

  explicit DescribeGraph4InvestigationOnlineResponseBodyDataEdgeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (endId) {
      res["EndId"] = boost::any(*endId);
    }
    if (startType) {
      res["StartType"] = boost::any(*startType);
    }
    if (endType) {
      res["EndType"] = boost::any(*endType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (startId) {
      res["StartId"] = boost::any(*startId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("EndId") != m.end() && !m["EndId"].empty()) {
      endId = make_shared<string>(boost::any_cast<string>(m["EndId"]));
    }
    if (m.find("StartType") != m.end() && !m["StartType"].empty()) {
      startType = make_shared<string>(boost::any_cast<string>(m["StartType"]));
    }
    if (m.find("EndType") != m.end() && !m["EndType"].empty()) {
      endType = make_shared<string>(boost::any_cast<string>(m["EndType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StartId") != m.end() && !m["StartId"].empty()) {
      startId = make_shared<string>(boost::any_cast<string>(m["StartId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DescribeGraph4InvestigationOnlineResponseBodyDataEdgeList() = default;
};
class DescribeGraph4InvestigationOnlineResponseBodyDataEntityTypeList : public Darabonba::Model {
public:
  shared_ptr<string> displayColor{};
  shared_ptr<string> displayOrder{};
  shared_ptr<string> name{};
  shared_ptr<string> displayIcon{};
  shared_ptr<string> id{};

  DescribeGraph4InvestigationOnlineResponseBodyDataEntityTypeList() {}

  explicit DescribeGraph4InvestigationOnlineResponseBodyDataEntityTypeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayColor) {
      res["DisplayColor"] = boost::any(*displayColor);
    }
    if (displayOrder) {
      res["DisplayOrder"] = boost::any(*displayOrder);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (displayIcon) {
      res["DisplayIcon"] = boost::any(*displayIcon);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayColor") != m.end() && !m["DisplayColor"].empty()) {
      displayColor = make_shared<string>(boost::any_cast<string>(m["DisplayColor"]));
    }
    if (m.find("DisplayOrder") != m.end() && !m["DisplayOrder"].empty()) {
      displayOrder = make_shared<string>(boost::any_cast<string>(m["DisplayOrder"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("DisplayIcon") != m.end() && !m["DisplayIcon"].empty()) {
      displayIcon = make_shared<string>(boost::any_cast<string>(m["DisplayIcon"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DescribeGraph4InvestigationOnlineResponseBodyDataEntityTypeList() = default;
};
class DescribeGraph4InvestigationOnlineResponseBodyDataRelationTypeList : public Darabonba::Model {
public:
  shared_ptr<string> showType{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};
  shared_ptr<long> directed{};

  DescribeGraph4InvestigationOnlineResponseBodyDataRelationTypeList() {}

  explicit DescribeGraph4InvestigationOnlineResponseBodyDataRelationTypeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (showType) {
      res["ShowType"] = boost::any(*showType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (directed) {
      res["Directed"] = boost::any(*directed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ShowType") != m.end() && !m["ShowType"].empty()) {
      showType = make_shared<string>(boost::any_cast<string>(m["ShowType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Directed") != m.end() && !m["Directed"].empty()) {
      directed = make_shared<long>(boost::any_cast<long>(m["Directed"]));
    }
  }


  virtual ~DescribeGraph4InvestigationOnlineResponseBodyDataRelationTypeList() = default;
};
class DescribeGraph4InvestigationOnlineResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGraph4InvestigationOnlineResponseBodyDataVertexList>> vertexList{};
  shared_ptr<vector<DescribeGraph4InvestigationOnlineResponseBodyDataEdgeList>> edgeList{};
  shared_ptr<vector<DescribeGraph4InvestigationOnlineResponseBodyDataEntityTypeList>> entityTypeList{};
  shared_ptr<vector<DescribeGraph4InvestigationOnlineResponseBodyDataRelationTypeList>> relationTypeList{};

  DescribeGraph4InvestigationOnlineResponseBodyData() {}

  explicit DescribeGraph4InvestigationOnlineResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vertexList) {
      vector<boost::any> temp1;
      for(auto item1:*vertexList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VertexList"] = boost::any(temp1);
    }
    if (edgeList) {
      vector<boost::any> temp1;
      for(auto item1:*edgeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EdgeList"] = boost::any(temp1);
    }
    if (entityTypeList) {
      vector<boost::any> temp1;
      for(auto item1:*entityTypeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EntityTypeList"] = boost::any(temp1);
    }
    if (relationTypeList) {
      vector<boost::any> temp1;
      for(auto item1:*relationTypeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RelationTypeList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VertexList") != m.end() && !m["VertexList"].empty()) {
      if (typeid(vector<boost::any>) == m["VertexList"].type()) {
        vector<DescribeGraph4InvestigationOnlineResponseBodyDataVertexList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VertexList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGraph4InvestigationOnlineResponseBodyDataVertexList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vertexList = make_shared<vector<DescribeGraph4InvestigationOnlineResponseBodyDataVertexList>>(expect1);
      }
    }
    if (m.find("EdgeList") != m.end() && !m["EdgeList"].empty()) {
      if (typeid(vector<boost::any>) == m["EdgeList"].type()) {
        vector<DescribeGraph4InvestigationOnlineResponseBodyDataEdgeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EdgeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGraph4InvestigationOnlineResponseBodyDataEdgeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        edgeList = make_shared<vector<DescribeGraph4InvestigationOnlineResponseBodyDataEdgeList>>(expect1);
      }
    }
    if (m.find("EntityTypeList") != m.end() && !m["EntityTypeList"].empty()) {
      if (typeid(vector<boost::any>) == m["EntityTypeList"].type()) {
        vector<DescribeGraph4InvestigationOnlineResponseBodyDataEntityTypeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EntityTypeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGraph4InvestigationOnlineResponseBodyDataEntityTypeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entityTypeList = make_shared<vector<DescribeGraph4InvestigationOnlineResponseBodyDataEntityTypeList>>(expect1);
      }
    }
    if (m.find("RelationTypeList") != m.end() && !m["RelationTypeList"].empty()) {
      if (typeid(vector<boost::any>) == m["RelationTypeList"].type()) {
        vector<DescribeGraph4InvestigationOnlineResponseBodyDataRelationTypeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RelationTypeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGraph4InvestigationOnlineResponseBodyDataRelationTypeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relationTypeList = make_shared<vector<DescribeGraph4InvestigationOnlineResponseBodyDataRelationTypeList>>(expect1);
      }
    }
  }


  virtual ~DescribeGraph4InvestigationOnlineResponseBodyData() = default;
};
class DescribeGraph4InvestigationOnlineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeGraph4InvestigationOnlineResponseBodyData> data{};

  DescribeGraph4InvestigationOnlineResponseBody() {}

  explicit DescribeGraph4InvestigationOnlineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeGraph4InvestigationOnlineResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeGraph4InvestigationOnlineResponseBodyData>(model1);
      }
    }
  }


  virtual ~DescribeGraph4InvestigationOnlineResponseBody() = default;
};
class DescribeGraph4InvestigationOnlineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeGraph4InvestigationOnlineResponseBody> body{};

  DescribeGraph4InvestigationOnlineResponse() {}

  explicit DescribeGraph4InvestigationOnlineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGraph4InvestigationOnlineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGraph4InvestigationOnlineResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGraph4InvestigationOnlineResponse() = default;
};
class DescribeGroupedContainerInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> criteria{};
  shared_ptr<string> logicalExp{};
  shared_ptr<string> groupField{};
  shared_ptr<string> fieldValue{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};

  DescribeGroupedContainerInstancesRequest() {}

  explicit DescribeGroupedContainerInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (logicalExp) {
      res["LogicalExp"] = boost::any(*logicalExp);
    }
    if (groupField) {
      res["GroupField"] = boost::any(*groupField);
    }
    if (fieldValue) {
      res["FieldValue"] = boost::any(*fieldValue);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("LogicalExp") != m.end() && !m["LogicalExp"].empty()) {
      logicalExp = make_shared<string>(boost::any_cast<string>(m["LogicalExp"]));
    }
    if (m.find("GroupField") != m.end() && !m["GroupField"].empty()) {
      groupField = make_shared<string>(boost::any_cast<string>(m["GroupField"]));
    }
    if (m.find("FieldValue") != m.end() && !m["FieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["FieldValue"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~DescribeGroupedContainerInstancesRequest() = default;
};
class DescribeGroupedContainerInstancesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribeGroupedContainerInstancesResponseBodyPageInfo() {}

  explicit DescribeGroupedContainerInstancesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeGroupedContainerInstancesResponseBodyPageInfo() = default;
};
class DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList : public Darabonba::Model {
public:
  shared_ptr<string> riskLevel{};
  shared_ptr<string> hostIp{};
  shared_ptr<string> pod{};
  shared_ptr<string> riskStatus{};
  shared_ptr<long> createTime{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> custerState{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> appName{};
  shared_ptr<long> instanceCount{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> podIp{};
  shared_ptr<long> vulCount{};
  shared_ptr<long> alarmCount{};
  shared_ptr<long> riskInstanceCount{};
  shared_ptr<string> clusterId{};

  DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList() {}

  explicit DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (hostIp) {
      res["HostIp"] = boost::any(*hostIp);
    }
    if (pod) {
      res["Pod"] = boost::any(*pod);
    }
    if (riskStatus) {
      res["RiskStatus"] = boost::any(*riskStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (custerState) {
      res["CusterState"] = boost::any(*custerState);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (podIp) {
      res["PodIp"] = boost::any(*podIp);
    }
    if (vulCount) {
      res["VulCount"] = boost::any(*vulCount);
    }
    if (alarmCount) {
      res["AlarmCount"] = boost::any(*alarmCount);
    }
    if (riskInstanceCount) {
      res["RiskInstanceCount"] = boost::any(*riskInstanceCount);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<string>(boost::any_cast<string>(m["RiskLevel"]));
    }
    if (m.find("HostIp") != m.end() && !m["HostIp"].empty()) {
      hostIp = make_shared<string>(boost::any_cast<string>(m["HostIp"]));
    }
    if (m.find("Pod") != m.end() && !m["Pod"].empty()) {
      pod = make_shared<string>(boost::any_cast<string>(m["Pod"]));
    }
    if (m.find("RiskStatus") != m.end() && !m["RiskStatus"].empty()) {
      riskStatus = make_shared<string>(boost::any_cast<string>(m["RiskStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("CusterState") != m.end() && !m["CusterState"].empty()) {
      custerState = make_shared<string>(boost::any_cast<string>(m["CusterState"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("PodIp") != m.end() && !m["PodIp"].empty()) {
      podIp = make_shared<string>(boost::any_cast<string>(m["PodIp"]));
    }
    if (m.find("VulCount") != m.end() && !m["VulCount"].empty()) {
      vulCount = make_shared<long>(boost::any_cast<long>(m["VulCount"]));
    }
    if (m.find("AlarmCount") != m.end() && !m["AlarmCount"].empty()) {
      alarmCount = make_shared<long>(boost::any_cast<long>(m["AlarmCount"]));
    }
    if (m.find("RiskInstanceCount") != m.end() && !m["RiskInstanceCount"].empty()) {
      riskInstanceCount = make_shared<long>(boost::any_cast<long>(m["RiskInstanceCount"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList() = default;
};
class DescribeGroupedContainerInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeGroupedContainerInstancesResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList>> groupedContainerInstanceList{};

  DescribeGroupedContainerInstancesResponseBody() {}

  explicit DescribeGroupedContainerInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupedContainerInstanceList) {
      vector<boost::any> temp1;
      for(auto item1:*groupedContainerInstanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupedContainerInstanceList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeGroupedContainerInstancesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeGroupedContainerInstancesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("GroupedContainerInstanceList") != m.end() && !m["GroupedContainerInstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupedContainerInstanceList"].type()) {
        vector<DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupedContainerInstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupedContainerInstanceList = make_shared<vector<DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList>>(expect1);
      }
    }
  }


  virtual ~DescribeGroupedContainerInstancesResponseBody() = default;
};
class DescribeGroupedContainerInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeGroupedContainerInstancesResponseBody> body{};

  DescribeGroupedContainerInstancesResponse() {}

  explicit DescribeGroupedContainerInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGroupedContainerInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGroupedContainerInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGroupedContainerInstancesResponse() = default;
};
class DescribeGroupedInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> criteria{};
  shared_ptr<string> machineTypes{};
  shared_ptr<string> groupField{};
  shared_ptr<string> fieldValue{};
  shared_ptr<bool> noPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};

  DescribeGroupedInstancesRequest() {}

  explicit DescribeGroupedInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (machineTypes) {
      res["MachineTypes"] = boost::any(*machineTypes);
    }
    if (groupField) {
      res["GroupField"] = boost::any(*groupField);
    }
    if (fieldValue) {
      res["FieldValue"] = boost::any(*fieldValue);
    }
    if (noPage) {
      res["NoPage"] = boost::any(*noPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("MachineTypes") != m.end() && !m["MachineTypes"].empty()) {
      machineTypes = make_shared<string>(boost::any_cast<string>(m["MachineTypes"]));
    }
    if (m.find("GroupField") != m.end() && !m["GroupField"].empty()) {
      groupField = make_shared<string>(boost::any_cast<string>(m["GroupField"]));
    }
    if (m.find("FieldValue") != m.end() && !m["FieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["FieldValue"]));
    }
    if (m.find("NoPage") != m.end() && !m["NoPage"].empty()) {
      noPage = make_shared<bool>(boost::any_cast<bool>(m["NoPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~DescribeGroupedInstancesRequest() = default;
};
class DescribeGroupedInstancesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribeGroupedInstancesResponseBodyPageInfo() {}

  explicit DescribeGroupedInstancesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeGroupedInstancesResponseBodyPageInfo() = default;
};
class DescribeGroupedInstancesResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<long> asapVulInstanceCount{};
  shared_ptr<string> unProtectedInstanceCount{};
  shared_ptr<string> fieldAliasName{};
  shared_ptr<string> instanceCount{};
  shared_ptr<long> fieldId{};
  shared_ptr<string> riskInstanceCount{};
  shared_ptr<long> groupFlag{};
  shared_ptr<vector<string>> groupPath{};

  DescribeGroupedInstancesResponseBodyInstances() {}

  explicit DescribeGroupedInstancesResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asapVulInstanceCount) {
      res["AsapVulInstanceCount"] = boost::any(*asapVulInstanceCount);
    }
    if (unProtectedInstanceCount) {
      res["UnProtectedInstanceCount"] = boost::any(*unProtectedInstanceCount);
    }
    if (fieldAliasName) {
      res["FieldAliasName"] = boost::any(*fieldAliasName);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (fieldId) {
      res["FieldId"] = boost::any(*fieldId);
    }
    if (riskInstanceCount) {
      res["RiskInstanceCount"] = boost::any(*riskInstanceCount);
    }
    if (groupFlag) {
      res["GroupFlag"] = boost::any(*groupFlag);
    }
    if (groupPath) {
      res["GroupPath"] = boost::any(*groupPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsapVulInstanceCount") != m.end() && !m["AsapVulInstanceCount"].empty()) {
      asapVulInstanceCount = make_shared<long>(boost::any_cast<long>(m["AsapVulInstanceCount"]));
    }
    if (m.find("UnProtectedInstanceCount") != m.end() && !m["UnProtectedInstanceCount"].empty()) {
      unProtectedInstanceCount = make_shared<string>(boost::any_cast<string>(m["UnProtectedInstanceCount"]));
    }
    if (m.find("FieldAliasName") != m.end() && !m["FieldAliasName"].empty()) {
      fieldAliasName = make_shared<string>(boost::any_cast<string>(m["FieldAliasName"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<string>(boost::any_cast<string>(m["InstanceCount"]));
    }
    if (m.find("FieldId") != m.end() && !m["FieldId"].empty()) {
      fieldId = make_shared<long>(boost::any_cast<long>(m["FieldId"]));
    }
    if (m.find("RiskInstanceCount") != m.end() && !m["RiskInstanceCount"].empty()) {
      riskInstanceCount = make_shared<string>(boost::any_cast<string>(m["RiskInstanceCount"]));
    }
    if (m.find("GroupFlag") != m.end() && !m["GroupFlag"].empty()) {
      groupFlag = make_shared<long>(boost::any_cast<long>(m["GroupFlag"]));
    }
    if (m.find("GroupPath") != m.end() && !m["GroupPath"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupPath"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupPath"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupPath = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeGroupedInstancesResponseBodyInstances() = default;
};
class DescribeGroupedInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeGroupedInstancesResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribeGroupedInstancesResponseBodyInstances>> instances{};

  DescribeGroupedInstancesResponseBody() {}

  explicit DescribeGroupedInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeGroupedInstancesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeGroupedInstancesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<DescribeGroupedInstancesResponseBodyInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGroupedInstancesResponseBodyInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<DescribeGroupedInstancesResponseBodyInstances>>(expect1);
      }
    }
  }


  virtual ~DescribeGroupedInstancesResponseBody() = default;
};
class DescribeGroupedInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeGroupedInstancesResponseBody> body{};

  DescribeGroupedInstancesResponse() {}

  explicit DescribeGroupedInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGroupedInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGroupedInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGroupedInstancesResponse() = default;
};
class DescribeGroupedMaliciousFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> levels{};
  shared_ptr<string> fuzzyMaliciousName{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> repoRegionId{};
  shared_ptr<string> repoInstanceId{};
  shared_ptr<string> repoId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> imageTag{};
  shared_ptr<string> imageDigest{};
  shared_ptr<string> imageLayer{};

  DescribeGroupedMaliciousFilesRequest() {}

  explicit DescribeGroupedMaliciousFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (levels) {
      res["Levels"] = boost::any(*levels);
    }
    if (fuzzyMaliciousName) {
      res["FuzzyMaliciousName"] = boost::any(*fuzzyMaliciousName);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (repoRegionId) {
      res["RepoRegionId"] = boost::any(*repoRegionId);
    }
    if (repoInstanceId) {
      res["RepoInstanceId"] = boost::any(*repoInstanceId);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (imageTag) {
      res["ImageTag"] = boost::any(*imageTag);
    }
    if (imageDigest) {
      res["ImageDigest"] = boost::any(*imageDigest);
    }
    if (imageLayer) {
      res["ImageLayer"] = boost::any(*imageLayer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Levels") != m.end() && !m["Levels"].empty()) {
      levels = make_shared<string>(boost::any_cast<string>(m["Levels"]));
    }
    if (m.find("FuzzyMaliciousName") != m.end() && !m["FuzzyMaliciousName"].empty()) {
      fuzzyMaliciousName = make_shared<string>(boost::any_cast<string>(m["FuzzyMaliciousName"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RepoRegionId") != m.end() && !m["RepoRegionId"].empty()) {
      repoRegionId = make_shared<string>(boost::any_cast<string>(m["RepoRegionId"]));
    }
    if (m.find("RepoInstanceId") != m.end() && !m["RepoInstanceId"].empty()) {
      repoInstanceId = make_shared<string>(boost::any_cast<string>(m["RepoInstanceId"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("ImageTag") != m.end() && !m["ImageTag"].empty()) {
      imageTag = make_shared<string>(boost::any_cast<string>(m["ImageTag"]));
    }
    if (m.find("ImageDigest") != m.end() && !m["ImageDigest"].empty()) {
      imageDigest = make_shared<string>(boost::any_cast<string>(m["ImageDigest"]));
    }
    if (m.find("ImageLayer") != m.end() && !m["ImageLayer"].empty()) {
      imageLayer = make_shared<string>(boost::any_cast<string>(m["ImageLayer"]));
    }
  }


  virtual ~DescribeGroupedMaliciousFilesRequest() = default;
};
class DescribeGroupedMaliciousFilesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribeGroupedMaliciousFilesResponseBodyPageInfo() {}

  explicit DescribeGroupedMaliciousFilesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeGroupedMaliciousFilesResponseBodyPageInfo() = default;
};
class DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<long> imageCount{};
  shared_ptr<long> latestScanTimestamp{};
  shared_ptr<string> maliciousName{};
  shared_ptr<string> maliciousMd5{};
  shared_ptr<long> firstScanTimestamp{};
  shared_ptr<string> level{};

  DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse() {}

  explicit DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (imageCount) {
      res["ImageCount"] = boost::any(*imageCount);
    }
    if (latestScanTimestamp) {
      res["LatestScanTimestamp"] = boost::any(*latestScanTimestamp);
    }
    if (maliciousName) {
      res["MaliciousName"] = boost::any(*maliciousName);
    }
    if (maliciousMd5) {
      res["MaliciousMd5"] = boost::any(*maliciousMd5);
    }
    if (firstScanTimestamp) {
      res["FirstScanTimestamp"] = boost::any(*firstScanTimestamp);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("ImageCount") != m.end() && !m["ImageCount"].empty()) {
      imageCount = make_shared<long>(boost::any_cast<long>(m["ImageCount"]));
    }
    if (m.find("LatestScanTimestamp") != m.end() && !m["LatestScanTimestamp"].empty()) {
      latestScanTimestamp = make_shared<long>(boost::any_cast<long>(m["LatestScanTimestamp"]));
    }
    if (m.find("MaliciousName") != m.end() && !m["MaliciousName"].empty()) {
      maliciousName = make_shared<string>(boost::any_cast<string>(m["MaliciousName"]));
    }
    if (m.find("MaliciousMd5") != m.end() && !m["MaliciousMd5"].empty()) {
      maliciousMd5 = make_shared<string>(boost::any_cast<string>(m["MaliciousMd5"]));
    }
    if (m.find("FirstScanTimestamp") != m.end() && !m["FirstScanTimestamp"].empty()) {
      firstScanTimestamp = make_shared<long>(boost::any_cast<long>(m["FirstScanTimestamp"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse() = default;
};
class DescribeGroupedMaliciousFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeGroupedMaliciousFilesResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse>> groupedMaliciousFileResponse{};

  DescribeGroupedMaliciousFilesResponseBody() {}

  explicit DescribeGroupedMaliciousFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupedMaliciousFileResponse) {
      vector<boost::any> temp1;
      for(auto item1:*groupedMaliciousFileResponse){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupedMaliciousFileResponse"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeGroupedMaliciousFilesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeGroupedMaliciousFilesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("GroupedMaliciousFileResponse") != m.end() && !m["GroupedMaliciousFileResponse"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupedMaliciousFileResponse"].type()) {
        vector<DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupedMaliciousFileResponse"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupedMaliciousFileResponse = make_shared<vector<DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse>>(expect1);
      }
    }
  }


  virtual ~DescribeGroupedMaliciousFilesResponseBody() = default;
};
class DescribeGroupedMaliciousFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeGroupedMaliciousFilesResponseBody> body{};

  DescribeGroupedMaliciousFilesResponse() {}

  explicit DescribeGroupedMaliciousFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGroupedMaliciousFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGroupedMaliciousFilesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGroupedMaliciousFilesResponse() = default;
};
class DescribeGroupedTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> machineTypes{};

  DescribeGroupedTagsRequest() {}

  explicit DescribeGroupedTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (machineTypes) {
      res["MachineTypes"] = boost::any(*machineTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MachineTypes") != m.end() && !m["MachineTypes"].empty()) {
      machineTypes = make_shared<string>(boost::any_cast<string>(m["MachineTypes"]));
    }
  }


  virtual ~DescribeGroupedTagsRequest() = default;
};
class DescribeGroupedTagsResponseBodyGroupedFileds : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> count{};
  shared_ptr<long> tagId{};

  DescribeGroupedTagsResponseBodyGroupedFileds() {}

  explicit DescribeGroupedTagsResponseBodyGroupedFileds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (tagId) {
      res["TagId"] = boost::any(*tagId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("TagId") != m.end() && !m["TagId"].empty()) {
      tagId = make_shared<long>(boost::any_cast<long>(m["TagId"]));
    }
  }


  virtual ~DescribeGroupedTagsResponseBodyGroupedFileds() = default;
};
class DescribeGroupedTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeGroupedTagsResponseBodyGroupedFileds>> groupedFileds{};

  DescribeGroupedTagsResponseBody() {}

  explicit DescribeGroupedTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (groupedFileds) {
      vector<boost::any> temp1;
      for(auto item1:*groupedFileds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupedFileds"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("GroupedFileds") != m.end() && !m["GroupedFileds"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupedFileds"].type()) {
        vector<DescribeGroupedTagsResponseBodyGroupedFileds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupedFileds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGroupedTagsResponseBodyGroupedFileds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupedFileds = make_shared<vector<DescribeGroupedTagsResponseBodyGroupedFileds>>(expect1);
      }
    }
  }


  virtual ~DescribeGroupedTagsResponseBody() = default;
};
class DescribeGroupedTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeGroupedTagsResponseBody> body{};

  DescribeGroupedTagsResponse() {}

  explicit DescribeGroupedTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGroupedTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGroupedTagsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGroupedTagsResponse() = default;
};
class DescribeGroupedVulRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> type{};
  shared_ptr<string> uuids{};
  shared_ptr<string> aliasName{};
  shared_ptr<string> necessity{};
  shared_ptr<string> dealed{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> groupId{};
  shared_ptr<string> containerFieldName{};
  shared_ptr<string> containerFieldValue{};
  shared_ptr<string> targetType{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> minScore{};

  DescribeGroupedVulRequest() {}

  explicit DescribeGroupedVulRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (necessity) {
      res["Necessity"] = boost::any(*necessity);
    }
    if (dealed) {
      res["Dealed"] = boost::any(*dealed);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (containerFieldName) {
      res["ContainerFieldName"] = boost::any(*containerFieldName);
    }
    if (containerFieldValue) {
      res["ContainerFieldValue"] = boost::any(*containerFieldValue);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (minScore) {
      res["MinScore"] = boost::any(*minScore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("Necessity") != m.end() && !m["Necessity"].empty()) {
      necessity = make_shared<string>(boost::any_cast<string>(m["Necessity"]));
    }
    if (m.find("Dealed") != m.end() && !m["Dealed"].empty()) {
      dealed = make_shared<string>(boost::any_cast<string>(m["Dealed"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ContainerFieldName") != m.end() && !m["ContainerFieldName"].empty()) {
      containerFieldName = make_shared<string>(boost::any_cast<string>(m["ContainerFieldName"]));
    }
    if (m.find("ContainerFieldValue") != m.end() && !m["ContainerFieldValue"].empty()) {
      containerFieldValue = make_shared<string>(boost::any_cast<string>(m["ContainerFieldValue"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("MinScore") != m.end() && !m["MinScore"].empty()) {
      minScore = make_shared<long>(boost::any_cast<long>(m["MinScore"]));
    }
  }


  virtual ~DescribeGroupedVulRequest() = default;
};
class DescribeGroupedVulResponseBodyGroupedVulItems : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<long> nntfCount{};
  shared_ptr<long> handledCount{};
  shared_ptr<long> gmtLast{};
  shared_ptr<string> tags{};
  shared_ptr<long> laterCount{};
  shared_ptr<string> aliasName{};
  shared_ptr<string> name{};
  shared_ptr<long> totalFixCount{};
  shared_ptr<long> asapCount{};

  DescribeGroupedVulResponseBodyGroupedVulItems() {}

  explicit DescribeGroupedVulResponseBodyGroupedVulItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (nntfCount) {
      res["NntfCount"] = boost::any(*nntfCount);
    }
    if (handledCount) {
      res["HandledCount"] = boost::any(*handledCount);
    }
    if (gmtLast) {
      res["GmtLast"] = boost::any(*gmtLast);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (laterCount) {
      res["LaterCount"] = boost::any(*laterCount);
    }
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (totalFixCount) {
      res["TotalFixCount"] = boost::any(*totalFixCount);
    }
    if (asapCount) {
      res["AsapCount"] = boost::any(*asapCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("NntfCount") != m.end() && !m["NntfCount"].empty()) {
      nntfCount = make_shared<long>(boost::any_cast<long>(m["NntfCount"]));
    }
    if (m.find("HandledCount") != m.end() && !m["HandledCount"].empty()) {
      handledCount = make_shared<long>(boost::any_cast<long>(m["HandledCount"]));
    }
    if (m.find("GmtLast") != m.end() && !m["GmtLast"].empty()) {
      gmtLast = make_shared<long>(boost::any_cast<long>(m["GmtLast"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("LaterCount") != m.end() && !m["LaterCount"].empty()) {
      laterCount = make_shared<long>(boost::any_cast<long>(m["LaterCount"]));
    }
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TotalFixCount") != m.end() && !m["TotalFixCount"].empty()) {
      totalFixCount = make_shared<long>(boost::any_cast<long>(m["TotalFixCount"]));
    }
    if (m.find("AsapCount") != m.end() && !m["AsapCount"].empty()) {
      asapCount = make_shared<long>(boost::any_cast<long>(m["AsapCount"]));
    }
  }


  virtual ~DescribeGroupedVulResponseBodyGroupedVulItems() = default;
};
class DescribeGroupedVulResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribeGroupedVulResponseBodyGroupedVulItems>> groupedVulItems{};

  DescribeGroupedVulResponseBody() {}

  explicit DescribeGroupedVulResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (groupedVulItems) {
      vector<boost::any> temp1;
      for(auto item1:*groupedVulItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupedVulItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("GroupedVulItems") != m.end() && !m["GroupedVulItems"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupedVulItems"].type()) {
        vector<DescribeGroupedVulResponseBodyGroupedVulItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupedVulItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGroupedVulResponseBodyGroupedVulItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupedVulItems = make_shared<vector<DescribeGroupedVulResponseBodyGroupedVulItems>>(expect1);
      }
    }
  }


  virtual ~DescribeGroupedVulResponseBody() = default;
};
class DescribeGroupedVulResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeGroupedVulResponseBody> body{};

  DescribeGroupedVulResponse() {}

  explicit DescribeGroupedVulResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGroupedVulResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGroupedVulResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGroupedVulResponse() = default;
};
class DescribeHoneyPotAuthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> honeyPotCount{};
  shared_ptr<long> honeyPotAuthCount{};

  DescribeHoneyPotAuthResponseBody() {}

  explicit DescribeHoneyPotAuthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (honeyPotCount) {
      res["HoneyPotCount"] = boost::any(*honeyPotCount);
    }
    if (honeyPotAuthCount) {
      res["HoneyPotAuthCount"] = boost::any(*honeyPotAuthCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HoneyPotCount") != m.end() && !m["HoneyPotCount"].empty()) {
      honeyPotCount = make_shared<long>(boost::any_cast<long>(m["HoneyPotCount"]));
    }
    if (m.find("HoneyPotAuthCount") != m.end() && !m["HoneyPotAuthCount"].empty()) {
      honeyPotAuthCount = make_shared<long>(boost::any_cast<long>(m["HoneyPotAuthCount"]));
    }
  }


  virtual ~DescribeHoneyPotAuthResponseBody() = default;
};
class DescribeHoneyPotAuthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeHoneyPotAuthResponseBody> body{};

  DescribeHoneyPotAuthResponse() {}

  explicit DescribeHoneyPotAuthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHoneyPotAuthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHoneyPotAuthResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHoneyPotAuthResponse() = default;
};
class DescribeHoneyPotSuspStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> from{};
  shared_ptr<string> statisticsKeyType{};
  shared_ptr<long> statisticsDays{};

  DescribeHoneyPotSuspStatisticsRequest() {}

  explicit DescribeHoneyPotSuspStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (statisticsKeyType) {
      res["StatisticsKeyType"] = boost::any(*statisticsKeyType);
    }
    if (statisticsDays) {
      res["StatisticsDays"] = boost::any(*statisticsDays);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("StatisticsKeyType") != m.end() && !m["StatisticsKeyType"].empty()) {
      statisticsKeyType = make_shared<string>(boost::any_cast<string>(m["StatisticsKeyType"]));
    }
    if (m.find("StatisticsDays") != m.end() && !m["StatisticsDays"].empty()) {
      statisticsDays = make_shared<long>(boost::any_cast<long>(m["StatisticsDays"]));
    }
  }


  virtual ~DescribeHoneyPotSuspStatisticsRequest() = default;
};
class DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcName{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> count{};

  DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse() {}

  explicit DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse() = default;
};
class DescribeHoneyPotSuspStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse>> suspHoneyPotStatisticsResponse{};

  DescribeHoneyPotSuspStatisticsResponseBody() {}

  explicit DescribeHoneyPotSuspStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (suspHoneyPotStatisticsResponse) {
      vector<boost::any> temp1;
      for(auto item1:*suspHoneyPotStatisticsResponse){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SuspHoneyPotStatisticsResponse"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuspHoneyPotStatisticsResponse") != m.end() && !m["SuspHoneyPotStatisticsResponse"].empty()) {
      if (typeid(vector<boost::any>) == m["SuspHoneyPotStatisticsResponse"].type()) {
        vector<DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SuspHoneyPotStatisticsResponse"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        suspHoneyPotStatisticsResponse = make_shared<vector<DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse>>(expect1);
      }
    }
  }


  virtual ~DescribeHoneyPotSuspStatisticsResponseBody() = default;
};
class DescribeHoneyPotSuspStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeHoneyPotSuspStatisticsResponseBody> body{};

  DescribeHoneyPotSuspStatisticsResponse() {}

  explicit DescribeHoneyPotSuspStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHoneyPotSuspStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHoneyPotSuspStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHoneyPotSuspStatisticsResponse() = default;
};
class DescribeImageGroupedVulListRequest : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> groupId{};
  shared_ptr<string> cveId{};
  shared_ptr<string> uuids{};
  shared_ptr<string> name{};
  shared_ptr<string> aliasName{};
  shared_ptr<long> patchId{};
  shared_ptr<string> level{};
  shared_ptr<long> lastTsStart{};
  shared_ptr<long> lastTsEnd{};
  shared_ptr<string> statusList{};
  shared_ptr<string> orderBy{};
  shared_ptr<string> direction{};
  shared_ptr<string> necessity{};
  shared_ptr<string> dealed{};
  shared_ptr<long> createTsStart{};
  shared_ptr<long> createTsEnd{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> remark{};
  shared_ptr<string> searchTags{};
  shared_ptr<string> repoRegionId{};
  shared_ptr<string> repoInstanceId{};
  shared_ptr<string> repoId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> imageTag{};
  shared_ptr<string> imageDigest{};
  shared_ptr<string> imageLayer{};
  shared_ptr<string> lang{};

  DescribeImageGroupedVulListRequest() {}

  explicit DescribeImageGroupedVulListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (cveId) {
      res["CveId"] = boost::any(*cveId);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (patchId) {
      res["PatchId"] = boost::any(*patchId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (lastTsStart) {
      res["LastTsStart"] = boost::any(*lastTsStart);
    }
    if (lastTsEnd) {
      res["LastTsEnd"] = boost::any(*lastTsEnd);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (necessity) {
      res["Necessity"] = boost::any(*necessity);
    }
    if (dealed) {
      res["Dealed"] = boost::any(*dealed);
    }
    if (createTsStart) {
      res["CreateTsStart"] = boost::any(*createTsStart);
    }
    if (createTsEnd) {
      res["CreateTsEnd"] = boost::any(*createTsEnd);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (searchTags) {
      res["SearchTags"] = boost::any(*searchTags);
    }
    if (repoRegionId) {
      res["RepoRegionId"] = boost::any(*repoRegionId);
    }
    if (repoInstanceId) {
      res["RepoInstanceId"] = boost::any(*repoInstanceId);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (imageTag) {
      res["ImageTag"] = boost::any(*imageTag);
    }
    if (imageDigest) {
      res["ImageDigest"] = boost::any(*imageDigest);
    }
    if (imageLayer) {
      res["ImageLayer"] = boost::any(*imageLayer);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("CveId") != m.end() && !m["CveId"].empty()) {
      cveId = make_shared<string>(boost::any_cast<string>(m["CveId"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("PatchId") != m.end() && !m["PatchId"].empty()) {
      patchId = make_shared<long>(boost::any_cast<long>(m["PatchId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("LastTsStart") != m.end() && !m["LastTsStart"].empty()) {
      lastTsStart = make_shared<long>(boost::any_cast<long>(m["LastTsStart"]));
    }
    if (m.find("LastTsEnd") != m.end() && !m["LastTsEnd"].empty()) {
      lastTsEnd = make_shared<long>(boost::any_cast<long>(m["LastTsEnd"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      statusList = make_shared<string>(boost::any_cast<string>(m["StatusList"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("Necessity") != m.end() && !m["Necessity"].empty()) {
      necessity = make_shared<string>(boost::any_cast<string>(m["Necessity"]));
    }
    if (m.find("Dealed") != m.end() && !m["Dealed"].empty()) {
      dealed = make_shared<string>(boost::any_cast<string>(m["Dealed"]));
    }
    if (m.find("CreateTsStart") != m.end() && !m["CreateTsStart"].empty()) {
      createTsStart = make_shared<long>(boost::any_cast<long>(m["CreateTsStart"]));
    }
    if (m.find("CreateTsEnd") != m.end() && !m["CreateTsEnd"].empty()) {
      createTsEnd = make_shared<long>(boost::any_cast<long>(m["CreateTsEnd"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SearchTags") != m.end() && !m["SearchTags"].empty()) {
      searchTags = make_shared<string>(boost::any_cast<string>(m["SearchTags"]));
    }
    if (m.find("RepoRegionId") != m.end() && !m["RepoRegionId"].empty()) {
      repoRegionId = make_shared<string>(boost::any_cast<string>(m["RepoRegionId"]));
    }
    if (m.find("RepoInstanceId") != m.end() && !m["RepoInstanceId"].empty()) {
      repoInstanceId = make_shared<string>(boost::any_cast<string>(m["RepoInstanceId"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("ImageTag") != m.end() && !m["ImageTag"].empty()) {
      imageTag = make_shared<string>(boost::any_cast<string>(m["ImageTag"]));
    }
    if (m.find("ImageDigest") != m.end() && !m["ImageDigest"].empty()) {
      imageDigest = make_shared<string>(boost::any_cast<string>(m["ImageDigest"]));
    }
    if (m.find("ImageLayer") != m.end() && !m["ImageLayer"].empty()) {
      imageLayer = make_shared<string>(boost::any_cast<string>(m["ImageLayer"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeImageGroupedVulListRequest() = default;
};
class DescribeImageGroupedVulListResponseBodyGroupedVulItems : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<string> type{};
  shared_ptr<long> nntfCount{};
  shared_ptr<long> gmtLast{};
  shared_ptr<long> lastScanTime{};
  shared_ptr<string> tags{};
  shared_ptr<long> laterCount{};
  shared_ptr<string> aliasName{};
  shared_ptr<string> name{};
  shared_ptr<long> asapCount{};

  DescribeImageGroupedVulListResponseBodyGroupedVulItems() {}

  explicit DescribeImageGroupedVulListResponseBodyGroupedVulItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (nntfCount) {
      res["NntfCount"] = boost::any(*nntfCount);
    }
    if (gmtLast) {
      res["GmtLast"] = boost::any(*gmtLast);
    }
    if (lastScanTime) {
      res["LastScanTime"] = boost::any(*lastScanTime);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (laterCount) {
      res["LaterCount"] = boost::any(*laterCount);
    }
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (asapCount) {
      res["AsapCount"] = boost::any(*asapCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("NntfCount") != m.end() && !m["NntfCount"].empty()) {
      nntfCount = make_shared<long>(boost::any_cast<long>(m["NntfCount"]));
    }
    if (m.find("GmtLast") != m.end() && !m["GmtLast"].empty()) {
      gmtLast = make_shared<long>(boost::any_cast<long>(m["GmtLast"]));
    }
    if (m.find("LastScanTime") != m.end() && !m["LastScanTime"].empty()) {
      lastScanTime = make_shared<long>(boost::any_cast<long>(m["LastScanTime"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("LaterCount") != m.end() && !m["LaterCount"].empty()) {
      laterCount = make_shared<long>(boost::any_cast<long>(m["LaterCount"]));
    }
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("AsapCount") != m.end() && !m["AsapCount"].empty()) {
      asapCount = make_shared<long>(boost::any_cast<long>(m["AsapCount"]));
    }
  }


  virtual ~DescribeImageGroupedVulListResponseBodyGroupedVulItems() = default;
};
class DescribeImageGroupedVulListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribeImageGroupedVulListResponseBodyGroupedVulItems>> groupedVulItems{};

  DescribeImageGroupedVulListResponseBody() {}

  explicit DescribeImageGroupedVulListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (groupedVulItems) {
      vector<boost::any> temp1;
      for(auto item1:*groupedVulItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupedVulItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("GroupedVulItems") != m.end() && !m["GroupedVulItems"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupedVulItems"].type()) {
        vector<DescribeImageGroupedVulListResponseBodyGroupedVulItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupedVulItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageGroupedVulListResponseBodyGroupedVulItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupedVulItems = make_shared<vector<DescribeImageGroupedVulListResponseBodyGroupedVulItems>>(expect1);
      }
    }
  }


  virtual ~DescribeImageGroupedVulListResponseBody() = default;
};
class DescribeImageGroupedVulListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeImageGroupedVulListResponseBody> body{};

  DescribeImageGroupedVulListResponse() {}

  explicit DescribeImageGroupedVulListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageGroupedVulListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageGroupedVulListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageGroupedVulListResponse() = default;
};
class DescribeImageScanAuthCountResponseBodyImageScan : public Darabonba::Model {
public:
  shared_ptr<long> scanCount{};
  shared_ptr<long> imageScanCapacity{};
  shared_ptr<string> instanceId{};

  DescribeImageScanAuthCountResponseBodyImageScan() {}

  explicit DescribeImageScanAuthCountResponseBodyImageScan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scanCount) {
      res["ScanCount"] = boost::any(*scanCount);
    }
    if (imageScanCapacity) {
      res["ImageScanCapacity"] = boost::any(*imageScanCapacity);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScanCount") != m.end() && !m["ScanCount"].empty()) {
      scanCount = make_shared<long>(boost::any_cast<long>(m["ScanCount"]));
    }
    if (m.find("ImageScanCapacity") != m.end() && !m["ImageScanCapacity"].empty()) {
      imageScanCapacity = make_shared<long>(boost::any_cast<long>(m["ImageScanCapacity"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeImageScanAuthCountResponseBodyImageScan() = default;
};
class DescribeImageScanAuthCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeImageScanAuthCountResponseBodyImageScan> imageScan{};

  DescribeImageScanAuthCountResponseBody() {}

  explicit DescribeImageScanAuthCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (imageScan) {
      res["ImageScan"] = imageScan ? boost::any(imageScan->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ImageScan") != m.end() && !m["ImageScan"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageScan"].type()) {
        DescribeImageScanAuthCountResponseBodyImageScan model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageScan"]));
        imageScan = make_shared<DescribeImageScanAuthCountResponseBodyImageScan>(model1);
      }
    }
  }


  virtual ~DescribeImageScanAuthCountResponseBody() = default;
};
class DescribeImageScanAuthCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeImageScanAuthCountResponseBody> body{};

  DescribeImageScanAuthCountResponse() {}

  explicit DescribeImageScanAuthCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageScanAuthCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageScanAuthCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageScanAuthCountResponse() = default;
};
class DescribeImageStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> instanceCount{};
  shared_ptr<long> riskInstanceCount{};

  DescribeImageStatisticsResponseBody() {}

  explicit DescribeImageStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (riskInstanceCount) {
      res["RiskInstanceCount"] = boost::any(*riskInstanceCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("RiskInstanceCount") != m.end() && !m["RiskInstanceCount"].empty()) {
      riskInstanceCount = make_shared<long>(boost::any_cast<long>(m["RiskInstanceCount"]));
    }
  }


  virtual ~DescribeImageStatisticsResponseBody() = default;
};
class DescribeImageStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeImageStatisticsResponseBody> body{};

  DescribeImageStatisticsResponse() {}

  explicit DescribeImageStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageStatisticsResponse() = default;
};
class DescribeImageVulListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> type{};
  shared_ptr<string> uuids{};
  shared_ptr<string> name{};
  shared_ptr<string> aliasName{};
  shared_ptr<string> statusList{};
  shared_ptr<string> necessity{};
  shared_ptr<string> dealed{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> repoRegionId{};
  shared_ptr<string> repoInstanceId{};
  shared_ptr<string> repoId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> tag{};
  shared_ptr<string> digest{};
  shared_ptr<string> containerFieldName{};
  shared_ptr<string> containerFieldValue{};
  shared_ptr<string> targetType{};

  DescribeImageVulListRequest() {}

  explicit DescribeImageVulListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    if (necessity) {
      res["Necessity"] = boost::any(*necessity);
    }
    if (dealed) {
      res["Dealed"] = boost::any(*dealed);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (repoRegionId) {
      res["RepoRegionId"] = boost::any(*repoRegionId);
    }
    if (repoInstanceId) {
      res["RepoInstanceId"] = boost::any(*repoInstanceId);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (digest) {
      res["Digest"] = boost::any(*digest);
    }
    if (containerFieldName) {
      res["ContainerFieldName"] = boost::any(*containerFieldName);
    }
    if (containerFieldValue) {
      res["ContainerFieldValue"] = boost::any(*containerFieldValue);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      statusList = make_shared<string>(boost::any_cast<string>(m["StatusList"]));
    }
    if (m.find("Necessity") != m.end() && !m["Necessity"].empty()) {
      necessity = make_shared<string>(boost::any_cast<string>(m["Necessity"]));
    }
    if (m.find("Dealed") != m.end() && !m["Dealed"].empty()) {
      dealed = make_shared<string>(boost::any_cast<string>(m["Dealed"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RepoRegionId") != m.end() && !m["RepoRegionId"].empty()) {
      repoRegionId = make_shared<string>(boost::any_cast<string>(m["RepoRegionId"]));
    }
    if (m.find("RepoInstanceId") != m.end() && !m["RepoInstanceId"].empty()) {
      repoInstanceId = make_shared<string>(boost::any_cast<string>(m["RepoInstanceId"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Digest") != m.end() && !m["Digest"].empty()) {
      digest = make_shared<string>(boost::any_cast<string>(m["Digest"]));
    }
    if (m.find("ContainerFieldName") != m.end() && !m["ContainerFieldName"].empty()) {
      containerFieldName = make_shared<string>(boost::any_cast<string>(m["ContainerFieldName"]));
    }
    if (m.find("ContainerFieldValue") != m.end() && !m["ContainerFieldValue"].empty()) {
      containerFieldValue = make_shared<string>(boost::any_cast<string>(m["ContainerFieldValue"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~DescribeImageVulListRequest() = default;
};
class DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList : public Darabonba::Model {
public:
  shared_ptr<string> matchList{};
  shared_ptr<string> layer{};
  shared_ptr<string> fullVersion{};
  shared_ptr<string> version{};
  shared_ptr<string> matchDetail{};
  shared_ptr<string> path{};
  shared_ptr<string> name{};
  shared_ptr<string> updateCmd{};

  DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList() {}

  explicit DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchList) {
      res["MatchList"] = boost::any(*matchList);
    }
    if (layer) {
      res["Layer"] = boost::any(*layer);
    }
    if (fullVersion) {
      res["FullVersion"] = boost::any(*fullVersion);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (matchDetail) {
      res["MatchDetail"] = boost::any(*matchDetail);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (updateCmd) {
      res["UpdateCmd"] = boost::any(*updateCmd);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MatchList") != m.end() && !m["MatchList"].empty()) {
      matchList = make_shared<string>(boost::any_cast<string>(m["MatchList"]));
    }
    if (m.find("Layer") != m.end() && !m["Layer"].empty()) {
      layer = make_shared<string>(boost::any_cast<string>(m["Layer"]));
    }
    if (m.find("FullVersion") != m.end() && !m["FullVersion"].empty()) {
      fullVersion = make_shared<string>(boost::any_cast<string>(m["FullVersion"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("MatchDetail") != m.end() && !m["MatchDetail"].empty()) {
      matchDetail = make_shared<string>(boost::any_cast<string>(m["MatchDetail"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpdateCmd") != m.end() && !m["UpdateCmd"].empty()) {
      updateCmd = make_shared<string>(boost::any_cast<string>(m["UpdateCmd"]));
    }
  }


  virtual ~DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList() = default;
};
class DescribeImageVulListResponseBodyVulRecordsExtendContentJson : public Darabonba::Model {
public:
  shared_ptr<string> osRelease{};
  shared_ptr<string> os{};
  shared_ptr<vector<DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList>> rpmEntityList{};

  DescribeImageVulListResponseBodyVulRecordsExtendContentJson() {}

  explicit DescribeImageVulListResponseBodyVulRecordsExtendContentJson(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (osRelease) {
      res["OsRelease"] = boost::any(*osRelease);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (rpmEntityList) {
      vector<boost::any> temp1;
      for(auto item1:*rpmEntityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RpmEntityList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OsRelease") != m.end() && !m["OsRelease"].empty()) {
      osRelease = make_shared<string>(boost::any_cast<string>(m["OsRelease"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("RpmEntityList") != m.end() && !m["RpmEntityList"].empty()) {
      if (typeid(vector<boost::any>) == m["RpmEntityList"].type()) {
        vector<DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RpmEntityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rpmEntityList = make_shared<vector<DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList>>(expect1);
      }
    }
  }


  virtual ~DescribeImageVulListResponseBodyVulRecordsExtendContentJson() = default;
};
class DescribeImageVulListResponseBodyVulRecords : public Darabonba::Model {
public:
  shared_ptr<bool> canUpdate{};
  shared_ptr<string> type{};
  shared_ptr<long> status{};
  shared_ptr<long> modifyTs{};
  shared_ptr<string> imageDigest{};
  shared_ptr<long> primaryId{};
  shared_ptr<string> tag{};
  shared_ptr<string> related{};
  shared_ptr<long> firstTs{};
  shared_ptr<long> lastTs{};
  shared_ptr<string> necessity{};
  shared_ptr<string> uuid{};
  shared_ptr<string> aliasName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> layers{};
  shared_ptr<DescribeImageVulListResponseBodyVulRecordsExtendContentJson> extendContentJson{};

  DescribeImageVulListResponseBodyVulRecords() {}

  explicit DescribeImageVulListResponseBodyVulRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canUpdate) {
      res["CanUpdate"] = boost::any(*canUpdate);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (modifyTs) {
      res["ModifyTs"] = boost::any(*modifyTs);
    }
    if (imageDigest) {
      res["ImageDigest"] = boost::any(*imageDigest);
    }
    if (primaryId) {
      res["PrimaryId"] = boost::any(*primaryId);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (related) {
      res["Related"] = boost::any(*related);
    }
    if (firstTs) {
      res["FirstTs"] = boost::any(*firstTs);
    }
    if (lastTs) {
      res["LastTs"] = boost::any(*lastTs);
    }
    if (necessity) {
      res["Necessity"] = boost::any(*necessity);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (layers) {
      res["Layers"] = boost::any(*layers);
    }
    if (extendContentJson) {
      res["ExtendContentJson"] = extendContentJson ? boost::any(extendContentJson->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanUpdate") != m.end() && !m["CanUpdate"].empty()) {
      canUpdate = make_shared<bool>(boost::any_cast<bool>(m["CanUpdate"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("ModifyTs") != m.end() && !m["ModifyTs"].empty()) {
      modifyTs = make_shared<long>(boost::any_cast<long>(m["ModifyTs"]));
    }
    if (m.find("ImageDigest") != m.end() && !m["ImageDigest"].empty()) {
      imageDigest = make_shared<string>(boost::any_cast<string>(m["ImageDigest"]));
    }
    if (m.find("PrimaryId") != m.end() && !m["PrimaryId"].empty()) {
      primaryId = make_shared<long>(boost::any_cast<long>(m["PrimaryId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Related") != m.end() && !m["Related"].empty()) {
      related = make_shared<string>(boost::any_cast<string>(m["Related"]));
    }
    if (m.find("FirstTs") != m.end() && !m["FirstTs"].empty()) {
      firstTs = make_shared<long>(boost::any_cast<long>(m["FirstTs"]));
    }
    if (m.find("LastTs") != m.end() && !m["LastTs"].empty()) {
      lastTs = make_shared<long>(boost::any_cast<long>(m["LastTs"]));
    }
    if (m.find("Necessity") != m.end() && !m["Necessity"].empty()) {
      necessity = make_shared<string>(boost::any_cast<string>(m["Necessity"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Layers") != m.end() && !m["Layers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Layers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Layers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      layers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExtendContentJson") != m.end() && !m["ExtendContentJson"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtendContentJson"].type()) {
        DescribeImageVulListResponseBodyVulRecordsExtendContentJson model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtendContentJson"]));
        extendContentJson = make_shared<DescribeImageVulListResponseBodyVulRecordsExtendContentJson>(model1);
      }
    }
  }


  virtual ~DescribeImageVulListResponseBodyVulRecords() = default;
};
class DescribeImageVulListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribeImageVulListResponseBodyVulRecords>> vulRecords{};

  DescribeImageVulListResponseBody() {}

  explicit DescribeImageVulListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vulRecords) {
      vector<boost::any> temp1;
      for(auto item1:*vulRecords){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VulRecords"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VulRecords") != m.end() && !m["VulRecords"].empty()) {
      if (typeid(vector<boost::any>) == m["VulRecords"].type()) {
        vector<DescribeImageVulListResponseBodyVulRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VulRecords"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageVulListResponseBodyVulRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vulRecords = make_shared<vector<DescribeImageVulListResponseBodyVulRecords>>(expect1);
      }
    }
  }


  virtual ~DescribeImageVulListResponseBody() = default;
};
class DescribeImageVulListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeImageVulListResponseBody> body{};

  DescribeImageVulListResponse() {}

  explicit DescribeImageVulListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageVulListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageVulListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageVulListResponse() = default;
};
class DescribeInstallCaptchaRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};
  shared_ptr<string> deadline{};

  DescribeInstallCaptchaRequest() {}

  explicit DescribeInstallCaptchaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (deadline) {
      res["Deadline"] = boost::any(*deadline);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Deadline") != m.end() && !m["Deadline"].empty()) {
      deadline = make_shared<string>(boost::any_cast<string>(m["Deadline"]));
    }
  }


  virtual ~DescribeInstallCaptchaRequest() = default;
};
class DescribeInstallCaptchaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> deadline{};
  shared_ptr<string> requestId{};
  shared_ptr<string> captchaCode{};

  DescribeInstallCaptchaResponseBody() {}

  explicit DescribeInstallCaptchaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deadline) {
      res["Deadline"] = boost::any(*deadline);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (captchaCode) {
      res["CaptchaCode"] = boost::any(*captchaCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Deadline") != m.end() && !m["Deadline"].empty()) {
      deadline = make_shared<string>(boost::any_cast<string>(m["Deadline"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CaptchaCode") != m.end() && !m["CaptchaCode"].empty()) {
      captchaCode = make_shared<string>(boost::any_cast<string>(m["CaptchaCode"]));
    }
  }


  virtual ~DescribeInstallCaptchaResponseBody() = default;
};
class DescribeInstallCaptchaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstallCaptchaResponseBody> body{};

  DescribeInstallCaptchaResponse() {}

  explicit DescribeInstallCaptchaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstallCaptchaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstallCaptchaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstallCaptchaResponse() = default;
};
class DescribeInstanceAntiBruteForceRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<string>> uuidList{};

  DescribeInstanceAntiBruteForceRulesRequest() {}

  explicit DescribeInstanceAntiBruteForceRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstanceAntiBruteForceRulesRequest() = default;
};
class DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo() {}

  explicit DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo() = default;
};
class DescribeInstanceAntiBruteForceRulesResponseBodyRules : public Darabonba::Model {
public:
  shared_ptr<string> uuid{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};

  DescribeInstanceAntiBruteForceRulesResponseBodyRules() {}

  explicit DescribeInstanceAntiBruteForceRulesResponseBodyRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DescribeInstanceAntiBruteForceRulesResponseBodyRules() = default;
};
class DescribeInstanceAntiBruteForceRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribeInstanceAntiBruteForceRulesResponseBodyRules>> rules{};

  DescribeInstanceAntiBruteForceRulesResponseBody() {}

  explicit DescribeInstanceAntiBruteForceRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<DescribeInstanceAntiBruteForceRulesResponseBodyRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceAntiBruteForceRulesResponseBodyRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<DescribeInstanceAntiBruteForceRulesResponseBodyRules>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceAntiBruteForceRulesResponseBody() = default;
};
class DescribeInstanceAntiBruteForceRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceAntiBruteForceRulesResponseBody> body{};

  DescribeInstanceAntiBruteForceRulesResponse() {}

  explicit DescribeInstanceAntiBruteForceRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceAntiBruteForceRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceAntiBruteForceRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceAntiBruteForceRulesResponse() = default;
};
class DescribeInstanceStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};
  shared_ptr<string> uuid{};
  shared_ptr<string> from{};

  DescribeInstanceStatisticsRequest() {}

  explicit DescribeInstanceStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
  }


  virtual ~DescribeInstanceStatisticsRequest() = default;
};
class DescribeInstanceStatisticsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> account{};
  shared_ptr<long> appNum{};
  shared_ptr<long> scaNum{};
  shared_ptr<long> trojan{};
  shared_ptr<long> cveNum{};
  shared_ptr<long> emgNum{};
  shared_ptr<long> suspicious{};
  shared_ptr<long> cmsNum{};
  shared_ptr<string> uuid{};
  shared_ptr<long> vul{};
  shared_ptr<long> health{};
  shared_ptr<long> sysNum{};

  DescribeInstanceStatisticsResponseBodyData() {}

  explicit DescribeInstanceStatisticsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (appNum) {
      res["AppNum"] = boost::any(*appNum);
    }
    if (scaNum) {
      res["ScaNum"] = boost::any(*scaNum);
    }
    if (trojan) {
      res["Trojan"] = boost::any(*trojan);
    }
    if (cveNum) {
      res["CveNum"] = boost::any(*cveNum);
    }
    if (emgNum) {
      res["EmgNum"] = boost::any(*emgNum);
    }
    if (suspicious) {
      res["Suspicious"] = boost::any(*suspicious);
    }
    if (cmsNum) {
      res["CmsNum"] = boost::any(*cmsNum);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (vul) {
      res["Vul"] = boost::any(*vul);
    }
    if (health) {
      res["Health"] = boost::any(*health);
    }
    if (sysNum) {
      res["SysNum"] = boost::any(*sysNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<long>(boost::any_cast<long>(m["Account"]));
    }
    if (m.find("AppNum") != m.end() && !m["AppNum"].empty()) {
      appNum = make_shared<long>(boost::any_cast<long>(m["AppNum"]));
    }
    if (m.find("ScaNum") != m.end() && !m["ScaNum"].empty()) {
      scaNum = make_shared<long>(boost::any_cast<long>(m["ScaNum"]));
    }
    if (m.find("Trojan") != m.end() && !m["Trojan"].empty()) {
      trojan = make_shared<long>(boost::any_cast<long>(m["Trojan"]));
    }
    if (m.find("CveNum") != m.end() && !m["CveNum"].empty()) {
      cveNum = make_shared<long>(boost::any_cast<long>(m["CveNum"]));
    }
    if (m.find("EmgNum") != m.end() && !m["EmgNum"].empty()) {
      emgNum = make_shared<long>(boost::any_cast<long>(m["EmgNum"]));
    }
    if (m.find("Suspicious") != m.end() && !m["Suspicious"].empty()) {
      suspicious = make_shared<long>(boost::any_cast<long>(m["Suspicious"]));
    }
    if (m.find("CmsNum") != m.end() && !m["CmsNum"].empty()) {
      cmsNum = make_shared<long>(boost::any_cast<long>(m["CmsNum"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Vul") != m.end() && !m["Vul"].empty()) {
      vul = make_shared<long>(boost::any_cast<long>(m["Vul"]));
    }
    if (m.find("Health") != m.end() && !m["Health"].empty()) {
      health = make_shared<long>(boost::any_cast<long>(m["Health"]));
    }
    if (m.find("SysNum") != m.end() && !m["SysNum"].empty()) {
      sysNum = make_shared<long>(boost::any_cast<long>(m["SysNum"]));
    }
  }


  virtual ~DescribeInstanceStatisticsResponseBodyData() = default;
};
class DescribeInstanceStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeInstanceStatisticsResponseBodyData>> data{};

  DescribeInstanceStatisticsResponseBody() {}

  explicit DescribeInstanceStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeInstanceStatisticsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceStatisticsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeInstanceStatisticsResponseBodyData>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceStatisticsResponseBody() = default;
};
class DescribeInstanceStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeInstanceStatisticsResponseBody> body{};

  DescribeInstanceStatisticsResponse() {}

  explicit DescribeInstanceStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceStatisticsResponse() = default;
};
class DescribeIpInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> ip{};
  shared_ptr<string> field{};

  DescribeIpInfoRequest() {}

  explicit DescribeIpInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (field) {
      res["Field"] = boost::any(*field);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
  }


  virtual ~DescribeIpInfoRequest() = default;
};
class DescribeIpInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> gmtLastC2{};
  shared_ptr<string> natDayTrace{};
  shared_ptr<string> isProxy1d{};
  shared_ptr<string> gmtFirstMiningPool{};
  shared_ptr<string> province{};
  shared_ptr<string> isMaliciousLogin7d{};
  shared_ptr<string> totalDayCntTor{};
  shared_ptr<string> totalDayCntWebAttack{};
  shared_ptr<string> gmtLastProxy{};
  shared_ptr<string> isNat7d{};
  shared_ptr<string> requestId{};
  shared_ptr<string> isp{};
  shared_ptr<string> tags{};
  shared_ptr<string> proxyDayTrace{};
  shared_ptr<string> dayCnt7dWebAttack{};
  shared_ptr<string> gmtLastTor{};
  shared_ptr<string> webAttackDayTrace{};
  shared_ptr<string> gmtLastMaliciousLogin{};
  shared_ptr<string> gmtLastWebAttack{};
  shared_ptr<string> isWebAttack1d{};
  shared_ptr<string> dayCnt7dTor{};
  shared_ptr<string> isTor{};
  shared_ptr<string> isProxy7d{};
  shared_ptr<string> gmtLastMaliciousSource{};
  shared_ptr<string> rdns{};
  shared_ptr<string> isC21d{};
  shared_ptr<string> isWebAttack7d{};
  shared_ptr<string> isMaliciousSource1d{};
  shared_ptr<string> geo{};
  shared_ptr<string> isTor1d{};
  shared_ptr<string> isMaliciousLogin{};
  shared_ptr<string> gmtFirstC2{};
  shared_ptr<string> c2DayTrace{};
  shared_ptr<string> dayCnt30dWebAttack{};
  shared_ptr<string> maliciousSourceDayTrace{};
  shared_ptr<string> isMiningPool{};
  shared_ptr<string> isMaliciousSource7d{};
  shared_ptr<string> miningPoolDayTrace{};
  shared_ptr<string> isIdc{};
  shared_ptr<string> gmtLastMiningPool{};
  shared_ptr<string> isWebAttack30d{};
  shared_ptr<string> isTor7d{};
  shared_ptr<string> isNat{};
  shared_ptr<string> isNat1d{};
  shared_ptr<string> isMaliciousSource{};
  shared_ptr<string> torDayTrace{};
  shared_ptr<string> ip{};
  shared_ptr<string> isWebAttack{};
  shared_ptr<string> city{};
  shared_ptr<string> isC2{};
  shared_ptr<string> isMiningPool7d{};
  shared_ptr<string> maliciousScore{};
  shared_ptr<string> isMaliciousSource30d{};
  shared_ptr<string> gmtLastNat{};
  shared_ptr<string> idcName{};
  shared_ptr<string> isMiningPool1d{};
  shared_ptr<string> isMaliciousLogin1d{};
  shared_ptr<string> country{};
  shared_ptr<string> dayCnt30dTor{};
  shared_ptr<string> isProxy{};
  shared_ptr<string> maliciousLoginDayTrace{};
  shared_ptr<string> isC27d{};

  DescribeIpInfoResponseBody() {}

  explicit DescribeIpInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtLastC2) {
      res["gmt_last_c2"] = boost::any(*gmtLastC2);
    }
    if (natDayTrace) {
      res["nat_day_trace"] = boost::any(*natDayTrace);
    }
    if (isProxy1d) {
      res["is_proxy_1d"] = boost::any(*isProxy1d);
    }
    if (gmtFirstMiningPool) {
      res["gmt_first_mining_pool"] = boost::any(*gmtFirstMiningPool);
    }
    if (province) {
      res["province"] = boost::any(*province);
    }
    if (isMaliciousLogin7d) {
      res["is_malicious_login_7d"] = boost::any(*isMaliciousLogin7d);
    }
    if (totalDayCntTor) {
      res["total_day_cnt_tor"] = boost::any(*totalDayCntTor);
    }
    if (totalDayCntWebAttack) {
      res["total_day_cnt_web_attack"] = boost::any(*totalDayCntWebAttack);
    }
    if (gmtLastProxy) {
      res["gmt_last_proxy"] = boost::any(*gmtLastProxy);
    }
    if (isNat7d) {
      res["is_nat_7d"] = boost::any(*isNat7d);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (isp) {
      res["isp"] = boost::any(*isp);
    }
    if (tags) {
      res["tags"] = boost::any(*tags);
    }
    if (proxyDayTrace) {
      res["proxy_day_trace"] = boost::any(*proxyDayTrace);
    }
    if (dayCnt7dWebAttack) {
      res["day_cnt_7d_web_attack"] = boost::any(*dayCnt7dWebAttack);
    }
    if (gmtLastTor) {
      res["gmt_last_tor"] = boost::any(*gmtLastTor);
    }
    if (webAttackDayTrace) {
      res["web_attack_day_trace"] = boost::any(*webAttackDayTrace);
    }
    if (gmtLastMaliciousLogin) {
      res["gmt_last_malicious_login"] = boost::any(*gmtLastMaliciousLogin);
    }
    if (gmtLastWebAttack) {
      res["gmt_last_web_attack"] = boost::any(*gmtLastWebAttack);
    }
    if (isWebAttack1d) {
      res["is_web_attack_1d"] = boost::any(*isWebAttack1d);
    }
    if (dayCnt7dTor) {
      res["day_cnt_7d_tor"] = boost::any(*dayCnt7dTor);
    }
    if (isTor) {
      res["is_tor"] = boost::any(*isTor);
    }
    if (isProxy7d) {
      res["is_proxy_7d"] = boost::any(*isProxy7d);
    }
    if (gmtLastMaliciousSource) {
      res["gmt_last_malicious_source"] = boost::any(*gmtLastMaliciousSource);
    }
    if (rdns) {
      res["rdns"] = boost::any(*rdns);
    }
    if (isC21d) {
      res["is_c2_1d"] = boost::any(*isC21d);
    }
    if (isWebAttack7d) {
      res["is_web_attack_7d"] = boost::any(*isWebAttack7d);
    }
    if (isMaliciousSource1d) {
      res["is_malicious_source_1d"] = boost::any(*isMaliciousSource1d);
    }
    if (geo) {
      res["geo"] = boost::any(*geo);
    }
    if (isTor1d) {
      res["is_tor_1d"] = boost::any(*isTor1d);
    }
    if (isMaliciousLogin) {
      res["is_malicious_login"] = boost::any(*isMaliciousLogin);
    }
    if (gmtFirstC2) {
      res["gmt_first_c2"] = boost::any(*gmtFirstC2);
    }
    if (c2DayTrace) {
      res["c2_day_trace"] = boost::any(*c2DayTrace);
    }
    if (dayCnt30dWebAttack) {
      res["day_cnt_30d_web_attack"] = boost::any(*dayCnt30dWebAttack);
    }
    if (maliciousSourceDayTrace) {
      res["malicious_source_day_trace"] = boost::any(*maliciousSourceDayTrace);
    }
    if (isMiningPool) {
      res["is_mining_pool"] = boost::any(*isMiningPool);
    }
    if (isMaliciousSource7d) {
      res["is_malicious_source_7d"] = boost::any(*isMaliciousSource7d);
    }
    if (miningPoolDayTrace) {
      res["mining_pool_day_trace"] = boost::any(*miningPoolDayTrace);
    }
    if (isIdc) {
      res["is_idc"] = boost::any(*isIdc);
    }
    if (gmtLastMiningPool) {
      res["gmt_last_mining_pool"] = boost::any(*gmtLastMiningPool);
    }
    if (isWebAttack30d) {
      res["is_web_attack_30d"] = boost::any(*isWebAttack30d);
    }
    if (isTor7d) {
      res["is_tor_7d"] = boost::any(*isTor7d);
    }
    if (isNat) {
      res["is_nat"] = boost::any(*isNat);
    }
    if (isNat1d) {
      res["is_nat_1d"] = boost::any(*isNat1d);
    }
    if (isMaliciousSource) {
      res["is_malicious_source"] = boost::any(*isMaliciousSource);
    }
    if (torDayTrace) {
      res["tor_day_trace"] = boost::any(*torDayTrace);
    }
    if (ip) {
      res["ip"] = boost::any(*ip);
    }
    if (isWebAttack) {
      res["is_web_attack"] = boost::any(*isWebAttack);
    }
    if (city) {
      res["city"] = boost::any(*city);
    }
    if (isC2) {
      res["is_c2"] = boost::any(*isC2);
    }
    if (isMiningPool7d) {
      res["is_mining_pool_7d"] = boost::any(*isMiningPool7d);
    }
    if (maliciousScore) {
      res["malicious_score"] = boost::any(*maliciousScore);
    }
    if (isMaliciousSource30d) {
      res["is_malicious_source_30d"] = boost::any(*isMaliciousSource30d);
    }
    if (gmtLastNat) {
      res["gmt_last_nat"] = boost::any(*gmtLastNat);
    }
    if (idcName) {
      res["idc_name"] = boost::any(*idcName);
    }
    if (isMiningPool1d) {
      res["is_mining_pool_1d"] = boost::any(*isMiningPool1d);
    }
    if (isMaliciousLogin1d) {
      res["is_malicious_login_1d"] = boost::any(*isMaliciousLogin1d);
    }
    if (country) {
      res["country"] = boost::any(*country);
    }
    if (dayCnt30dTor) {
      res["day_cnt_30d_tor"] = boost::any(*dayCnt30dTor);
    }
    if (isProxy) {
      res["is_proxy"] = boost::any(*isProxy);
    }
    if (maliciousLoginDayTrace) {
      res["malicious_login_day_trace"] = boost::any(*maliciousLoginDayTrace);
    }
    if (isC27d) {
      res["is_c2_7d"] = boost::any(*isC27d);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmt_last_c2") != m.end() && !m["gmt_last_c2"].empty()) {
      gmtLastC2 = make_shared<string>(boost::any_cast<string>(m["gmt_last_c2"]));
    }
    if (m.find("nat_day_trace") != m.end() && !m["nat_day_trace"].empty()) {
      natDayTrace = make_shared<string>(boost::any_cast<string>(m["nat_day_trace"]));
    }
    if (m.find("is_proxy_1d") != m.end() && !m["is_proxy_1d"].empty()) {
      isProxy1d = make_shared<string>(boost::any_cast<string>(m["is_proxy_1d"]));
    }
    if (m.find("gmt_first_mining_pool") != m.end() && !m["gmt_first_mining_pool"].empty()) {
      gmtFirstMiningPool = make_shared<string>(boost::any_cast<string>(m["gmt_first_mining_pool"]));
    }
    if (m.find("province") != m.end() && !m["province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["province"]));
    }
    if (m.find("is_malicious_login_7d") != m.end() && !m["is_malicious_login_7d"].empty()) {
      isMaliciousLogin7d = make_shared<string>(boost::any_cast<string>(m["is_malicious_login_7d"]));
    }
    if (m.find("total_day_cnt_tor") != m.end() && !m["total_day_cnt_tor"].empty()) {
      totalDayCntTor = make_shared<string>(boost::any_cast<string>(m["total_day_cnt_tor"]));
    }
    if (m.find("total_day_cnt_web_attack") != m.end() && !m["total_day_cnt_web_attack"].empty()) {
      totalDayCntWebAttack = make_shared<string>(boost::any_cast<string>(m["total_day_cnt_web_attack"]));
    }
    if (m.find("gmt_last_proxy") != m.end() && !m["gmt_last_proxy"].empty()) {
      gmtLastProxy = make_shared<string>(boost::any_cast<string>(m["gmt_last_proxy"]));
    }
    if (m.find("is_nat_7d") != m.end() && !m["is_nat_7d"].empty()) {
      isNat7d = make_shared<string>(boost::any_cast<string>(m["is_nat_7d"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("isp") != m.end() && !m["isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["isp"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["tags"]));
    }
    if (m.find("proxy_day_trace") != m.end() && !m["proxy_day_trace"].empty()) {
      proxyDayTrace = make_shared<string>(boost::any_cast<string>(m["proxy_day_trace"]));
    }
    if (m.find("day_cnt_7d_web_attack") != m.end() && !m["day_cnt_7d_web_attack"].empty()) {
      dayCnt7dWebAttack = make_shared<string>(boost::any_cast<string>(m["day_cnt_7d_web_attack"]));
    }
    if (m.find("gmt_last_tor") != m.end() && !m["gmt_last_tor"].empty()) {
      gmtLastTor = make_shared<string>(boost::any_cast<string>(m["gmt_last_tor"]));
    }
    if (m.find("web_attack_day_trace") != m.end() && !m["web_attack_day_trace"].empty()) {
      webAttackDayTrace = make_shared<string>(boost::any_cast<string>(m["web_attack_day_trace"]));
    }
    if (m.find("gmt_last_malicious_login") != m.end() && !m["gmt_last_malicious_login"].empty()) {
      gmtLastMaliciousLogin = make_shared<string>(boost::any_cast<string>(m["gmt_last_malicious_login"]));
    }
    if (m.find("gmt_last_web_attack") != m.end() && !m["gmt_last_web_attack"].empty()) {
      gmtLastWebAttack = make_shared<string>(boost::any_cast<string>(m["gmt_last_web_attack"]));
    }
    if (m.find("is_web_attack_1d") != m.end() && !m["is_web_attack_1d"].empty()) {
      isWebAttack1d = make_shared<string>(boost::any_cast<string>(m["is_web_attack_1d"]));
    }
    if (m.find("day_cnt_7d_tor") != m.end() && !m["day_cnt_7d_tor"].empty()) {
      dayCnt7dTor = make_shared<string>(boost::any_cast<string>(m["day_cnt_7d_tor"]));
    }
    if (m.find("is_tor") != m.end() && !m["is_tor"].empty()) {
      isTor = make_shared<string>(boost::any_cast<string>(m["is_tor"]));
    }
    if (m.find("is_proxy_7d") != m.end() && !m["is_proxy_7d"].empty()) {
      isProxy7d = make_shared<string>(boost::any_cast<string>(m["is_proxy_7d"]));
    }
    if (m.find("gmt_last_malicious_source") != m.end() && !m["gmt_last_malicious_source"].empty()) {
      gmtLastMaliciousSource = make_shared<string>(boost::any_cast<string>(m["gmt_last_malicious_source"]));
    }
    if (m.find("rdns") != m.end() && !m["rdns"].empty()) {
      rdns = make_shared<string>(boost::any_cast<string>(m["rdns"]));
    }
    if (m.find("is_c2_1d") != m.end() && !m["is_c2_1d"].empty()) {
      isC21d = make_shared<string>(boost::any_cast<string>(m["is_c2_1d"]));
    }
    if (m.find("is_web_attack_7d") != m.end() && !m["is_web_attack_7d"].empty()) {
      isWebAttack7d = make_shared<string>(boost::any_cast<string>(m["is_web_attack_7d"]));
    }
    if (m.find("is_malicious_source_1d") != m.end() && !m["is_malicious_source_1d"].empty()) {
      isMaliciousSource1d = make_shared<string>(boost::any_cast<string>(m["is_malicious_source_1d"]));
    }
    if (m.find("geo") != m.end() && !m["geo"].empty()) {
      geo = make_shared<string>(boost::any_cast<string>(m["geo"]));
    }
    if (m.find("is_tor_1d") != m.end() && !m["is_tor_1d"].empty()) {
      isTor1d = make_shared<string>(boost::any_cast<string>(m["is_tor_1d"]));
    }
    if (m.find("is_malicious_login") != m.end() && !m["is_malicious_login"].empty()) {
      isMaliciousLogin = make_shared<string>(boost::any_cast<string>(m["is_malicious_login"]));
    }
    if (m.find("gmt_first_c2") != m.end() && !m["gmt_first_c2"].empty()) {
      gmtFirstC2 = make_shared<string>(boost::any_cast<string>(m["gmt_first_c2"]));
    }
    if (m.find("c2_day_trace") != m.end() && !m["c2_day_trace"].empty()) {
      c2DayTrace = make_shared<string>(boost::any_cast<string>(m["c2_day_trace"]));
    }
    if (m.find("day_cnt_30d_web_attack") != m.end() && !m["day_cnt_30d_web_attack"].empty()) {
      dayCnt30dWebAttack = make_shared<string>(boost::any_cast<string>(m["day_cnt_30d_web_attack"]));
    }
    if (m.find("malicious_source_day_trace") != m.end() && !m["malicious_source_day_trace"].empty()) {
      maliciousSourceDayTrace = make_shared<string>(boost::any_cast<string>(m["malicious_source_day_trace"]));
    }
    if (m.find("is_mining_pool") != m.end() && !m["is_mining_pool"].empty()) {
      isMiningPool = make_shared<string>(boost::any_cast<string>(m["is_mining_pool"]));
    }
    if (m.find("is_malicious_source_7d") != m.end() && !m["is_malicious_source_7d"].empty()) {
      isMaliciousSource7d = make_shared<string>(boost::any_cast<string>(m["is_malicious_source_7d"]));
    }
    if (m.find("mining_pool_day_trace") != m.end() && !m["mining_pool_day_trace"].empty()) {
      miningPoolDayTrace = make_shared<string>(boost::any_cast<string>(m["mining_pool_day_trace"]));
    }
    if (m.find("is_idc") != m.end() && !m["is_idc"].empty()) {
      isIdc = make_shared<string>(boost::any_cast<string>(m["is_idc"]));
    }
    if (m.find("gmt_last_mining_pool") != m.end() && !m["gmt_last_mining_pool"].empty()) {
      gmtLastMiningPool = make_shared<string>(boost::any_cast<string>(m["gmt_last_mining_pool"]));
    }
    if (m.find("is_web_attack_30d") != m.end() && !m["is_web_attack_30d"].empty()) {
      isWebAttack30d = make_shared<string>(boost::any_cast<string>(m["is_web_attack_30d"]));
    }
    if (m.find("is_tor_7d") != m.end() && !m["is_tor_7d"].empty()) {
      isTor7d = make_shared<string>(boost::any_cast<string>(m["is_tor_7d"]));
    }
    if (m.find("is_nat") != m.end() && !m["is_nat"].empty()) {
      isNat = make_shared<string>(boost::any_cast<string>(m["is_nat"]));
    }
    if (m.find("is_nat_1d") != m.end() && !m["is_nat_1d"].empty()) {
      isNat1d = make_shared<string>(boost::any_cast<string>(m["is_nat_1d"]));
    }
    if (m.find("is_malicious_source") != m.end() && !m["is_malicious_source"].empty()) {
      isMaliciousSource = make_shared<string>(boost::any_cast<string>(m["is_malicious_source"]));
    }
    if (m.find("tor_day_trace") != m.end() && !m["tor_day_trace"].empty()) {
      torDayTrace = make_shared<string>(boost::any_cast<string>(m["tor_day_trace"]));
    }
    if (m.find("ip") != m.end() && !m["ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["ip"]));
    }
    if (m.find("is_web_attack") != m.end() && !m["is_web_attack"].empty()) {
      isWebAttack = make_shared<string>(boost::any_cast<string>(m["is_web_attack"]));
    }
    if (m.find("city") != m.end() && !m["city"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["city"]));
    }
    if (m.find("is_c2") != m.end() && !m["is_c2"].empty()) {
      isC2 = make_shared<string>(boost::any_cast<string>(m["is_c2"]));
    }
    if (m.find("is_mining_pool_7d") != m.end() && !m["is_mining_pool_7d"].empty()) {
      isMiningPool7d = make_shared<string>(boost::any_cast<string>(m["is_mining_pool_7d"]));
    }
    if (m.find("malicious_score") != m.end() && !m["malicious_score"].empty()) {
      maliciousScore = make_shared<string>(boost::any_cast<string>(m["malicious_score"]));
    }
    if (m.find("is_malicious_source_30d") != m.end() && !m["is_malicious_source_30d"].empty()) {
      isMaliciousSource30d = make_shared<string>(boost::any_cast<string>(m["is_malicious_source_30d"]));
    }
    if (m.find("gmt_last_nat") != m.end() && !m["gmt_last_nat"].empty()) {
      gmtLastNat = make_shared<string>(boost::any_cast<string>(m["gmt_last_nat"]));
    }
    if (m.find("idc_name") != m.end() && !m["idc_name"].empty()) {
      idcName = make_shared<string>(boost::any_cast<string>(m["idc_name"]));
    }
    if (m.find("is_mining_pool_1d") != m.end() && !m["is_mining_pool_1d"].empty()) {
      isMiningPool1d = make_shared<string>(boost::any_cast<string>(m["is_mining_pool_1d"]));
    }
    if (m.find("is_malicious_login_1d") != m.end() && !m["is_malicious_login_1d"].empty()) {
      isMaliciousLogin1d = make_shared<string>(boost::any_cast<string>(m["is_malicious_login_1d"]));
    }
    if (m.find("country") != m.end() && !m["country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["country"]));
    }
    if (m.find("day_cnt_30d_tor") != m.end() && !m["day_cnt_30d_tor"].empty()) {
      dayCnt30dTor = make_shared<string>(boost::any_cast<string>(m["day_cnt_30d_tor"]));
    }
    if (m.find("is_proxy") != m.end() && !m["is_proxy"].empty()) {
      isProxy = make_shared<string>(boost::any_cast<string>(m["is_proxy"]));
    }
    if (m.find("malicious_login_day_trace") != m.end() && !m["malicious_login_day_trace"].empty()) {
      maliciousLoginDayTrace = make_shared<string>(boost::any_cast<string>(m["malicious_login_day_trace"]));
    }
    if (m.find("is_c2_7d") != m.end() && !m["is_c2_7d"].empty()) {
      isC27d = make_shared<string>(boost::any_cast<string>(m["is_c2_7d"]));
    }
  }


  virtual ~DescribeIpInfoResponseBody() = default;
};
class DescribeIpInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeIpInfoResponseBody> body{};

  DescribeIpInfoResponse() {}

  explicit DescribeIpInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIpInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIpInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIpInfoResponse() = default;
};
class DescribeLogstoreStorageRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> from{};

  DescribeLogstoreStorageRequest() {}

  explicit DescribeLogstoreStorageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
  }


  virtual ~DescribeLogstoreStorageRequest() = default;
};
class DescribeLogstoreStorageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> used{};
  shared_ptr<long> ttl{};
  shared_ptr<string> logstore{};
  shared_ptr<string> requestId{};
  shared_ptr<long> preserve{};

  DescribeLogstoreStorageResponseBody() {}

  explicit DescribeLogstoreStorageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (used) {
      res["Used"] = boost::any(*used);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (preserve) {
      res["Preserve"] = boost::any(*preserve);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Preserve") != m.end() && !m["Preserve"].empty()) {
      preserve = make_shared<long>(boost::any_cast<long>(m["Preserve"]));
    }
  }


  virtual ~DescribeLogstoreStorageResponseBody() = default;
};
class DescribeLogstoreStorageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeLogstoreStorageResponseBody> body{};

  DescribeLogstoreStorageResponse() {}

  explicit DescribeLogstoreStorageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLogstoreStorageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLogstoreStorageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLogstoreStorageResponse() = default;
};
class DescribeModuleConfigResponseBodyModuleConfigListItems : public Darabonba::Model {
public:
  shared_ptr<string> uuid{};
  shared_ptr<long> groupId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> region{};
  shared_ptr<string> ip{};
  shared_ptr<string> instanceId{};

  DescribeModuleConfigResponseBodyModuleConfigListItems() {}

  explicit DescribeModuleConfigResponseBodyModuleConfigListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeModuleConfigResponseBodyModuleConfigListItems() = default;
};
class DescribeModuleConfigResponseBodyModuleConfigList : public Darabonba::Model {
public:
  shared_ptr<string> moduleName{};
  shared_ptr<string> configName{};
  shared_ptr<vector<DescribeModuleConfigResponseBodyModuleConfigListItems>> items{};

  DescribeModuleConfigResponseBodyModuleConfigList() {}

  explicit DescribeModuleConfigResponseBodyModuleConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (configName) {
      res["ConfigName"] = boost::any(*configName);
    }
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("ConfigName") != m.end() && !m["ConfigName"].empty()) {
      configName = make_shared<string>(boost::any_cast<string>(m["ConfigName"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<DescribeModuleConfigResponseBodyModuleConfigListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeModuleConfigResponseBodyModuleConfigListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<DescribeModuleConfigResponseBodyModuleConfigListItems>>(expect1);
      }
    }
  }


  virtual ~DescribeModuleConfigResponseBodyModuleConfigList() = default;
};
class DescribeModuleConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeModuleConfigResponseBodyModuleConfigList>> moduleConfigList{};

  DescribeModuleConfigResponseBody() {}

  explicit DescribeModuleConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (moduleConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*moduleConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ModuleConfigList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("ModuleConfigList") != m.end() && !m["ModuleConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["ModuleConfigList"].type()) {
        vector<DescribeModuleConfigResponseBodyModuleConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ModuleConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeModuleConfigResponseBodyModuleConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        moduleConfigList = make_shared<vector<DescribeModuleConfigResponseBodyModuleConfigList>>(expect1);
      }
    }
  }


  virtual ~DescribeModuleConfigResponseBody() = default;
};
class DescribeModuleConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeModuleConfigResponseBody> body{};

  DescribeModuleConfigResponse() {}

  explicit DescribeModuleConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeModuleConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeModuleConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeModuleConfigResponse() = default;
};
class DescribeNoticeConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};

  DescribeNoticeConfigRequest() {}

  explicit DescribeNoticeConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeNoticeConfigRequest() = default;
};
class DescribeNoticeConfigResponseBodyNoticeConfigList : public Darabonba::Model {
public:
  shared_ptr<long> timeLimit{};
  shared_ptr<long> aliUid{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> project{};
  shared_ptr<long> route{};

  DescribeNoticeConfigResponseBodyNoticeConfigList() {}

  explicit DescribeNoticeConfigResponseBodyNoticeConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeLimit) {
      res["TimeLimit"] = boost::any(*timeLimit);
    }
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (route) {
      res["Route"] = boost::any(*route);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeLimit") != m.end() && !m["TimeLimit"].empty()) {
      timeLimit = make_shared<long>(boost::any_cast<long>(m["TimeLimit"]));
    }
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<long>(boost::any_cast<long>(m["AliUid"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Route") != m.end() && !m["Route"].empty()) {
      route = make_shared<long>(boost::any_cast<long>(m["Route"]));
    }
  }


  virtual ~DescribeNoticeConfigResponseBodyNoticeConfigList() = default;
};
class DescribeNoticeConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeNoticeConfigResponseBodyNoticeConfigList>> noticeConfigList{};

  DescribeNoticeConfigResponseBody() {}

  explicit DescribeNoticeConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (noticeConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*noticeConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NoticeConfigList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NoticeConfigList") != m.end() && !m["NoticeConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["NoticeConfigList"].type()) {
        vector<DescribeNoticeConfigResponseBodyNoticeConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NoticeConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNoticeConfigResponseBodyNoticeConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        noticeConfigList = make_shared<vector<DescribeNoticeConfigResponseBodyNoticeConfigList>>(expect1);
      }
    }
  }


  virtual ~DescribeNoticeConfigResponseBody() = default;
};
class DescribeNoticeConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeNoticeConfigResponseBody> body{};

  DescribeNoticeConfigResponse() {}

  explicit DescribeNoticeConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNoticeConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNoticeConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNoticeConfigResponse() = default;
};
class DescribePropertyCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> uuidList{};

  DescribePropertyCountRequest() {}

  explicit DescribePropertyCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      uuidList = make_shared<string>(boost::any_cast<string>(m["UuidList"]));
    }
  }


  virtual ~DescribePropertyCountRequest() = default;
};
class DescribePropertyCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> process{};
  shared_ptr<long> autoRun{};
  shared_ptr<string> requestId{};
  shared_ptr<long> user{};
  shared_ptr<long> software{};
  shared_ptr<long> cron{};
  shared_ptr<long> port{};
  shared_ptr<long> sca{};

  DescribePropertyCountResponseBody() {}

  explicit DescribePropertyCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (process) {
      res["Process"] = boost::any(*process);
    }
    if (autoRun) {
      res["AutoRun"] = boost::any(*autoRun);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    if (software) {
      res["Software"] = boost::any(*software);
    }
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (sca) {
      res["Sca"] = boost::any(*sca);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Process") != m.end() && !m["Process"].empty()) {
      process = make_shared<long>(boost::any_cast<long>(m["Process"]));
    }
    if (m.find("AutoRun") != m.end() && !m["AutoRun"].empty()) {
      autoRun = make_shared<long>(boost::any_cast<long>(m["AutoRun"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<long>(boost::any_cast<long>(m["User"]));
    }
    if (m.find("Software") != m.end() && !m["Software"].empty()) {
      software = make_shared<long>(boost::any_cast<long>(m["Software"]));
    }
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<long>(boost::any_cast<long>(m["Cron"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Sca") != m.end() && !m["Sca"].empty()) {
      sca = make_shared<long>(boost::any_cast<long>(m["Sca"]));
    }
  }


  virtual ~DescribePropertyCountResponseBody() = default;
};
class DescribePropertyCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePropertyCountResponseBody> body{};

  DescribePropertyCountResponse() {}

  explicit DescribePropertyCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyCountResponse() = default;
};
class DescribePropertyCronDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> remark{};
  shared_ptr<string> source{};
  shared_ptr<string> user{};
  shared_ptr<string> uuid{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  DescribePropertyCronDetailRequest() {}

  explicit DescribePropertyCronDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribePropertyCronDetailRequest() = default;
};
class DescribePropertyCronDetailResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribePropertyCronDetailResponseBodyPageInfo() {}

  explicit DescribePropertyCronDetailResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribePropertyCronDetailResponseBodyPageInfo() = default;
};
class DescribePropertyCronDetailResponseBodyPropertys : public Darabonba::Model {
public:
  shared_ptr<string> create{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> ip{};
  shared_ptr<string> user{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> source{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> cmd{};
  shared_ptr<string> period{};
  shared_ptr<string> uuid{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> md5{};
  shared_ptr<long> createTimestamp{};

  DescribePropertyCronDetailResponseBodyPropertys() {}

  explicit DescribePropertyCronDetailResponseBodyPropertys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (create) {
      res["Create"] = boost::any(*create);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (cmd) {
      res["Cmd"] = boost::any(*cmd);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Create") != m.end() && !m["Create"].empty()) {
      create = make_shared<string>(boost::any_cast<string>(m["Create"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Cmd") != m.end() && !m["Cmd"].empty()) {
      cmd = make_shared<string>(boost::any_cast<string>(m["Cmd"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
  }


  virtual ~DescribePropertyCronDetailResponseBodyPropertys() = default;
};
class DescribePropertyCronDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribePropertyCronDetailResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribePropertyCronDetailResponseBodyPropertys>> propertys{};

  DescribePropertyCronDetailResponseBody() {}

  explicit DescribePropertyCronDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertys) {
      vector<boost::any> temp1;
      for(auto item1:*propertys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Propertys"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribePropertyCronDetailResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribePropertyCronDetailResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("Propertys") != m.end() && !m["Propertys"].empty()) {
      if (typeid(vector<boost::any>) == m["Propertys"].type()) {
        vector<DescribePropertyCronDetailResponseBodyPropertys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Propertys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertyCronDetailResponseBodyPropertys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertys = make_shared<vector<DescribePropertyCronDetailResponseBodyPropertys>>(expect1);
      }
    }
  }


  virtual ~DescribePropertyCronDetailResponseBody() = default;
};
class DescribePropertyCronDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePropertyCronDetailResponseBody> body{};

  DescribePropertyCronDetailResponse() {}

  explicit DescribePropertyCronDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyCronDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyCronDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyCronDetailResponse() = default;
};
class DescribePropertyPortDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> remark{};
  shared_ptr<string> port{};
  shared_ptr<string> procName{};
  shared_ptr<string> uuid{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  DescribePropertyPortDetailRequest() {}

  explicit DescribePropertyPortDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (procName) {
      res["ProcName"] = boost::any(*procName);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("ProcName") != m.end() && !m["ProcName"].empty()) {
      procName = make_shared<string>(boost::any_cast<string>(m["ProcName"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribePropertyPortDetailRequest() = default;
};
class DescribePropertyPortDetailResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribePropertyPortDetailResponseBodyPageInfo() {}

  explicit DescribePropertyPortDetailResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribePropertyPortDetailResponseBodyPageInfo() = default;
};
class DescribePropertyPortDetailResponseBodyPropertys : public Darabonba::Model {
public:
  shared_ptr<string> create{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> bindIp{};
  shared_ptr<string> ip{};
  shared_ptr<string> procName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> port{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> uuid{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> proto{};
  shared_ptr<long> createTimestamp{};

  DescribePropertyPortDetailResponseBodyPropertys() {}

  explicit DescribePropertyPortDetailResponseBodyPropertys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (create) {
      res["Create"] = boost::any(*create);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (bindIp) {
      res["BindIp"] = boost::any(*bindIp);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (procName) {
      res["ProcName"] = boost::any(*procName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (proto) {
      res["Proto"] = boost::any(*proto);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Create") != m.end() && !m["Create"].empty()) {
      create = make_shared<string>(boost::any_cast<string>(m["Create"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("BindIp") != m.end() && !m["BindIp"].empty()) {
      bindIp = make_shared<string>(boost::any_cast<string>(m["BindIp"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("ProcName") != m.end() && !m["ProcName"].empty()) {
      procName = make_shared<string>(boost::any_cast<string>(m["ProcName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Proto") != m.end() && !m["Proto"].empty()) {
      proto = make_shared<string>(boost::any_cast<string>(m["Proto"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
  }


  virtual ~DescribePropertyPortDetailResponseBodyPropertys() = default;
};
class DescribePropertyPortDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribePropertyPortDetailResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribePropertyPortDetailResponseBodyPropertys>> propertys{};

  DescribePropertyPortDetailResponseBody() {}

  explicit DescribePropertyPortDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertys) {
      vector<boost::any> temp1;
      for(auto item1:*propertys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Propertys"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribePropertyPortDetailResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribePropertyPortDetailResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("Propertys") != m.end() && !m["Propertys"].empty()) {
      if (typeid(vector<boost::any>) == m["Propertys"].type()) {
        vector<DescribePropertyPortDetailResponseBodyPropertys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Propertys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertyPortDetailResponseBodyPropertys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertys = make_shared<vector<DescribePropertyPortDetailResponseBodyPropertys>>(expect1);
      }
    }
  }


  virtual ~DescribePropertyPortDetailResponseBody() = default;
};
class DescribePropertyPortDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePropertyPortDetailResponseBody> body{};

  DescribePropertyPortDetailResponse() {}

  explicit DescribePropertyPortDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyPortDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyPortDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyPortDetailResponse() = default;
};
class DescribePropertyPortItemRequest : public Darabonba::Model {
public:
  shared_ptr<bool> forceFlush{};
  shared_ptr<string> port{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  DescribePropertyPortItemRequest() {}

  explicit DescribePropertyPortItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forceFlush) {
      res["ForceFlush"] = boost::any(*forceFlush);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForceFlush") != m.end() && !m["ForceFlush"].empty()) {
      forceFlush = make_shared<bool>(boost::any_cast<bool>(m["ForceFlush"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribePropertyPortItemRequest() = default;
};
class DescribePropertyPortItemResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribePropertyPortItemResponseBodyPageInfo() {}

  explicit DescribePropertyPortItemResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribePropertyPortItemResponseBodyPageInfo() = default;
};
class DescribePropertyPortItemResponseBodyPropertyItems : public Darabonba::Model {
public:
  shared_ptr<string> port{};
  shared_ptr<long> count{};
  shared_ptr<string> proto{};

  DescribePropertyPortItemResponseBodyPropertyItems() {}

  explicit DescribePropertyPortItemResponseBodyPropertyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (proto) {
      res["Proto"] = boost::any(*proto);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Proto") != m.end() && !m["Proto"].empty()) {
      proto = make_shared<string>(boost::any_cast<string>(m["Proto"]));
    }
  }


  virtual ~DescribePropertyPortItemResponseBodyPropertyItems() = default;
};
class DescribePropertyPortItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribePropertyPortItemResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribePropertyPortItemResponseBodyPropertyItems>> propertyItems{};

  DescribePropertyPortItemResponseBody() {}

  explicit DescribePropertyPortItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertyItems) {
      vector<boost::any> temp1;
      for(auto item1:*propertyItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribePropertyPortItemResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribePropertyPortItemResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("PropertyItems") != m.end() && !m["PropertyItems"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyItems"].type()) {
        vector<DescribePropertyPortItemResponseBodyPropertyItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertyPortItemResponseBodyPropertyItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyItems = make_shared<vector<DescribePropertyPortItemResponseBodyPropertyItems>>(expect1);
      }
    }
  }


  virtual ~DescribePropertyPortItemResponseBody() = default;
};
class DescribePropertyPortItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePropertyPortItemResponseBody> body{};

  DescribePropertyPortItemResponse() {}

  explicit DescribePropertyPortItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyPortItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyPortItemResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyPortItemResponse() = default;
};
class DescribePropertyProcDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> remark{};
  shared_ptr<string> name{};
  shared_ptr<string> user{};
  shared_ptr<string> cmdline{};
  shared_ptr<string> uuid{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  DescribePropertyProcDetailRequest() {}

  explicit DescribePropertyProcDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    if (cmdline) {
      res["Cmdline"] = boost::any(*cmdline);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
    if (m.find("Cmdline") != m.end() && !m["Cmdline"].empty()) {
      cmdline = make_shared<string>(boost::any_cast<string>(m["Cmdline"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribePropertyProcDetailRequest() = default;
};
class DescribePropertyProcDetailResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribePropertyProcDetailResponseBodyPageInfo() {}

  explicit DescribePropertyProcDetailResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribePropertyProcDetailResponseBodyPageInfo() = default;
};
class DescribePropertyProcDetailResponseBodyPropertys : public Darabonba::Model {
public:
  shared_ptr<string> create{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> pid{};
  shared_ptr<string> user{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> cmdline{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> euidName{};
  shared_ptr<string> uuid{};
  shared_ptr<string> startTime{};
  shared_ptr<string> pname{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> path{};
  shared_ptr<string> md5{};
  shared_ptr<string> name{};
  shared_ptr<long> createTimestamp{};

  DescribePropertyProcDetailResponseBodyPropertys() {}

  explicit DescribePropertyProcDetailResponseBodyPropertys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (create) {
      res["Create"] = boost::any(*create);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (cmdline) {
      res["Cmdline"] = boost::any(*cmdline);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (euidName) {
      res["EuidName"] = boost::any(*euidName);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (pname) {
      res["Pname"] = boost::any(*pname);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Create") != m.end() && !m["Create"].empty()) {
      create = make_shared<string>(boost::any_cast<string>(m["Create"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Cmdline") != m.end() && !m["Cmdline"].empty()) {
      cmdline = make_shared<string>(boost::any_cast<string>(m["Cmdline"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("EuidName") != m.end() && !m["EuidName"].empty()) {
      euidName = make_shared<string>(boost::any_cast<string>(m["EuidName"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Pname") != m.end() && !m["Pname"].empty()) {
      pname = make_shared<string>(boost::any_cast<string>(m["Pname"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
  }


  virtual ~DescribePropertyProcDetailResponseBodyPropertys() = default;
};
class DescribePropertyProcDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribePropertyProcDetailResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribePropertyProcDetailResponseBodyPropertys>> propertys{};

  DescribePropertyProcDetailResponseBody() {}

  explicit DescribePropertyProcDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertys) {
      vector<boost::any> temp1;
      for(auto item1:*propertys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Propertys"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribePropertyProcDetailResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribePropertyProcDetailResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("Propertys") != m.end() && !m["Propertys"].empty()) {
      if (typeid(vector<boost::any>) == m["Propertys"].type()) {
        vector<DescribePropertyProcDetailResponseBodyPropertys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Propertys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertyProcDetailResponseBodyPropertys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertys = make_shared<vector<DescribePropertyProcDetailResponseBodyPropertys>>(expect1);
      }
    }
  }


  virtual ~DescribePropertyProcDetailResponseBody() = default;
};
class DescribePropertyProcDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePropertyProcDetailResponseBody> body{};

  DescribePropertyProcDetailResponse() {}

  explicit DescribePropertyProcDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyProcDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyProcDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyProcDetailResponse() = default;
};
class DescribePropertyProcItemRequest : public Darabonba::Model {
public:
  shared_ptr<bool> forceFlush{};
  shared_ptr<string> name{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  DescribePropertyProcItemRequest() {}

  explicit DescribePropertyProcItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forceFlush) {
      res["ForceFlush"] = boost::any(*forceFlush);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForceFlush") != m.end() && !m["ForceFlush"].empty()) {
      forceFlush = make_shared<bool>(boost::any_cast<bool>(m["ForceFlush"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribePropertyProcItemRequest() = default;
};
class DescribePropertyProcItemResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribePropertyProcItemResponseBodyPageInfo() {}

  explicit DescribePropertyProcItemResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribePropertyProcItemResponseBodyPageInfo() = default;
};
class DescribePropertyProcItemResponseBodyPropertyItems : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> count{};

  DescribePropertyProcItemResponseBodyPropertyItems() {}

  explicit DescribePropertyProcItemResponseBodyPropertyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribePropertyProcItemResponseBodyPropertyItems() = default;
};
class DescribePropertyProcItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribePropertyProcItemResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribePropertyProcItemResponseBodyPropertyItems>> propertyItems{};

  DescribePropertyProcItemResponseBody() {}

  explicit DescribePropertyProcItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertyItems) {
      vector<boost::any> temp1;
      for(auto item1:*propertyItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribePropertyProcItemResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribePropertyProcItemResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("PropertyItems") != m.end() && !m["PropertyItems"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyItems"].type()) {
        vector<DescribePropertyProcItemResponseBodyPropertyItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertyProcItemResponseBodyPropertyItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyItems = make_shared<vector<DescribePropertyProcItemResponseBodyPropertyItems>>(expect1);
      }
    }
  }


  virtual ~DescribePropertyProcItemResponseBody() = default;
};
class DescribePropertyProcItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePropertyProcItemResponseBody> body{};

  DescribePropertyProcItemResponse() {}

  explicit DescribePropertyProcItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyProcItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyProcItemResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyProcItemResponse() = default;
};
class DescribePropertyScaDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> searchItem{};
  shared_ptr<string> searchInfo{};
  shared_ptr<string> scaName{};
  shared_ptr<string> bizType{};
  shared_ptr<string> searchItemSub{};
  shared_ptr<string> searchInfoSub{};
  shared_ptr<string> remark{};
  shared_ptr<long> name{};
  shared_ptr<string> uuid{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  DescribePropertyScaDetailRequest() {}

  explicit DescribePropertyScaDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (searchItem) {
      res["SearchItem"] = boost::any(*searchItem);
    }
    if (searchInfo) {
      res["SearchInfo"] = boost::any(*searchInfo);
    }
    if (scaName) {
      res["ScaName"] = boost::any(*scaName);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (searchItemSub) {
      res["SearchItemSub"] = boost::any(*searchItemSub);
    }
    if (searchInfoSub) {
      res["SearchInfoSub"] = boost::any(*searchInfoSub);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SearchItem") != m.end() && !m["SearchItem"].empty()) {
      searchItem = make_shared<string>(boost::any_cast<string>(m["SearchItem"]));
    }
    if (m.find("SearchInfo") != m.end() && !m["SearchInfo"].empty()) {
      searchInfo = make_shared<string>(boost::any_cast<string>(m["SearchInfo"]));
    }
    if (m.find("ScaName") != m.end() && !m["ScaName"].empty()) {
      scaName = make_shared<string>(boost::any_cast<string>(m["ScaName"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("SearchItemSub") != m.end() && !m["SearchItemSub"].empty()) {
      searchItemSub = make_shared<string>(boost::any_cast<string>(m["SearchItemSub"]));
    }
    if (m.find("SearchInfoSub") != m.end() && !m["SearchInfoSub"].empty()) {
      searchInfoSub = make_shared<string>(boost::any_cast<string>(m["SearchInfoSub"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<long>(boost::any_cast<long>(m["Name"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribePropertyScaDetailRequest() = default;
};
class DescribePropertyScaDetailResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribePropertyScaDetailResponseBodyPageInfo() {}

  explicit DescribePropertyScaDetailResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribePropertyScaDetailResponseBodyPageInfo() = default;
};
class DescribePropertyScaDetailResponseBodyPropertys : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> bizTypeDispaly{};
  shared_ptr<long> processStarted{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> configPath{};
  shared_ptr<string> pid{};
  shared_ptr<string> port{};
  shared_ptr<string> cmdline{};
  shared_ptr<string> bizType{};
  shared_ptr<string> listenIp{};
  shared_ptr<string> version{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> listenStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> create{};
  shared_ptr<string> ip{};
  shared_ptr<string> processUser{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> webPath{};
  shared_ptr<string> ppid{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> uuid{};
  shared_ptr<string> listenProtocol{};
  shared_ptr<string> imageName{};
  shared_ptr<string> path{};
  shared_ptr<string> containerName{};
  shared_ptr<string> proof{};
  shared_ptr<long> createTimestamp{};

  DescribePropertyScaDetailResponseBodyPropertys() {}

  explicit DescribePropertyScaDetailResponseBodyPropertys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (bizTypeDispaly) {
      res["BizTypeDispaly"] = boost::any(*bizTypeDispaly);
    }
    if (processStarted) {
      res["ProcessStarted"] = boost::any(*processStarted);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (configPath) {
      res["ConfigPath"] = boost::any(*configPath);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (cmdline) {
      res["Cmdline"] = boost::any(*cmdline);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (listenIp) {
      res["ListenIp"] = boost::any(*listenIp);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (listenStatus) {
      res["ListenStatus"] = boost::any(*listenStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (create) {
      res["Create"] = boost::any(*create);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (processUser) {
      res["ProcessUser"] = boost::any(*processUser);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (webPath) {
      res["WebPath"] = boost::any(*webPath);
    }
    if (ppid) {
      res["Ppid"] = boost::any(*ppid);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (listenProtocol) {
      res["ListenProtocol"] = boost::any(*listenProtocol);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (containerName) {
      res["ContainerName"] = boost::any(*containerName);
    }
    if (proof) {
      res["Proof"] = boost::any(*proof);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("BizTypeDispaly") != m.end() && !m["BizTypeDispaly"].empty()) {
      bizTypeDispaly = make_shared<string>(boost::any_cast<string>(m["BizTypeDispaly"]));
    }
    if (m.find("ProcessStarted") != m.end() && !m["ProcessStarted"].empty()) {
      processStarted = make_shared<long>(boost::any_cast<long>(m["ProcessStarted"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("ConfigPath") != m.end() && !m["ConfigPath"].empty()) {
      configPath = make_shared<string>(boost::any_cast<string>(m["ConfigPath"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Cmdline") != m.end() && !m["Cmdline"].empty()) {
      cmdline = make_shared<string>(boost::any_cast<string>(m["Cmdline"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("ListenIp") != m.end() && !m["ListenIp"].empty()) {
      listenIp = make_shared<string>(boost::any_cast<string>(m["ListenIp"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("ListenStatus") != m.end() && !m["ListenStatus"].empty()) {
      listenStatus = make_shared<string>(boost::any_cast<string>(m["ListenStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Create") != m.end() && !m["Create"].empty()) {
      create = make_shared<string>(boost::any_cast<string>(m["Create"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("ProcessUser") != m.end() && !m["ProcessUser"].empty()) {
      processUser = make_shared<string>(boost::any_cast<string>(m["ProcessUser"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("WebPath") != m.end() && !m["WebPath"].empty()) {
      webPath = make_shared<string>(boost::any_cast<string>(m["WebPath"]));
    }
    if (m.find("Ppid") != m.end() && !m["Ppid"].empty()) {
      ppid = make_shared<string>(boost::any_cast<string>(m["Ppid"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("ListenProtocol") != m.end() && !m["ListenProtocol"].empty()) {
      listenProtocol = make_shared<string>(boost::any_cast<string>(m["ListenProtocol"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ContainerName") != m.end() && !m["ContainerName"].empty()) {
      containerName = make_shared<string>(boost::any_cast<string>(m["ContainerName"]));
    }
    if (m.find("Proof") != m.end() && !m["Proof"].empty()) {
      proof = make_shared<string>(boost::any_cast<string>(m["Proof"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
  }


  virtual ~DescribePropertyScaDetailResponseBodyPropertys() = default;
};
class DescribePropertyScaDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribePropertyScaDetailResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribePropertyScaDetailResponseBodyPropertys>> propertys{};

  DescribePropertyScaDetailResponseBody() {}

  explicit DescribePropertyScaDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertys) {
      vector<boost::any> temp1;
      for(auto item1:*propertys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Propertys"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribePropertyScaDetailResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribePropertyScaDetailResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("Propertys") != m.end() && !m["Propertys"].empty()) {
      if (typeid(vector<boost::any>) == m["Propertys"].type()) {
        vector<DescribePropertyScaDetailResponseBodyPropertys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Propertys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertyScaDetailResponseBodyPropertys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertys = make_shared<vector<DescribePropertyScaDetailResponseBodyPropertys>>(expect1);
      }
    }
  }


  virtual ~DescribePropertyScaDetailResponseBody() = default;
};
class DescribePropertyScaDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePropertyScaDetailResponseBody> body{};

  DescribePropertyScaDetailResponse() {}

  explicit DescribePropertyScaDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyScaDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyScaDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyScaDetailResponse() = default;
};
class DescribePropertySoftwareDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> remark{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<string> softwareVersion{};
  shared_ptr<string> uuid{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  DescribePropertySoftwareDetailRequest() {}

  explicit DescribePropertySoftwareDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (softwareVersion) {
      res["SoftwareVersion"] = boost::any(*softwareVersion);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("SoftwareVersion") != m.end() && !m["SoftwareVersion"].empty()) {
      softwareVersion = make_shared<string>(boost::any_cast<string>(m["SoftwareVersion"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribePropertySoftwareDetailRequest() = default;
};
class DescribePropertySoftwareDetailResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribePropertySoftwareDetailResponseBodyPageInfo() {}

  explicit DescribePropertySoftwareDetailResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribePropertySoftwareDetailResponseBodyPageInfo() = default;
};
class DescribePropertySoftwareDetailResponseBodyPropertys : public Darabonba::Model {
public:
  shared_ptr<long> create{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> ip{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> installTime{};
  shared_ptr<string> uuid{};
  shared_ptr<string> version{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> path{};
  shared_ptr<string> name{};
  shared_ptr<long> createTimestamp{};

  DescribePropertySoftwareDetailResponseBodyPropertys() {}

  explicit DescribePropertySoftwareDetailResponseBodyPropertys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (create) {
      res["Create"] = boost::any(*create);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (installTime) {
      res["InstallTime"] = boost::any(*installTime);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Create") != m.end() && !m["Create"].empty()) {
      create = make_shared<long>(boost::any_cast<long>(m["Create"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("InstallTime") != m.end() && !m["InstallTime"].empty()) {
      installTime = make_shared<string>(boost::any_cast<string>(m["InstallTime"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
  }


  virtual ~DescribePropertySoftwareDetailResponseBodyPropertys() = default;
};
class DescribePropertySoftwareDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribePropertySoftwareDetailResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribePropertySoftwareDetailResponseBodyPropertys>> propertys{};

  DescribePropertySoftwareDetailResponseBody() {}

  explicit DescribePropertySoftwareDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertys) {
      vector<boost::any> temp1;
      for(auto item1:*propertys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Propertys"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribePropertySoftwareDetailResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribePropertySoftwareDetailResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("Propertys") != m.end() && !m["Propertys"].empty()) {
      if (typeid(vector<boost::any>) == m["Propertys"].type()) {
        vector<DescribePropertySoftwareDetailResponseBodyPropertys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Propertys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertySoftwareDetailResponseBodyPropertys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertys = make_shared<vector<DescribePropertySoftwareDetailResponseBodyPropertys>>(expect1);
      }
    }
  }


  virtual ~DescribePropertySoftwareDetailResponseBody() = default;
};
class DescribePropertySoftwareDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePropertySoftwareDetailResponseBody> body{};

  DescribePropertySoftwareDetailResponse() {}

  explicit DescribePropertySoftwareDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertySoftwareDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertySoftwareDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertySoftwareDetailResponse() = default;
};
class DescribePropertySoftwareItemRequest : public Darabonba::Model {
public:
  shared_ptr<bool> forceFlush{};
  shared_ptr<string> name{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  DescribePropertySoftwareItemRequest() {}

  explicit DescribePropertySoftwareItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forceFlush) {
      res["ForceFlush"] = boost::any(*forceFlush);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForceFlush") != m.end() && !m["ForceFlush"].empty()) {
      forceFlush = make_shared<bool>(boost::any_cast<bool>(m["ForceFlush"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribePropertySoftwareItemRequest() = default;
};
class DescribePropertySoftwareItemResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribePropertySoftwareItemResponseBodyPageInfo() {}

  explicit DescribePropertySoftwareItemResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribePropertySoftwareItemResponseBodyPageInfo() = default;
};
class DescribePropertySoftwareItemResponseBodyPropertyItems : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> count{};

  DescribePropertySoftwareItemResponseBodyPropertyItems() {}

  explicit DescribePropertySoftwareItemResponseBodyPropertyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribePropertySoftwareItemResponseBodyPropertyItems() = default;
};
class DescribePropertySoftwareItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribePropertySoftwareItemResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribePropertySoftwareItemResponseBodyPropertyItems>> propertyItems{};

  DescribePropertySoftwareItemResponseBody() {}

  explicit DescribePropertySoftwareItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertyItems) {
      vector<boost::any> temp1;
      for(auto item1:*propertyItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribePropertySoftwareItemResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribePropertySoftwareItemResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("PropertyItems") != m.end() && !m["PropertyItems"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyItems"].type()) {
        vector<DescribePropertySoftwareItemResponseBodyPropertyItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertySoftwareItemResponseBodyPropertyItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyItems = make_shared<vector<DescribePropertySoftwareItemResponseBodyPropertyItems>>(expect1);
      }
    }
  }


  virtual ~DescribePropertySoftwareItemResponseBody() = default;
};
class DescribePropertySoftwareItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePropertySoftwareItemResponseBody> body{};

  DescribePropertySoftwareItemResponse() {}

  explicit DescribePropertySoftwareItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertySoftwareItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertySoftwareItemResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertySoftwareItemResponse() = default;
};
class DescribePropertyUsageNewestRequest : public Darabonba::Model {
public:
  shared_ptr<string> type{};

  DescribePropertyUsageNewestRequest() {}

  explicit DescribePropertyUsageNewestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribePropertyUsageNewestRequest() = default;
};
class DescribePropertyUsageNewestResponseBodyNewestStatisticItems : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> create{};

  DescribePropertyUsageNewestResponseBodyNewestStatisticItems() {}

  explicit DescribePropertyUsageNewestResponseBodyNewestStatisticItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (create) {
      res["Create"] = boost::any(*create);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Create") != m.end() && !m["Create"].empty()) {
      create = make_shared<long>(boost::any_cast<long>(m["Create"]));
    }
  }


  virtual ~DescribePropertyUsageNewestResponseBodyNewestStatisticItems() = default;
};
class DescribePropertyUsageNewestResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<long> itemCount{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribePropertyUsageNewestResponseBodyNewestStatisticItems>> newestStatisticItems{};

  DescribePropertyUsageNewestResponseBody() {}

  explicit DescribePropertyUsageNewestResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (itemCount) {
      res["ItemCount"] = boost::any(*itemCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (newestStatisticItems) {
      vector<boost::any> temp1;
      for(auto item1:*newestStatisticItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NewestStatisticItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ItemCount") != m.end() && !m["ItemCount"].empty()) {
      itemCount = make_shared<long>(boost::any_cast<long>(m["ItemCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NewestStatisticItems") != m.end() && !m["NewestStatisticItems"].empty()) {
      if (typeid(vector<boost::any>) == m["NewestStatisticItems"].type()) {
        vector<DescribePropertyUsageNewestResponseBodyNewestStatisticItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NewestStatisticItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertyUsageNewestResponseBodyNewestStatisticItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        newestStatisticItems = make_shared<vector<DescribePropertyUsageNewestResponseBodyNewestStatisticItems>>(expect1);
      }
    }
  }


  virtual ~DescribePropertyUsageNewestResponseBody() = default;
};
class DescribePropertyUsageNewestResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePropertyUsageNewestResponseBody> body{};

  DescribePropertyUsageNewestResponse() {}

  explicit DescribePropertyUsageNewestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyUsageNewestResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyUsageNewestResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyUsageNewestResponse() = default;
};
class DescribePropertyUserDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> remark{};
  shared_ptr<string> user{};
  shared_ptr<string> isRoot{};
  shared_ptr<string> uuid{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  DescribePropertyUserDetailRequest() {}

  explicit DescribePropertyUserDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    if (isRoot) {
      res["IsRoot"] = boost::any(*isRoot);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
    if (m.find("IsRoot") != m.end() && !m["IsRoot"].empty()) {
      isRoot = make_shared<string>(boost::any_cast<string>(m["IsRoot"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribePropertyUserDetailRequest() = default;
};
class DescribePropertyUserDetailResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribePropertyUserDetailResponseBodyPageInfo() {}

  explicit DescribePropertyUserDetailResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribePropertyUserDetailResponseBodyPageInfo() = default;
};
class DescribePropertyUserDetailResponseBodyPropertys : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> create{};
  shared_ptr<string> lastLoginIp{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> lastLoginTime{};
  shared_ptr<string> isRoot{};
  shared_ptr<string> ip{};
  shared_ptr<string> user{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> passwordExpirationDate{};
  shared_ptr<string> uuid{};
  shared_ptr<long> lastLoginTimestamp{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> accountsExpirationDate{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<vector<string>> groupNames{};

  DescribePropertyUserDetailResponseBodyPropertys() {}

  explicit DescribePropertyUserDetailResponseBodyPropertys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (create) {
      res["Create"] = boost::any(*create);
    }
    if (lastLoginIp) {
      res["LastLoginIp"] = boost::any(*lastLoginIp);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (lastLoginTime) {
      res["LastLoginTime"] = boost::any(*lastLoginTime);
    }
    if (isRoot) {
      res["IsRoot"] = boost::any(*isRoot);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (passwordExpirationDate) {
      res["PasswordExpirationDate"] = boost::any(*passwordExpirationDate);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (lastLoginTimestamp) {
      res["LastLoginTimestamp"] = boost::any(*lastLoginTimestamp);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (accountsExpirationDate) {
      res["AccountsExpirationDate"] = boost::any(*accountsExpirationDate);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (groupNames) {
      res["GroupNames"] = boost::any(*groupNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Create") != m.end() && !m["Create"].empty()) {
      create = make_shared<string>(boost::any_cast<string>(m["Create"]));
    }
    if (m.find("LastLoginIp") != m.end() && !m["LastLoginIp"].empty()) {
      lastLoginIp = make_shared<string>(boost::any_cast<string>(m["LastLoginIp"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("LastLoginTime") != m.end() && !m["LastLoginTime"].empty()) {
      lastLoginTime = make_shared<string>(boost::any_cast<string>(m["LastLoginTime"]));
    }
    if (m.find("IsRoot") != m.end() && !m["IsRoot"].empty()) {
      isRoot = make_shared<string>(boost::any_cast<string>(m["IsRoot"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("PasswordExpirationDate") != m.end() && !m["PasswordExpirationDate"].empty()) {
      passwordExpirationDate = make_shared<string>(boost::any_cast<string>(m["PasswordExpirationDate"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("LastLoginTimestamp") != m.end() && !m["LastLoginTimestamp"].empty()) {
      lastLoginTimestamp = make_shared<long>(boost::any_cast<long>(m["LastLoginTimestamp"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("AccountsExpirationDate") != m.end() && !m["AccountsExpirationDate"].empty()) {
      accountsExpirationDate = make_shared<string>(boost::any_cast<string>(m["AccountsExpirationDate"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("GroupNames") != m.end() && !m["GroupNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribePropertyUserDetailResponseBodyPropertys() = default;
};
class DescribePropertyUserDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribePropertyUserDetailResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribePropertyUserDetailResponseBodyPropertys>> propertys{};

  DescribePropertyUserDetailResponseBody() {}

  explicit DescribePropertyUserDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertys) {
      vector<boost::any> temp1;
      for(auto item1:*propertys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Propertys"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribePropertyUserDetailResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribePropertyUserDetailResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("Propertys") != m.end() && !m["Propertys"].empty()) {
      if (typeid(vector<boost::any>) == m["Propertys"].type()) {
        vector<DescribePropertyUserDetailResponseBodyPropertys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Propertys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertyUserDetailResponseBodyPropertys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertys = make_shared<vector<DescribePropertyUserDetailResponseBodyPropertys>>(expect1);
      }
    }
  }


  virtual ~DescribePropertyUserDetailResponseBody() = default;
};
class DescribePropertyUserDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePropertyUserDetailResponseBody> body{};

  DescribePropertyUserDetailResponse() {}

  explicit DescribePropertyUserDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyUserDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyUserDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyUserDetailResponse() = default;
};
class DescribePropertyUserItemRequest : public Darabonba::Model {
public:
  shared_ptr<bool> forceFlush{};
  shared_ptr<string> user{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  DescribePropertyUserItemRequest() {}

  explicit DescribePropertyUserItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forceFlush) {
      res["ForceFlush"] = boost::any(*forceFlush);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForceFlush") != m.end() && !m["ForceFlush"].empty()) {
      forceFlush = make_shared<bool>(boost::any_cast<bool>(m["ForceFlush"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribePropertyUserItemRequest() = default;
};
class DescribePropertyUserItemResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribePropertyUserItemResponseBodyPageInfo() {}

  explicit DescribePropertyUserItemResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribePropertyUserItemResponseBodyPageInfo() = default;
};
class DescribePropertyUserItemResponseBodyPropertyItems : public Darabonba::Model {
public:
  shared_ptr<string> user{};
  shared_ptr<long> count{};

  DescribePropertyUserItemResponseBodyPropertyItems() {}

  explicit DescribePropertyUserItemResponseBodyPropertyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (user) {
      res["User"] = boost::any(*user);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribePropertyUserItemResponseBodyPropertyItems() = default;
};
class DescribePropertyUserItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribePropertyUserItemResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribePropertyUserItemResponseBodyPropertyItems>> propertyItems{};

  DescribePropertyUserItemResponseBody() {}

  explicit DescribePropertyUserItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertyItems) {
      vector<boost::any> temp1;
      for(auto item1:*propertyItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribePropertyUserItemResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribePropertyUserItemResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("PropertyItems") != m.end() && !m["PropertyItems"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyItems"].type()) {
        vector<DescribePropertyUserItemResponseBodyPropertyItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertyUserItemResponseBodyPropertyItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyItems = make_shared<vector<DescribePropertyUserItemResponseBodyPropertyItems>>(expect1);
      }
    }
  }


  virtual ~DescribePropertyUserItemResponseBody() = default;
};
class DescribePropertyUserItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePropertyUserItemResponseBody> body{};

  DescribePropertyUserItemResponse() {}

  explicit DescribePropertyUserItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyUserItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyUserItemResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyUserItemResponse() = default;
};
class DescribeQuaraFileDownloadInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> quaraFileId{};
  shared_ptr<string> from{};

  DescribeQuaraFileDownloadInfoRequest() {}

  explicit DescribeQuaraFileDownloadInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (quaraFileId) {
      res["QuaraFileId"] = boost::any(*quaraFileId);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("QuaraFileId") != m.end() && !m["QuaraFileId"].empty()) {
      quaraFileId = make_shared<long>(boost::any_cast<long>(m["QuaraFileId"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
  }


  virtual ~DescribeQuaraFileDownloadInfoRequest() = default;
};
class DescribeQuaraFileDownloadInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> uuid{};
  shared_ptr<long> quaraFileId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> path{};
  shared_ptr<string> md5{};
  shared_ptr<string> tag{};

  DescribeQuaraFileDownloadInfoResponseBody() {}

  explicit DescribeQuaraFileDownloadInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (quaraFileId) {
      res["QuaraFileId"] = boost::any(*quaraFileId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("QuaraFileId") != m.end() && !m["QuaraFileId"].empty()) {
      quaraFileId = make_shared<long>(boost::any_cast<long>(m["QuaraFileId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~DescribeQuaraFileDownloadInfoResponseBody() = default;
};
class DescribeQuaraFileDownloadInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeQuaraFileDownloadInfoResponseBody> body{};

  DescribeQuaraFileDownloadInfoResponse() {}

  explicit DescribeQuaraFileDownloadInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeQuaraFileDownloadInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeQuaraFileDownloadInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeQuaraFileDownloadInfoResponse() = default;
};
class DescribeRestoreJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> status{};
  shared_ptr<string> machineRemark{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};

  DescribeRestoreJobsRequest() {}

  explicit DescribeRestoreJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (machineRemark) {
      res["MachineRemark"] = boost::any(*machineRemark);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("MachineRemark") != m.end() && !m["MachineRemark"].empty()) {
      machineRemark = make_shared<string>(boost::any_cast<string>(m["MachineRemark"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~DescribeRestoreJobsRequest() = default;
};
class DescribeRestoreJobsResponseBodyRestoreJobs : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> createdTime{};
  shared_ptr<long> updatedTime{};
  shared_ptr<string> uuid{};
  shared_ptr<string> message{};
  shared_ptr<string> restoreId{};
  shared_ptr<string> clientId{};
  shared_ptr<string> vaultId{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> snapshotHash{};
  shared_ptr<string> source{};
  shared_ptr<string> target{};
  shared_ptr<string> status{};
  shared_ptr<string> restoreType{};
  shared_ptr<long> speed{};
  shared_ptr<long> completeTime{};
  shared_ptr<long> eta{};
  shared_ptr<long> errorCount{};
  shared_ptr<long> bytesDone{};
  shared_ptr<long> bytesTotal{};
  shared_ptr<long> itemsDone{};
  shared_ptr<long> itemsTotal{};
  shared_ptr<long> actualBytes{};
  shared_ptr<long> percentage{};
  shared_ptr<string> errorType{};
  shared_ptr<string> sourceClientId{};
  shared_ptr<string> snapshotVersion{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> errorFile{};
  shared_ptr<string> errorFileUrl{};
  shared_ptr<string> requestId{};
  shared_ptr<string> restoreName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> extra{};
  shared_ptr<long> duration{};
  shared_ptr<string> exitCode{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> excludes{};
  shared_ptr<string> includes{};

  DescribeRestoreJobsResponseBodyRestoreJobs() {}

  explicit DescribeRestoreJobsResponseBodyRestoreJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (restoreId) {
      res["RestoreId"] = boost::any(*restoreId);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (vaultId) {
      res["VaultId"] = boost::any(*vaultId);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (snapshotHash) {
      res["SnapshotHash"] = boost::any(*snapshotHash);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (restoreType) {
      res["RestoreType"] = boost::any(*restoreType);
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (completeTime) {
      res["CompleteTime"] = boost::any(*completeTime);
    }
    if (eta) {
      res["Eta"] = boost::any(*eta);
    }
    if (errorCount) {
      res["ErrorCount"] = boost::any(*errorCount);
    }
    if (bytesDone) {
      res["BytesDone"] = boost::any(*bytesDone);
    }
    if (bytesTotal) {
      res["BytesTotal"] = boost::any(*bytesTotal);
    }
    if (itemsDone) {
      res["ItemsDone"] = boost::any(*itemsDone);
    }
    if (itemsTotal) {
      res["ItemsTotal"] = boost::any(*itemsTotal);
    }
    if (actualBytes) {
      res["ActualBytes"] = boost::any(*actualBytes);
    }
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (errorType) {
      res["ErrorType"] = boost::any(*errorType);
    }
    if (sourceClientId) {
      res["SourceClientId"] = boost::any(*sourceClientId);
    }
    if (snapshotVersion) {
      res["SnapshotVersion"] = boost::any(*snapshotVersion);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (errorFile) {
      res["ErrorFile"] = boost::any(*errorFile);
    }
    if (errorFileUrl) {
      res["ErrorFileUrl"] = boost::any(*errorFileUrl);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (restoreName) {
      res["RestoreName"] = boost::any(*restoreName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (exitCode) {
      res["ExitCode"] = boost::any(*exitCode);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (excludes) {
      res["Excludes"] = boost::any(*excludes);
    }
    if (includes) {
      res["Includes"] = boost::any(*includes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["UpdatedTime"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RestoreId") != m.end() && !m["RestoreId"].empty()) {
      restoreId = make_shared<string>(boost::any_cast<string>(m["RestoreId"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("VaultId") != m.end() && !m["VaultId"].empty()) {
      vaultId = make_shared<string>(boost::any_cast<string>(m["VaultId"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("SnapshotHash") != m.end() && !m["SnapshotHash"].empty()) {
      snapshotHash = make_shared<string>(boost::any_cast<string>(m["SnapshotHash"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("RestoreType") != m.end() && !m["RestoreType"].empty()) {
      restoreType = make_shared<string>(boost::any_cast<string>(m["RestoreType"]));
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<long>(boost::any_cast<long>(m["Speed"]));
    }
    if (m.find("CompleteTime") != m.end() && !m["CompleteTime"].empty()) {
      completeTime = make_shared<long>(boost::any_cast<long>(m["CompleteTime"]));
    }
    if (m.find("Eta") != m.end() && !m["Eta"].empty()) {
      eta = make_shared<long>(boost::any_cast<long>(m["Eta"]));
    }
    if (m.find("ErrorCount") != m.end() && !m["ErrorCount"].empty()) {
      errorCount = make_shared<long>(boost::any_cast<long>(m["ErrorCount"]));
    }
    if (m.find("BytesDone") != m.end() && !m["BytesDone"].empty()) {
      bytesDone = make_shared<long>(boost::any_cast<long>(m["BytesDone"]));
    }
    if (m.find("BytesTotal") != m.end() && !m["BytesTotal"].empty()) {
      bytesTotal = make_shared<long>(boost::any_cast<long>(m["BytesTotal"]));
    }
    if (m.find("ItemsDone") != m.end() && !m["ItemsDone"].empty()) {
      itemsDone = make_shared<long>(boost::any_cast<long>(m["ItemsDone"]));
    }
    if (m.find("ItemsTotal") != m.end() && !m["ItemsTotal"].empty()) {
      itemsTotal = make_shared<long>(boost::any_cast<long>(m["ItemsTotal"]));
    }
    if (m.find("ActualBytes") != m.end() && !m["ActualBytes"].empty()) {
      actualBytes = make_shared<long>(boost::any_cast<long>(m["ActualBytes"]));
    }
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("ErrorType") != m.end() && !m["ErrorType"].empty()) {
      errorType = make_shared<string>(boost::any_cast<string>(m["ErrorType"]));
    }
    if (m.find("SourceClientId") != m.end() && !m["SourceClientId"].empty()) {
      sourceClientId = make_shared<string>(boost::any_cast<string>(m["SourceClientId"]));
    }
    if (m.find("SnapshotVersion") != m.end() && !m["SnapshotVersion"].empty()) {
      snapshotVersion = make_shared<string>(boost::any_cast<string>(m["SnapshotVersion"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("ErrorFile") != m.end() && !m["ErrorFile"].empty()) {
      errorFile = make_shared<string>(boost::any_cast<string>(m["ErrorFile"]));
    }
    if (m.find("ErrorFileUrl") != m.end() && !m["ErrorFileUrl"].empty()) {
      errorFileUrl = make_shared<string>(boost::any_cast<string>(m["ErrorFileUrl"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RestoreName") != m.end() && !m["RestoreName"].empty()) {
      restoreName = make_shared<string>(boost::any_cast<string>(m["RestoreName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["Extra"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("ExitCode") != m.end() && !m["ExitCode"].empty()) {
      exitCode = make_shared<string>(boost::any_cast<string>(m["ExitCode"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Excludes") != m.end() && !m["Excludes"].empty()) {
      excludes = make_shared<string>(boost::any_cast<string>(m["Excludes"]));
    }
    if (m.find("Includes") != m.end() && !m["Includes"].empty()) {
      includes = make_shared<string>(boost::any_cast<string>(m["Includes"]));
    }
  }


  virtual ~DescribeRestoreJobsResponseBodyRestoreJobs() = default;
};
class DescribeRestoreJobsResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> currentPage{};

  DescribeRestoreJobsResponseBodyPageInfo() {}

  explicit DescribeRestoreJobsResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~DescribeRestoreJobsResponseBodyPageInfo() = default;
};
class DescribeRestoreJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRestoreJobsResponseBodyRestoreJobs>> restoreJobs{};
  shared_ptr<DescribeRestoreJobsResponseBodyPageInfo> pageInfo{};

  DescribeRestoreJobsResponseBody() {}

  explicit DescribeRestoreJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (restoreJobs) {
      vector<boost::any> temp1;
      for(auto item1:*restoreJobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RestoreJobs"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RestoreJobs") != m.end() && !m["RestoreJobs"].empty()) {
      if (typeid(vector<boost::any>) == m["RestoreJobs"].type()) {
        vector<DescribeRestoreJobsResponseBodyRestoreJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RestoreJobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRestoreJobsResponseBodyRestoreJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        restoreJobs = make_shared<vector<DescribeRestoreJobsResponseBodyRestoreJobs>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeRestoreJobsResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeRestoreJobsResponseBodyPageInfo>(model1);
      }
    }
  }


  virtual ~DescribeRestoreJobsResponseBody() = default;
};
class DescribeRestoreJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRestoreJobsResponseBody> body{};

  DescribeRestoreJobsResponse() {}

  explicit DescribeRestoreJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRestoreJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRestoreJobsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRestoreJobsResponse() = default;
};
class DescribeRiskCheckItemResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> lang{};
  shared_ptr<long> itemId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  DescribeRiskCheckItemResultRequest() {}

  explicit DescribeRiskCheckItemResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeRiskCheckItemResultRequest() = default;
};
class DescribeRiskCheckItemResultResponseBodyPageContentResource : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> contentResource{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> count{};

  DescribeRiskCheckItemResultResponseBodyPageContentResource() {}

  explicit DescribeRiskCheckItemResultResponseBodyPageContentResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (contentResource) {
      res["ContentResource"] = boost::any(*contentResource);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ContentResource") != m.end() && !m["ContentResource"].empty()) {
      contentResource = make_shared<string>(boost::any_cast<string>(m["ContentResource"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeRiskCheckItemResultResponseBodyPageContentResource() = default;
};
class DescribeRiskCheckItemResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRiskCheckItemResultResponseBodyPageContentResource> pageContentResource{};

  DescribeRiskCheckItemResultResponseBody() {}

  explicit DescribeRiskCheckItemResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageContentResource) {
      res["PageContentResource"] = pageContentResource ? boost::any(pageContentResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageContentResource") != m.end() && !m["PageContentResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageContentResource"].type()) {
        DescribeRiskCheckItemResultResponseBodyPageContentResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageContentResource"]));
        pageContentResource = make_shared<DescribeRiskCheckItemResultResponseBodyPageContentResource>(model1);
      }
    }
  }


  virtual ~DescribeRiskCheckItemResultResponseBody() = default;
};
class DescribeRiskCheckItemResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRiskCheckItemResultResponseBody> body{};

  DescribeRiskCheckItemResultResponse() {}

  explicit DescribeRiskCheckItemResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRiskCheckItemResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRiskCheckItemResultResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRiskCheckItemResultResponse() = default;
};
class DescribeRiskCheckResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> lang{};
  shared_ptr<long> groupId{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> riskLevel{};
  shared_ptr<string> status{};
  shared_ptr<string> assetType{};
  shared_ptr<string> name{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queryFlag{};
  shared_ptr<vector<string>> itemIds{};

  DescribeRiskCheckResultRequest() {}

  explicit DescribeRiskCheckResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (assetType) {
      res["AssetType"] = boost::any(*assetType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryFlag) {
      res["QueryFlag"] = boost::any(*queryFlag);
    }
    if (itemIds) {
      res["ItemIds"] = boost::any(*itemIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<string>(boost::any_cast<string>(m["RiskLevel"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("AssetType") != m.end() && !m["AssetType"].empty()) {
      assetType = make_shared<string>(boost::any_cast<string>(m["AssetType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryFlag") != m.end() && !m["QueryFlag"].empty()) {
      queryFlag = make_shared<string>(boost::any_cast<string>(m["QueryFlag"]));
    }
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ItemIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ItemIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      itemIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeRiskCheckResultRequest() = default;
};
class DescribeRiskCheckResultResponseBodyListRiskItemResources : public Darabonba::Model {
public:
  shared_ptr<string> contentResource{};
  shared_ptr<string> resourceName{};

  DescribeRiskCheckResultResponseBodyListRiskItemResources() {}

  explicit DescribeRiskCheckResultResponseBodyListRiskItemResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentResource) {
      res["ContentResource"] = boost::any(*contentResource);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentResource") != m.end() && !m["ContentResource"].empty()) {
      contentResource = make_shared<string>(boost::any_cast<string>(m["ContentResource"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
  }


  virtual ~DescribeRiskCheckResultResponseBodyListRiskItemResources() = default;
};
class DescribeRiskCheckResultResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<string> riskLevel{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<long> sort{};
  shared_ptr<string> repairStatus{};
  shared_ptr<long> remainingTime{};
  shared_ptr<long> itemId{};
  shared_ptr<string> startStatus{};
  shared_ptr<long> affectedCount{};
  shared_ptr<string> riskAssertType{};
  shared_ptr<string> title{};
  shared_ptr<long> taskId{};
  shared_ptr<long> checkTime{};
  shared_ptr<vector<DescribeRiskCheckResultResponseBodyListRiskItemResources>> riskItemResources{};

  DescribeRiskCheckResultResponseBodyList() {}

  explicit DescribeRiskCheckResultResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (repairStatus) {
      res["RepairStatus"] = boost::any(*repairStatus);
    }
    if (remainingTime) {
      res["RemainingTime"] = boost::any(*remainingTime);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (startStatus) {
      res["StartStatus"] = boost::any(*startStatus);
    }
    if (affectedCount) {
      res["AffectedCount"] = boost::any(*affectedCount);
    }
    if (riskAssertType) {
      res["RiskAssertType"] = boost::any(*riskAssertType);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (checkTime) {
      res["CheckTime"] = boost::any(*checkTime);
    }
    if (riskItemResources) {
      vector<boost::any> temp1;
      for(auto item1:*riskItemResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RiskItemResources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<string>(boost::any_cast<string>(m["RiskLevel"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<long>(boost::any_cast<long>(m["Sort"]));
    }
    if (m.find("RepairStatus") != m.end() && !m["RepairStatus"].empty()) {
      repairStatus = make_shared<string>(boost::any_cast<string>(m["RepairStatus"]));
    }
    if (m.find("RemainingTime") != m.end() && !m["RemainingTime"].empty()) {
      remainingTime = make_shared<long>(boost::any_cast<long>(m["RemainingTime"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("StartStatus") != m.end() && !m["StartStatus"].empty()) {
      startStatus = make_shared<string>(boost::any_cast<string>(m["StartStatus"]));
    }
    if (m.find("AffectedCount") != m.end() && !m["AffectedCount"].empty()) {
      affectedCount = make_shared<long>(boost::any_cast<long>(m["AffectedCount"]));
    }
    if (m.find("RiskAssertType") != m.end() && !m["RiskAssertType"].empty()) {
      riskAssertType = make_shared<string>(boost::any_cast<string>(m["RiskAssertType"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("CheckTime") != m.end() && !m["CheckTime"].empty()) {
      checkTime = make_shared<long>(boost::any_cast<long>(m["CheckTime"]));
    }
    if (m.find("RiskItemResources") != m.end() && !m["RiskItemResources"].empty()) {
      if (typeid(vector<boost::any>) == m["RiskItemResources"].type()) {
        vector<DescribeRiskCheckResultResponseBodyListRiskItemResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RiskItemResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRiskCheckResultResponseBodyListRiskItemResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        riskItemResources = make_shared<vector<DescribeRiskCheckResultResponseBodyListRiskItemResources>>(expect1);
      }
    }
  }


  virtual ~DescribeRiskCheckResultResponseBodyList() = default;
};
class DescribeRiskCheckResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeRiskCheckResultResponseBodyList>> list{};

  DescribeRiskCheckResultResponseBody() {}

  explicit DescribeRiskCheckResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<DescribeRiskCheckResultResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRiskCheckResultResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<DescribeRiskCheckResultResponseBodyList>>(expect1);
      }
    }
  }


  virtual ~DescribeRiskCheckResultResponseBody() = default;
};
class DescribeRiskCheckResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRiskCheckResultResponseBody> body{};

  DescribeRiskCheckResultResponse() {}

  explicit DescribeRiskCheckResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRiskCheckResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRiskCheckResultResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRiskCheckResultResponse() = default;
};
class DescribeRiskCheckSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> lang{};
  shared_ptr<string> resourceDirectoryAccountId{};

  DescribeRiskCheckSummaryRequest() {}

  explicit DescribeRiskCheckSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (resourceDirectoryAccountId) {
      res["ResourceDirectoryAccountId"] = boost::any(*resourceDirectoryAccountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ResourceDirectoryAccountId") != m.end() && !m["ResourceDirectoryAccountId"].empty()) {
      resourceDirectoryAccountId = make_shared<string>(boost::any_cast<string>(m["ResourceDirectoryAccountId"]));
    }
  }


  virtual ~DescribeRiskCheckSummaryRequest() = default;
};
class DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<long> count{};

  DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount() {}

  explicit DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount() = default;
};
class DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> count{};

  DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus() {}

  explicit DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus() = default;
};
class DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups : public Darabonba::Model {
public:
  shared_ptr<long> remainingTime{};
  shared_ptr<string> status{};
  shared_ptr<long> sort{};
  shared_ptr<string> title{};
  shared_ptr<long> id{};
  shared_ptr<vector<DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus>> countByStatus{};

  DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups() {}

  explicit DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remainingTime) {
      res["RemainingTime"] = boost::any(*remainingTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (countByStatus) {
      vector<boost::any> temp1;
      for(auto item1:*countByStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CountByStatus"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemainingTime") != m.end() && !m["RemainingTime"].empty()) {
      remainingTime = make_shared<long>(boost::any_cast<long>(m["RemainingTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<long>(boost::any_cast<long>(m["Sort"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("CountByStatus") != m.end() && !m["CountByStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["CountByStatus"].type()) {
        vector<DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CountByStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        countByStatus = make_shared<vector<DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus>>(expect1);
      }
    }
  }


  virtual ~DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups() = default;
};
class DescribeRiskCheckSummaryResponseBodyRiskCheckSummary : public Darabonba::Model {
public:
  shared_ptr<long> itemCount{};
  shared_ptr<long> affectedAssetCount{};
  shared_ptr<long> disabledRiskCount{};
  shared_ptr<long> riskCount{};
  shared_ptr<double> riskRate{};
  shared_ptr<long> previousCount{};
  shared_ptr<long> previousTime{};
  shared_ptr<long> enabledRiskCount{};
  shared_ptr<vector<DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount>> riskLevelCount{};
  shared_ptr<vector<DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups>> groups{};

  DescribeRiskCheckSummaryResponseBodyRiskCheckSummary() {}

  explicit DescribeRiskCheckSummaryResponseBodyRiskCheckSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemCount) {
      res["ItemCount"] = boost::any(*itemCount);
    }
    if (affectedAssetCount) {
      res["AffectedAssetCount"] = boost::any(*affectedAssetCount);
    }
    if (disabledRiskCount) {
      res["DisabledRiskCount"] = boost::any(*disabledRiskCount);
    }
    if (riskCount) {
      res["RiskCount"] = boost::any(*riskCount);
    }
    if (riskRate) {
      res["RiskRate"] = boost::any(*riskRate);
    }
    if (previousCount) {
      res["PreviousCount"] = boost::any(*previousCount);
    }
    if (previousTime) {
      res["PreviousTime"] = boost::any(*previousTime);
    }
    if (enabledRiskCount) {
      res["EnabledRiskCount"] = boost::any(*enabledRiskCount);
    }
    if (riskLevelCount) {
      vector<boost::any> temp1;
      for(auto item1:*riskLevelCount){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RiskLevelCount"] = boost::any(temp1);
    }
    if (groups) {
      vector<boost::any> temp1;
      for(auto item1:*groups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Groups"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemCount") != m.end() && !m["ItemCount"].empty()) {
      itemCount = make_shared<long>(boost::any_cast<long>(m["ItemCount"]));
    }
    if (m.find("AffectedAssetCount") != m.end() && !m["AffectedAssetCount"].empty()) {
      affectedAssetCount = make_shared<long>(boost::any_cast<long>(m["AffectedAssetCount"]));
    }
    if (m.find("DisabledRiskCount") != m.end() && !m["DisabledRiskCount"].empty()) {
      disabledRiskCount = make_shared<long>(boost::any_cast<long>(m["DisabledRiskCount"]));
    }
    if (m.find("RiskCount") != m.end() && !m["RiskCount"].empty()) {
      riskCount = make_shared<long>(boost::any_cast<long>(m["RiskCount"]));
    }
    if (m.find("RiskRate") != m.end() && !m["RiskRate"].empty()) {
      riskRate = make_shared<double>(boost::any_cast<double>(m["RiskRate"]));
    }
    if (m.find("PreviousCount") != m.end() && !m["PreviousCount"].empty()) {
      previousCount = make_shared<long>(boost::any_cast<long>(m["PreviousCount"]));
    }
    if (m.find("PreviousTime") != m.end() && !m["PreviousTime"].empty()) {
      previousTime = make_shared<long>(boost::any_cast<long>(m["PreviousTime"]));
    }
    if (m.find("EnabledRiskCount") != m.end() && !m["EnabledRiskCount"].empty()) {
      enabledRiskCount = make_shared<long>(boost::any_cast<long>(m["EnabledRiskCount"]));
    }
    if (m.find("RiskLevelCount") != m.end() && !m["RiskLevelCount"].empty()) {
      if (typeid(vector<boost::any>) == m["RiskLevelCount"].type()) {
        vector<DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RiskLevelCount"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        riskLevelCount = make_shared<vector<DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount>>(expect1);
      }
    }
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      if (typeid(vector<boost::any>) == m["Groups"].type()) {
        vector<DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Groups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groups = make_shared<vector<DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups>>(expect1);
      }
    }
  }


  virtual ~DescribeRiskCheckSummaryResponseBodyRiskCheckSummary() = default;
};
class DescribeRiskCheckSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRiskCheckSummaryResponseBodyRiskCheckSummary> riskCheckSummary{};

  DescribeRiskCheckSummaryResponseBody() {}

  explicit DescribeRiskCheckSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (riskCheckSummary) {
      res["RiskCheckSummary"] = riskCheckSummary ? boost::any(riskCheckSummary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RiskCheckSummary") != m.end() && !m["RiskCheckSummary"].empty()) {
      if (typeid(map<string, boost::any>) == m["RiskCheckSummary"].type()) {
        DescribeRiskCheckSummaryResponseBodyRiskCheckSummary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RiskCheckSummary"]));
        riskCheckSummary = make_shared<DescribeRiskCheckSummaryResponseBodyRiskCheckSummary>(model1);
      }
    }
  }


  virtual ~DescribeRiskCheckSummaryResponseBody() = default;
};
class DescribeRiskCheckSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRiskCheckSummaryResponseBody> body{};

  DescribeRiskCheckSummaryResponse() {}

  explicit DescribeRiskCheckSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRiskCheckSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRiskCheckSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRiskCheckSummaryResponse() = default;
};
class DescribeRiskItemTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> lang{};

  DescribeRiskItemTypeRequest() {}

  explicit DescribeRiskItemTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeRiskItemTypeRequest() = default;
};
class DescribeRiskItemTypeResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> title{};

  DescribeRiskItemTypeResponseBodyList() {}

  explicit DescribeRiskItemTypeResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~DescribeRiskItemTypeResponseBodyList() = default;
};
class DescribeRiskItemTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRiskItemTypeResponseBodyList>> list{};

  DescribeRiskItemTypeResponseBody() {}

  explicit DescribeRiskItemTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<DescribeRiskItemTypeResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRiskItemTypeResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<DescribeRiskItemTypeResponseBodyList>>(expect1);
      }
    }
  }


  virtual ~DescribeRiskItemTypeResponseBody() = default;
};
class DescribeRiskItemTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRiskItemTypeResponseBody> body{};

  DescribeRiskItemTypeResponse() {}

  explicit DescribeRiskItemTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRiskItemTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRiskItemTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRiskItemTypeResponse() = default;
};
class DescribeRiskListCheckResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> lang{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> instanceIds{};

  DescribeRiskListCheckResultRequest() {}

  explicit DescribeRiskListCheckResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeRiskListCheckResultRequest() = default;
};
class DescribeRiskListCheckResultResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<long> riskCount{};
  shared_ptr<string> instanceId{};

  DescribeRiskListCheckResultResponseBodyList() {}

  explicit DescribeRiskListCheckResultResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (riskCount) {
      res["riskCount"] = boost::any(*riskCount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("riskCount") != m.end() && !m["riskCount"].empty()) {
      riskCount = make_shared<long>(boost::any_cast<long>(m["riskCount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeRiskListCheckResultResponseBodyList() = default;
};
class DescribeRiskListCheckResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRiskListCheckResultResponseBodyList>> list{};

  DescribeRiskListCheckResultResponseBody() {}

  explicit DescribeRiskListCheckResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<DescribeRiskListCheckResultResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRiskListCheckResultResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<DescribeRiskListCheckResultResponseBodyList>>(expect1);
      }
    }
  }


  virtual ~DescribeRiskListCheckResultResponseBody() = default;
};
class DescribeRiskListCheckResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRiskListCheckResultResponseBody> body{};

  DescribeRiskListCheckResultResponse() {}

  explicit DescribeRiskListCheckResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRiskListCheckResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRiskListCheckResultResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRiskListCheckResultResponse() = default;
};
class DescribeSasAssetStatisticsColumnRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};

  DescribeSasAssetStatisticsColumnRequest() {}

  explicit DescribeSasAssetStatisticsColumnRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeSasAssetStatisticsColumnRequest() = default;
};
class DescribeSasAssetStatisticsColumnResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> statisticsColumn{};
  shared_ptr<string> requestId{};

  DescribeSasAssetStatisticsColumnResponseBody() {}

  explicit DescribeSasAssetStatisticsColumnResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (statisticsColumn) {
      res["StatisticsColumn"] = boost::any(*statisticsColumn);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StatisticsColumn") != m.end() && !m["StatisticsColumn"].empty()) {
      statisticsColumn = make_shared<string>(boost::any_cast<string>(m["StatisticsColumn"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeSasAssetStatisticsColumnResponseBody() = default;
};
class DescribeSasAssetStatisticsColumnResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSasAssetStatisticsColumnResponseBody> body{};

  DescribeSasAssetStatisticsColumnResponse() {}

  explicit DescribeSasAssetStatisticsColumnResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSasAssetStatisticsColumnResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSasAssetStatisticsColumnResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSasAssetStatisticsColumnResponse() = default;
};
class DescribeScanTaskProgressRequest : public Darabonba::Model {
public:
  shared_ptr<long> taskId{};

  DescribeScanTaskProgressRequest() {}

  explicit DescribeScanTaskProgressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~DescribeScanTaskProgressRequest() = default;
};
class DescribeScanTaskProgressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> targetInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<string> scanTaskProgress{};

  DescribeScanTaskProgressResponseBody() {}

  explicit DescribeScanTaskProgressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetInfo) {
      res["TargetInfo"] = boost::any(*targetInfo);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scanTaskProgress) {
      res["ScanTaskProgress"] = boost::any(*scanTaskProgress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetInfo") != m.end() && !m["TargetInfo"].empty()) {
      targetInfo = make_shared<string>(boost::any_cast<string>(m["TargetInfo"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScanTaskProgress") != m.end() && !m["ScanTaskProgress"].empty()) {
      scanTaskProgress = make_shared<string>(boost::any_cast<string>(m["ScanTaskProgress"]));
    }
  }


  virtual ~DescribeScanTaskProgressResponseBody() = default;
};
class DescribeScanTaskProgressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeScanTaskProgressResponseBody> body{};

  DescribeScanTaskProgressResponse() {}

  explicit DescribeScanTaskProgressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScanTaskProgressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScanTaskProgressResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScanTaskProgressResponse() = default;
};
class DescribeSearchConditionRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};
  shared_ptr<string> type{};

  DescribeSearchConditionRequest() {}

  explicit DescribeSearchConditionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeSearchConditionRequest() = default;
};
class DescribeSearchConditionResponseBodyConditionList : public Darabonba::Model {
public:
  shared_ptr<string> conditionType{};
  shared_ptr<string> nameKey{};
  shared_ptr<string> name{};
  shared_ptr<string> filterConditions{};

  DescribeSearchConditionResponseBodyConditionList() {}

  explicit DescribeSearchConditionResponseBodyConditionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionType) {
      res["ConditionType"] = boost::any(*conditionType);
    }
    if (nameKey) {
      res["NameKey"] = boost::any(*nameKey);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (filterConditions) {
      res["FilterConditions"] = boost::any(*filterConditions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionType") != m.end() && !m["ConditionType"].empty()) {
      conditionType = make_shared<string>(boost::any_cast<string>(m["ConditionType"]));
    }
    if (m.find("NameKey") != m.end() && !m["NameKey"].empty()) {
      nameKey = make_shared<string>(boost::any_cast<string>(m["NameKey"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("FilterConditions") != m.end() && !m["FilterConditions"].empty()) {
      filterConditions = make_shared<string>(boost::any_cast<string>(m["FilterConditions"]));
    }
  }


  virtual ~DescribeSearchConditionResponseBodyConditionList() = default;
};
class DescribeSearchConditionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSearchConditionResponseBodyConditionList>> conditionList{};

  DescribeSearchConditionResponseBody() {}

  explicit DescribeSearchConditionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (conditionList) {
      vector<boost::any> temp1;
      for(auto item1:*conditionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConditionList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ConditionList") != m.end() && !m["ConditionList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConditionList"].type()) {
        vector<DescribeSearchConditionResponseBodyConditionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConditionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSearchConditionResponseBodyConditionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditionList = make_shared<vector<DescribeSearchConditionResponseBodyConditionList>>(expect1);
      }
    }
  }


  virtual ~DescribeSearchConditionResponseBody() = default;
};
class DescribeSearchConditionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSearchConditionResponseBody> body{};

  DescribeSearchConditionResponse() {}

  explicit DescribeSearchConditionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSearchConditionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSearchConditionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSearchConditionResponse() = default;
};
class DescribeSecureSuggestionRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};

  DescribeSecureSuggestionRequest() {}

  explicit DescribeSecureSuggestionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeSecureSuggestionRequest() = default;
};
class DescribeSecureSuggestionResponseBodySuggestionsDetail : public Darabonba::Model {
public:
  shared_ptr<string> title{};
  shared_ptr<string> description{};
  shared_ptr<string> subType{};

  DescribeSecureSuggestionResponseBodySuggestionsDetail() {}

  explicit DescribeSecureSuggestionResponseBodySuggestionsDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
  }


  virtual ~DescribeSecureSuggestionResponseBodySuggestionsDetail() = default;
};
class DescribeSecureSuggestionResponseBodySuggestions : public Darabonba::Model {
public:
  shared_ptr<long> points{};
  shared_ptr<string> suggestType{};
  shared_ptr<vector<DescribeSecureSuggestionResponseBodySuggestionsDetail>> detail{};

  DescribeSecureSuggestionResponseBodySuggestions() {}

  explicit DescribeSecureSuggestionResponseBodySuggestions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (suggestType) {
      res["SuggestType"] = boost::any(*suggestType);
    }
    if (detail) {
      vector<boost::any> temp1;
      for(auto item1:*detail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Detail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("SuggestType") != m.end() && !m["SuggestType"].empty()) {
      suggestType = make_shared<string>(boost::any_cast<string>(m["SuggestType"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(vector<boost::any>) == m["Detail"].type()) {
        vector<DescribeSecureSuggestionResponseBodySuggestionsDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Detail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecureSuggestionResponseBodySuggestionsDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        detail = make_shared<vector<DescribeSecureSuggestionResponseBodySuggestionsDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeSecureSuggestionResponseBodySuggestions() = default;
};
class DescribeSecureSuggestionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSecureSuggestionResponseBodySuggestions>> suggestions{};

  DescribeSecureSuggestionResponseBody() {}

  explicit DescribeSecureSuggestionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (suggestions) {
      vector<boost::any> temp1;
      for(auto item1:*suggestions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Suggestions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Suggestions") != m.end() && !m["Suggestions"].empty()) {
      if (typeid(vector<boost::any>) == m["Suggestions"].type()) {
        vector<DescribeSecureSuggestionResponseBodySuggestions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Suggestions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecureSuggestionResponseBodySuggestions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        suggestions = make_shared<vector<DescribeSecureSuggestionResponseBodySuggestions>>(expect1);
      }
    }
  }


  virtual ~DescribeSecureSuggestionResponseBody() = default;
};
class DescribeSecureSuggestionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSecureSuggestionResponseBody> body{};

  DescribeSecureSuggestionResponse() {}

  explicit DescribeSecureSuggestionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecureSuggestionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecureSuggestionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecureSuggestionResponse() = default;
};
class DescribeSecurityCheckScheduleConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> lang{};

  DescribeSecurityCheckScheduleConfigRequest() {}

  explicit DescribeSecurityCheckScheduleConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeSecurityCheckScheduleConfigRequest() = default;
};
class DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<string> daysOfWeek{};

  DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig() {}

  explicit DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (daysOfWeek) {
      res["DaysOfWeek"] = boost::any(*daysOfWeek);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("DaysOfWeek") != m.end() && !m["DaysOfWeek"].empty()) {
      daysOfWeek = make_shared<string>(boost::any_cast<string>(m["DaysOfWeek"]));
    }
  }


  virtual ~DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig() = default;
};
class DescribeSecurityCheckScheduleConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig> riskCheckJobConfig{};

  DescribeSecurityCheckScheduleConfigResponseBody() {}

  explicit DescribeSecurityCheckScheduleConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (riskCheckJobConfig) {
      res["RiskCheckJobConfig"] = riskCheckJobConfig ? boost::any(riskCheckJobConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RiskCheckJobConfig") != m.end() && !m["RiskCheckJobConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RiskCheckJobConfig"].type()) {
        DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RiskCheckJobConfig"]));
        riskCheckJobConfig = make_shared<DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig>(model1);
      }
    }
  }


  virtual ~DescribeSecurityCheckScheduleConfigResponseBody() = default;
};
class DescribeSecurityCheckScheduleConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSecurityCheckScheduleConfigResponseBody> body{};

  DescribeSecurityCheckScheduleConfigResponse() {}

  explicit DescribeSecurityCheckScheduleConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecurityCheckScheduleConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecurityCheckScheduleConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecurityCheckScheduleConfigResponse() = default;
};
class DescribeSecurityEventOperationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> lang{};
  shared_ptr<long> securityEventId{};

  DescribeSecurityEventOperationsRequest() {}

  explicit DescribeSecurityEventOperationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (securityEventId) {
      res["SecurityEventId"] = boost::any(*securityEventId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SecurityEventId") != m.end() && !m["SecurityEventId"].empty()) {
      securityEventId = make_shared<long>(boost::any_cast<long>(m["SecurityEventId"]));
    }
  }


  virtual ~DescribeSecurityEventOperationsRequest() = default;
};
class DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField : public Darabonba::Model {
public:
  shared_ptr<string> markMisType{};
  shared_ptr<string> filedName{};
  shared_ptr<string> filedAliasName{};
  shared_ptr<string> markMisValue{};
  shared_ptr<vector<string>> supportedMisType{};

  DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField() {}

  explicit DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (markMisType) {
      res["MarkMisType"] = boost::any(*markMisType);
    }
    if (filedName) {
      res["FiledName"] = boost::any(*filedName);
    }
    if (filedAliasName) {
      res["FiledAliasName"] = boost::any(*filedAliasName);
    }
    if (markMisValue) {
      res["MarkMisValue"] = boost::any(*markMisValue);
    }
    if (supportedMisType) {
      res["SupportedMisType"] = boost::any(*supportedMisType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MarkMisType") != m.end() && !m["MarkMisType"].empty()) {
      markMisType = make_shared<string>(boost::any_cast<string>(m["MarkMisType"]));
    }
    if (m.find("FiledName") != m.end() && !m["FiledName"].empty()) {
      filedName = make_shared<string>(boost::any_cast<string>(m["FiledName"]));
    }
    if (m.find("FiledAliasName") != m.end() && !m["FiledAliasName"].empty()) {
      filedAliasName = make_shared<string>(boost::any_cast<string>(m["FiledAliasName"]));
    }
    if (m.find("MarkMisValue") != m.end() && !m["MarkMisValue"].empty()) {
      markMisValue = make_shared<string>(boost::any_cast<string>(m["MarkMisValue"]));
    }
    if (m.find("SupportedMisType") != m.end() && !m["SupportedMisType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportedMisType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportedMisType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportedMisType = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField() = default;
};
class DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource : public Darabonba::Model {
public:
  shared_ptr<string> filedName{};
  shared_ptr<string> filedAliasName{};
  shared_ptr<string> markMisValue{};
  shared_ptr<vector<string>> supportedMisType{};

  DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource() {}

  explicit DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filedName) {
      res["FiledName"] = boost::any(*filedName);
    }
    if (filedAliasName) {
      res["FiledAliasName"] = boost::any(*filedAliasName);
    }
    if (markMisValue) {
      res["MarkMisValue"] = boost::any(*markMisValue);
    }
    if (supportedMisType) {
      res["SupportedMisType"] = boost::any(*supportedMisType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FiledName") != m.end() && !m["FiledName"].empty()) {
      filedName = make_shared<string>(boost::any_cast<string>(m["FiledName"]));
    }
    if (m.find("FiledAliasName") != m.end() && !m["FiledAliasName"].empty()) {
      filedAliasName = make_shared<string>(boost::any_cast<string>(m["FiledAliasName"]));
    }
    if (m.find("MarkMisValue") != m.end() && !m["MarkMisValue"].empty()) {
      markMisValue = make_shared<string>(boost::any_cast<string>(m["MarkMisValue"]));
    }
    if (m.find("SupportedMisType") != m.end() && !m["SupportedMisType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportedMisType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportedMisType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportedMisType = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource() = default;
};
class DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse : public Darabonba::Model {
public:
  shared_ptr<string> operationParams{};
  shared_ptr<string> operationCode{};
  shared_ptr<bool> userCanOperate{};
  shared_ptr<vector<DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField>> markField{};
  shared_ptr<vector<DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource>> markFieldsSource{};

  DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse() {}

  explicit DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationParams) {
      res["OperationParams"] = boost::any(*operationParams);
    }
    if (operationCode) {
      res["OperationCode"] = boost::any(*operationCode);
    }
    if (userCanOperate) {
      res["UserCanOperate"] = boost::any(*userCanOperate);
    }
    if (markField) {
      vector<boost::any> temp1;
      for(auto item1:*markField){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MarkField"] = boost::any(temp1);
    }
    if (markFieldsSource) {
      vector<boost::any> temp1;
      for(auto item1:*markFieldsSource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MarkFieldsSource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationParams") != m.end() && !m["OperationParams"].empty()) {
      operationParams = make_shared<string>(boost::any_cast<string>(m["OperationParams"]));
    }
    if (m.find("OperationCode") != m.end() && !m["OperationCode"].empty()) {
      operationCode = make_shared<string>(boost::any_cast<string>(m["OperationCode"]));
    }
    if (m.find("UserCanOperate") != m.end() && !m["UserCanOperate"].empty()) {
      userCanOperate = make_shared<bool>(boost::any_cast<bool>(m["UserCanOperate"]));
    }
    if (m.find("MarkField") != m.end() && !m["MarkField"].empty()) {
      if (typeid(vector<boost::any>) == m["MarkField"].type()) {
        vector<DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MarkField"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        markField = make_shared<vector<DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField>>(expect1);
      }
    }
    if (m.find("MarkFieldsSource") != m.end() && !m["MarkFieldsSource"].empty()) {
      if (typeid(vector<boost::any>) == m["MarkFieldsSource"].type()) {
        vector<DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MarkFieldsSource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        markFieldsSource = make_shared<vector<DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource>>(expect1);
      }
    }
  }


  virtual ~DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse() = default;
};
class DescribeSecurityEventOperationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse>> securityEventOperationsResponse{};

  DescribeSecurityEventOperationsResponseBody() {}

  explicit DescribeSecurityEventOperationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityEventOperationsResponse) {
      vector<boost::any> temp1;
      for(auto item1:*securityEventOperationsResponse){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityEventOperationsResponse"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityEventOperationsResponse") != m.end() && !m["SecurityEventOperationsResponse"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityEventOperationsResponse"].type()) {
        vector<DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityEventOperationsResponse"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityEventOperationsResponse = make_shared<vector<DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse>>(expect1);
      }
    }
  }


  virtual ~DescribeSecurityEventOperationsResponseBody() = default;
};
class DescribeSecurityEventOperationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSecurityEventOperationsResponseBody> body{};

  DescribeSecurityEventOperationsResponse() {}

  explicit DescribeSecurityEventOperationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecurityEventOperationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecurityEventOperationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecurityEventOperationsResponse() = default;
};
class DescribeSecurityEventOperationStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> taskId{};
  shared_ptr<vector<string>> securityEventIds{};

  DescribeSecurityEventOperationStatusRequest() {}

  explicit DescribeSecurityEventOperationStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (securityEventIds) {
      res["SecurityEventIds"] = boost::any(*securityEventIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("SecurityEventIds") != m.end() && !m["SecurityEventIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityEventIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityEventIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityEventIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSecurityEventOperationStatusRequest() = default;
};
class DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> securityEventId{};
  shared_ptr<string> errorCode{};

  DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses() {}

  explicit DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (securityEventId) {
      res["SecurityEventId"] = boost::any(*securityEventId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SecurityEventId") != m.end() && !m["SecurityEventId"].empty()) {
      securityEventId = make_shared<string>(boost::any_cast<string>(m["SecurityEventId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses() = default;
};
class DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse : public Darabonba::Model {
public:
  shared_ptr<string> taskStatus{};
  shared_ptr<vector<DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses>> securityEventOperationStatuses{};

  DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse() {}

  explicit DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (securityEventOperationStatuses) {
      vector<boost::any> temp1;
      for(auto item1:*securityEventOperationStatuses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityEventOperationStatuses"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("SecurityEventOperationStatuses") != m.end() && !m["SecurityEventOperationStatuses"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityEventOperationStatuses"].type()) {
        vector<DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityEventOperationStatuses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityEventOperationStatuses = make_shared<vector<DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses>>(expect1);
      }
    }
  }


  virtual ~DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse() = default;
};
class DescribeSecurityEventOperationStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse> securityEventOperationStatusResponse{};

  DescribeSecurityEventOperationStatusResponseBody() {}

  explicit DescribeSecurityEventOperationStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityEventOperationStatusResponse) {
      res["SecurityEventOperationStatusResponse"] = securityEventOperationStatusResponse ? boost::any(securityEventOperationStatusResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityEventOperationStatusResponse") != m.end() && !m["SecurityEventOperationStatusResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityEventOperationStatusResponse"].type()) {
        DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityEventOperationStatusResponse"]));
        securityEventOperationStatusResponse = make_shared<DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse>(model1);
      }
    }
  }


  virtual ~DescribeSecurityEventOperationStatusResponseBody() = default;
};
class DescribeSecurityEventOperationStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSecurityEventOperationStatusResponseBody> body{};

  DescribeSecurityEventOperationStatusResponse() {}

  explicit DescribeSecurityEventOperationStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecurityEventOperationStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecurityEventOperationStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecurityEventOperationStatusResponse() = default;
};
class DescribeSecurityStatInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};
  shared_ptr<string> resourceDirectoryAccountId{};

  DescribeSecurityStatInfoRequest() {}

  explicit DescribeSecurityStatInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (resourceDirectoryAccountId) {
      res["ResourceDirectoryAccountId"] = boost::any(*resourceDirectoryAccountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ResourceDirectoryAccountId") != m.end() && !m["ResourceDirectoryAccountId"].empty()) {
      resourceDirectoryAccountId = make_shared<string>(boost::any_cast<string>(m["ResourceDirectoryAccountId"]));
    }
  }


  virtual ~DescribeSecurityStatInfoRequest() = default;
};
class DescribeSecurityStatInfoResponseBodySecurityEvent : public Darabonba::Model {
public:
  shared_ptr<long> suspiciousCount{};
  shared_ptr<long> seriousCount{};
  shared_ptr<long> remindCount{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<string>> valueArray{};
  shared_ptr<vector<string>> timeArray{};
  shared_ptr<vector<string>> remindList{};
  shared_ptr<vector<string>> levelsOn{};
  shared_ptr<vector<string>> dateArray{};
  shared_ptr<vector<string>> suspiciousList{};
  shared_ptr<vector<string>> seriousList{};

  DescribeSecurityStatInfoResponseBodySecurityEvent() {}

  explicit DescribeSecurityStatInfoResponseBodySecurityEvent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suspiciousCount) {
      res["SuspiciousCount"] = boost::any(*suspiciousCount);
    }
    if (seriousCount) {
      res["SeriousCount"] = boost::any(*seriousCount);
    }
    if (remindCount) {
      res["RemindCount"] = boost::any(*remindCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (valueArray) {
      res["ValueArray"] = boost::any(*valueArray);
    }
    if (timeArray) {
      res["TimeArray"] = boost::any(*timeArray);
    }
    if (remindList) {
      res["RemindList"] = boost::any(*remindList);
    }
    if (levelsOn) {
      res["LevelsOn"] = boost::any(*levelsOn);
    }
    if (dateArray) {
      res["DateArray"] = boost::any(*dateArray);
    }
    if (suspiciousList) {
      res["SuspiciousList"] = boost::any(*suspiciousList);
    }
    if (seriousList) {
      res["SeriousList"] = boost::any(*seriousList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SuspiciousCount") != m.end() && !m["SuspiciousCount"].empty()) {
      suspiciousCount = make_shared<long>(boost::any_cast<long>(m["SuspiciousCount"]));
    }
    if (m.find("SeriousCount") != m.end() && !m["SeriousCount"].empty()) {
      seriousCount = make_shared<long>(boost::any_cast<long>(m["SeriousCount"]));
    }
    if (m.find("RemindCount") != m.end() && !m["RemindCount"].empty()) {
      remindCount = make_shared<long>(boost::any_cast<long>(m["RemindCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("ValueArray") != m.end() && !m["ValueArray"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ValueArray"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ValueArray"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      valueArray = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TimeArray") != m.end() && !m["TimeArray"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TimeArray"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TimeArray"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      timeArray = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RemindList") != m.end() && !m["RemindList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RemindList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RemindList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      remindList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LevelsOn") != m.end() && !m["LevelsOn"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LevelsOn"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LevelsOn"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      levelsOn = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DateArray") != m.end() && !m["DateArray"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DateArray"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DateArray"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dateArray = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SuspiciousList") != m.end() && !m["SuspiciousList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SuspiciousList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SuspiciousList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      suspiciousList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SeriousList") != m.end() && !m["SeriousList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SeriousList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SeriousList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      seriousList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSecurityStatInfoResponseBodySecurityEvent() = default;
};
class DescribeSecurityStatInfoResponseBodyAttackEvent : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<vector<string>> dateArray{};
  shared_ptr<vector<string>> valueArray{};

  DescribeSecurityStatInfoResponseBodyAttackEvent() {}

  explicit DescribeSecurityStatInfoResponseBodyAttackEvent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (dateArray) {
      res["DateArray"] = boost::any(*dateArray);
    }
    if (valueArray) {
      res["ValueArray"] = boost::any(*valueArray);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("DateArray") != m.end() && !m["DateArray"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DateArray"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DateArray"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dateArray = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ValueArray") != m.end() && !m["ValueArray"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ValueArray"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ValueArray"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      valueArray = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSecurityStatInfoResponseBodyAttackEvent() = default;
};
class DescribeSecurityStatInfoResponseBodyHealthCheck : public Darabonba::Model {
public:
  shared_ptr<long> highCount{};
  shared_ptr<long> lowCount{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> mediumCount{};
  shared_ptr<vector<string>> valueArray{};
  shared_ptr<vector<string>> timeArray{};
  shared_ptr<vector<string>> levelsOn{};
  shared_ptr<vector<string>> lowList{};
  shared_ptr<vector<string>> mediumList{};
  shared_ptr<vector<string>> dateArray{};
  shared_ptr<vector<string>> highList{};

  DescribeSecurityStatInfoResponseBodyHealthCheck() {}

  explicit DescribeSecurityStatInfoResponseBodyHealthCheck(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (highCount) {
      res["HighCount"] = boost::any(*highCount);
    }
    if (lowCount) {
      res["LowCount"] = boost::any(*lowCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (mediumCount) {
      res["MediumCount"] = boost::any(*mediumCount);
    }
    if (valueArray) {
      res["ValueArray"] = boost::any(*valueArray);
    }
    if (timeArray) {
      res["TimeArray"] = boost::any(*timeArray);
    }
    if (levelsOn) {
      res["LevelsOn"] = boost::any(*levelsOn);
    }
    if (lowList) {
      res["LowList"] = boost::any(*lowList);
    }
    if (mediumList) {
      res["MediumList"] = boost::any(*mediumList);
    }
    if (dateArray) {
      res["DateArray"] = boost::any(*dateArray);
    }
    if (highList) {
      res["HighList"] = boost::any(*highList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HighCount") != m.end() && !m["HighCount"].empty()) {
      highCount = make_shared<long>(boost::any_cast<long>(m["HighCount"]));
    }
    if (m.find("LowCount") != m.end() && !m["LowCount"].empty()) {
      lowCount = make_shared<long>(boost::any_cast<long>(m["LowCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("MediumCount") != m.end() && !m["MediumCount"].empty()) {
      mediumCount = make_shared<long>(boost::any_cast<long>(m["MediumCount"]));
    }
    if (m.find("ValueArray") != m.end() && !m["ValueArray"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ValueArray"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ValueArray"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      valueArray = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TimeArray") != m.end() && !m["TimeArray"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TimeArray"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TimeArray"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      timeArray = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LevelsOn") != m.end() && !m["LevelsOn"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LevelsOn"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LevelsOn"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      levelsOn = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LowList") != m.end() && !m["LowList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LowList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LowList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      lowList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MediumList") != m.end() && !m["MediumList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MediumList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MediumList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mediumList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DateArray") != m.end() && !m["DateArray"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DateArray"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DateArray"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dateArray = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HighList") != m.end() && !m["HighList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HighList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HighList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      highList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSecurityStatInfoResponseBodyHealthCheck() = default;
};
class DescribeSecurityStatInfoResponseBodyVulnerability : public Darabonba::Model {
public:
  shared_ptr<long> nntfCount{};
  shared_ptr<long> laterCount{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> asapCount{};
  shared_ptr<vector<string>> nntfList{};
  shared_ptr<vector<string>> asapList{};
  shared_ptr<vector<string>> valueArray{};
  shared_ptr<vector<string>> timeArray{};
  shared_ptr<vector<string>> levelsOn{};
  shared_ptr<vector<string>> laterList{};
  shared_ptr<vector<string>> dateArray{};

  DescribeSecurityStatInfoResponseBodyVulnerability() {}

  explicit DescribeSecurityStatInfoResponseBodyVulnerability(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nntfCount) {
      res["NntfCount"] = boost::any(*nntfCount);
    }
    if (laterCount) {
      res["LaterCount"] = boost::any(*laterCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (asapCount) {
      res["AsapCount"] = boost::any(*asapCount);
    }
    if (nntfList) {
      res["NntfList"] = boost::any(*nntfList);
    }
    if (asapList) {
      res["AsapList"] = boost::any(*asapList);
    }
    if (valueArray) {
      res["ValueArray"] = boost::any(*valueArray);
    }
    if (timeArray) {
      res["TimeArray"] = boost::any(*timeArray);
    }
    if (levelsOn) {
      res["LevelsOn"] = boost::any(*levelsOn);
    }
    if (laterList) {
      res["LaterList"] = boost::any(*laterList);
    }
    if (dateArray) {
      res["DateArray"] = boost::any(*dateArray);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NntfCount") != m.end() && !m["NntfCount"].empty()) {
      nntfCount = make_shared<long>(boost::any_cast<long>(m["NntfCount"]));
    }
    if (m.find("LaterCount") != m.end() && !m["LaterCount"].empty()) {
      laterCount = make_shared<long>(boost::any_cast<long>(m["LaterCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("AsapCount") != m.end() && !m["AsapCount"].empty()) {
      asapCount = make_shared<long>(boost::any_cast<long>(m["AsapCount"]));
    }
    if (m.find("NntfList") != m.end() && !m["NntfList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NntfList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NntfList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nntfList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AsapList") != m.end() && !m["AsapList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AsapList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AsapList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      asapList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ValueArray") != m.end() && !m["ValueArray"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ValueArray"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ValueArray"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      valueArray = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TimeArray") != m.end() && !m["TimeArray"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TimeArray"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TimeArray"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      timeArray = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LevelsOn") != m.end() && !m["LevelsOn"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LevelsOn"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LevelsOn"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      levelsOn = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LaterList") != m.end() && !m["LaterList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LaterList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LaterList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      laterList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DateArray") != m.end() && !m["DateArray"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DateArray"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DateArray"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dateArray = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSecurityStatInfoResponseBodyVulnerability() = default;
};
class DescribeSecurityStatInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSecurityStatInfoResponseBodySecurityEvent> securityEvent{};
  shared_ptr<DescribeSecurityStatInfoResponseBodyAttackEvent> attackEvent{};
  shared_ptr<DescribeSecurityStatInfoResponseBodyHealthCheck> healthCheck{};
  shared_ptr<DescribeSecurityStatInfoResponseBodyVulnerability> vulnerability{};

  DescribeSecurityStatInfoResponseBody() {}

  explicit DescribeSecurityStatInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityEvent) {
      res["SecurityEvent"] = securityEvent ? boost::any(securityEvent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (attackEvent) {
      res["AttackEvent"] = attackEvent ? boost::any(attackEvent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (healthCheck) {
      res["HealthCheck"] = healthCheck ? boost::any(healthCheck->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vulnerability) {
      res["Vulnerability"] = vulnerability ? boost::any(vulnerability->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityEvent") != m.end() && !m["SecurityEvent"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityEvent"].type()) {
        DescribeSecurityStatInfoResponseBodySecurityEvent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityEvent"]));
        securityEvent = make_shared<DescribeSecurityStatInfoResponseBodySecurityEvent>(model1);
      }
    }
    if (m.find("AttackEvent") != m.end() && !m["AttackEvent"].empty()) {
      if (typeid(map<string, boost::any>) == m["AttackEvent"].type()) {
        DescribeSecurityStatInfoResponseBodyAttackEvent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AttackEvent"]));
        attackEvent = make_shared<DescribeSecurityStatInfoResponseBodyAttackEvent>(model1);
      }
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      if (typeid(map<string, boost::any>) == m["HealthCheck"].type()) {
        DescribeSecurityStatInfoResponseBodyHealthCheck model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HealthCheck"]));
        healthCheck = make_shared<DescribeSecurityStatInfoResponseBodyHealthCheck>(model1);
      }
    }
    if (m.find("Vulnerability") != m.end() && !m["Vulnerability"].empty()) {
      if (typeid(map<string, boost::any>) == m["Vulnerability"].type()) {
        DescribeSecurityStatInfoResponseBodyVulnerability model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Vulnerability"]));
        vulnerability = make_shared<DescribeSecurityStatInfoResponseBodyVulnerability>(model1);
      }
    }
  }


  virtual ~DescribeSecurityStatInfoResponseBody() = default;
};
class DescribeSecurityStatInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSecurityStatInfoResponseBody> body{};

  DescribeSecurityStatInfoResponse() {}

  explicit DescribeSecurityStatInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecurityStatInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecurityStatInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecurityStatInfoResponse() = default;
};
class DescribeServiceLinkedRoleStatusResponseBodyRoleStatus : public Darabonba::Model {
public:
  shared_ptr<bool> status{};

  DescribeServiceLinkedRoleStatusResponseBodyRoleStatus() {}

  explicit DescribeServiceLinkedRoleStatusResponseBodyRoleStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
  }


  virtual ~DescribeServiceLinkedRoleStatusResponseBodyRoleStatus() = default;
};
class DescribeServiceLinkedRoleStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeServiceLinkedRoleStatusResponseBodyRoleStatus> roleStatus{};

  DescribeServiceLinkedRoleStatusResponseBody() {}

  explicit DescribeServiceLinkedRoleStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (roleStatus) {
      res["RoleStatus"] = roleStatus ? boost::any(roleStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RoleStatus") != m.end() && !m["RoleStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoleStatus"].type()) {
        DescribeServiceLinkedRoleStatusResponseBodyRoleStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoleStatus"]));
        roleStatus = make_shared<DescribeServiceLinkedRoleStatusResponseBodyRoleStatus>(model1);
      }
    }
  }


  virtual ~DescribeServiceLinkedRoleStatusResponseBody() = default;
};
class DescribeServiceLinkedRoleStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeServiceLinkedRoleStatusResponseBody> body{};

  DescribeServiceLinkedRoleStatusResponse() {}

  explicit DescribeServiceLinkedRoleStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeServiceLinkedRoleStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeServiceLinkedRoleStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeServiceLinkedRoleStatusResponse() = default;
};
class DescribeSimilarEventScenariosRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> securityEventId{};

  DescribeSimilarEventScenariosRequest() {}

  explicit DescribeSimilarEventScenariosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityEventId) {
      res["SecurityEventId"] = boost::any(*securityEventId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityEventId") != m.end() && !m["SecurityEventId"].empty()) {
      securityEventId = make_shared<long>(boost::any_cast<long>(m["SecurityEventId"]));
    }
  }


  virtual ~DescribeSimilarEventScenariosRequest() = default;
};
class DescribeSimilarEventScenariosResponseBodyScenarios : public Darabonba::Model {
public:
  shared_ptr<string> code{};

  DescribeSimilarEventScenariosResponseBodyScenarios() {}

  explicit DescribeSimilarEventScenariosResponseBodyScenarios(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~DescribeSimilarEventScenariosResponseBodyScenarios() = default;
};
class DescribeSimilarEventScenariosResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSimilarEventScenariosResponseBodyScenarios>> scenarios{};

  DescribeSimilarEventScenariosResponseBody() {}

  explicit DescribeSimilarEventScenariosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scenarios) {
      vector<boost::any> temp1;
      for(auto item1:*scenarios){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Scenarios"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Scenarios") != m.end() && !m["Scenarios"].empty()) {
      if (typeid(vector<boost::any>) == m["Scenarios"].type()) {
        vector<DescribeSimilarEventScenariosResponseBodyScenarios> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Scenarios"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSimilarEventScenariosResponseBodyScenarios model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scenarios = make_shared<vector<DescribeSimilarEventScenariosResponseBodyScenarios>>(expect1);
      }
    }
  }


  virtual ~DescribeSimilarEventScenariosResponseBody() = default;
};
class DescribeSimilarEventScenariosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSimilarEventScenariosResponseBody> body{};

  DescribeSimilarEventScenariosResponse() {}

  explicit DescribeSimilarEventScenariosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSimilarEventScenariosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSimilarEventScenariosResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSimilarEventScenariosResponse() = default;
};
class DescribeSimilarSecurityEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> lang{};
  shared_ptr<long> taskId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  DescribeSimilarSecurityEventsRequest() {}

  explicit DescribeSimilarSecurityEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeSimilarSecurityEventsRequest() = default;
};
class DescribeSimilarSecurityEventsResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribeSimilarSecurityEventsResponseBodyPageInfo() {}

  explicit DescribeSimilarSecurityEventsResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeSimilarSecurityEventsResponseBodyPageInfo() = default;
};
class DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse : public Darabonba::Model {
public:
  shared_ptr<long> lastTime{};
  shared_ptr<string> uuid{};
  shared_ptr<string> eventName{};
  shared_ptr<string> eventType{};
  shared_ptr<long> securityEventId{};
  shared_ptr<long> occurrenceTime{};

  DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse() {}

  explicit DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lastTime) {
      res["LastTime"] = boost::any(*lastTime);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (securityEventId) {
      res["SecurityEventId"] = boost::any(*securityEventId);
    }
    if (occurrenceTime) {
      res["OccurrenceTime"] = boost::any(*occurrenceTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LastTime") != m.end() && !m["LastTime"].empty()) {
      lastTime = make_shared<long>(boost::any_cast<long>(m["LastTime"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("SecurityEventId") != m.end() && !m["SecurityEventId"].empty()) {
      securityEventId = make_shared<long>(boost::any_cast<long>(m["SecurityEventId"]));
    }
    if (m.find("OccurrenceTime") != m.end() && !m["OccurrenceTime"].empty()) {
      occurrenceTime = make_shared<long>(boost::any_cast<long>(m["OccurrenceTime"]));
    }
  }


  virtual ~DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse() = default;
};
class DescribeSimilarSecurityEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSimilarSecurityEventsResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse>> securityEventsResponse{};

  DescribeSimilarSecurityEventsResponseBody() {}

  explicit DescribeSimilarSecurityEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (securityEventsResponse) {
      vector<boost::any> temp1;
      for(auto item1:*securityEventsResponse){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityEventsResponse"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeSimilarSecurityEventsResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeSimilarSecurityEventsResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("SecurityEventsResponse") != m.end() && !m["SecurityEventsResponse"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityEventsResponse"].type()) {
        vector<DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityEventsResponse"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityEventsResponse = make_shared<vector<DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse>>(expect1);
      }
    }
  }


  virtual ~DescribeSimilarSecurityEventsResponseBody() = default;
};
class DescribeSimilarSecurityEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSimilarSecurityEventsResponseBody> body{};

  DescribeSimilarSecurityEventsResponse() {}

  explicit DescribeSimilarSecurityEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSimilarSecurityEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSimilarSecurityEventsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSimilarSecurityEventsResponse() = default;
};
class DescribeSnapshotsRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> uuid{};
  shared_ptr<string> machineRegion{};
  shared_ptr<string> machineRemark{};
  shared_ptr<string> statusList{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> apiVersion{};
  shared_ptr<string> isAliYunEcs{};

  DescribeSnapshotsRequest() {}

  explicit DescribeSnapshotsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (machineRegion) {
      res["MachineRegion"] = boost::any(*machineRegion);
    }
    if (machineRemark) {
      res["MachineRemark"] = boost::any(*machineRemark);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (apiVersion) {
      res["ApiVersion"] = boost::any(*apiVersion);
    }
    if (isAliYunEcs) {
      res["IsAliYunEcs"] = boost::any(*isAliYunEcs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("MachineRegion") != m.end() && !m["MachineRegion"].empty()) {
      machineRegion = make_shared<string>(boost::any_cast<string>(m["MachineRegion"]));
    }
    if (m.find("MachineRemark") != m.end() && !m["MachineRemark"].empty()) {
      machineRemark = make_shared<string>(boost::any_cast<string>(m["MachineRemark"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      statusList = make_shared<string>(boost::any_cast<string>(m["StatusList"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ApiVersion") != m.end() && !m["ApiVersion"].empty()) {
      apiVersion = make_shared<string>(boost::any_cast<string>(m["ApiVersion"]));
    }
    if (m.find("IsAliYunEcs") != m.end() && !m["IsAliYunEcs"].empty()) {
      isAliYunEcs = make_shared<string>(boost::any_cast<string>(m["IsAliYunEcs"]));
    }
  }


  virtual ~DescribeSnapshotsRequest() = default;
};
class DescribeSnapshotsResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribeSnapshotsResponseBodyPageInfo() {}

  explicit DescribeSnapshotsResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeSnapshotsResponseBodyPageInfo() = default;
};
class DescribeSnapshotsResponseBodySnapshots : public Darabonba::Model {
public:
  shared_ptr<string> containerSnapshotId{};
  shared_ptr<string> status{};
  shared_ptr<string> snapshotHash{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> actualItems{};
  shared_ptr<string> vaultId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> backupType{};
  shared_ptr<long> actualBytes{};
  shared_ptr<string> prefix{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> extra{};
  shared_ptr<string> serverId{};
  shared_ptr<string> exitCode{};
  shared_ptr<string> clientId{};
  shared_ptr<long> itemsDone{};
  shared_ptr<long> bytesTotal{};
  shared_ptr<long> completeTime{};
  shared_ptr<long> retention{};
  shared_ptr<string> errorType{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> bucket{};
  shared_ptr<string> parentSnapshotHash{};
  shared_ptr<string> machineInfoJson{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> planId{};
  shared_ptr<string> source{};
  shared_ptr<string> regionId{};
  shared_ptr<string> fileSystemId{};
  shared_ptr<string> parentHash{};
  shared_ptr<long> startTime{};
  shared_ptr<string> uuid{};
  shared_ptr<string> errorFile{};
  shared_ptr<string> snapshotType{};
  shared_ptr<string> snapshotName{};
  shared_ptr<string> snapshotOption{};
  shared_ptr<long> updatedTime{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> size{};
  shared_ptr<string> path{};
  shared_ptr<long> errorCount{};
  shared_ptr<long> duration{};
  shared_ptr<long> itemsTotal{};
  shared_ptr<long> bytesDone{};
  shared_ptr<vector<string>> paths{};

  DescribeSnapshotsResponseBodySnapshots() {}

  explicit DescribeSnapshotsResponseBodySnapshots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerSnapshotId) {
      res["ContainerSnapshotId"] = boost::any(*containerSnapshotId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (snapshotHash) {
      res["SnapshotHash"] = boost::any(*snapshotHash);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (actualItems) {
      res["ActualItems"] = boost::any(*actualItems);
    }
    if (vaultId) {
      res["VaultId"] = boost::any(*vaultId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (backupType) {
      res["BackupType"] = boost::any(*backupType);
    }
    if (actualBytes) {
      res["ActualBytes"] = boost::any(*actualBytes);
    }
    if (prefix) {
      res["Prefix"] = boost::any(*prefix);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    if (exitCode) {
      res["ExitCode"] = boost::any(*exitCode);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (itemsDone) {
      res["ItemsDone"] = boost::any(*itemsDone);
    }
    if (bytesTotal) {
      res["BytesTotal"] = boost::any(*bytesTotal);
    }
    if (completeTime) {
      res["CompleteTime"] = boost::any(*completeTime);
    }
    if (retention) {
      res["Retention"] = boost::any(*retention);
    }
    if (errorType) {
      res["ErrorType"] = boost::any(*errorType);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (parentSnapshotHash) {
      res["ParentSnapshotHash"] = boost::any(*parentSnapshotHash);
    }
    if (machineInfoJson) {
      res["MachineInfoJson"] = boost::any(*machineInfoJson);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (planId) {
      res["PlanId"] = boost::any(*planId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (fileSystemId) {
      res["FileSystemId"] = boost::any(*fileSystemId);
    }
    if (parentHash) {
      res["ParentHash"] = boost::any(*parentHash);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (errorFile) {
      res["ErrorFile"] = boost::any(*errorFile);
    }
    if (snapshotType) {
      res["SnapshotType"] = boost::any(*snapshotType);
    }
    if (snapshotName) {
      res["SnapshotName"] = boost::any(*snapshotName);
    }
    if (snapshotOption) {
      res["SnapshotOption"] = boost::any(*snapshotOption);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (errorCount) {
      res["ErrorCount"] = boost::any(*errorCount);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (itemsTotal) {
      res["ItemsTotal"] = boost::any(*itemsTotal);
    }
    if (bytesDone) {
      res["BytesDone"] = boost::any(*bytesDone);
    }
    if (paths) {
      res["Paths"] = boost::any(*paths);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerSnapshotId") != m.end() && !m["ContainerSnapshotId"].empty()) {
      containerSnapshotId = make_shared<string>(boost::any_cast<string>(m["ContainerSnapshotId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SnapshotHash") != m.end() && !m["SnapshotHash"].empty()) {
      snapshotHash = make_shared<string>(boost::any_cast<string>(m["SnapshotHash"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ActualItems") != m.end() && !m["ActualItems"].empty()) {
      actualItems = make_shared<long>(boost::any_cast<long>(m["ActualItems"]));
    }
    if (m.find("VaultId") != m.end() && !m["VaultId"].empty()) {
      vaultId = make_shared<string>(boost::any_cast<string>(m["VaultId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("BackupType") != m.end() && !m["BackupType"].empty()) {
      backupType = make_shared<string>(boost::any_cast<string>(m["BackupType"]));
    }
    if (m.find("ActualBytes") != m.end() && !m["ActualBytes"].empty()) {
      actualBytes = make_shared<long>(boost::any_cast<long>(m["ActualBytes"]));
    }
    if (m.find("Prefix") != m.end() && !m["Prefix"].empty()) {
      prefix = make_shared<string>(boost::any_cast<string>(m["Prefix"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["Extra"]));
    }
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<string>(boost::any_cast<string>(m["ServerId"]));
    }
    if (m.find("ExitCode") != m.end() && !m["ExitCode"].empty()) {
      exitCode = make_shared<string>(boost::any_cast<string>(m["ExitCode"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("ItemsDone") != m.end() && !m["ItemsDone"].empty()) {
      itemsDone = make_shared<long>(boost::any_cast<long>(m["ItemsDone"]));
    }
    if (m.find("BytesTotal") != m.end() && !m["BytesTotal"].empty()) {
      bytesTotal = make_shared<long>(boost::any_cast<long>(m["BytesTotal"]));
    }
    if (m.find("CompleteTime") != m.end() && !m["CompleteTime"].empty()) {
      completeTime = make_shared<long>(boost::any_cast<long>(m["CompleteTime"]));
    }
    if (m.find("Retention") != m.end() && !m["Retention"].empty()) {
      retention = make_shared<long>(boost::any_cast<long>(m["Retention"]));
    }
    if (m.find("ErrorType") != m.end() && !m["ErrorType"].empty()) {
      errorType = make_shared<string>(boost::any_cast<string>(m["ErrorType"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("ParentSnapshotHash") != m.end() && !m["ParentSnapshotHash"].empty()) {
      parentSnapshotHash = make_shared<string>(boost::any_cast<string>(m["ParentSnapshotHash"]));
    }
    if (m.find("MachineInfoJson") != m.end() && !m["MachineInfoJson"].empty()) {
      machineInfoJson = make_shared<string>(boost::any_cast<string>(m["MachineInfoJson"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PlanId") != m.end() && !m["PlanId"].empty()) {
      planId = make_shared<string>(boost::any_cast<string>(m["PlanId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("FileSystemId") != m.end() && !m["FileSystemId"].empty()) {
      fileSystemId = make_shared<string>(boost::any_cast<string>(m["FileSystemId"]));
    }
    if (m.find("ParentHash") != m.end() && !m["ParentHash"].empty()) {
      parentHash = make_shared<string>(boost::any_cast<string>(m["ParentHash"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("ErrorFile") != m.end() && !m["ErrorFile"].empty()) {
      errorFile = make_shared<string>(boost::any_cast<string>(m["ErrorFile"]));
    }
    if (m.find("SnapshotType") != m.end() && !m["SnapshotType"].empty()) {
      snapshotType = make_shared<string>(boost::any_cast<string>(m["SnapshotType"]));
    }
    if (m.find("SnapshotName") != m.end() && !m["SnapshotName"].empty()) {
      snapshotName = make_shared<string>(boost::any_cast<string>(m["SnapshotName"]));
    }
    if (m.find("SnapshotOption") != m.end() && !m["SnapshotOption"].empty()) {
      snapshotOption = make_shared<string>(boost::any_cast<string>(m["SnapshotOption"]));
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["UpdatedTime"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ErrorCount") != m.end() && !m["ErrorCount"].empty()) {
      errorCount = make_shared<long>(boost::any_cast<long>(m["ErrorCount"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("ItemsTotal") != m.end() && !m["ItemsTotal"].empty()) {
      itemsTotal = make_shared<long>(boost::any_cast<long>(m["ItemsTotal"]));
    }
    if (m.find("BytesDone") != m.end() && !m["BytesDone"].empty()) {
      bytesDone = make_shared<long>(boost::any_cast<long>(m["BytesDone"]));
    }
    if (m.find("Paths") != m.end() && !m["Paths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Paths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Paths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      paths = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSnapshotsResponseBodySnapshots() = default;
};
class DescribeSnapshotsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSnapshotsResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribeSnapshotsResponseBodySnapshots>> snapshots{};

  DescribeSnapshotsResponseBody() {}

  explicit DescribeSnapshotsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (snapshots) {
      vector<boost::any> temp1;
      for(auto item1:*snapshots){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Snapshots"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeSnapshotsResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeSnapshotsResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      if (typeid(vector<boost::any>) == m["Snapshots"].type()) {
        vector<DescribeSnapshotsResponseBodySnapshots> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Snapshots"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSnapshotsResponseBodySnapshots model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshots = make_shared<vector<DescribeSnapshotsResponseBodySnapshots>>(expect1);
      }
    }
  }


  virtual ~DescribeSnapshotsResponseBody() = default;
};
class DescribeSnapshotsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSnapshotsResponseBody> body{};

  DescribeSnapshotsResponse() {}

  explicit DescribeSnapshotsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSnapshotsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSnapshotsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSnapshotsResponse() = default;
};
class DescribeStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};
  shared_ptr<string> strategyIds{};

  DescribeStrategyRequest() {}

  explicit DescribeStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (strategyIds) {
      res["StrategyIds"] = boost::any(*strategyIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StrategyIds") != m.end() && !m["StrategyIds"].empty()) {
      strategyIds = make_shared<string>(boost::any_cast<string>(m["StrategyIds"]));
    }
  }


  virtual ~DescribeStrategyRequest() = default;
};
class DescribeStrategyResponseBodyStrategiesConfigTargets : public Darabonba::Model {
public:
  shared_ptr<string> flag{};
  shared_ptr<string> target{};
  shared_ptr<string> targetType{};

  DescribeStrategyResponseBodyStrategiesConfigTargets() {}

  explicit DescribeStrategyResponseBodyStrategiesConfigTargets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<string>(boost::any_cast<string>(m["Flag"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~DescribeStrategyResponseBodyStrategiesConfigTargets() = default;
};
class DescribeStrategyResponseBodyStrategies : public Darabonba::Model {
public:
  shared_ptr<long> execStatus{};
  shared_ptr<long> type{};
  shared_ptr<long> cycleStartTime{};
  shared_ptr<long> ecsCount{};
  shared_ptr<long> processRate{};
  shared_ptr<long> cycleDays{};
  shared_ptr<long> riskCount{};
  shared_ptr<string> name{};
  shared_ptr<long> passRate{};
  shared_ptr<long> id{};
  shared_ptr<vector<DescribeStrategyResponseBodyStrategiesConfigTargets>> configTargets{};

  DescribeStrategyResponseBodyStrategies() {}

  explicit DescribeStrategyResponseBodyStrategies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (execStatus) {
      res["ExecStatus"] = boost::any(*execStatus);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (cycleStartTime) {
      res["CycleStartTime"] = boost::any(*cycleStartTime);
    }
    if (ecsCount) {
      res["EcsCount"] = boost::any(*ecsCount);
    }
    if (processRate) {
      res["ProcessRate"] = boost::any(*processRate);
    }
    if (cycleDays) {
      res["CycleDays"] = boost::any(*cycleDays);
    }
    if (riskCount) {
      res["RiskCount"] = boost::any(*riskCount);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (passRate) {
      res["PassRate"] = boost::any(*passRate);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (configTargets) {
      vector<boost::any> temp1;
      for(auto item1:*configTargets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigTargets"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExecStatus") != m.end() && !m["ExecStatus"].empty()) {
      execStatus = make_shared<long>(boost::any_cast<long>(m["ExecStatus"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("CycleStartTime") != m.end() && !m["CycleStartTime"].empty()) {
      cycleStartTime = make_shared<long>(boost::any_cast<long>(m["CycleStartTime"]));
    }
    if (m.find("EcsCount") != m.end() && !m["EcsCount"].empty()) {
      ecsCount = make_shared<long>(boost::any_cast<long>(m["EcsCount"]));
    }
    if (m.find("ProcessRate") != m.end() && !m["ProcessRate"].empty()) {
      processRate = make_shared<long>(boost::any_cast<long>(m["ProcessRate"]));
    }
    if (m.find("CycleDays") != m.end() && !m["CycleDays"].empty()) {
      cycleDays = make_shared<long>(boost::any_cast<long>(m["CycleDays"]));
    }
    if (m.find("RiskCount") != m.end() && !m["RiskCount"].empty()) {
      riskCount = make_shared<long>(boost::any_cast<long>(m["RiskCount"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PassRate") != m.end() && !m["PassRate"].empty()) {
      passRate = make_shared<long>(boost::any_cast<long>(m["PassRate"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ConfigTargets") != m.end() && !m["ConfigTargets"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigTargets"].type()) {
        vector<DescribeStrategyResponseBodyStrategiesConfigTargets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigTargets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStrategyResponseBodyStrategiesConfigTargets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configTargets = make_shared<vector<DescribeStrategyResponseBodyStrategiesConfigTargets>>(expect1);
      }
    }
  }


  virtual ~DescribeStrategyResponseBodyStrategies() = default;
};
class DescribeStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeStrategyResponseBodyStrategies>> strategies{};

  DescribeStrategyResponseBody() {}

  explicit DescribeStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (strategies) {
      vector<boost::any> temp1;
      for(auto item1:*strategies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Strategies"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Strategies") != m.end() && !m["Strategies"].empty()) {
      if (typeid(vector<boost::any>) == m["Strategies"].type()) {
        vector<DescribeStrategyResponseBodyStrategies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Strategies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStrategyResponseBodyStrategies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        strategies = make_shared<vector<DescribeStrategyResponseBodyStrategies>>(expect1);
      }
    }
  }


  virtual ~DescribeStrategyResponseBody() = default;
};
class DescribeStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeStrategyResponseBody> body{};

  DescribeStrategyResponse() {}

  explicit DescribeStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStrategyResponse() = default;
};
class DescribeStrategyExecDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> strategyId{};

  DescribeStrategyExecDetailRequest() {}

  explicit DescribeStrategyExecDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<long>(boost::any_cast<long>(m["StrategyId"]));
    }
  }


  virtual ~DescribeStrategyExecDetailRequest() = default;
};
class DescribeStrategyExecDetailResponseBodyFailedEcsList : public Darabonba::Model {
public:
  shared_ptr<string> IP{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> reason{};
  shared_ptr<string> instanceName{};

  DescribeStrategyExecDetailResponseBodyFailedEcsList() {}

  explicit DescribeStrategyExecDetailResponseBodyFailedEcsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
  }


  virtual ~DescribeStrategyExecDetailResponseBodyFailedEcsList() = default;
};
class DescribeStrategyExecDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> inProcessCount{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> percent{};
  shared_ptr<string> requestId{};
  shared_ptr<long> failCount{};
  shared_ptr<string> source{};
  shared_ptr<long> successCount{};
  shared_ptr<vector<DescribeStrategyExecDetailResponseBodyFailedEcsList>> failedEcsList{};

  DescribeStrategyExecDetailResponseBody() {}

  explicit DescribeStrategyExecDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inProcessCount) {
      res["InProcessCount"] = boost::any(*inProcessCount);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    if (failedEcsList) {
      vector<boost::any> temp1;
      for(auto item1:*failedEcsList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedEcsList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InProcessCount") != m.end() && !m["InProcessCount"].empty()) {
      inProcessCount = make_shared<long>(boost::any_cast<long>(m["InProcessCount"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<long>(boost::any_cast<long>(m["FailCount"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
    if (m.find("FailedEcsList") != m.end() && !m["FailedEcsList"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedEcsList"].type()) {
        vector<DescribeStrategyExecDetailResponseBodyFailedEcsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedEcsList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStrategyExecDetailResponseBodyFailedEcsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedEcsList = make_shared<vector<DescribeStrategyExecDetailResponseBodyFailedEcsList>>(expect1);
      }
    }
  }


  virtual ~DescribeStrategyExecDetailResponseBody() = default;
};
class DescribeStrategyExecDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeStrategyExecDetailResponseBody> body{};

  DescribeStrategyExecDetailResponse() {}

  explicit DescribeStrategyExecDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStrategyExecDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStrategyExecDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStrategyExecDetailResponse() = default;
};
class DescribeStrategyProcessRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> strategyId{};

  DescribeStrategyProcessRequest() {}

  explicit DescribeStrategyProcessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<long>(boost::any_cast<long>(m["StrategyId"]));
    }
  }


  virtual ~DescribeStrategyProcessRequest() = default;
};
class DescribeStrategyProcessResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> execStatus{};
  shared_ptr<long> processRate{};
  shared_ptr<long> strategyId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> passRate{};

  DescribeStrategyProcessResponseBody() {}

  explicit DescribeStrategyProcessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (execStatus) {
      res["ExecStatus"] = boost::any(*execStatus);
    }
    if (processRate) {
      res["ProcessRate"] = boost::any(*processRate);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (passRate) {
      res["PassRate"] = boost::any(*passRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExecStatus") != m.end() && !m["ExecStatus"].empty()) {
      execStatus = make_shared<long>(boost::any_cast<long>(m["ExecStatus"]));
    }
    if (m.find("ProcessRate") != m.end() && !m["ProcessRate"].empty()) {
      processRate = make_shared<long>(boost::any_cast<long>(m["ProcessRate"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<long>(boost::any_cast<long>(m["StrategyId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PassRate") != m.end() && !m["PassRate"].empty()) {
      passRate = make_shared<string>(boost::any_cast<string>(m["PassRate"]));
    }
  }


  virtual ~DescribeStrategyProcessResponseBody() = default;
};
class DescribeStrategyProcessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeStrategyProcessResponseBody> body{};

  DescribeStrategyProcessResponse() {}

  explicit DescribeStrategyProcessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStrategyProcessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStrategyProcessResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStrategyProcessResponse() = default;
};
class DescribeStrategyTargetRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> type{};
  shared_ptr<string> config{};

  DescribeStrategyTargetRequest() {}

  explicit DescribeStrategyTargetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
  }


  virtual ~DescribeStrategyTargetRequest() = default;
};
class DescribeStrategyTargetResponseBodyStrategyTargets : public Darabonba::Model {
public:
  shared_ptr<long> bindUuidCount{};
  shared_ptr<string> flag{};
  shared_ptr<string> target{};
  shared_ptr<string> targetType{};

  DescribeStrategyTargetResponseBodyStrategyTargets() {}

  explicit DescribeStrategyTargetResponseBodyStrategyTargets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindUuidCount) {
      res["BindUuidCount"] = boost::any(*bindUuidCount);
    }
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindUuidCount") != m.end() && !m["BindUuidCount"].empty()) {
      bindUuidCount = make_shared<long>(boost::any_cast<long>(m["BindUuidCount"]));
    }
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<string>(boost::any_cast<string>(m["Flag"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~DescribeStrategyTargetResponseBodyStrategyTargets() = default;
};
class DescribeStrategyTargetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeStrategyTargetResponseBodyStrategyTargets>> strategyTargets{};

  DescribeStrategyTargetResponseBody() {}

  explicit DescribeStrategyTargetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (strategyTargets) {
      vector<boost::any> temp1;
      for(auto item1:*strategyTargets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StrategyTargets"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StrategyTargets") != m.end() && !m["StrategyTargets"].empty()) {
      if (typeid(vector<boost::any>) == m["StrategyTargets"].type()) {
        vector<DescribeStrategyTargetResponseBodyStrategyTargets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StrategyTargets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStrategyTargetResponseBodyStrategyTargets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        strategyTargets = make_shared<vector<DescribeStrategyTargetResponseBodyStrategyTargets>>(expect1);
      }
    }
  }


  virtual ~DescribeStrategyTargetResponseBody() = default;
};
class DescribeStrategyTargetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeStrategyTargetResponseBody> body{};

  DescribeStrategyTargetResponse() {}

  explicit DescribeStrategyTargetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStrategyTargetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStrategyTargetResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStrategyTargetResponse() = default;
};
class DescribeSummaryInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};
  shared_ptr<string> resourceDirectoryAccountId{};

  DescribeSummaryInfoRequest() {}

  explicit DescribeSummaryInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (resourceDirectoryAccountId) {
      res["ResourceDirectoryAccountId"] = boost::any(*resourceDirectoryAccountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ResourceDirectoryAccountId") != m.end() && !m["ResourceDirectoryAccountId"].empty()) {
      resourceDirectoryAccountId = make_shared<string>(boost::any_cast<string>(m["ResourceDirectoryAccountId"]));
    }
  }


  virtual ~DescribeSummaryInfoRequest() = default;
};
class DescribeSummaryInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> aegisClientOfflineCount{};
  shared_ptr<long> aegisClientOnlineCount{};
  shared_ptr<long> securityScore{};

  DescribeSummaryInfoResponseBody() {}

  explicit DescribeSummaryInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (aegisClientOfflineCount) {
      res["AegisClientOfflineCount"] = boost::any(*aegisClientOfflineCount);
    }
    if (aegisClientOnlineCount) {
      res["AegisClientOnlineCount"] = boost::any(*aegisClientOnlineCount);
    }
    if (securityScore) {
      res["SecurityScore"] = boost::any(*securityScore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("AegisClientOfflineCount") != m.end() && !m["AegisClientOfflineCount"].empty()) {
      aegisClientOfflineCount = make_shared<long>(boost::any_cast<long>(m["AegisClientOfflineCount"]));
    }
    if (m.find("AegisClientOnlineCount") != m.end() && !m["AegisClientOnlineCount"].empty()) {
      aegisClientOnlineCount = make_shared<long>(boost::any_cast<long>(m["AegisClientOnlineCount"]));
    }
    if (m.find("SecurityScore") != m.end() && !m["SecurityScore"].empty()) {
      securityScore = make_shared<long>(boost::any_cast<long>(m["SecurityScore"]));
    }
  }


  virtual ~DescribeSummaryInfoResponseBody() = default;
};
class DescribeSummaryInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSummaryInfoResponseBody> body{};

  DescribeSummaryInfoResponse() {}

  explicit DescribeSummaryInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSummaryInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSummaryInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSummaryInfoResponse() = default;
};
class DescribeSupportRegionRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};

  DescribeSupportRegionRequest() {}

  explicit DescribeSupportRegionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DescribeSupportRegionRequest() = default;
};
class DescribeSupportRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> supportRegion{};

  DescribeSupportRegionResponseBody() {}

  explicit DescribeSupportRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (supportRegion) {
      res["SupportRegion"] = boost::any(*supportRegion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SupportRegion") != m.end() && !m["SupportRegion"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportRegion"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportRegion"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportRegion = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSupportRegionResponseBody() = default;
};
class DescribeSupportRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSupportRegionResponseBody> body{};

  DescribeSupportRegionResponse() {}

  explicit DescribeSupportRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSupportRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSupportRegionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSupportRegionResponse() = default;
};
class DescribeSuspEventDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};
  shared_ptr<long> suspiciousEventId{};
  shared_ptr<string> from{};

  DescribeSuspEventDetailRequest() {}

  explicit DescribeSuspEventDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (suspiciousEventId) {
      res["SuspiciousEventId"] = boost::any(*suspiciousEventId);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SuspiciousEventId") != m.end() && !m["SuspiciousEventId"].empty()) {
      suspiciousEventId = make_shared<long>(boost::any_cast<long>(m["SuspiciousEventId"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
  }


  virtual ~DescribeSuspEventDetailRequest() = default;
};
class DescribeSuspEventDetailResponseBodyDetails : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> value{};
  shared_ptr<string> name{};
  shared_ptr<string> infoType{};

  DescribeSuspEventDetailResponseBodyDetails() {}

  explicit DescribeSuspEventDetailResponseBodyDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (infoType) {
      res["InfoType"] = boost::any(*infoType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("InfoType") != m.end() && !m["InfoType"].empty()) {
      infoType = make_shared<string>(boost::any_cast<string>(m["InfoType"]));
    }
  }


  virtual ~DescribeSuspEventDetailResponseBodyDetails() = default;
};
class DescribeSuspEventDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataSource{};
  shared_ptr<string> eventName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> lastTime{};
  shared_ptr<string> operateMsg{};
  shared_ptr<string> uuid{};
  shared_ptr<bool> canBeDealOnLine{};
  shared_ptr<string> requestId{};
  shared_ptr<string> eventTypeDesc{};
  shared_ptr<string> eventDesc{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> eventStatus{};
  shared_ptr<string> saleVersion{};
  shared_ptr<string> operateErrorCode{};
  shared_ptr<string> sasId{};
  shared_ptr<string> level{};
  shared_ptr<long> id{};
  shared_ptr<vector<DescribeSuspEventDetailResponseBodyDetails>> details{};

  DescribeSuspEventDetailResponseBody() {}

  explicit DescribeSuspEventDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSource) {
      res["DataSource"] = boost::any(*dataSource);
    }
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (lastTime) {
      res["LastTime"] = boost::any(*lastTime);
    }
    if (operateMsg) {
      res["OperateMsg"] = boost::any(*operateMsg);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (canBeDealOnLine) {
      res["CanBeDealOnLine"] = boost::any(*canBeDealOnLine);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (eventTypeDesc) {
      res["EventTypeDesc"] = boost::any(*eventTypeDesc);
    }
    if (eventDesc) {
      res["EventDesc"] = boost::any(*eventDesc);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (eventStatus) {
      res["EventStatus"] = boost::any(*eventStatus);
    }
    if (saleVersion) {
      res["SaleVersion"] = boost::any(*saleVersion);
    }
    if (operateErrorCode) {
      res["OperateErrorCode"] = boost::any(*operateErrorCode);
    }
    if (sasId) {
      res["SasId"] = boost::any(*sasId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (details) {
      vector<boost::any> temp1;
      for(auto item1:*details){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Details"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      dataSource = make_shared<string>(boost::any_cast<string>(m["DataSource"]));
    }
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("LastTime") != m.end() && !m["LastTime"].empty()) {
      lastTime = make_shared<string>(boost::any_cast<string>(m["LastTime"]));
    }
    if (m.find("OperateMsg") != m.end() && !m["OperateMsg"].empty()) {
      operateMsg = make_shared<string>(boost::any_cast<string>(m["OperateMsg"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("CanBeDealOnLine") != m.end() && !m["CanBeDealOnLine"].empty()) {
      canBeDealOnLine = make_shared<bool>(boost::any_cast<bool>(m["CanBeDealOnLine"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("EventTypeDesc") != m.end() && !m["EventTypeDesc"].empty()) {
      eventTypeDesc = make_shared<string>(boost::any_cast<string>(m["EventTypeDesc"]));
    }
    if (m.find("EventDesc") != m.end() && !m["EventDesc"].empty()) {
      eventDesc = make_shared<string>(boost::any_cast<string>(m["EventDesc"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("EventStatus") != m.end() && !m["EventStatus"].empty()) {
      eventStatus = make_shared<string>(boost::any_cast<string>(m["EventStatus"]));
    }
    if (m.find("SaleVersion") != m.end() && !m["SaleVersion"].empty()) {
      saleVersion = make_shared<string>(boost::any_cast<string>(m["SaleVersion"]));
    }
    if (m.find("OperateErrorCode") != m.end() && !m["OperateErrorCode"].empty()) {
      operateErrorCode = make_shared<string>(boost::any_cast<string>(m["OperateErrorCode"]));
    }
    if (m.find("SasId") != m.end() && !m["SasId"].empty()) {
      sasId = make_shared<string>(boost::any_cast<string>(m["SasId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      if (typeid(vector<boost::any>) == m["Details"].type()) {
        vector<DescribeSuspEventDetailResponseBodyDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Details"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSuspEventDetailResponseBodyDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        details = make_shared<vector<DescribeSuspEventDetailResponseBodyDetails>>(expect1);
      }
    }
  }


  virtual ~DescribeSuspEventDetailResponseBody() = default;
};
class DescribeSuspEventDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSuspEventDetailResponseBody> body{};

  DescribeSuspEventDetailResponse() {}

  explicit DescribeSuspEventDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSuspEventDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSuspEventDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSuspEventDetailResponse() = default;
};
class DescribeSuspEventQuaraFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> status{};
  shared_ptr<string> groupId{};
  shared_ptr<string> quaraTag{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> from{};

  DescribeSuspEventQuaraFilesRequest() {}

  explicit DescribeSuspEventQuaraFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (quaraTag) {
      res["QuaraTag"] = boost::any(*quaraTag);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("QuaraTag") != m.end() && !m["QuaraTag"].empty()) {
      quaraTag = make_shared<string>(boost::any_cast<string>(m["QuaraTag"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["CurrentPage"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
  }


  virtual ~DescribeSuspEventQuaraFilesRequest() = default;
};
class DescribeSuspEventQuaraFilesResponseBodyQuaraFiles : public Darabonba::Model {
public:
  shared_ptr<string> link{};
  shared_ptr<string> status{};
  shared_ptr<string> eventName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> ip{};
  shared_ptr<string> tag{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> uuid{};
  shared_ptr<string> eventType{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> path{};
  shared_ptr<string> md5{};
  shared_ptr<long> id{};
  shared_ptr<string> modifyTime{};

  DescribeSuspEventQuaraFilesResponseBodyQuaraFiles() {}

  explicit DescribeSuspEventQuaraFilesResponseBodyQuaraFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (link) {
      res["Link"] = boost::any(*link);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Link") != m.end() && !m["Link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["Link"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
  }


  virtual ~DescribeSuspEventQuaraFilesResponseBodyQuaraFiles() = default;
};
class DescribeSuspEventQuaraFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeSuspEventQuaraFilesResponseBodyQuaraFiles>> quaraFiles{};

  DescribeSuspEventQuaraFilesResponseBody() {}

  explicit DescribeSuspEventQuaraFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (quaraFiles) {
      vector<boost::any> temp1;
      for(auto item1:*quaraFiles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QuaraFiles"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("QuaraFiles") != m.end() && !m["QuaraFiles"].empty()) {
      if (typeid(vector<boost::any>) == m["QuaraFiles"].type()) {
        vector<DescribeSuspEventQuaraFilesResponseBodyQuaraFiles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QuaraFiles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSuspEventQuaraFilesResponseBodyQuaraFiles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        quaraFiles = make_shared<vector<DescribeSuspEventQuaraFilesResponseBodyQuaraFiles>>(expect1);
      }
    }
  }


  virtual ~DescribeSuspEventQuaraFilesResponseBody() = default;
};
class DescribeSuspEventQuaraFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSuspEventQuaraFilesResponseBody> body{};

  DescribeSuspEventQuaraFilesResponse() {}

  explicit DescribeSuspEventQuaraFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSuspEventQuaraFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSuspEventQuaraFilesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSuspEventQuaraFilesResponse() = default;
};
class DescribeSuspEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> dealed{};
  shared_ptr<string> name{};
  shared_ptr<string> levels{};
  shared_ptr<string> parentEventTypes{};
  shared_ptr<string> remark{};
  shared_ptr<string> status{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> lang{};
  shared_ptr<string> alarmUniqueInfo{};
  shared_ptr<string> uniqueInfo{};
  shared_ptr<string> from{};
  shared_ptr<string> source{};
  shared_ptr<long> groupId{};
  shared_ptr<string> uuids{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> containerFieldName{};
  shared_ptr<string> containerFieldValue{};
  shared_ptr<string> targetType{};
  shared_ptr<vector<string>> operateErrorCodeList{};

  DescribeSuspEventsRequest() {}

  explicit DescribeSuspEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (dealed) {
      res["Dealed"] = boost::any(*dealed);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (levels) {
      res["Levels"] = boost::any(*levels);
    }
    if (parentEventTypes) {
      res["ParentEventTypes"] = boost::any(*parentEventTypes);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (alarmUniqueInfo) {
      res["AlarmUniqueInfo"] = boost::any(*alarmUniqueInfo);
    }
    if (uniqueInfo) {
      res["UniqueInfo"] = boost::any(*uniqueInfo);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (containerFieldName) {
      res["ContainerFieldName"] = boost::any(*containerFieldName);
    }
    if (containerFieldValue) {
      res["ContainerFieldValue"] = boost::any(*containerFieldValue);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (operateErrorCodeList) {
      res["OperateErrorCodeList"] = boost::any(*operateErrorCodeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Dealed") != m.end() && !m["Dealed"].empty()) {
      dealed = make_shared<string>(boost::any_cast<string>(m["Dealed"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Levels") != m.end() && !m["Levels"].empty()) {
      levels = make_shared<string>(boost::any_cast<string>(m["Levels"]));
    }
    if (m.find("ParentEventTypes") != m.end() && !m["ParentEventTypes"].empty()) {
      parentEventTypes = make_shared<string>(boost::any_cast<string>(m["ParentEventTypes"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["CurrentPage"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("AlarmUniqueInfo") != m.end() && !m["AlarmUniqueInfo"].empty()) {
      alarmUniqueInfo = make_shared<string>(boost::any_cast<string>(m["AlarmUniqueInfo"]));
    }
    if (m.find("UniqueInfo") != m.end() && !m["UniqueInfo"].empty()) {
      uniqueInfo = make_shared<string>(boost::any_cast<string>(m["UniqueInfo"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ContainerFieldName") != m.end() && !m["ContainerFieldName"].empty()) {
      containerFieldName = make_shared<string>(boost::any_cast<string>(m["ContainerFieldName"]));
    }
    if (m.find("ContainerFieldValue") != m.end() && !m["ContainerFieldValue"].empty()) {
      containerFieldValue = make_shared<string>(boost::any_cast<string>(m["ContainerFieldValue"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("OperateErrorCodeList") != m.end() && !m["OperateErrorCodeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OperateErrorCodeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OperateErrorCodeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      operateErrorCodeList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSuspEventsRequest() = default;
};
class DescribeSuspEventsResponseBodySuspEventsDetails : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> value{};
  shared_ptr<string> name{};
  shared_ptr<string> nameDisplay{};
  shared_ptr<string> infoType{};
  shared_ptr<string> valueDisplay{};

  DescribeSuspEventsResponseBodySuspEventsDetails() {}

  explicit DescribeSuspEventsResponseBodySuspEventsDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nameDisplay) {
      res["NameDisplay"] = boost::any(*nameDisplay);
    }
    if (infoType) {
      res["InfoType"] = boost::any(*infoType);
    }
    if (valueDisplay) {
      res["ValueDisplay"] = boost::any(*valueDisplay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NameDisplay") != m.end() && !m["NameDisplay"].empty()) {
      nameDisplay = make_shared<string>(boost::any_cast<string>(m["NameDisplay"]));
    }
    if (m.find("InfoType") != m.end() && !m["InfoType"].empty()) {
      infoType = make_shared<string>(boost::any_cast<string>(m["InfoType"]));
    }
    if (m.find("ValueDisplay") != m.end() && !m["ValueDisplay"].empty()) {
      valueDisplay = make_shared<string>(boost::any_cast<string>(m["ValueDisplay"]));
    }
  }


  virtual ~DescribeSuspEventsResponseBodySuspEventsDetails() = default;
};
class DescribeSuspEventsResponseBodySuspEventsEventNotes : public Darabonba::Model {
public:
  shared_ptr<string> note{};
  shared_ptr<long> noteId{};
  shared_ptr<string> noteTime{};

  DescribeSuspEventsResponseBodySuspEventsEventNotes() {}

  explicit DescribeSuspEventsResponseBodySuspEventsEventNotes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (noteId) {
      res["NoteId"] = boost::any(*noteId);
    }
    if (noteTime) {
      res["NoteTime"] = boost::any(*noteTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("NoteId") != m.end() && !m["NoteId"].empty()) {
      noteId = make_shared<long>(boost::any_cast<long>(m["NoteId"]));
    }
    if (m.find("NoteTime") != m.end() && !m["NoteTime"].empty()) {
      noteTime = make_shared<string>(boost::any_cast<string>(m["NoteTime"]));
    }
  }


  virtual ~DescribeSuspEventsResponseBodySuspEventsEventNotes() = default;
};
class DescribeSuspEventsResponseBodySuspEvents : public Darabonba::Model {
public:
  shared_ptr<string> stages{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> k8sClusterName{};
  shared_ptr<string> containerImageId{};
  shared_ptr<long> lastTimeStamp{};
  shared_ptr<string> occurrenceTime{};
  shared_ptr<string> alarmUniqueInfo{};
  shared_ptr<string> desc{};
  shared_ptr<bool> canCancelFault{};
  shared_ptr<string> alarmEventNameDisplay{};
  shared_ptr<string> appName{};
  shared_ptr<string> securityEventIds{};
  shared_ptr<string> k8sClusterId{};
  shared_ptr<string> containerImageName{};
  shared_ptr<string> markMisRules{};
  shared_ptr<bool> canBeDealOnLine{};
  shared_ptr<bool> containHwMode{};
  shared_ptr<string> k8sNodeId{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> eventStatus{};
  shared_ptr<string> saleVersion{};
  shared_ptr<string> operateErrorCode{};
  shared_ptr<string> name{};
  shared_ptr<bool> hasTraceInfo{};
  shared_ptr<string> dataSource{};
  shared_ptr<long> operateTime{};
  shared_ptr<string> eventSubType{};
  shared_ptr<bool> advanced{};
  shared_ptr<long> occurrenceTimeStamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> alarmEventTypeDisplay{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> lastTime{};
  shared_ptr<string> operateMsg{};
  shared_ptr<string> uuid{};
  shared_ptr<string> k8sPodName{};
  shared_ptr<string> containerId{};
  shared_ptr<string> alarmEventType{};
  shared_ptr<string> k8sNamespace{};
  shared_ptr<bool> autoBreaking{};
  shared_ptr<string> k8sNodeName{};
  shared_ptr<string> alarmEventName{};
  shared_ptr<string> uniqueInfo{};
  shared_ptr<string> level{};
  shared_ptr<long> id{};
  shared_ptr<vector<DescribeSuspEventsResponseBodySuspEventsDetails>> details{};
  shared_ptr<vector<DescribeSuspEventsResponseBodySuspEventsEventNotes>> eventNotes{};

  DescribeSuspEventsResponseBodySuspEvents() {}

  explicit DescribeSuspEventsResponseBodySuspEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stages) {
      res["Stages"] = boost::any(*stages);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (k8sClusterName) {
      res["K8sClusterName"] = boost::any(*k8sClusterName);
    }
    if (containerImageId) {
      res["ContainerImageId"] = boost::any(*containerImageId);
    }
    if (lastTimeStamp) {
      res["LastTimeStamp"] = boost::any(*lastTimeStamp);
    }
    if (occurrenceTime) {
      res["OccurrenceTime"] = boost::any(*occurrenceTime);
    }
    if (alarmUniqueInfo) {
      res["AlarmUniqueInfo"] = boost::any(*alarmUniqueInfo);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (canCancelFault) {
      res["CanCancelFault"] = boost::any(*canCancelFault);
    }
    if (alarmEventNameDisplay) {
      res["AlarmEventNameDisplay"] = boost::any(*alarmEventNameDisplay);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (securityEventIds) {
      res["SecurityEventIds"] = boost::any(*securityEventIds);
    }
    if (k8sClusterId) {
      res["K8sClusterId"] = boost::any(*k8sClusterId);
    }
    if (containerImageName) {
      res["ContainerImageName"] = boost::any(*containerImageName);
    }
    if (markMisRules) {
      res["MarkMisRules"] = boost::any(*markMisRules);
    }
    if (canBeDealOnLine) {
      res["CanBeDealOnLine"] = boost::any(*canBeDealOnLine);
    }
    if (containHwMode) {
      res["ContainHwMode"] = boost::any(*containHwMode);
    }
    if (k8sNodeId) {
      res["K8sNodeId"] = boost::any(*k8sNodeId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (eventStatus) {
      res["EventStatus"] = boost::any(*eventStatus);
    }
    if (saleVersion) {
      res["SaleVersion"] = boost::any(*saleVersion);
    }
    if (operateErrorCode) {
      res["OperateErrorCode"] = boost::any(*operateErrorCode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (hasTraceInfo) {
      res["HasTraceInfo"] = boost::any(*hasTraceInfo);
    }
    if (dataSource) {
      res["DataSource"] = boost::any(*dataSource);
    }
    if (operateTime) {
      res["OperateTime"] = boost::any(*operateTime);
    }
    if (eventSubType) {
      res["EventSubType"] = boost::any(*eventSubType);
    }
    if (advanced) {
      res["Advanced"] = boost::any(*advanced);
    }
    if (occurrenceTimeStamp) {
      res["OccurrenceTimeStamp"] = boost::any(*occurrenceTimeStamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (alarmEventTypeDisplay) {
      res["AlarmEventTypeDisplay"] = boost::any(*alarmEventTypeDisplay);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (lastTime) {
      res["LastTime"] = boost::any(*lastTime);
    }
    if (operateMsg) {
      res["OperateMsg"] = boost::any(*operateMsg);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (k8sPodName) {
      res["K8sPodName"] = boost::any(*k8sPodName);
    }
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (alarmEventType) {
      res["AlarmEventType"] = boost::any(*alarmEventType);
    }
    if (k8sNamespace) {
      res["K8sNamespace"] = boost::any(*k8sNamespace);
    }
    if (autoBreaking) {
      res["AutoBreaking"] = boost::any(*autoBreaking);
    }
    if (k8sNodeName) {
      res["K8sNodeName"] = boost::any(*k8sNodeName);
    }
    if (alarmEventName) {
      res["AlarmEventName"] = boost::any(*alarmEventName);
    }
    if (uniqueInfo) {
      res["UniqueInfo"] = boost::any(*uniqueInfo);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (details) {
      vector<boost::any> temp1;
      for(auto item1:*details){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Details"] = boost::any(temp1);
    }
    if (eventNotes) {
      vector<boost::any> temp1;
      for(auto item1:*eventNotes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventNotes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Stages") != m.end() && !m["Stages"].empty()) {
      stages = make_shared<string>(boost::any_cast<string>(m["Stages"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("K8sClusterName") != m.end() && !m["K8sClusterName"].empty()) {
      k8sClusterName = make_shared<string>(boost::any_cast<string>(m["K8sClusterName"]));
    }
    if (m.find("ContainerImageId") != m.end() && !m["ContainerImageId"].empty()) {
      containerImageId = make_shared<string>(boost::any_cast<string>(m["ContainerImageId"]));
    }
    if (m.find("LastTimeStamp") != m.end() && !m["LastTimeStamp"].empty()) {
      lastTimeStamp = make_shared<long>(boost::any_cast<long>(m["LastTimeStamp"]));
    }
    if (m.find("OccurrenceTime") != m.end() && !m["OccurrenceTime"].empty()) {
      occurrenceTime = make_shared<string>(boost::any_cast<string>(m["OccurrenceTime"]));
    }
    if (m.find("AlarmUniqueInfo") != m.end() && !m["AlarmUniqueInfo"].empty()) {
      alarmUniqueInfo = make_shared<string>(boost::any_cast<string>(m["AlarmUniqueInfo"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("CanCancelFault") != m.end() && !m["CanCancelFault"].empty()) {
      canCancelFault = make_shared<bool>(boost::any_cast<bool>(m["CanCancelFault"]));
    }
    if (m.find("AlarmEventNameDisplay") != m.end() && !m["AlarmEventNameDisplay"].empty()) {
      alarmEventNameDisplay = make_shared<string>(boost::any_cast<string>(m["AlarmEventNameDisplay"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("SecurityEventIds") != m.end() && !m["SecurityEventIds"].empty()) {
      securityEventIds = make_shared<string>(boost::any_cast<string>(m["SecurityEventIds"]));
    }
    if (m.find("K8sClusterId") != m.end() && !m["K8sClusterId"].empty()) {
      k8sClusterId = make_shared<string>(boost::any_cast<string>(m["K8sClusterId"]));
    }
    if (m.find("ContainerImageName") != m.end() && !m["ContainerImageName"].empty()) {
      containerImageName = make_shared<string>(boost::any_cast<string>(m["ContainerImageName"]));
    }
    if (m.find("MarkMisRules") != m.end() && !m["MarkMisRules"].empty()) {
      markMisRules = make_shared<string>(boost::any_cast<string>(m["MarkMisRules"]));
    }
    if (m.find("CanBeDealOnLine") != m.end() && !m["CanBeDealOnLine"].empty()) {
      canBeDealOnLine = make_shared<bool>(boost::any_cast<bool>(m["CanBeDealOnLine"]));
    }
    if (m.find("ContainHwMode") != m.end() && !m["ContainHwMode"].empty()) {
      containHwMode = make_shared<bool>(boost::any_cast<bool>(m["ContainHwMode"]));
    }
    if (m.find("K8sNodeId") != m.end() && !m["K8sNodeId"].empty()) {
      k8sNodeId = make_shared<string>(boost::any_cast<string>(m["K8sNodeId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("EventStatus") != m.end() && !m["EventStatus"].empty()) {
      eventStatus = make_shared<long>(boost::any_cast<long>(m["EventStatus"]));
    }
    if (m.find("SaleVersion") != m.end() && !m["SaleVersion"].empty()) {
      saleVersion = make_shared<string>(boost::any_cast<string>(m["SaleVersion"]));
    }
    if (m.find("OperateErrorCode") != m.end() && !m["OperateErrorCode"].empty()) {
      operateErrorCode = make_shared<string>(boost::any_cast<string>(m["OperateErrorCode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("HasTraceInfo") != m.end() && !m["HasTraceInfo"].empty()) {
      hasTraceInfo = make_shared<bool>(boost::any_cast<bool>(m["HasTraceInfo"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      dataSource = make_shared<string>(boost::any_cast<string>(m["DataSource"]));
    }
    if (m.find("OperateTime") != m.end() && !m["OperateTime"].empty()) {
      operateTime = make_shared<long>(boost::any_cast<long>(m["OperateTime"]));
    }
    if (m.find("EventSubType") != m.end() && !m["EventSubType"].empty()) {
      eventSubType = make_shared<string>(boost::any_cast<string>(m["EventSubType"]));
    }
    if (m.find("Advanced") != m.end() && !m["Advanced"].empty()) {
      advanced = make_shared<bool>(boost::any_cast<bool>(m["Advanced"]));
    }
    if (m.find("OccurrenceTimeStamp") != m.end() && !m["OccurrenceTimeStamp"].empty()) {
      occurrenceTimeStamp = make_shared<long>(boost::any_cast<long>(m["OccurrenceTimeStamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("AlarmEventTypeDisplay") != m.end() && !m["AlarmEventTypeDisplay"].empty()) {
      alarmEventTypeDisplay = make_shared<string>(boost::any_cast<string>(m["AlarmEventTypeDisplay"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("LastTime") != m.end() && !m["LastTime"].empty()) {
      lastTime = make_shared<string>(boost::any_cast<string>(m["LastTime"]));
    }
    if (m.find("OperateMsg") != m.end() && !m["OperateMsg"].empty()) {
      operateMsg = make_shared<string>(boost::any_cast<string>(m["OperateMsg"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("K8sPodName") != m.end() && !m["K8sPodName"].empty()) {
      k8sPodName = make_shared<string>(boost::any_cast<string>(m["K8sPodName"]));
    }
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<string>(boost::any_cast<string>(m["ContainerId"]));
    }
    if (m.find("AlarmEventType") != m.end() && !m["AlarmEventType"].empty()) {
      alarmEventType = make_shared<string>(boost::any_cast<string>(m["AlarmEventType"]));
    }
    if (m.find("K8sNamespace") != m.end() && !m["K8sNamespace"].empty()) {
      k8sNamespace = make_shared<string>(boost::any_cast<string>(m["K8sNamespace"]));
    }
    if (m.find("AutoBreaking") != m.end() && !m["AutoBreaking"].empty()) {
      autoBreaking = make_shared<bool>(boost::any_cast<bool>(m["AutoBreaking"]));
    }
    if (m.find("K8sNodeName") != m.end() && !m["K8sNodeName"].empty()) {
      k8sNodeName = make_shared<string>(boost::any_cast<string>(m["K8sNodeName"]));
    }
    if (m.find("AlarmEventName") != m.end() && !m["AlarmEventName"].empty()) {
      alarmEventName = make_shared<string>(boost::any_cast<string>(m["AlarmEventName"]));
    }
    if (m.find("UniqueInfo") != m.end() && !m["UniqueInfo"].empty()) {
      uniqueInfo = make_shared<string>(boost::any_cast<string>(m["UniqueInfo"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      if (typeid(vector<boost::any>) == m["Details"].type()) {
        vector<DescribeSuspEventsResponseBodySuspEventsDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Details"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSuspEventsResponseBodySuspEventsDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        details = make_shared<vector<DescribeSuspEventsResponseBodySuspEventsDetails>>(expect1);
      }
    }
    if (m.find("EventNotes") != m.end() && !m["EventNotes"].empty()) {
      if (typeid(vector<boost::any>) == m["EventNotes"].type()) {
        vector<DescribeSuspEventsResponseBodySuspEventsEventNotes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventNotes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSuspEventsResponseBodySuspEventsEventNotes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventNotes = make_shared<vector<DescribeSuspEventsResponseBodySuspEventsEventNotes>>(expect1);
      }
    }
  }


  virtual ~DescribeSuspEventsResponseBodySuspEvents() = default;
};
class DescribeSuspEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeSuspEventsResponseBodySuspEvents>> suspEvents{};

  DescribeSuspEventsResponseBody() {}

  explicit DescribeSuspEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (suspEvents) {
      vector<boost::any> temp1;
      for(auto item1:*suspEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SuspEvents"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("SuspEvents") != m.end() && !m["SuspEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["SuspEvents"].type()) {
        vector<DescribeSuspEventsResponseBodySuspEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SuspEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSuspEventsResponseBodySuspEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        suspEvents = make_shared<vector<DescribeSuspEventsResponseBodySuspEvents>>(expect1);
      }
    }
  }


  virtual ~DescribeSuspEventsResponseBody() = default;
};
class DescribeSuspEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSuspEventsResponseBody> body{};

  DescribeSuspEventsResponse() {}

  explicit DescribeSuspEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSuspEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSuspEventsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSuspEventsResponse() = default;
};
class DescribeUserBackupMachinesRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};

  DescribeUserBackupMachinesRequest() {}

  explicit DescribeUserBackupMachinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~DescribeUserBackupMachinesRequest() = default;
};
class DescribeUserBackupMachinesResponseBodyMachines : public Darabonba::Model {
public:
  shared_ptr<string> uuid{};
  shared_ptr<string> policyName{};
  shared_ptr<long> id{};

  DescribeUserBackupMachinesResponseBodyMachines() {}

  explicit DescribeUserBackupMachinesResponseBodyMachines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DescribeUserBackupMachinesResponseBodyMachines() = default;
};
class DescribeUserBackupMachinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeUserBackupMachinesResponseBodyMachines>> machines{};

  DescribeUserBackupMachinesResponseBody() {}

  explicit DescribeUserBackupMachinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (machines) {
      vector<boost::any> temp1;
      for(auto item1:*machines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Machines"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Machines") != m.end() && !m["Machines"].empty()) {
      if (typeid(vector<boost::any>) == m["Machines"].type()) {
        vector<DescribeUserBackupMachinesResponseBodyMachines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Machines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserBackupMachinesResponseBodyMachines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        machines = make_shared<vector<DescribeUserBackupMachinesResponseBodyMachines>>(expect1);
      }
    }
  }


  virtual ~DescribeUserBackupMachinesResponseBody() = default;
};
class DescribeUserBackupMachinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeUserBackupMachinesResponseBody> body{};

  DescribeUserBackupMachinesResponse() {}

  explicit DescribeUserBackupMachinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserBackupMachinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserBackupMachinesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserBackupMachinesResponse() = default;
};
class DescribeUserBaselineAuthorizationRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> lang{};

  DescribeUserBaselineAuthorizationRequest() {}

  explicit DescribeUserBaselineAuthorizationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeUserBaselineAuthorizationRequest() = default;
};
class DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization : public Darabonba::Model {
public:
  shared_ptr<long> status{};

  DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization() {}

  explicit DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization() = default;
};
class DescribeUserBaselineAuthorizationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization> userBaselineAuthorization{};

  DescribeUserBaselineAuthorizationResponseBody() {}

  explicit DescribeUserBaselineAuthorizationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userBaselineAuthorization) {
      res["UserBaselineAuthorization"] = userBaselineAuthorization ? boost::any(userBaselineAuthorization->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserBaselineAuthorization") != m.end() && !m["UserBaselineAuthorization"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserBaselineAuthorization"].type()) {
        DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserBaselineAuthorization"]));
        userBaselineAuthorization = make_shared<DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization>(model1);
      }
    }
  }


  virtual ~DescribeUserBaselineAuthorizationResponseBody() = default;
};
class DescribeUserBaselineAuthorizationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeUserBaselineAuthorizationResponseBody> body{};

  DescribeUserBaselineAuthorizationResponse() {}

  explicit DescribeUserBaselineAuthorizationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserBaselineAuthorizationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserBaselineAuthorizationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserBaselineAuthorizationResponse() = default;
};
class DescribeUserLayoutAuthorizationRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> lang{};

  DescribeUserLayoutAuthorizationRequest() {}

  explicit DescribeUserLayoutAuthorizationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeUserLayoutAuthorizationRequest() = default;
};
class DescribeUserLayoutAuthorizationResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> authorized{};
  shared_ptr<string> requestId{};

  DescribeUserLayoutAuthorizationResponseBody() {}

  explicit DescribeUserLayoutAuthorizationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorized) {
      res["Authorized"] = boost::any(*authorized);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Authorized") != m.end() && !m["Authorized"].empty()) {
      authorized = make_shared<bool>(boost::any_cast<bool>(m["Authorized"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUserLayoutAuthorizationResponseBody() = default;
};
class DescribeUserLayoutAuthorizationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeUserLayoutAuthorizationResponseBody> body{};

  DescribeUserLayoutAuthorizationResponse() {}

  explicit DescribeUserLayoutAuthorizationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserLayoutAuthorizationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserLayoutAuthorizationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserLayoutAuthorizationResponse() = default;
};
class DescribeUuidsByVulNamesRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> type{};
  shared_ptr<string> statusList{};
  shared_ptr<string> tag{};
  shared_ptr<string> level{};
  shared_ptr<string> dealed{};
  shared_ptr<long> groupId{};
  shared_ptr<string> vpcInstanceIds{};
  shared_ptr<string> remark{};
  shared_ptr<string> searchTags{};
  shared_ptr<string> fieldName{};
  shared_ptr<string> fieldValue{};
  shared_ptr<string> targetType{};
  shared_ptr<string> necessity{};
  shared_ptr<vector<string>> vulNames{};

  DescribeUuidsByVulNamesRequest() {}

  explicit DescribeUuidsByVulNamesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (dealed) {
      res["Dealed"] = boost::any(*dealed);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (vpcInstanceIds) {
      res["VpcInstanceIds"] = boost::any(*vpcInstanceIds);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (searchTags) {
      res["SearchTags"] = boost::any(*searchTags);
    }
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (fieldValue) {
      res["FieldValue"] = boost::any(*fieldValue);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (necessity) {
      res["Necessity"] = boost::any(*necessity);
    }
    if (vulNames) {
      res["VulNames"] = boost::any(*vulNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      statusList = make_shared<string>(boost::any_cast<string>(m["StatusList"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Dealed") != m.end() && !m["Dealed"].empty()) {
      dealed = make_shared<string>(boost::any_cast<string>(m["Dealed"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("VpcInstanceIds") != m.end() && !m["VpcInstanceIds"].empty()) {
      vpcInstanceIds = make_shared<string>(boost::any_cast<string>(m["VpcInstanceIds"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SearchTags") != m.end() && !m["SearchTags"].empty()) {
      searchTags = make_shared<string>(boost::any_cast<string>(m["SearchTags"]));
    }
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("FieldValue") != m.end() && !m["FieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["FieldValue"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("Necessity") != m.end() && !m["Necessity"].empty()) {
      necessity = make_shared<string>(boost::any_cast<string>(m["Necessity"]));
    }
    if (m.find("VulNames") != m.end() && !m["VulNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VulNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VulNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vulNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeUuidsByVulNamesRequest() = default;
};
class DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics : public Darabonba::Model {
public:
  shared_ptr<string> uuid{};
  shared_ptr<string> machineIp{};
  shared_ptr<string> os{};
  shared_ptr<string> machineName{};
  shared_ptr<string> machineInstanceId{};
  shared_ptr<string> regionId{};

  DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics() {}

  explicit DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (machineIp) {
      res["MachineIp"] = boost::any(*machineIp);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (machineName) {
      res["MachineName"] = boost::any(*machineName);
    }
    if (machineInstanceId) {
      res["MachineInstanceId"] = boost::any(*machineInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("MachineIp") != m.end() && !m["MachineIp"].empty()) {
      machineIp = make_shared<string>(boost::any_cast<string>(m["MachineIp"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("MachineName") != m.end() && !m["MachineName"].empty()) {
      machineName = make_shared<string>(boost::any_cast<string>(m["MachineName"]));
    }
    if (m.find("MachineInstanceId") != m.end() && !m["MachineInstanceId"].empty()) {
      machineInstanceId = make_shared<string>(boost::any_cast<string>(m["MachineInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics() = default;
};
class DescribeUuidsByVulNamesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics>> machineInfoStatistics{};

  DescribeUuidsByVulNamesResponseBody() {}

  explicit DescribeUuidsByVulNamesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (machineInfoStatistics) {
      vector<boost::any> temp1;
      for(auto item1:*machineInfoStatistics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MachineInfoStatistics"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("MachineInfoStatistics") != m.end() && !m["MachineInfoStatistics"].empty()) {
      if (typeid(vector<boost::any>) == m["MachineInfoStatistics"].type()) {
        vector<DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MachineInfoStatistics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        machineInfoStatistics = make_shared<vector<DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics>>(expect1);
      }
    }
  }


  virtual ~DescribeUuidsByVulNamesResponseBody() = default;
};
class DescribeUuidsByVulNamesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeUuidsByVulNamesResponseBody> body{};

  DescribeUuidsByVulNamesResponse() {}

  explicit DescribeUuidsByVulNamesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUuidsByVulNamesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUuidsByVulNamesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUuidsByVulNamesResponse() = default;
};
class DescribeVersionConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> resourceDirectoryAccountId{};

  DescribeVersionConfigRequest() {}

  explicit DescribeVersionConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceDirectoryAccountId) {
      res["ResourceDirectoryAccountId"] = boost::any(*resourceDirectoryAccountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceDirectoryAccountId") != m.end() && !m["ResourceDirectoryAccountId"].empty()) {
      resourceDirectoryAccountId = make_shared<string>(boost::any_cast<string>(m["ResourceDirectoryAccountId"]));
    }
  }


  virtual ~DescribeVersionConfigRequest() = default;
};
class DescribeVersionConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> MVAuthCount{};
  shared_ptr<long> sasLog{};
  shared_ptr<long> sasScreen{};
  shared_ptr<long> honeypotCapacity{};
  shared_ptr<long> MVUnusedAuthCount{};
  shared_ptr<long> webLock{};
  shared_ptr<long> appWhiteListAuthCount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> lastTrailEndTime{};
  shared_ptr<long> version{};
  shared_ptr<long> webLockAuthCount{};
  shared_ptr<long> releaseTime{};
  shared_ptr<long> highestVersion{};
  shared_ptr<long> assetLevel{};
  shared_ptr<bool> isOverBalance{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> slsCapacity{};
  shared_ptr<long> vmCores{};
  shared_ptr<long> allowPartialBuy{};
  shared_ptr<long> appWhiteList{};
  shared_ptr<long> imageScanCapacity{};
  shared_ptr<long> isTrialVersion{};
  shared_ptr<long> userDefinedAlarms{};

  DescribeVersionConfigResponseBody() {}

  explicit DescribeVersionConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (MVAuthCount) {
      res["MVAuthCount"] = boost::any(*MVAuthCount);
    }
    if (sasLog) {
      res["SasLog"] = boost::any(*sasLog);
    }
    if (sasScreen) {
      res["SasScreen"] = boost::any(*sasScreen);
    }
    if (honeypotCapacity) {
      res["HoneypotCapacity"] = boost::any(*honeypotCapacity);
    }
    if (MVUnusedAuthCount) {
      res["MVUnusedAuthCount"] = boost::any(*MVUnusedAuthCount);
    }
    if (webLock) {
      res["WebLock"] = boost::any(*webLock);
    }
    if (appWhiteListAuthCount) {
      res["AppWhiteListAuthCount"] = boost::any(*appWhiteListAuthCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (lastTrailEndTime) {
      res["LastTrailEndTime"] = boost::any(*lastTrailEndTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (webLockAuthCount) {
      res["WebLockAuthCount"] = boost::any(*webLockAuthCount);
    }
    if (releaseTime) {
      res["ReleaseTime"] = boost::any(*releaseTime);
    }
    if (highestVersion) {
      res["HighestVersion"] = boost::any(*highestVersion);
    }
    if (assetLevel) {
      res["AssetLevel"] = boost::any(*assetLevel);
    }
    if (isOverBalance) {
      res["IsOverBalance"] = boost::any(*isOverBalance);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (slsCapacity) {
      res["SlsCapacity"] = boost::any(*slsCapacity);
    }
    if (vmCores) {
      res["VmCores"] = boost::any(*vmCores);
    }
    if (allowPartialBuy) {
      res["AllowPartialBuy"] = boost::any(*allowPartialBuy);
    }
    if (appWhiteList) {
      res["AppWhiteList"] = boost::any(*appWhiteList);
    }
    if (imageScanCapacity) {
      res["ImageScanCapacity"] = boost::any(*imageScanCapacity);
    }
    if (isTrialVersion) {
      res["IsTrialVersion"] = boost::any(*isTrialVersion);
    }
    if (userDefinedAlarms) {
      res["UserDefinedAlarms"] = boost::any(*userDefinedAlarms);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MVAuthCount") != m.end() && !m["MVAuthCount"].empty()) {
      MVAuthCount = make_shared<long>(boost::any_cast<long>(m["MVAuthCount"]));
    }
    if (m.find("SasLog") != m.end() && !m["SasLog"].empty()) {
      sasLog = make_shared<long>(boost::any_cast<long>(m["SasLog"]));
    }
    if (m.find("SasScreen") != m.end() && !m["SasScreen"].empty()) {
      sasScreen = make_shared<long>(boost::any_cast<long>(m["SasScreen"]));
    }
    if (m.find("HoneypotCapacity") != m.end() && !m["HoneypotCapacity"].empty()) {
      honeypotCapacity = make_shared<long>(boost::any_cast<long>(m["HoneypotCapacity"]));
    }
    if (m.find("MVUnusedAuthCount") != m.end() && !m["MVUnusedAuthCount"].empty()) {
      MVUnusedAuthCount = make_shared<long>(boost::any_cast<long>(m["MVUnusedAuthCount"]));
    }
    if (m.find("WebLock") != m.end() && !m["WebLock"].empty()) {
      webLock = make_shared<long>(boost::any_cast<long>(m["WebLock"]));
    }
    if (m.find("AppWhiteListAuthCount") != m.end() && !m["AppWhiteListAuthCount"].empty()) {
      appWhiteListAuthCount = make_shared<long>(boost::any_cast<long>(m["AppWhiteListAuthCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("LastTrailEndTime") != m.end() && !m["LastTrailEndTime"].empty()) {
      lastTrailEndTime = make_shared<long>(boost::any_cast<long>(m["LastTrailEndTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
    if (m.find("WebLockAuthCount") != m.end() && !m["WebLockAuthCount"].empty()) {
      webLockAuthCount = make_shared<long>(boost::any_cast<long>(m["WebLockAuthCount"]));
    }
    if (m.find("ReleaseTime") != m.end() && !m["ReleaseTime"].empty()) {
      releaseTime = make_shared<long>(boost::any_cast<long>(m["ReleaseTime"]));
    }
    if (m.find("HighestVersion") != m.end() && !m["HighestVersion"].empty()) {
      highestVersion = make_shared<long>(boost::any_cast<long>(m["HighestVersion"]));
    }
    if (m.find("AssetLevel") != m.end() && !m["AssetLevel"].empty()) {
      assetLevel = make_shared<long>(boost::any_cast<long>(m["AssetLevel"]));
    }
    if (m.find("IsOverBalance") != m.end() && !m["IsOverBalance"].empty()) {
      isOverBalance = make_shared<bool>(boost::any_cast<bool>(m["IsOverBalance"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SlsCapacity") != m.end() && !m["SlsCapacity"].empty()) {
      slsCapacity = make_shared<long>(boost::any_cast<long>(m["SlsCapacity"]));
    }
    if (m.find("VmCores") != m.end() && !m["VmCores"].empty()) {
      vmCores = make_shared<long>(boost::any_cast<long>(m["VmCores"]));
    }
    if (m.find("AllowPartialBuy") != m.end() && !m["AllowPartialBuy"].empty()) {
      allowPartialBuy = make_shared<long>(boost::any_cast<long>(m["AllowPartialBuy"]));
    }
    if (m.find("AppWhiteList") != m.end() && !m["AppWhiteList"].empty()) {
      appWhiteList = make_shared<long>(boost::any_cast<long>(m["AppWhiteList"]));
    }
    if (m.find("ImageScanCapacity") != m.end() && !m["ImageScanCapacity"].empty()) {
      imageScanCapacity = make_shared<long>(boost::any_cast<long>(m["ImageScanCapacity"]));
    }
    if (m.find("IsTrialVersion") != m.end() && !m["IsTrialVersion"].empty()) {
      isTrialVersion = make_shared<long>(boost::any_cast<long>(m["IsTrialVersion"]));
    }
    if (m.find("UserDefinedAlarms") != m.end() && !m["UserDefinedAlarms"].empty()) {
      userDefinedAlarms = make_shared<long>(boost::any_cast<long>(m["UserDefinedAlarms"]));
    }
  }


  virtual ~DescribeVersionConfigResponseBody() = default;
};
class DescribeVersionConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeVersionConfigResponseBody> body{};

  DescribeVersionConfigResponse() {}

  explicit DescribeVersionConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVersionConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVersionConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVersionConfigResponse() = default;
};
class DescribeVolDingdingMessageRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};

  DescribeVolDingdingMessageRequest() {}

  explicit DescribeVolDingdingMessageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeVolDingdingMessageRequest() = default;
};
class DescribeVolDingdingMessageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dingdingUrl{};
  shared_ptr<string> requestId{};

  DescribeVolDingdingMessageResponseBody() {}

  explicit DescribeVolDingdingMessageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dingdingUrl) {
      res["DingdingUrl"] = boost::any(*dingdingUrl);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DingdingUrl") != m.end() && !m["DingdingUrl"].empty()) {
      dingdingUrl = make_shared<string>(boost::any_cast<string>(m["DingdingUrl"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVolDingdingMessageResponseBody() = default;
};
class DescribeVolDingdingMessageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeVolDingdingMessageResponseBody> body{};

  DescribeVolDingdingMessageResponse() {}

  explicit DescribeVolDingdingMessageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVolDingdingMessageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVolDingdingMessageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVolDingdingMessageResponse() = default;
};
class DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> name{};
  shared_ptr<string> values{};

  DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList() {}

  explicit DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      values = make_shared<string>(boost::any_cast<string>(m["Values"]));
    }
  }


  virtual ~DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList() = default;
};
class DescribeVpcHoneyPotCriteriaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList>> criteriaList{};

  DescribeVpcHoneyPotCriteriaResponseBody() {}

  explicit DescribeVpcHoneyPotCriteriaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (criteriaList) {
      vector<boost::any> temp1;
      for(auto item1:*criteriaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CriteriaList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CriteriaList") != m.end() && !m["CriteriaList"].empty()) {
      if (typeid(vector<boost::any>) == m["CriteriaList"].type()) {
        vector<DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CriteriaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        criteriaList = make_shared<vector<DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList>>(expect1);
      }
    }
  }


  virtual ~DescribeVpcHoneyPotCriteriaResponseBody() = default;
};
class DescribeVpcHoneyPotCriteriaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeVpcHoneyPotCriteriaResponseBody> body{};

  DescribeVpcHoneyPotCriteriaResponse() {}

  explicit DescribeVpcHoneyPotCriteriaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVpcHoneyPotCriteriaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVpcHoneyPotCriteriaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVpcHoneyPotCriteriaResponse() = default;
};
class DescribeVpcHoneyPotListRequest : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcName{};
  shared_ptr<string> vpcRegionId{};
  shared_ptr<bool> honeyPotExistence{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};

  DescribeVpcHoneyPotListRequest() {}

  explicit DescribeVpcHoneyPotListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    if (vpcRegionId) {
      res["VpcRegionId"] = boost::any(*vpcRegionId);
    }
    if (honeyPotExistence) {
      res["HoneyPotExistence"] = boost::any(*honeyPotExistence);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
    if (m.find("VpcRegionId") != m.end() && !m["VpcRegionId"].empty()) {
      vpcRegionId = make_shared<string>(boost::any_cast<string>(m["VpcRegionId"]));
    }
    if (m.find("HoneyPotExistence") != m.end() && !m["HoneyPotExistence"].empty()) {
      honeyPotExistence = make_shared<bool>(boost::any_cast<bool>(m["HoneyPotExistence"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~DescribeVpcHoneyPotListRequest() = default;
};
class DescribeVpcHoneyPotListResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};

  DescribeVpcHoneyPotListResponseBodyPageInfo() {}

  explicit DescribeVpcHoneyPotListResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeVpcHoneyPotListResponseBodyPageInfo() = default;
};
class DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList : public Darabonba::Model {
public:
  shared_ptr<string> vpcSwitchName{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> vpcSwitchId{};

  DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList() {}

  explicit DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcSwitchName) {
      res["VpcSwitchName"] = boost::any(*vpcSwitchName);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (vpcSwitchId) {
      res["VpcSwitchId"] = boost::any(*vpcSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcSwitchName") != m.end() && !m["VpcSwitchName"].empty()) {
      vpcSwitchName = make_shared<string>(boost::any_cast<string>(m["VpcSwitchName"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("VpcSwitchId") != m.end() && !m["VpcSwitchId"].empty()) {
      vpcSwitchId = make_shared<string>(boost::any_cast<string>(m["VpcSwitchId"]));
    }
  }


  virtual ~DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList() = default;
};
class DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList : public Darabonba::Model {
public:
  shared_ptr<string> vpcName{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> honeyPotEniInstanceId{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> vpcStatus{};
  shared_ptr<long> createTime{};
  shared_ptr<string> honeyPotVpcSwitchId{};
  shared_ptr<bool> honeyPotExistence{};
  shared_ptr<string> vpcRegionId{};
  shared_ptr<string> honeyPotEcsInstanceStatus{};
  shared_ptr<string> honeyPotInstanceStatus{};
  shared_ptr<vector<DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList>> vpcSwitchIdList{};

  DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList() {}

  explicit DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (honeyPotEniInstanceId) {
      res["HoneyPotEniInstanceId"] = boost::any(*honeyPotEniInstanceId);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (vpcStatus) {
      res["VpcStatus"] = boost::any(*vpcStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (honeyPotVpcSwitchId) {
      res["HoneyPotVpcSwitchId"] = boost::any(*honeyPotVpcSwitchId);
    }
    if (honeyPotExistence) {
      res["HoneyPotExistence"] = boost::any(*honeyPotExistence);
    }
    if (vpcRegionId) {
      res["VpcRegionId"] = boost::any(*vpcRegionId);
    }
    if (honeyPotEcsInstanceStatus) {
      res["HoneyPotEcsInstanceStatus"] = boost::any(*honeyPotEcsInstanceStatus);
    }
    if (honeyPotInstanceStatus) {
      res["HoneyPotInstanceStatus"] = boost::any(*honeyPotInstanceStatus);
    }
    if (vpcSwitchIdList) {
      vector<boost::any> temp1;
      for(auto item1:*vpcSwitchIdList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VpcSwitchIdList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("HoneyPotEniInstanceId") != m.end() && !m["HoneyPotEniInstanceId"].empty()) {
      honeyPotEniInstanceId = make_shared<string>(boost::any_cast<string>(m["HoneyPotEniInstanceId"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("VpcStatus") != m.end() && !m["VpcStatus"].empty()) {
      vpcStatus = make_shared<string>(boost::any_cast<string>(m["VpcStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("HoneyPotVpcSwitchId") != m.end() && !m["HoneyPotVpcSwitchId"].empty()) {
      honeyPotVpcSwitchId = make_shared<string>(boost::any_cast<string>(m["HoneyPotVpcSwitchId"]));
    }
    if (m.find("HoneyPotExistence") != m.end() && !m["HoneyPotExistence"].empty()) {
      honeyPotExistence = make_shared<bool>(boost::any_cast<bool>(m["HoneyPotExistence"]));
    }
    if (m.find("VpcRegionId") != m.end() && !m["VpcRegionId"].empty()) {
      vpcRegionId = make_shared<string>(boost::any_cast<string>(m["VpcRegionId"]));
    }
    if (m.find("HoneyPotEcsInstanceStatus") != m.end() && !m["HoneyPotEcsInstanceStatus"].empty()) {
      honeyPotEcsInstanceStatus = make_shared<string>(boost::any_cast<string>(m["HoneyPotEcsInstanceStatus"]));
    }
    if (m.find("HoneyPotInstanceStatus") != m.end() && !m["HoneyPotInstanceStatus"].empty()) {
      honeyPotInstanceStatus = make_shared<string>(boost::any_cast<string>(m["HoneyPotInstanceStatus"]));
    }
    if (m.find("VpcSwitchIdList") != m.end() && !m["VpcSwitchIdList"].empty()) {
      if (typeid(vector<boost::any>) == m["VpcSwitchIdList"].type()) {
        vector<DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VpcSwitchIdList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vpcSwitchIdList = make_shared<vector<DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList>>(expect1);
      }
    }
  }


  virtual ~DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList() = default;
};
class DescribeVpcHoneyPotListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeVpcHoneyPotListResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList>> vpcHoneyPotDTOList{};

  DescribeVpcHoneyPotListResponseBody() {}

  explicit DescribeVpcHoneyPotListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcHoneyPotDTOList) {
      vector<boost::any> temp1;
      for(auto item1:*vpcHoneyPotDTOList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VpcHoneyPotDTOList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeVpcHoneyPotListResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeVpcHoneyPotListResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("VpcHoneyPotDTOList") != m.end() && !m["VpcHoneyPotDTOList"].empty()) {
      if (typeid(vector<boost::any>) == m["VpcHoneyPotDTOList"].type()) {
        vector<DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VpcHoneyPotDTOList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vpcHoneyPotDTOList = make_shared<vector<DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList>>(expect1);
      }
    }
  }


  virtual ~DescribeVpcHoneyPotListResponseBody() = default;
};
class DescribeVpcHoneyPotListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeVpcHoneyPotListResponseBody> body{};

  DescribeVpcHoneyPotListResponse() {}

  explicit DescribeVpcHoneyPotListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVpcHoneyPotListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVpcHoneyPotListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVpcHoneyPotListResponse() = default;
};
class DescribeVpcListResponseBodyVpcList : public Darabonba::Model {
public:
  shared_ptr<string> instanceDesc{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> ecsCount{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  DescribeVpcListResponseBodyVpcList() {}

  explicit DescribeVpcListResponseBodyVpcList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceDesc) {
      res["InstanceDesc"] = boost::any(*instanceDesc);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (ecsCount) {
      res["EcsCount"] = boost::any(*ecsCount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceDesc") != m.end() && !m["InstanceDesc"].empty()) {
      instanceDesc = make_shared<string>(boost::any_cast<string>(m["InstanceDesc"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("EcsCount") != m.end() && !m["EcsCount"].empty()) {
      ecsCount = make_shared<long>(boost::any_cast<long>(m["EcsCount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeVpcListResponseBodyVpcList() = default;
};
class DescribeVpcListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeVpcListResponseBodyVpcList>> vpcList{};

  DescribeVpcListResponseBody() {}

  explicit DescribeVpcListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vpcList) {
      vector<boost::any> temp1;
      for(auto item1:*vpcList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VpcList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VpcList") != m.end() && !m["VpcList"].empty()) {
      if (typeid(vector<boost::any>) == m["VpcList"].type()) {
        vector<DescribeVpcListResponseBodyVpcList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VpcList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcListResponseBodyVpcList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vpcList = make_shared<vector<DescribeVpcListResponseBodyVpcList>>(expect1);
      }
    }
  }


  virtual ~DescribeVpcListResponseBody() = default;
};
class DescribeVpcListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeVpcListResponseBody> body{};

  DescribeVpcListResponse() {}

  explicit DescribeVpcListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVpcListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVpcListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVpcListResponse() = default;
};
class DescribeVulDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> type{};
  shared_ptr<string> name{};
  shared_ptr<string> aliasName{};

  DescribeVulDetailsRequest() {}

  explicit DescribeVulDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
  }


  virtual ~DescribeVulDetailsRequest() = default;
};
class DescribeVulDetailsResponseBodyCvesClassifys : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> classify{};
  shared_ptr<string> demoVideoUrl{};

  DescribeVulDetailsResponseBodyCvesClassifys() {}

  explicit DescribeVulDetailsResponseBodyCvesClassifys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (classify) {
      res["Classify"] = boost::any(*classify);
    }
    if (demoVideoUrl) {
      res["DemoVideoUrl"] = boost::any(*demoVideoUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Classify") != m.end() && !m["Classify"].empty()) {
      classify = make_shared<string>(boost::any_cast<string>(m["Classify"]));
    }
    if (m.find("DemoVideoUrl") != m.end() && !m["DemoVideoUrl"].empty()) {
      demoVideoUrl = make_shared<string>(boost::any_cast<string>(m["DemoVideoUrl"]));
    }
  }


  virtual ~DescribeVulDetailsResponseBodyCvesClassifys() = default;
};
class DescribeVulDetailsResponseBodyCves : public Darabonba::Model {
public:
  shared_ptr<string> summary{};
  shared_ptr<string> complexity{};
  shared_ptr<string> product{};
  shared_ptr<long> pocCreateTime{};
  shared_ptr<string> cveId{};
  shared_ptr<string> cnvdId{};
  shared_ptr<string> reference{};
  shared_ptr<string> cvssScore{};
  shared_ptr<string> vendor{};
  shared_ptr<long> pocDisclosureTime{};
  shared_ptr<string> classify{};
  shared_ptr<string> cvssVector{};
  shared_ptr<string> vulLevel{};
  shared_ptr<long> releaseTime{};
  shared_ptr<string> title{};
  shared_ptr<string> solution{};
  shared_ptr<string> content{};
  shared_ptr<string> poc{};
  shared_ptr<vector<DescribeVulDetailsResponseBodyCvesClassifys>> classifys{};

  DescribeVulDetailsResponseBodyCves() {}

  explicit DescribeVulDetailsResponseBodyCves(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (complexity) {
      res["Complexity"] = boost::any(*complexity);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (pocCreateTime) {
      res["PocCreateTime"] = boost::any(*pocCreateTime);
    }
    if (cveId) {
      res["CveId"] = boost::any(*cveId);
    }
    if (cnvdId) {
      res["CnvdId"] = boost::any(*cnvdId);
    }
    if (reference) {
      res["Reference"] = boost::any(*reference);
    }
    if (cvssScore) {
      res["CvssScore"] = boost::any(*cvssScore);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    if (pocDisclosureTime) {
      res["PocDisclosureTime"] = boost::any(*pocDisclosureTime);
    }
    if (classify) {
      res["Classify"] = boost::any(*classify);
    }
    if (cvssVector) {
      res["CvssVector"] = boost::any(*cvssVector);
    }
    if (vulLevel) {
      res["VulLevel"] = boost::any(*vulLevel);
    }
    if (releaseTime) {
      res["ReleaseTime"] = boost::any(*releaseTime);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (solution) {
      res["Solution"] = boost::any(*solution);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (poc) {
      res["Poc"] = boost::any(*poc);
    }
    if (classifys) {
      vector<boost::any> temp1;
      for(auto item1:*classifys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Classifys"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Complexity") != m.end() && !m["Complexity"].empty()) {
      complexity = make_shared<string>(boost::any_cast<string>(m["Complexity"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("PocCreateTime") != m.end() && !m["PocCreateTime"].empty()) {
      pocCreateTime = make_shared<long>(boost::any_cast<long>(m["PocCreateTime"]));
    }
    if (m.find("CveId") != m.end() && !m["CveId"].empty()) {
      cveId = make_shared<string>(boost::any_cast<string>(m["CveId"]));
    }
    if (m.find("CnvdId") != m.end() && !m["CnvdId"].empty()) {
      cnvdId = make_shared<string>(boost::any_cast<string>(m["CnvdId"]));
    }
    if (m.find("Reference") != m.end() && !m["Reference"].empty()) {
      reference = make_shared<string>(boost::any_cast<string>(m["Reference"]));
    }
    if (m.find("CvssScore") != m.end() && !m["CvssScore"].empty()) {
      cvssScore = make_shared<string>(boost::any_cast<string>(m["CvssScore"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
    if (m.find("PocDisclosureTime") != m.end() && !m["PocDisclosureTime"].empty()) {
      pocDisclosureTime = make_shared<long>(boost::any_cast<long>(m["PocDisclosureTime"]));
    }
    if (m.find("Classify") != m.end() && !m["Classify"].empty()) {
      classify = make_shared<string>(boost::any_cast<string>(m["Classify"]));
    }
    if (m.find("CvssVector") != m.end() && !m["CvssVector"].empty()) {
      cvssVector = make_shared<string>(boost::any_cast<string>(m["CvssVector"]));
    }
    if (m.find("VulLevel") != m.end() && !m["VulLevel"].empty()) {
      vulLevel = make_shared<string>(boost::any_cast<string>(m["VulLevel"]));
    }
    if (m.find("ReleaseTime") != m.end() && !m["ReleaseTime"].empty()) {
      releaseTime = make_shared<long>(boost::any_cast<long>(m["ReleaseTime"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Solution") != m.end() && !m["Solution"].empty()) {
      solution = make_shared<string>(boost::any_cast<string>(m["Solution"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Poc") != m.end() && !m["Poc"].empty()) {
      poc = make_shared<string>(boost::any_cast<string>(m["Poc"]));
    }
    if (m.find("Classifys") != m.end() && !m["Classifys"].empty()) {
      if (typeid(vector<boost::any>) == m["Classifys"].type()) {
        vector<DescribeVulDetailsResponseBodyCvesClassifys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Classifys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVulDetailsResponseBodyCvesClassifys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        classifys = make_shared<vector<DescribeVulDetailsResponseBodyCvesClassifys>>(expect1);
      }
    }
  }


  virtual ~DescribeVulDetailsResponseBodyCves() = default;
};
class DescribeVulDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeVulDetailsResponseBodyCves>> cves{};

  DescribeVulDetailsResponseBody() {}

  explicit DescribeVulDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (cves) {
      vector<boost::any> temp1;
      for(auto item1:*cves){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Cves"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Cves") != m.end() && !m["Cves"].empty()) {
      if (typeid(vector<boost::any>) == m["Cves"].type()) {
        vector<DescribeVulDetailsResponseBodyCves> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Cves"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVulDetailsResponseBodyCves model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cves = make_shared<vector<DescribeVulDetailsResponseBodyCves>>(expect1);
      }
    }
  }


  virtual ~DescribeVulDetailsResponseBody() = default;
};
class DescribeVulDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeVulDetailsResponseBody> body{};

  DescribeVulDetailsResponse() {}

  explicit DescribeVulDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVulDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVulDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVulDetailsResponse() = default;
};
class DescribeVulListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> remark{};
  shared_ptr<string> groupId{};
  shared_ptr<string> type{};
  shared_ptr<string> uuids{};
  shared_ptr<string> aliasName{};
  shared_ptr<string> necessity{};
  shared_ptr<string> dealed{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> attachTypes{};
  shared_ptr<string> vpcInstanceIds{};

  DescribeVulListRequest() {}

  explicit DescribeVulListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (necessity) {
      res["Necessity"] = boost::any(*necessity);
    }
    if (dealed) {
      res["Dealed"] = boost::any(*dealed);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (attachTypes) {
      res["AttachTypes"] = boost::any(*attachTypes);
    }
    if (vpcInstanceIds) {
      res["VpcInstanceIds"] = boost::any(*vpcInstanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("Necessity") != m.end() && !m["Necessity"].empty()) {
      necessity = make_shared<string>(boost::any_cast<string>(m["Necessity"]));
    }
    if (m.find("Dealed") != m.end() && !m["Dealed"].empty()) {
      dealed = make_shared<string>(boost::any_cast<string>(m["Dealed"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("AttachTypes") != m.end() && !m["AttachTypes"].empty()) {
      attachTypes = make_shared<string>(boost::any_cast<string>(m["AttachTypes"]));
    }
    if (m.find("VpcInstanceIds") != m.end() && !m["VpcInstanceIds"].empty()) {
      vpcInstanceIds = make_shared<string>(boost::any_cast<string>(m["VpcInstanceIds"]));
    }
  }


  virtual ~DescribeVulListRequest() = default;
};
class DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList : public Darabonba::Model {
public:
  shared_ptr<string> fullVersion{};
  shared_ptr<string> version{};
  shared_ptr<string> matchDetail{};
  shared_ptr<string> path{};
  shared_ptr<string> name{};
  shared_ptr<string> updateCmd{};

  DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList() {}

  explicit DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fullVersion) {
      res["FullVersion"] = boost::any(*fullVersion);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (matchDetail) {
      res["MatchDetail"] = boost::any(*matchDetail);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (updateCmd) {
      res["UpdateCmd"] = boost::any(*updateCmd);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FullVersion") != m.end() && !m["FullVersion"].empty()) {
      fullVersion = make_shared<string>(boost::any_cast<string>(m["FullVersion"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("MatchDetail") != m.end() && !m["MatchDetail"].empty()) {
      matchDetail = make_shared<string>(boost::any_cast<string>(m["MatchDetail"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpdateCmd") != m.end() && !m["UpdateCmd"].empty()) {
      updateCmd = make_shared<string>(boost::any_cast<string>(m["UpdateCmd"]));
    }
  }


  virtual ~DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList() = default;
};
class DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> timeFactor{};
  shared_ptr<string> enviromentFactor{};
  shared_ptr<string> isCalc{};
  shared_ptr<string> totalScore{};
  shared_ptr<string> cvssFactor{};
  shared_ptr<string> assetsFactor{};

  DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity() {}

  explicit DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (timeFactor) {
      res["Time_factor"] = boost::any(*timeFactor);
    }
    if (enviromentFactor) {
      res["Enviroment_factor"] = boost::any(*enviromentFactor);
    }
    if (isCalc) {
      res["Is_calc"] = boost::any(*isCalc);
    }
    if (totalScore) {
      res["Total_score"] = boost::any(*totalScore);
    }
    if (cvssFactor) {
      res["Cvss_factor"] = boost::any(*cvssFactor);
    }
    if (assetsFactor) {
      res["Assets_factor"] = boost::any(*assetsFactor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Time_factor") != m.end() && !m["Time_factor"].empty()) {
      timeFactor = make_shared<string>(boost::any_cast<string>(m["Time_factor"]));
    }
    if (m.find("Enviroment_factor") != m.end() && !m["Enviroment_factor"].empty()) {
      enviromentFactor = make_shared<string>(boost::any_cast<string>(m["Enviroment_factor"]));
    }
    if (m.find("Is_calc") != m.end() && !m["Is_calc"].empty()) {
      isCalc = make_shared<string>(boost::any_cast<string>(m["Is_calc"]));
    }
    if (m.find("Total_score") != m.end() && !m["Total_score"].empty()) {
      totalScore = make_shared<string>(boost::any_cast<string>(m["Total_score"]));
    }
    if (m.find("Cvss_factor") != m.end() && !m["Cvss_factor"].empty()) {
      cvssFactor = make_shared<string>(boost::any_cast<string>(m["Cvss_factor"]));
    }
    if (m.find("Assets_factor") != m.end() && !m["Assets_factor"].empty()) {
      assetsFactor = make_shared<string>(boost::any_cast<string>(m["Assets_factor"]));
    }
  }


  virtual ~DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity() = default;
};
class DescribeVulListResponseBodyVulRecordsExtendContentJson : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> ip{};
  shared_ptr<long> primaryId{};
  shared_ptr<string> os{};
  shared_ptr<string> tag{};
  shared_ptr<long> lastTs{};
  shared_ptr<string> osRelease{};
  shared_ptr<string> aliasName{};
  shared_ptr<string> absolutePath{};
  shared_ptr<vector<DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList>> rpmEntityList{};
  shared_ptr<vector<string>> cveList{};
  shared_ptr<DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity> necessity{};

  DescribeVulListResponseBodyVulRecordsExtendContentJson() {}

  explicit DescribeVulListResponseBodyVulRecordsExtendContentJson(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (primaryId) {
      res["PrimaryId"] = boost::any(*primaryId);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (lastTs) {
      res["LastTs"] = boost::any(*lastTs);
    }
    if (osRelease) {
      res["OsRelease"] = boost::any(*osRelease);
    }
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (absolutePath) {
      res["AbsolutePath"] = boost::any(*absolutePath);
    }
    if (rpmEntityList) {
      vector<boost::any> temp1;
      for(auto item1:*rpmEntityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RpmEntityList"] = boost::any(temp1);
    }
    if (cveList) {
      res["cveList"] = boost::any(*cveList);
    }
    if (necessity) {
      res["Necessity"] = necessity ? boost::any(necessity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("PrimaryId") != m.end() && !m["PrimaryId"].empty()) {
      primaryId = make_shared<long>(boost::any_cast<long>(m["PrimaryId"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("LastTs") != m.end() && !m["LastTs"].empty()) {
      lastTs = make_shared<long>(boost::any_cast<long>(m["LastTs"]));
    }
    if (m.find("OsRelease") != m.end() && !m["OsRelease"].empty()) {
      osRelease = make_shared<string>(boost::any_cast<string>(m["OsRelease"]));
    }
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("AbsolutePath") != m.end() && !m["AbsolutePath"].empty()) {
      absolutePath = make_shared<string>(boost::any_cast<string>(m["AbsolutePath"]));
    }
    if (m.find("RpmEntityList") != m.end() && !m["RpmEntityList"].empty()) {
      if (typeid(vector<boost::any>) == m["RpmEntityList"].type()) {
        vector<DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RpmEntityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rpmEntityList = make_shared<vector<DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList>>(expect1);
      }
    }
    if (m.find("cveList") != m.end() && !m["cveList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["cveList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["cveList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cveList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Necessity") != m.end() && !m["Necessity"].empty()) {
      if (typeid(map<string, boost::any>) == m["Necessity"].type()) {
        DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Necessity"]));
        necessity = make_shared<DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity>(model1);
      }
    }
  }


  virtual ~DescribeVulListResponseBodyVulRecordsExtendContentJson() = default;
};
class DescribeVulListResponseBodyVulRecords : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<string> type{};
  shared_ptr<long> modifyTs{};
  shared_ptr<string> internetIp{};
  shared_ptr<long> primaryId{};
  shared_ptr<string> tag{};
  shared_ptr<string> instanceName{};
  shared_ptr<bool> online{};
  shared_ptr<string> osVersion{};
  shared_ptr<string> name{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> related{};
  shared_ptr<string> intranetIp{};
  shared_ptr<long> lastTs{};
  shared_ptr<long> firstTs{};
  shared_ptr<string> necessity{};
  shared_ptr<long> repairTs{};
  shared_ptr<string> uuid{};
  shared_ptr<long> groupId{};
  shared_ptr<string> resultMessage{};
  shared_ptr<string> aliasName{};
  shared_ptr<DescribeVulListResponseBodyVulRecordsExtendContentJson> extendContentJson{};

  DescribeVulListResponseBodyVulRecords() {}

  explicit DescribeVulListResponseBodyVulRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (modifyTs) {
      res["ModifyTs"] = boost::any(*modifyTs);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (primaryId) {
      res["PrimaryId"] = boost::any(*primaryId);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (osVersion) {
      res["OsVersion"] = boost::any(*osVersion);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (related) {
      res["Related"] = boost::any(*related);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (lastTs) {
      res["LastTs"] = boost::any(*lastTs);
    }
    if (firstTs) {
      res["FirstTs"] = boost::any(*firstTs);
    }
    if (necessity) {
      res["Necessity"] = boost::any(*necessity);
    }
    if (repairTs) {
      res["RepairTs"] = boost::any(*repairTs);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (extendContentJson) {
      res["ExtendContentJson"] = extendContentJson ? boost::any(extendContentJson->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ModifyTs") != m.end() && !m["ModifyTs"].empty()) {
      modifyTs = make_shared<long>(boost::any_cast<long>(m["ModifyTs"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("PrimaryId") != m.end() && !m["PrimaryId"].empty()) {
      primaryId = make_shared<long>(boost::any_cast<long>(m["PrimaryId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<bool>(boost::any_cast<bool>(m["Online"]));
    }
    if (m.find("OsVersion") != m.end() && !m["OsVersion"].empty()) {
      osVersion = make_shared<string>(boost::any_cast<string>(m["OsVersion"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Related") != m.end() && !m["Related"].empty()) {
      related = make_shared<string>(boost::any_cast<string>(m["Related"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("LastTs") != m.end() && !m["LastTs"].empty()) {
      lastTs = make_shared<long>(boost::any_cast<long>(m["LastTs"]));
    }
    if (m.find("FirstTs") != m.end() && !m["FirstTs"].empty()) {
      firstTs = make_shared<long>(boost::any_cast<long>(m["FirstTs"]));
    }
    if (m.find("Necessity") != m.end() && !m["Necessity"].empty()) {
      necessity = make_shared<string>(boost::any_cast<string>(m["Necessity"]));
    }
    if (m.find("RepairTs") != m.end() && !m["RepairTs"].empty()) {
      repairTs = make_shared<long>(boost::any_cast<long>(m["RepairTs"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("ExtendContentJson") != m.end() && !m["ExtendContentJson"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtendContentJson"].type()) {
        DescribeVulListResponseBodyVulRecordsExtendContentJson model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtendContentJson"]));
        extendContentJson = make_shared<DescribeVulListResponseBodyVulRecordsExtendContentJson>(model1);
      }
    }
  }


  virtual ~DescribeVulListResponseBodyVulRecords() = default;
};
class DescribeVulListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribeVulListResponseBodyVulRecords>> vulRecords{};

  DescribeVulListResponseBody() {}

  explicit DescribeVulListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vulRecords) {
      vector<boost::any> temp1;
      for(auto item1:*vulRecords){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VulRecords"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VulRecords") != m.end() && !m["VulRecords"].empty()) {
      if (typeid(vector<boost::any>) == m["VulRecords"].type()) {
        vector<DescribeVulListResponseBodyVulRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VulRecords"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVulListResponseBodyVulRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vulRecords = make_shared<vector<DescribeVulListResponseBodyVulRecords>>(expect1);
      }
    }
  }


  virtual ~DescribeVulListResponseBody() = default;
};
class DescribeVulListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeVulListResponseBody> body{};

  DescribeVulListResponse() {}

  explicit DescribeVulListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVulListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVulListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVulListResponse() = default;
};
class DescribeVulWhitelistRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  DescribeVulWhitelistRequest() {}

  explicit DescribeVulWhitelistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeVulWhitelistRequest() = default;
};
class DescribeVulWhitelistResponseBodyVulWhitelists : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> aliasName{};
  shared_ptr<string> name{};
  shared_ptr<string> reason{};

  DescribeVulWhitelistResponseBodyVulWhitelists() {}

  explicit DescribeVulWhitelistResponseBodyVulWhitelists(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~DescribeVulWhitelistResponseBodyVulWhitelists() = default;
};
class DescribeVulWhitelistResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribeVulWhitelistResponseBodyVulWhitelists>> vulWhitelists{};

  DescribeVulWhitelistResponseBody() {}

  explicit DescribeVulWhitelistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vulWhitelists) {
      vector<boost::any> temp1;
      for(auto item1:*vulWhitelists){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VulWhitelists"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VulWhitelists") != m.end() && !m["VulWhitelists"].empty()) {
      if (typeid(vector<boost::any>) == m["VulWhitelists"].type()) {
        vector<DescribeVulWhitelistResponseBodyVulWhitelists> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VulWhitelists"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVulWhitelistResponseBodyVulWhitelists model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vulWhitelists = make_shared<vector<DescribeVulWhitelistResponseBodyVulWhitelists>>(expect1);
      }
    }
  }


  virtual ~DescribeVulWhitelistResponseBody() = default;
};
class DescribeVulWhitelistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeVulWhitelistResponseBody> body{};

  DescribeVulWhitelistResponse() {}

  explicit DescribeVulWhitelistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVulWhitelistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVulWhitelistResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVulWhitelistResponse() = default;
};
class DescribeWarningMachinesRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};
  shared_ptr<string> machineName{};
  shared_ptr<string> uuids{};
  shared_ptr<long> riskId{};
  shared_ptr<long> strategyId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};

  DescribeWarningMachinesRequest() {}

  explicit DescribeWarningMachinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (machineName) {
      res["MachineName"] = boost::any(*machineName);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    if (riskId) {
      res["RiskId"] = boost::any(*riskId);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("MachineName") != m.end() && !m["MachineName"].empty()) {
      machineName = make_shared<string>(boost::any_cast<string>(m["MachineName"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
    if (m.find("RiskId") != m.end() && !m["RiskId"].empty()) {
      riskId = make_shared<long>(boost::any_cast<long>(m["RiskId"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<long>(boost::any_cast<long>(m["StrategyId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
  }


  virtual ~DescribeWarningMachinesRequest() = default;
};
class DescribeWarningMachinesResponseBodyWarningMachines : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<long> lowWarningCount{};
  shared_ptr<string> uuid{};
  shared_ptr<long> mediumWarningCount{};
  shared_ptr<long> passCount{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> highWarningCount{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> regionId{};

  DescribeWarningMachinesResponseBodyWarningMachines() {}

  explicit DescribeWarningMachinesResponseBodyWarningMachines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (lowWarningCount) {
      res["LowWarningCount"] = boost::any(*lowWarningCount);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (mediumWarningCount) {
      res["MediumWarningCount"] = boost::any(*mediumWarningCount);
    }
    if (passCount) {
      res["PassCount"] = boost::any(*passCount);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (highWarningCount) {
      res["HighWarningCount"] = boost::any(*highWarningCount);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("LowWarningCount") != m.end() && !m["LowWarningCount"].empty()) {
      lowWarningCount = make_shared<long>(boost::any_cast<long>(m["LowWarningCount"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("MediumWarningCount") != m.end() && !m["MediumWarningCount"].empty()) {
      mediumWarningCount = make_shared<long>(boost::any_cast<long>(m["MediumWarningCount"]));
    }
    if (m.find("PassCount") != m.end() && !m["PassCount"].empty()) {
      passCount = make_shared<long>(boost::any_cast<long>(m["PassCount"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("HighWarningCount") != m.end() && !m["HighWarningCount"].empty()) {
      highWarningCount = make_shared<long>(boost::any_cast<long>(m["HighWarningCount"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeWarningMachinesResponseBodyWarningMachines() = default;
};
class DescribeWarningMachinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeWarningMachinesResponseBodyWarningMachines>> warningMachines{};

  DescribeWarningMachinesResponseBody() {}

  explicit DescribeWarningMachinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (warningMachines) {
      vector<boost::any> temp1;
      for(auto item1:*warningMachines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WarningMachines"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("WarningMachines") != m.end() && !m["WarningMachines"].empty()) {
      if (typeid(vector<boost::any>) == m["WarningMachines"].type()) {
        vector<DescribeWarningMachinesResponseBodyWarningMachines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WarningMachines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWarningMachinesResponseBodyWarningMachines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        warningMachines = make_shared<vector<DescribeWarningMachinesResponseBodyWarningMachines>>(expect1);
      }
    }
  }


  virtual ~DescribeWarningMachinesResponseBody() = default;
};
class DescribeWarningMachinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeWarningMachinesResponseBody> body{};

  DescribeWarningMachinesResponse() {}

  explicit DescribeWarningMachinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWarningMachinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWarningMachinesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWarningMachinesResponse() = default;
};
class DescribeWebLockBindListRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};
  shared_ptr<string> remark{};
  shared_ptr<string> status{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  DescribeWebLockBindListRequest() {}

  explicit DescribeWebLockBindListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeWebLockBindListRequest() = default;
};
class DescribeWebLockBindListResponseBodyBindList : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> percent{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> serviceDetail{};
  shared_ptr<string> os{};
  shared_ptr<string> serviceStatus{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> auditCount{};
  shared_ptr<string> uuid{};
  shared_ptr<string> serviceCode{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> dirCount{};
  shared_ptr<string> blockCount{};

  DescribeWebLockBindListResponseBodyBindList() {}

  explicit DescribeWebLockBindListResponseBodyBindList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (serviceDetail) {
      res["ServiceDetail"] = boost::any(*serviceDetail);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (serviceStatus) {
      res["ServiceStatus"] = boost::any(*serviceStatus);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (auditCount) {
      res["AuditCount"] = boost::any(*auditCount);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (serviceCode) {
      res["ServiceCode"] = boost::any(*serviceCode);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (dirCount) {
      res["DirCount"] = boost::any(*dirCount);
    }
    if (blockCount) {
      res["BlockCount"] = boost::any(*blockCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("ServiceDetail") != m.end() && !m["ServiceDetail"].empty()) {
      serviceDetail = make_shared<string>(boost::any_cast<string>(m["ServiceDetail"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("ServiceStatus") != m.end() && !m["ServiceStatus"].empty()) {
      serviceStatus = make_shared<string>(boost::any_cast<string>(m["ServiceStatus"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("AuditCount") != m.end() && !m["AuditCount"].empty()) {
      auditCount = make_shared<string>(boost::any_cast<string>(m["AuditCount"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("ServiceCode") != m.end() && !m["ServiceCode"].empty()) {
      serviceCode = make_shared<string>(boost::any_cast<string>(m["ServiceCode"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("DirCount") != m.end() && !m["DirCount"].empty()) {
      dirCount = make_shared<string>(boost::any_cast<string>(m["DirCount"]));
    }
    if (m.find("BlockCount") != m.end() && !m["BlockCount"].empty()) {
      blockCount = make_shared<string>(boost::any_cast<string>(m["BlockCount"]));
    }
  }


  virtual ~DescribeWebLockBindListResponseBodyBindList() = default;
};
class DescribeWebLockBindListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribeWebLockBindListResponseBodyBindList>> bindList{};

  DescribeWebLockBindListResponseBody() {}

  explicit DescribeWebLockBindListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (bindList) {
      vector<boost::any> temp1;
      for(auto item1:*bindList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BindList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("BindList") != m.end() && !m["BindList"].empty()) {
      if (typeid(vector<boost::any>) == m["BindList"].type()) {
        vector<DescribeWebLockBindListResponseBodyBindList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BindList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebLockBindListResponseBodyBindList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bindList = make_shared<vector<DescribeWebLockBindListResponseBodyBindList>>(expect1);
      }
    }
  }


  virtual ~DescribeWebLockBindListResponseBody() = default;
};
class DescribeWebLockBindListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeWebLockBindListResponseBody> body{};

  DescribeWebLockBindListResponse() {}

  explicit DescribeWebLockBindListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebLockBindListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebLockBindListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebLockBindListResponse() = default;
};
class DescribeWebLockConfigListRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};
  shared_ptr<string> uuid{};

  DescribeWebLockConfigListRequest() {}

  explicit DescribeWebLockConfigListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeWebLockConfigListRequest() = default;
};
class DescribeWebLockConfigListResponseBodyConfigList : public Darabonba::Model {
public:
  shared_ptr<string> exclusiveDir{};
  shared_ptr<string> uuid{};
  shared_ptr<string> inclusiveFileType{};
  shared_ptr<string> defenceMode{};
  shared_ptr<string> exclusiveFileType{};
  shared_ptr<string> inclusiveFile{};
  shared_ptr<string> mode{};
  shared_ptr<string> dir{};
  shared_ptr<string> exclusiveFile{};
  shared_ptr<string> id{};
  shared_ptr<string> localBackupDir{};

  DescribeWebLockConfigListResponseBodyConfigList() {}

  explicit DescribeWebLockConfigListResponseBodyConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exclusiveDir) {
      res["ExclusiveDir"] = boost::any(*exclusiveDir);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (inclusiveFileType) {
      res["InclusiveFileType"] = boost::any(*inclusiveFileType);
    }
    if (defenceMode) {
      res["DefenceMode"] = boost::any(*defenceMode);
    }
    if (exclusiveFileType) {
      res["ExclusiveFileType"] = boost::any(*exclusiveFileType);
    }
    if (inclusiveFile) {
      res["InclusiveFile"] = boost::any(*inclusiveFile);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (dir) {
      res["Dir"] = boost::any(*dir);
    }
    if (exclusiveFile) {
      res["ExclusiveFile"] = boost::any(*exclusiveFile);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (localBackupDir) {
      res["LocalBackupDir"] = boost::any(*localBackupDir);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExclusiveDir") != m.end() && !m["ExclusiveDir"].empty()) {
      exclusiveDir = make_shared<string>(boost::any_cast<string>(m["ExclusiveDir"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("InclusiveFileType") != m.end() && !m["InclusiveFileType"].empty()) {
      inclusiveFileType = make_shared<string>(boost::any_cast<string>(m["InclusiveFileType"]));
    }
    if (m.find("DefenceMode") != m.end() && !m["DefenceMode"].empty()) {
      defenceMode = make_shared<string>(boost::any_cast<string>(m["DefenceMode"]));
    }
    if (m.find("ExclusiveFileType") != m.end() && !m["ExclusiveFileType"].empty()) {
      exclusiveFileType = make_shared<string>(boost::any_cast<string>(m["ExclusiveFileType"]));
    }
    if (m.find("InclusiveFile") != m.end() && !m["InclusiveFile"].empty()) {
      inclusiveFile = make_shared<string>(boost::any_cast<string>(m["InclusiveFile"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Dir") != m.end() && !m["Dir"].empty()) {
      dir = make_shared<string>(boost::any_cast<string>(m["Dir"]));
    }
    if (m.find("ExclusiveFile") != m.end() && !m["ExclusiveFile"].empty()) {
      exclusiveFile = make_shared<string>(boost::any_cast<string>(m["ExclusiveFile"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LocalBackupDir") != m.end() && !m["LocalBackupDir"].empty()) {
      localBackupDir = make_shared<string>(boost::any_cast<string>(m["LocalBackupDir"]));
    }
  }


  virtual ~DescribeWebLockConfigListResponseBodyConfigList() = default;
};
class DescribeWebLockConfigListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeWebLockConfigListResponseBodyConfigList>> configList{};

  DescribeWebLockConfigListResponseBody() {}

  explicit DescribeWebLockConfigListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (configList) {
      vector<boost::any> temp1;
      for(auto item1:*configList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ConfigList") != m.end() && !m["ConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigList"].type()) {
        vector<DescribeWebLockConfigListResponseBodyConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebLockConfigListResponseBodyConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configList = make_shared<vector<DescribeWebLockConfigListResponseBodyConfigList>>(expect1);
      }
    }
  }


  virtual ~DescribeWebLockConfigListResponseBody() = default;
};
class DescribeWebLockConfigListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeWebLockConfigListResponseBody> body{};

  DescribeWebLockConfigListResponse() {}

  explicit DescribeWebLockConfigListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebLockConfigListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebLockConfigListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebLockConfigListResponse() = default;
};
class ExecStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};
  shared_ptr<long> strategyId{};

  ExecStrategyRequest() {}

  explicit ExecStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<long>(boost::any_cast<long>(m["StrategyId"]));
    }
  }


  virtual ~ExecStrategyRequest() = default;
};
class ExecStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ExecStrategyResponseBody() {}

  explicit ExecStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ExecStrategyResponseBody() = default;
};
class ExecStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ExecStrategyResponseBody> body{};

  ExecStrategyResponse() {}

  explicit ExecStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~ExecStrategyResponse() = default;
};
class ExportRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> params{};
  shared_ptr<string> exportType{};

  ExportRecordRequest() {}

  explicit ExportRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (exportType) {
      res["ExportType"] = boost::any(*exportType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("ExportType") != m.end() && !m["ExportType"].empty()) {
      exportType = make_shared<string>(boost::any_cast<string>(m["ExportType"]));
    }
  }


  virtual ~ExportRecordRequest() = default;
};
class ExportRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> fileName{};
  shared_ptr<long> id{};

  ExportRecordResponseBody() {}

  explicit ExportRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~ExportRecordResponseBody() = default;
};
class ExportRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ExportRecordResponseBody> body{};

  ExportRecordResponse() {}

  explicit ExportRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportRecordResponseBody>(model1);
      }
    }
  }


  virtual ~ExportRecordResponse() = default;
};
class FixCheckWarningsRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};
  shared_ptr<long> riskId{};
  shared_ptr<string> checkParams{};
  shared_ptr<string> uuids{};

  FixCheckWarningsRequest() {}

  explicit FixCheckWarningsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (riskId) {
      res["RiskId"] = boost::any(*riskId);
    }
    if (checkParams) {
      res["CheckParams"] = boost::any(*checkParams);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RiskId") != m.end() && !m["RiskId"].empty()) {
      riskId = make_shared<long>(boost::any_cast<long>(m["RiskId"]));
    }
    if (m.find("CheckParams") != m.end() && !m["CheckParams"].empty()) {
      checkParams = make_shared<string>(boost::any_cast<string>(m["CheckParams"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~FixCheckWarningsRequest() = default;
};
class FixCheckWarningsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> batchId{};
  shared_ptr<string> requestId{};

  FixCheckWarningsResponseBody() {}

  explicit FixCheckWarningsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchId) {
      res["BatchId"] = boost::any(*batchId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchId") != m.end() && !m["BatchId"].empty()) {
      batchId = make_shared<long>(boost::any_cast<long>(m["BatchId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~FixCheckWarningsResponseBody() = default;
};
class FixCheckWarningsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<FixCheckWarningsResponseBody> body{};

  FixCheckWarningsResponse() {}

  explicit FixCheckWarningsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FixCheckWarningsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FixCheckWarningsResponseBody>(model1);
      }
    }
  }


  virtual ~FixCheckWarningsResponse() = default;
};
class GetBackupStorageCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};

  GetBackupStorageCountRequest() {}

  explicit GetBackupStorageCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~GetBackupStorageCountRequest() = default;
};
class GetBackupStorageCountResponseBodyBackupStorageCount : public Darabonba::Model {
public:
  shared_ptr<long> overflow{};
  shared_ptr<long> buyStorageByte{};
  shared_ptr<long> usageStorageByte{};

  GetBackupStorageCountResponseBodyBackupStorageCount() {}

  explicit GetBackupStorageCountResponseBodyBackupStorageCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overflow) {
      res["Overflow"] = boost::any(*overflow);
    }
    if (buyStorageByte) {
      res["BuyStorageByte"] = boost::any(*buyStorageByte);
    }
    if (usageStorageByte) {
      res["UsageStorageByte"] = boost::any(*usageStorageByte);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Overflow") != m.end() && !m["Overflow"].empty()) {
      overflow = make_shared<long>(boost::any_cast<long>(m["Overflow"]));
    }
    if (m.find("BuyStorageByte") != m.end() && !m["BuyStorageByte"].empty()) {
      buyStorageByte = make_shared<long>(boost::any_cast<long>(m["BuyStorageByte"]));
    }
    if (m.find("UsageStorageByte") != m.end() && !m["UsageStorageByte"].empty()) {
      usageStorageByte = make_shared<long>(boost::any_cast<long>(m["UsageStorageByte"]));
    }
  }


  virtual ~GetBackupStorageCountResponseBodyBackupStorageCount() = default;
};
class GetBackupStorageCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetBackupStorageCountResponseBodyBackupStorageCount> backupStorageCount{};

  GetBackupStorageCountResponseBody() {}

  explicit GetBackupStorageCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (backupStorageCount) {
      res["BackupStorageCount"] = backupStorageCount ? boost::any(backupStorageCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("BackupStorageCount") != m.end() && !m["BackupStorageCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["BackupStorageCount"].type()) {
        GetBackupStorageCountResponseBodyBackupStorageCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BackupStorageCount"]));
        backupStorageCount = make_shared<GetBackupStorageCountResponseBodyBackupStorageCount>(model1);
      }
    }
  }


  virtual ~GetBackupStorageCountResponseBody() = default;
};
class GetBackupStorageCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetBackupStorageCountResponseBody> body{};

  GetBackupStorageCountResponse() {}

  explicit GetBackupStorageCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBackupStorageCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBackupStorageCountResponseBody>(model1);
      }
    }
  }


  virtual ~GetBackupStorageCountResponse() = default;
};
class GetIncIOCsRequest : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> date{};

  GetIncIOCsRequest() {}

  explicit GetIncIOCsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (date) {
      res["Date"] = boost::any(*date);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
  }


  virtual ~GetIncIOCsRequest() = default;
};
class GetIncIOCsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  GetIncIOCsResponseBody() {}

  explicit GetIncIOCsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetIncIOCsResponseBody() = default;
};
class GetIncIOCsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetIncIOCsResponseBody> body{};

  GetIncIOCsResponse() {}

  explicit GetIncIOCsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetIncIOCsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetIncIOCsResponseBody>(model1);
      }
    }
  }


  virtual ~GetIncIOCsResponse() = default;
};
class GetIOCsRequest : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> date{};

  GetIOCsRequest() {}

  explicit GetIOCsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (date) {
      res["Date"] = boost::any(*date);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
  }


  virtual ~GetIOCsRequest() = default;
};
class GetIOCsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  GetIOCsResponseBody() {}

  explicit GetIOCsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetIOCsResponseBody() = default;
};
class GetIOCsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetIOCsResponseBody> body{};

  GetIOCsResponse() {}

  explicit GetIOCsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetIOCsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetIOCsResponseBody>(model1);
      }
    }
  }


  virtual ~GetIOCsResponse() = default;
};
class GetLocalInstallScriptRequest : public Darabonba::Model {
public:
  shared_ptr<string> platformType{};
  shared_ptr<string> uuid{};
  shared_ptr<bool> internalNetwork{};

  GetLocalInstallScriptRequest() {}

  explicit GetLocalInstallScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (platformType) {
      res["PlatformType"] = boost::any(*platformType);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (internalNetwork) {
      res["InternalNetwork"] = boost::any(*internalNetwork);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PlatformType") != m.end() && !m["PlatformType"].empty()) {
      platformType = make_shared<string>(boost::any_cast<string>(m["PlatformType"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("InternalNetwork") != m.end() && !m["InternalNetwork"].empty()) {
      internalNetwork = make_shared<bool>(boost::any_cast<bool>(m["InternalNetwork"]));
    }
  }


  virtual ~GetLocalInstallScriptRequest() = default;
};
class GetLocalInstallScriptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> script{};
  shared_ptr<string> requestId{};

  GetLocalInstallScriptResponseBody() {}

  explicit GetLocalInstallScriptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (script) {
      res["Script"] = boost::any(*script);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetLocalInstallScriptResponseBody() = default;
};
class GetLocalInstallScriptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetLocalInstallScriptResponseBody> body{};

  GetLocalInstallScriptResponse() {}

  explicit GetLocalInstallScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLocalInstallScriptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLocalInstallScriptResponseBody>(model1);
      }
    }
  }


  virtual ~GetLocalInstallScriptResponse() = default;
};
class GetLocalUninstallScriptRequest : public Darabonba::Model {
public:
  shared_ptr<string> platformType{};
  shared_ptr<string> uuid{};
  shared_ptr<bool> internalNetwork{};

  GetLocalUninstallScriptRequest() {}

  explicit GetLocalUninstallScriptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (platformType) {
      res["PlatformType"] = boost::any(*platformType);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (internalNetwork) {
      res["InternalNetwork"] = boost::any(*internalNetwork);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PlatformType") != m.end() && !m["PlatformType"].empty()) {
      platformType = make_shared<string>(boost::any_cast<string>(m["PlatformType"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("InternalNetwork") != m.end() && !m["InternalNetwork"].empty()) {
      internalNetwork = make_shared<bool>(boost::any_cast<bool>(m["InternalNetwork"]));
    }
  }


  virtual ~GetLocalUninstallScriptRequest() = default;
};
class GetLocalUninstallScriptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> script{};
  shared_ptr<string> requestId{};

  GetLocalUninstallScriptResponseBody() {}

  explicit GetLocalUninstallScriptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (script) {
      res["Script"] = boost::any(*script);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetLocalUninstallScriptResponseBody() = default;
};
class GetLocalUninstallScriptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetLocalUninstallScriptResponseBody> body{};

  GetLocalUninstallScriptResponse() {}

  explicit GetLocalUninstallScriptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLocalUninstallScriptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLocalUninstallScriptResponseBody>(model1);
      }
    }
  }


  virtual ~GetLocalUninstallScriptResponse() = default;
};
class GetSuspiciousStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> groupIdList{};

  GetSuspiciousStatisticsRequest() {}

  explicit GetSuspiciousStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (groupIdList) {
      res["GroupIdList"] = boost::any(*groupIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("GroupIdList") != m.end() && !m["GroupIdList"].empty()) {
      groupIdList = make_shared<string>(boost::any_cast<string>(m["GroupIdList"]));
    }
  }


  virtual ~GetSuspiciousStatisticsRequest() = default;
};
class GetSuspiciousStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> suspiciousCount{};
  shared_ptr<long> remindCount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> seriousCount{};
  shared_ptr<long> totalCount{};

  GetSuspiciousStatisticsResponseBody() {}

  explicit GetSuspiciousStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suspiciousCount) {
      res["SuspiciousCount"] = boost::any(*suspiciousCount);
    }
    if (remindCount) {
      res["RemindCount"] = boost::any(*remindCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (seriousCount) {
      res["SeriousCount"] = boost::any(*seriousCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SuspiciousCount") != m.end() && !m["SuspiciousCount"].empty()) {
      suspiciousCount = make_shared<long>(boost::any_cast<long>(m["SuspiciousCount"]));
    }
    if (m.find("RemindCount") != m.end() && !m["RemindCount"].empty()) {
      remindCount = make_shared<long>(boost::any_cast<long>(m["RemindCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SeriousCount") != m.end() && !m["SeriousCount"].empty()) {
      seriousCount = make_shared<long>(boost::any_cast<long>(m["SeriousCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetSuspiciousStatisticsResponseBody() = default;
};
class GetSuspiciousStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetSuspiciousStatisticsResponseBody> body{};

  GetSuspiciousStatisticsResponse() {}

  explicit GetSuspiciousStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSuspiciousStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSuspiciousStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~GetSuspiciousStatisticsResponse() = default;
};
class GetVulStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> groupIdList{};
  shared_ptr<string> typeList{};

  GetVulStatisticsRequest() {}

  explicit GetVulStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (groupIdList) {
      res["GroupIdList"] = boost::any(*groupIdList);
    }
    if (typeList) {
      res["TypeList"] = boost::any(*typeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("GroupIdList") != m.end() && !m["GroupIdList"].empty()) {
      groupIdList = make_shared<string>(boost::any_cast<string>(m["GroupIdList"]));
    }
    if (m.find("TypeList") != m.end() && !m["TypeList"].empty()) {
      typeList = make_shared<string>(boost::any_cast<string>(m["TypeList"]));
    }
  }


  virtual ~GetVulStatisticsRequest() = default;
};
class GetVulStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> vulLaterSum{};
  shared_ptr<long> vulNntfSum{};
  shared_ptr<long> vulAsapSum{};

  GetVulStatisticsResponseBody() {}

  explicit GetVulStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vulLaterSum) {
      res["VulLaterSum"] = boost::any(*vulLaterSum);
    }
    if (vulNntfSum) {
      res["VulNntfSum"] = boost::any(*vulNntfSum);
    }
    if (vulAsapSum) {
      res["VulAsapSum"] = boost::any(*vulAsapSum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VulLaterSum") != m.end() && !m["VulLaterSum"].empty()) {
      vulLaterSum = make_shared<long>(boost::any_cast<long>(m["VulLaterSum"]));
    }
    if (m.find("VulNntfSum") != m.end() && !m["VulNntfSum"].empty()) {
      vulNntfSum = make_shared<long>(boost::any_cast<long>(m["VulNntfSum"]));
    }
    if (m.find("VulAsapSum") != m.end() && !m["VulAsapSum"].empty()) {
      vulAsapSum = make_shared<long>(boost::any_cast<long>(m["VulAsapSum"]));
    }
  }


  virtual ~GetVulStatisticsResponseBody() = default;
};
class GetVulStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetVulStatisticsResponseBody> body{};

  GetVulStatisticsResponse() {}

  explicit GetVulStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVulStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVulStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~GetVulStatisticsResponse() = default;
};
class HandleSecurityEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> operationCode{};
  shared_ptr<string> operationParams{};
  shared_ptr<string> markMissParam{};
  shared_ptr<string> markBatch{};
  shared_ptr<vector<string>> securityEventIds{};

  HandleSecurityEventsRequest() {}

  explicit HandleSecurityEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (operationCode) {
      res["OperationCode"] = boost::any(*operationCode);
    }
    if (operationParams) {
      res["OperationParams"] = boost::any(*operationParams);
    }
    if (markMissParam) {
      res["MarkMissParam"] = boost::any(*markMissParam);
    }
    if (markBatch) {
      res["MarkBatch"] = boost::any(*markBatch);
    }
    if (securityEventIds) {
      res["SecurityEventIds"] = boost::any(*securityEventIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OperationCode") != m.end() && !m["OperationCode"].empty()) {
      operationCode = make_shared<string>(boost::any_cast<string>(m["OperationCode"]));
    }
    if (m.find("OperationParams") != m.end() && !m["OperationParams"].empty()) {
      operationParams = make_shared<string>(boost::any_cast<string>(m["OperationParams"]));
    }
    if (m.find("MarkMissParam") != m.end() && !m["MarkMissParam"].empty()) {
      markMissParam = make_shared<string>(boost::any_cast<string>(m["MarkMissParam"]));
    }
    if (m.find("MarkBatch") != m.end() && !m["MarkBatch"].empty()) {
      markBatch = make_shared<string>(boost::any_cast<string>(m["MarkBatch"]));
    }
    if (m.find("SecurityEventIds") != m.end() && !m["SecurityEventIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityEventIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityEventIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityEventIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~HandleSecurityEventsRequest() = default;
};
class HandleSecurityEventsResponseBodyHandleSecurityEventsResponse : public Darabonba::Model {
public:
  shared_ptr<long> taskId{};

  HandleSecurityEventsResponseBodyHandleSecurityEventsResponse() {}

  explicit HandleSecurityEventsResponseBodyHandleSecurityEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~HandleSecurityEventsResponseBodyHandleSecurityEventsResponse() = default;
};
class HandleSecurityEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<HandleSecurityEventsResponseBodyHandleSecurityEventsResponse> handleSecurityEventsResponse{};

  HandleSecurityEventsResponseBody() {}

  explicit HandleSecurityEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (handleSecurityEventsResponse) {
      res["HandleSecurityEventsResponse"] = handleSecurityEventsResponse ? boost::any(handleSecurityEventsResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HandleSecurityEventsResponse") != m.end() && !m["HandleSecurityEventsResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["HandleSecurityEventsResponse"].type()) {
        HandleSecurityEventsResponseBodyHandleSecurityEventsResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HandleSecurityEventsResponse"]));
        handleSecurityEventsResponse = make_shared<HandleSecurityEventsResponseBodyHandleSecurityEventsResponse>(model1);
      }
    }
  }


  virtual ~HandleSecurityEventsResponseBody() = default;
};
class HandleSecurityEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<HandleSecurityEventsResponseBody> body{};

  HandleSecurityEventsResponse() {}

  explicit HandleSecurityEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HandleSecurityEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HandleSecurityEventsResponseBody>(model1);
      }
    }
  }


  virtual ~HandleSecurityEventsResponse() = default;
};
class HandleSimilarSecurityEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> taskId{};
  shared_ptr<string> operationCode{};
  shared_ptr<string> operationParams{};
  shared_ptr<string> markMissParam{};

  HandleSimilarSecurityEventsRequest() {}

  explicit HandleSimilarSecurityEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (operationCode) {
      res["OperationCode"] = boost::any(*operationCode);
    }
    if (operationParams) {
      res["OperationParams"] = boost::any(*operationParams);
    }
    if (markMissParam) {
      res["MarkMissParam"] = boost::any(*markMissParam);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("OperationCode") != m.end() && !m["OperationCode"].empty()) {
      operationCode = make_shared<string>(boost::any_cast<string>(m["OperationCode"]));
    }
    if (m.find("OperationParams") != m.end() && !m["OperationParams"].empty()) {
      operationParams = make_shared<string>(boost::any_cast<string>(m["OperationParams"]));
    }
    if (m.find("MarkMissParam") != m.end() && !m["MarkMissParam"].empty()) {
      markMissParam = make_shared<string>(boost::any_cast<string>(m["MarkMissParam"]));
    }
  }


  virtual ~HandleSimilarSecurityEventsRequest() = default;
};
class HandleSimilarSecurityEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  HandleSimilarSecurityEventsResponseBody() {}

  explicit HandleSimilarSecurityEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~HandleSimilarSecurityEventsResponseBody() = default;
};
class HandleSimilarSecurityEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<HandleSimilarSecurityEventsResponseBody> body{};

  HandleSimilarSecurityEventsResponse() {}

  explicit HandleSimilarSecurityEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HandleSimilarSecurityEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HandleSimilarSecurityEventsResponseBody>(model1);
      }
    }
  }


  virtual ~HandleSimilarSecurityEventsResponse() = default;
};
class IgnoreHcCheckWarningsRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> checkWarningIds{};
  shared_ptr<string> checkIds{};
  shared_ptr<string> riskId{};
  shared_ptr<long> type{};
  shared_ptr<string> reason{};

  IgnoreHcCheckWarningsRequest() {}

  explicit IgnoreHcCheckWarningsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (checkWarningIds) {
      res["CheckWarningIds"] = boost::any(*checkWarningIds);
    }
    if (checkIds) {
      res["CheckIds"] = boost::any(*checkIds);
    }
    if (riskId) {
      res["RiskId"] = boost::any(*riskId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("CheckWarningIds") != m.end() && !m["CheckWarningIds"].empty()) {
      checkWarningIds = make_shared<string>(boost::any_cast<string>(m["CheckWarningIds"]));
    }
    if (m.find("CheckIds") != m.end() && !m["CheckIds"].empty()) {
      checkIds = make_shared<string>(boost::any_cast<string>(m["CheckIds"]));
    }
    if (m.find("RiskId") != m.end() && !m["RiskId"].empty()) {
      riskId = make_shared<string>(boost::any_cast<string>(m["RiskId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~IgnoreHcCheckWarningsRequest() = default;
};
class IgnoreHcCheckWarningsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  IgnoreHcCheckWarningsResponseBody() {}

  explicit IgnoreHcCheckWarningsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~IgnoreHcCheckWarningsResponseBody() = default;
};
class IgnoreHcCheckWarningsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<IgnoreHcCheckWarningsResponseBody> body{};

  IgnoreHcCheckWarningsResponse() {}

  explicit IgnoreHcCheckWarningsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        IgnoreHcCheckWarningsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<IgnoreHcCheckWarningsResponseBody>(model1);
      }
    }
  }


  virtual ~IgnoreHcCheckWarningsResponse() = default;
};
class InstallBackupClientRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> uuid{};
  shared_ptr<string> policyVersion{};
  shared_ptr<vector<string>> uuidList{};

  InstallBackupClientRequest() {}

  explicit InstallBackupClientRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~InstallBackupClientRequest() = default;
};
class InstallBackupClientResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  InstallBackupClientResponseBody() {}

  explicit InstallBackupClientResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InstallBackupClientResponseBody() = default;
};
class InstallBackupClientResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<InstallBackupClientResponseBody> body{};

  InstallBackupClientResponse() {}

  explicit InstallBackupClientResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallBackupClientResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallBackupClientResponseBody>(model1);
      }
    }
  }


  virtual ~InstallBackupClientResponse() = default;
};
class ModifyAntiBruteForceRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> span{};
  shared_ptr<long> failCount{};
  shared_ptr<long> forbiddenTime{};
  shared_ptr<bool> defaultRule{};
  shared_ptr<vector<string>> uuidList{};

  ModifyAntiBruteForceRuleRequest() {}

  explicit ModifyAntiBruteForceRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (span) {
      res["Span"] = boost::any(*span);
    }
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (forbiddenTime) {
      res["ForbiddenTime"] = boost::any(*forbiddenTime);
    }
    if (defaultRule) {
      res["DefaultRule"] = boost::any(*defaultRule);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Span") != m.end() && !m["Span"].empty()) {
      span = make_shared<long>(boost::any_cast<long>(m["Span"]));
    }
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<long>(boost::any_cast<long>(m["FailCount"]));
    }
    if (m.find("ForbiddenTime") != m.end() && !m["ForbiddenTime"].empty()) {
      forbiddenTime = make_shared<long>(boost::any_cast<long>(m["ForbiddenTime"]));
    }
    if (m.find("DefaultRule") != m.end() && !m["DefaultRule"].empty()) {
      defaultRule = make_shared<bool>(boost::any_cast<bool>(m["DefaultRule"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyAntiBruteForceRuleRequest() = default;
};
class ModifyAntiBruteForceRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyAntiBruteForceRuleResponseBody() {}

  explicit ModifyAntiBruteForceRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyAntiBruteForceRuleResponseBody() = default;
};
class ModifyAntiBruteForceRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyAntiBruteForceRuleResponseBody> body{};

  ModifyAntiBruteForceRuleResponse() {}

  explicit ModifyAntiBruteForceRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAntiBruteForceRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAntiBruteForceRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAntiBruteForceRuleResponse() = default;
};
class ModifyAssetGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> groupId{};
  shared_ptr<string> uuids{};

  ModifyAssetGroupRequest() {}

  explicit ModifyAssetGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~ModifyAssetGroupRequest() = default;
};
class ModifyAssetGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyAssetGroupResponseBody() {}

  explicit ModifyAssetGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyAssetGroupResponseBody() = default;
};
class ModifyAssetGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyAssetGroupResponseBody> body{};

  ModifyAssetGroupResponse() {}

  explicit ModifyAssetGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAssetGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAssetGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAssetGroupResponse() = default;
};
class ModifyBackupPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<map<string, boost::any>> policy{};
  shared_ptr<string> policyVersion{};
  shared_ptr<string> policyRegionId{};
  shared_ptr<vector<string>> uuidList{};

  ModifyBackupPolicyRequest() {}

  explicit ModifyBackupPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    if (policyRegionId) {
      res["PolicyRegionId"] = boost::any(*policyRegionId);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Policy"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      policy = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
    if (m.find("PolicyRegionId") != m.end() && !m["PolicyRegionId"].empty()) {
      policyRegionId = make_shared<string>(boost::any_cast<string>(m["PolicyRegionId"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyBackupPolicyRequest() = default;
};
class ModifyBackupPolicyShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> policyShrink{};
  shared_ptr<string> policyVersion{};
  shared_ptr<string> policyRegionId{};
  shared_ptr<vector<string>> uuidList{};

  ModifyBackupPolicyShrinkRequest() {}

  explicit ModifyBackupPolicyShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (policyShrink) {
      res["Policy"] = boost::any(*policyShrink);
    }
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    if (policyRegionId) {
      res["PolicyRegionId"] = boost::any(*policyRegionId);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policyShrink = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
    if (m.find("PolicyRegionId") != m.end() && !m["PolicyRegionId"].empty()) {
      policyRegionId = make_shared<string>(boost::any_cast<string>(m["PolicyRegionId"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyBackupPolicyShrinkRequest() = default;
};
class ModifyBackupPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyBackupPolicyResponseBody() {}

  explicit ModifyBackupPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyBackupPolicyResponseBody() = default;
};
class ModifyBackupPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyBackupPolicyResponseBody> body{};

  ModifyBackupPolicyResponse() {}

  explicit ModifyBackupPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyBackupPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyBackupPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyBackupPolicyResponse() = default;
};
class ModifyBackupPolicyStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> id{};
  shared_ptr<string> status{};
  shared_ptr<string> policyVersion{};

  ModifyBackupPolicyStatusRequest() {}

  explicit ModifyBackupPolicyStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
  }


  virtual ~ModifyBackupPolicyStatusRequest() = default;
};
class ModifyBackupPolicyStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyBackupPolicyStatusResponseBody() {}

  explicit ModifyBackupPolicyStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyBackupPolicyStatusResponseBody() = default;
};
class ModifyBackupPolicyStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyBackupPolicyStatusResponseBody> body{};

  ModifyBackupPolicyStatusResponse() {}

  explicit ModifyBackupPolicyStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyBackupPolicyStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyBackupPolicyStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyBackupPolicyStatusResponse() = default;
};
class ModifyCreateVulWhitelistRequest : public Darabonba::Model {
public:
  shared_ptr<string> whitelist{};
  shared_ptr<string> reason{};

  ModifyCreateVulWhitelistRequest() {}

  explicit ModifyCreateVulWhitelistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (whitelist) {
      res["Whitelist"] = boost::any(*whitelist);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Whitelist") != m.end() && !m["Whitelist"].empty()) {
      whitelist = make_shared<string>(boost::any_cast<string>(m["Whitelist"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~ModifyCreateVulWhitelistRequest() = default;
};
class ModifyCreateVulWhitelistResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyCreateVulWhitelistResponseBody() {}

  explicit ModifyCreateVulWhitelistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCreateVulWhitelistResponseBody() = default;
};
class ModifyCreateVulWhitelistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyCreateVulWhitelistResponseBody> body{};

  ModifyCreateVulWhitelistResponse() {}

  explicit ModifyCreateVulWhitelistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCreateVulWhitelistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCreateVulWhitelistResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCreateVulWhitelistResponse() = default;
};
class ModifyEmgVulSubmitRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> name{};
  shared_ptr<string> userAgreement{};

  ModifyEmgVulSubmitRequest() {}

  explicit ModifyEmgVulSubmitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userAgreement) {
      res["UserAgreement"] = boost::any(*userAgreement);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserAgreement") != m.end() && !m["UserAgreement"].empty()) {
      userAgreement = make_shared<string>(boost::any_cast<string>(m["UserAgreement"]));
    }
  }


  virtual ~ModifyEmgVulSubmitRequest() = default;
};
class ModifyEmgVulSubmitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyEmgVulSubmitResponseBody() {}

  explicit ModifyEmgVulSubmitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyEmgVulSubmitResponseBody() = default;
};
class ModifyEmgVulSubmitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyEmgVulSubmitResponseBody> body{};

  ModifyEmgVulSubmitResponse() {}

  explicit ModifyEmgVulSubmitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyEmgVulSubmitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyEmgVulSubmitResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyEmgVulSubmitResponse() = default;
};
class ModifyGroupPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> data{};

  ModifyGroupPropertyRequest() {}

  explicit ModifyGroupPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~ModifyGroupPropertyRequest() = default;
};
class ModifyGroupPropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyGroupPropertyResponseBody() {}

  explicit ModifyGroupPropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyGroupPropertyResponseBody() = default;
};
class ModifyGroupPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyGroupPropertyResponseBody> body{};

  ModifyGroupPropertyResponse() {}

  explicit ModifyGroupPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyGroupPropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyGroupPropertyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyGroupPropertyResponse() = default;
};
class ModifyInstanceAntiBruteForceRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> uuid{};
  shared_ptr<long> newRuleId{};

  ModifyInstanceAntiBruteForceRuleRequest() {}

  explicit ModifyInstanceAntiBruteForceRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (newRuleId) {
      res["NewRuleId"] = boost::any(*newRuleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("NewRuleId") != m.end() && !m["NewRuleId"].empty()) {
      newRuleId = make_shared<long>(boost::any_cast<long>(m["NewRuleId"]));
    }
  }


  virtual ~ModifyInstanceAntiBruteForceRuleRequest() = default;
};
class ModifyInstanceAntiBruteForceRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceAntiBruteForceRuleResponseBody() {}

  explicit ModifyInstanceAntiBruteForceRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceAntiBruteForceRuleResponseBody() = default;
};
class ModifyInstanceAntiBruteForceRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyInstanceAntiBruteForceRuleResponseBody> body{};

  ModifyInstanceAntiBruteForceRuleResponse() {}

  explicit ModifyInstanceAntiBruteForceRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceAntiBruteForceRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceAntiBruteForceRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceAntiBruteForceRuleResponse() = default;
};
class ModifyLoginBaseConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> config{};
  shared_ptr<string> target{};

  ModifyLoginBaseConfigRequest() {}

  explicit ModifyLoginBaseConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
  }


  virtual ~ModifyLoginBaseConfigRequest() = default;
};
class ModifyLoginBaseConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyLoginBaseConfigResponseBody() {}

  explicit ModifyLoginBaseConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyLoginBaseConfigResponseBody() = default;
};
class ModifyLoginBaseConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyLoginBaseConfigResponseBody> body{};

  ModifyLoginBaseConfigResponse() {}

  explicit ModifyLoginBaseConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLoginBaseConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLoginBaseConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLoginBaseConfigResponse() = default;
};
class ModifyLoginSwitchConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> item{};
  shared_ptr<long> status{};

  ModifyLoginSwitchConfigRequest() {}

  explicit ModifyLoginSwitchConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ModifyLoginSwitchConfigRequest() = default;
};
class ModifyLoginSwitchConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyLoginSwitchConfigResponseBody() {}

  explicit ModifyLoginSwitchConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyLoginSwitchConfigResponseBody() = default;
};
class ModifyLoginSwitchConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyLoginSwitchConfigResponseBody> body{};

  ModifyLoginSwitchConfigResponse() {}

  explicit ModifyLoginSwitchConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLoginSwitchConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLoginSwitchConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLoginSwitchConfigResponse() = default;
};
class ModifyNoticeConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> route{};
  shared_ptr<string> project{};
  shared_ptr<long> timeLimit{};

  ModifyNoticeConfigRequest() {}

  explicit ModifyNoticeConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (route) {
      res["Route"] = boost::any(*route);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (timeLimit) {
      res["TimeLimit"] = boost::any(*timeLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Route") != m.end() && !m["Route"].empty()) {
      route = make_shared<long>(boost::any_cast<long>(m["Route"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("TimeLimit") != m.end() && !m["TimeLimit"].empty()) {
      timeLimit = make_shared<long>(boost::any_cast<long>(m["TimeLimit"]));
    }
  }


  virtual ~ModifyNoticeConfigRequest() = default;
};
class ModifyNoticeConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyNoticeConfigResponseBody() {}

  explicit ModifyNoticeConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyNoticeConfigResponseBody() = default;
};
class ModifyNoticeConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyNoticeConfigResponseBody> body{};

  ModifyNoticeConfigResponse() {}

  explicit ModifyNoticeConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyNoticeConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyNoticeConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyNoticeConfigResponse() = default;
};
class ModifyOpenLogShipperRequest : public Darabonba::Model {
public:
  shared_ptr<string> from{};

  ModifyOpenLogShipperRequest() {}

  explicit ModifyOpenLogShipperRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
  }


  virtual ~ModifyOpenLogShipperRequest() = default;
};
class ModifyOpenLogShipperResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyOpenLogShipperResponseBody() {}

  explicit ModifyOpenLogShipperResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyOpenLogShipperResponseBody() = default;
};
class ModifyOpenLogShipperResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyOpenLogShipperResponseBody> body{};

  ModifyOpenLogShipperResponse() {}

  explicit ModifyOpenLogShipperResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyOpenLogShipperResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyOpenLogShipperResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyOpenLogShipperResponse() = default;
};
class ModifyOperateVulRequest : public Darabonba::Model {
public:
  shared_ptr<string> info{};
  shared_ptr<string> operateType{};
  shared_ptr<string> type{};
  shared_ptr<string> reason{};

  ModifyOperateVulRequest() {}

  explicit ModifyOperateVulRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<string>(boost::any_cast<string>(m["Info"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<string>(boost::any_cast<string>(m["OperateType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~ModifyOperateVulRequest() = default;
};
class ModifyOperateVulResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyOperateVulResponseBody() {}

  explicit ModifyOperateVulResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyOperateVulResponseBody() = default;
};
class ModifyOperateVulResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyOperateVulResponseBody> body{};

  ModifyOperateVulResponse() {}

  explicit ModifyOperateVulResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyOperateVulResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyOperateVulResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyOperateVulResponse() = default;
};
class ModifyPushAllTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> uuids{};
  shared_ptr<string> tasks{};

  ModifyPushAllTaskRequest() {}

  explicit ModifyPushAllTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    if (tasks) {
      res["Tasks"] = boost::any(*tasks);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      tasks = make_shared<string>(boost::any_cast<string>(m["Tasks"]));
    }
  }


  virtual ~ModifyPushAllTaskRequest() = default;
};
class ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList : public Darabonba::Model {
public:
  shared_ptr<string> uuid{};
  shared_ptr<long> groupId{};
  shared_ptr<bool> success{};
  shared_ptr<string> region{};
  shared_ptr<string> instanceName{};
  shared_ptr<bool> online{};
  shared_ptr<string> message{};
  shared_ptr<string> ip{};
  shared_ptr<string> osVersion{};
  shared_ptr<string> instanceId{};

  ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList() {}

  explicit ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (osVersion) {
      res["OsVersion"] = boost::any(*osVersion);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<bool>(boost::any_cast<bool>(m["Online"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("OsVersion") != m.end() && !m["OsVersion"].empty()) {
      osVersion = make_shared<string>(boost::any_cast<string>(m["OsVersion"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList() = default;
};
class ModifyPushAllTaskResponseBodyPushTaskRsp : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList>> pushTaskResultList{};

  ModifyPushAllTaskResponseBodyPushTaskRsp() {}

  explicit ModifyPushAllTaskResponseBodyPushTaskRsp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pushTaskResultList) {
      vector<boost::any> temp1;
      for(auto item1:*pushTaskResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PushTaskResultList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PushTaskResultList") != m.end() && !m["PushTaskResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["PushTaskResultList"].type()) {
        vector<ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PushTaskResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pushTaskResultList = make_shared<vector<ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList>>(expect1);
      }
    }
  }


  virtual ~ModifyPushAllTaskResponseBodyPushTaskRsp() = default;
};
class ModifyPushAllTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ModifyPushAllTaskResponseBodyPushTaskRsp> pushTaskRsp{};

  ModifyPushAllTaskResponseBody() {}

  explicit ModifyPushAllTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pushTaskRsp) {
      res["PushTaskRsp"] = pushTaskRsp ? boost::any(pushTaskRsp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PushTaskRsp") != m.end() && !m["PushTaskRsp"].empty()) {
      if (typeid(map<string, boost::any>) == m["PushTaskRsp"].type()) {
        ModifyPushAllTaskResponseBodyPushTaskRsp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PushTaskRsp"]));
        pushTaskRsp = make_shared<ModifyPushAllTaskResponseBodyPushTaskRsp>(model1);
      }
    }
  }


  virtual ~ModifyPushAllTaskResponseBody() = default;
};
class ModifyPushAllTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyPushAllTaskResponseBody> body{};

  ModifyPushAllTaskResponse() {}

  explicit ModifyPushAllTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPushAllTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPushAllTaskResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPushAllTaskResponse() = default;
};
class ModifyRiskCheckStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> lang{};
  shared_ptr<long> itemId{};
  shared_ptr<long> taskId{};
  shared_ptr<string> status{};

  ModifyRiskCheckStatusRequest() {}

  explicit ModifyRiskCheckStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ModifyRiskCheckStatusRequest() = default;
};
class ModifyRiskCheckStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyRiskCheckStatusResponseBody() {}

  explicit ModifyRiskCheckStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyRiskCheckStatusResponseBody() = default;
};
class ModifyRiskCheckStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyRiskCheckStatusResponseBody> body{};

  ModifyRiskCheckStatusResponse() {}

  explicit ModifyRiskCheckStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyRiskCheckStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyRiskCheckStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyRiskCheckStatusResponse() = default;
};
class ModifyRiskSingleResultStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> lang{};
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};
  shared_ptr<vector<string>> ids{};

  ModifyRiskSingleResultStatusRequest() {}

  explicit ModifyRiskSingleResultStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ids = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyRiskSingleResultStatusRequest() = default;
};
class ModifyRiskSingleResultStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyRiskSingleResultStatusResponseBody() {}

  explicit ModifyRiskSingleResultStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyRiskSingleResultStatusResponseBody() = default;
};
class ModifyRiskSingleResultStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyRiskSingleResultStatusResponseBody> body{};

  ModifyRiskSingleResultStatusResponse() {}

  explicit ModifyRiskSingleResultStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyRiskSingleResultStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyRiskSingleResultStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyRiskSingleResultStatusResponse() = default;
};
class ModifySecurityCheckScheduleConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> lang{};
  shared_ptr<string> daysOfWeek{};
  shared_ptr<long> startTime{};
  shared_ptr<long> endTime{};

  ModifySecurityCheckScheduleConfigRequest() {}

  explicit ModifySecurityCheckScheduleConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (daysOfWeek) {
      res["DaysOfWeek"] = boost::any(*daysOfWeek);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("DaysOfWeek") != m.end() && !m["DaysOfWeek"].empty()) {
      daysOfWeek = make_shared<string>(boost::any_cast<string>(m["DaysOfWeek"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
  }


  virtual ~ModifySecurityCheckScheduleConfigRequest() = default;
};
class ModifySecurityCheckScheduleConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySecurityCheckScheduleConfigResponseBody() {}

  explicit ModifySecurityCheckScheduleConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySecurityCheckScheduleConfigResponseBody() = default;
};
class ModifySecurityCheckScheduleConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySecurityCheckScheduleConfigResponseBody> body{};

  ModifySecurityCheckScheduleConfigResponse() {}

  explicit ModifySecurityCheckScheduleConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySecurityCheckScheduleConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySecurityCheckScheduleConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySecurityCheckScheduleConfigResponse() = default;
};
class ModifyStartVulScanRequest : public Darabonba::Model {
public:
  shared_ptr<string> types{};
  shared_ptr<string> uuids{};

  ModifyStartVulScanRequest() {}

  explicit ModifyStartVulScanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (types) {
      res["Types"] = boost::any(*types);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      types = make_shared<string>(boost::any_cast<string>(m["Types"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~ModifyStartVulScanRequest() = default;
};
class ModifyStartVulScanResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyStartVulScanResponseBody() {}

  explicit ModifyStartVulScanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyStartVulScanResponseBody() = default;
};
class ModifyStartVulScanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyStartVulScanResponseBody> body{};

  ModifyStartVulScanResponse() {}

  explicit ModifyStartVulScanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyStartVulScanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyStartVulScanResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyStartVulScanResponse() = default;
};
class ModifyStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> cycleDays{};
  shared_ptr<string> name{};
  shared_ptr<string> cycleStartTime{};
  shared_ptr<string> riskSubTypeName{};
  shared_ptr<string> id{};

  ModifyStrategyRequest() {}

  explicit ModifyStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (cycleDays) {
      res["CycleDays"] = boost::any(*cycleDays);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (cycleStartTime) {
      res["CycleStartTime"] = boost::any(*cycleStartTime);
    }
    if (riskSubTypeName) {
      res["RiskSubTypeName"] = boost::any(*riskSubTypeName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("CycleDays") != m.end() && !m["CycleDays"].empty()) {
      cycleDays = make_shared<string>(boost::any_cast<string>(m["CycleDays"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("CycleStartTime") != m.end() && !m["CycleStartTime"].empty()) {
      cycleStartTime = make_shared<string>(boost::any_cast<string>(m["CycleStartTime"]));
    }
    if (m.find("RiskSubTypeName") != m.end() && !m["RiskSubTypeName"].empty()) {
      riskSubTypeName = make_shared<string>(boost::any_cast<string>(m["RiskSubTypeName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ModifyStrategyRequest() = default;
};
class ModifyStrategyResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> strategyId{};

  ModifyStrategyResponseBodyResult() {}

  explicit ModifyStrategyResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<long>(boost::any_cast<long>(m["StrategyId"]));
    }
  }


  virtual ~ModifyStrategyResponseBodyResult() = default;
};
class ModifyStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<bool> success{};
  shared_ptr<ModifyStrategyResponseBodyResult> result{};

  ModifyStrategyResponseBody() {}

  explicit ModifyStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ModifyStrategyResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ModifyStrategyResponseBodyResult>(model1);
      }
    }
  }


  virtual ~ModifyStrategyResponseBody() = default;
};
class ModifyStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyStrategyResponseBody> body{};

  ModifyStrategyResponse() {}

  explicit ModifyStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyStrategyResponse() = default;
};
class ModifyStrategyTargetRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> type{};
  shared_ptr<string> config{};
  shared_ptr<string> target{};

  ModifyStrategyTargetRequest() {}

  explicit ModifyStrategyTargetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
  }


  virtual ~ModifyStrategyTargetRequest() = default;
};
class ModifyStrategyTargetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyStrategyTargetResponseBody() {}

  explicit ModifyStrategyTargetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyStrategyTargetResponseBody() = default;
};
class ModifyStrategyTargetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyStrategyTargetResponseBody> body{};

  ModifyStrategyTargetResponse() {}

  explicit ModifyStrategyTargetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyStrategyTargetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyStrategyTargetResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyStrategyTargetResponse() = default;
};
class ModifyTagWithUuidRequest : public Darabonba::Model {
public:
  shared_ptr<string> uuidList{};
  shared_ptr<string> tagList{};
  shared_ptr<string> tagId{};
  shared_ptr<string> machineTypes{};

  ModifyTagWithUuidRequest() {}

  explicit ModifyTagWithUuidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    if (tagList) {
      res["TagList"] = boost::any(*tagList);
    }
    if (tagId) {
      res["TagId"] = boost::any(*tagId);
    }
    if (machineTypes) {
      res["MachineTypes"] = boost::any(*machineTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      uuidList = make_shared<string>(boost::any_cast<string>(m["UuidList"]));
    }
    if (m.find("TagList") != m.end() && !m["TagList"].empty()) {
      tagList = make_shared<string>(boost::any_cast<string>(m["TagList"]));
    }
    if (m.find("TagId") != m.end() && !m["TagId"].empty()) {
      tagId = make_shared<string>(boost::any_cast<string>(m["TagId"]));
    }
    if (m.find("MachineTypes") != m.end() && !m["MachineTypes"].empty()) {
      machineTypes = make_shared<string>(boost::any_cast<string>(m["MachineTypes"]));
    }
  }


  virtual ~ModifyTagWithUuidRequest() = default;
};
class ModifyTagWithUuidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyTagWithUuidResponseBody() {}

  explicit ModifyTagWithUuidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyTagWithUuidResponseBody() = default;
};
class ModifyTagWithUuidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyTagWithUuidResponseBody> body{};

  ModifyTagWithUuidResponse() {}

  explicit ModifyTagWithUuidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTagWithUuidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTagWithUuidResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTagWithUuidResponse() = default;
};
class ModifyVpcHoneyPotRequest : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};
  shared_ptr<string> honeyPotAction{};

  ModifyVpcHoneyPotRequest() {}

  explicit ModifyVpcHoneyPotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (honeyPotAction) {
      res["HoneyPotAction"] = boost::any(*honeyPotAction);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("HoneyPotAction") != m.end() && !m["HoneyPotAction"].empty()) {
      honeyPotAction = make_shared<string>(boost::any_cast<string>(m["HoneyPotAction"]));
    }
  }


  virtual ~ModifyVpcHoneyPotRequest() = default;
};
class ModifyVpcHoneyPotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyVpcHoneyPotResponseBody() {}

  explicit ModifyVpcHoneyPotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVpcHoneyPotResponseBody() = default;
};
class ModifyVpcHoneyPotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyVpcHoneyPotResponseBody> body{};

  ModifyVpcHoneyPotResponse() {}

  explicit ModifyVpcHoneyPotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVpcHoneyPotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVpcHoneyPotResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVpcHoneyPotResponse() = default;
};
class ModifyVulTargetConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};
  shared_ptr<string> config{};

  ModifyVulTargetConfigRequest() {}

  explicit ModifyVulTargetConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
  }


  virtual ~ModifyVulTargetConfigRequest() = default;
};
class ModifyVulTargetConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyVulTargetConfigResponseBody() {}

  explicit ModifyVulTargetConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVulTargetConfigResponseBody() = default;
};
class ModifyVulTargetConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyVulTargetConfigResponseBody> body{};

  ModifyVulTargetConfigResponse() {}

  explicit ModifyVulTargetConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVulTargetConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVulTargetConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVulTargetConfigResponse() = default;
};
class ModifyWebLockCreateConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};
  shared_ptr<string> uuid{};
  shared_ptr<string> dir{};
  shared_ptr<string> exclusiveDir{};
  shared_ptr<string> exclusiveFileType{};
  shared_ptr<string> localBackupDir{};
  shared_ptr<string> mode{};
  shared_ptr<string> inclusiveFileType{};
  shared_ptr<string> exclusiveFile{};
  shared_ptr<string> inclusiveFile{};
  shared_ptr<string> defenceMode{};

  ModifyWebLockCreateConfigRequest() {}

  explicit ModifyWebLockCreateConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (dir) {
      res["Dir"] = boost::any(*dir);
    }
    if (exclusiveDir) {
      res["ExclusiveDir"] = boost::any(*exclusiveDir);
    }
    if (exclusiveFileType) {
      res["ExclusiveFileType"] = boost::any(*exclusiveFileType);
    }
    if (localBackupDir) {
      res["LocalBackupDir"] = boost::any(*localBackupDir);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (inclusiveFileType) {
      res["InclusiveFileType"] = boost::any(*inclusiveFileType);
    }
    if (exclusiveFile) {
      res["ExclusiveFile"] = boost::any(*exclusiveFile);
    }
    if (inclusiveFile) {
      res["InclusiveFile"] = boost::any(*inclusiveFile);
    }
    if (defenceMode) {
      res["DefenceMode"] = boost::any(*defenceMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Dir") != m.end() && !m["Dir"].empty()) {
      dir = make_shared<string>(boost::any_cast<string>(m["Dir"]));
    }
    if (m.find("ExclusiveDir") != m.end() && !m["ExclusiveDir"].empty()) {
      exclusiveDir = make_shared<string>(boost::any_cast<string>(m["ExclusiveDir"]));
    }
    if (m.find("ExclusiveFileType") != m.end() && !m["ExclusiveFileType"].empty()) {
      exclusiveFileType = make_shared<string>(boost::any_cast<string>(m["ExclusiveFileType"]));
    }
    if (m.find("LocalBackupDir") != m.end() && !m["LocalBackupDir"].empty()) {
      localBackupDir = make_shared<string>(boost::any_cast<string>(m["LocalBackupDir"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("InclusiveFileType") != m.end() && !m["InclusiveFileType"].empty()) {
      inclusiveFileType = make_shared<string>(boost::any_cast<string>(m["InclusiveFileType"]));
    }
    if (m.find("ExclusiveFile") != m.end() && !m["ExclusiveFile"].empty()) {
      exclusiveFile = make_shared<string>(boost::any_cast<string>(m["ExclusiveFile"]));
    }
    if (m.find("InclusiveFile") != m.end() && !m["InclusiveFile"].empty()) {
      inclusiveFile = make_shared<string>(boost::any_cast<string>(m["InclusiveFile"]));
    }
    if (m.find("DefenceMode") != m.end() && !m["DefenceMode"].empty()) {
      defenceMode = make_shared<string>(boost::any_cast<string>(m["DefenceMode"]));
    }
  }


  virtual ~ModifyWebLockCreateConfigRequest() = default;
};
class ModifyWebLockCreateConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebLockCreateConfigResponseBody() {}

  explicit ModifyWebLockCreateConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebLockCreateConfigResponseBody() = default;
};
class ModifyWebLockCreateConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyWebLockCreateConfigResponseBody> body{};

  ModifyWebLockCreateConfigResponse() {}

  explicit ModifyWebLockCreateConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebLockCreateConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebLockCreateConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebLockCreateConfigResponse() = default;
};
class ModifyWebLockDeleteConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};
  shared_ptr<long> id{};
  shared_ptr<string> uuid{};

  ModifyWebLockDeleteConfigRequest() {}

  explicit ModifyWebLockDeleteConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~ModifyWebLockDeleteConfigRequest() = default;
};
class ModifyWebLockDeleteConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebLockDeleteConfigResponseBody() {}

  explicit ModifyWebLockDeleteConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebLockDeleteConfigResponseBody() = default;
};
class ModifyWebLockDeleteConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyWebLockDeleteConfigResponseBody> body{};

  ModifyWebLockDeleteConfigResponse() {}

  explicit ModifyWebLockDeleteConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebLockDeleteConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebLockDeleteConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebLockDeleteConfigResponse() = default;
};
class ModifyWebLockStartRequest : public Darabonba::Model {
public:
  shared_ptr<string> mode{};
  shared_ptr<string> localBackupDir{};
  shared_ptr<string> exclusiveFile{};
  shared_ptr<string> dir{};
  shared_ptr<string> inclusiveFileType{};
  shared_ptr<string> uuid{};
  shared_ptr<string> exclusiveFileType{};
  shared_ptr<string> exclusiveDir{};
  shared_ptr<string> defenceMode{};

  ModifyWebLockStartRequest() {}

  explicit ModifyWebLockStartRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (localBackupDir) {
      res["LocalBackupDir"] = boost::any(*localBackupDir);
    }
    if (exclusiveFile) {
      res["ExclusiveFile"] = boost::any(*exclusiveFile);
    }
    if (dir) {
      res["Dir"] = boost::any(*dir);
    }
    if (inclusiveFileType) {
      res["InclusiveFileType"] = boost::any(*inclusiveFileType);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (exclusiveFileType) {
      res["ExclusiveFileType"] = boost::any(*exclusiveFileType);
    }
    if (exclusiveDir) {
      res["ExclusiveDir"] = boost::any(*exclusiveDir);
    }
    if (defenceMode) {
      res["DefenceMode"] = boost::any(*defenceMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("LocalBackupDir") != m.end() && !m["LocalBackupDir"].empty()) {
      localBackupDir = make_shared<string>(boost::any_cast<string>(m["LocalBackupDir"]));
    }
    if (m.find("ExclusiveFile") != m.end() && !m["ExclusiveFile"].empty()) {
      exclusiveFile = make_shared<string>(boost::any_cast<string>(m["ExclusiveFile"]));
    }
    if (m.find("Dir") != m.end() && !m["Dir"].empty()) {
      dir = make_shared<string>(boost::any_cast<string>(m["Dir"]));
    }
    if (m.find("InclusiveFileType") != m.end() && !m["InclusiveFileType"].empty()) {
      inclusiveFileType = make_shared<string>(boost::any_cast<string>(m["InclusiveFileType"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("ExclusiveFileType") != m.end() && !m["ExclusiveFileType"].empty()) {
      exclusiveFileType = make_shared<string>(boost::any_cast<string>(m["ExclusiveFileType"]));
    }
    if (m.find("ExclusiveDir") != m.end() && !m["ExclusiveDir"].empty()) {
      exclusiveDir = make_shared<string>(boost::any_cast<string>(m["ExclusiveDir"]));
    }
    if (m.find("DefenceMode") != m.end() && !m["DefenceMode"].empty()) {
      defenceMode = make_shared<string>(boost::any_cast<string>(m["DefenceMode"]));
    }
  }


  virtual ~ModifyWebLockStartRequest() = default;
};
class ModifyWebLockStartResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebLockStartResponseBody() {}

  explicit ModifyWebLockStartResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebLockStartResponseBody() = default;
};
class ModifyWebLockStartResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyWebLockStartResponseBody> body{};

  ModifyWebLockStartResponse() {}

  explicit ModifyWebLockStartResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebLockStartResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebLockStartResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebLockStartResponse() = default;
};
class ModifyWebLockStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};
  shared_ptr<string> uuid{};
  shared_ptr<string> status{};

  ModifyWebLockStatusRequest() {}

  explicit ModifyWebLockStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ModifyWebLockStatusRequest() = default;
};
class ModifyWebLockStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebLockStatusResponseBody() {}

  explicit ModifyWebLockStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebLockStatusResponseBody() = default;
};
class ModifyWebLockStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyWebLockStatusResponseBody> body{};

  ModifyWebLockStatusResponse() {}

  explicit ModifyWebLockStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebLockStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebLockStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebLockStatusResponse() = default;
};
class ModifyWebLockUnbindRequest : public Darabonba::Model {
public:
  shared_ptr<string> uuid{};

  ModifyWebLockUnbindRequest() {}

  explicit ModifyWebLockUnbindRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~ModifyWebLockUnbindRequest() = default;
};
class ModifyWebLockUnbindResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebLockUnbindResponseBody() {}

  explicit ModifyWebLockUnbindResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebLockUnbindResponseBody() = default;
};
class ModifyWebLockUnbindResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyWebLockUnbindResponseBody> body{};

  ModifyWebLockUnbindResponse() {}

  explicit ModifyWebLockUnbindResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebLockUnbindResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebLockUnbindResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebLockUnbindResponse() = default;
};
class ModifyWebLockUpdateConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};
  shared_ptr<long> id{};
  shared_ptr<string> uuid{};
  shared_ptr<string> dir{};
  shared_ptr<string> exclusiveDir{};
  shared_ptr<string> exclusiveFileType{};
  shared_ptr<string> localBackupDir{};
  shared_ptr<string> mode{};
  shared_ptr<string> inclusiveFileType{};
  shared_ptr<string> exclusiveFile{};
  shared_ptr<string> inclusiveFile{};
  shared_ptr<string> defenceMode{};

  ModifyWebLockUpdateConfigRequest() {}

  explicit ModifyWebLockUpdateConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (dir) {
      res["Dir"] = boost::any(*dir);
    }
    if (exclusiveDir) {
      res["ExclusiveDir"] = boost::any(*exclusiveDir);
    }
    if (exclusiveFileType) {
      res["ExclusiveFileType"] = boost::any(*exclusiveFileType);
    }
    if (localBackupDir) {
      res["LocalBackupDir"] = boost::any(*localBackupDir);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (inclusiveFileType) {
      res["InclusiveFileType"] = boost::any(*inclusiveFileType);
    }
    if (exclusiveFile) {
      res["ExclusiveFile"] = boost::any(*exclusiveFile);
    }
    if (inclusiveFile) {
      res["InclusiveFile"] = boost::any(*inclusiveFile);
    }
    if (defenceMode) {
      res["DefenceMode"] = boost::any(*defenceMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Dir") != m.end() && !m["Dir"].empty()) {
      dir = make_shared<string>(boost::any_cast<string>(m["Dir"]));
    }
    if (m.find("ExclusiveDir") != m.end() && !m["ExclusiveDir"].empty()) {
      exclusiveDir = make_shared<string>(boost::any_cast<string>(m["ExclusiveDir"]));
    }
    if (m.find("ExclusiveFileType") != m.end() && !m["ExclusiveFileType"].empty()) {
      exclusiveFileType = make_shared<string>(boost::any_cast<string>(m["ExclusiveFileType"]));
    }
    if (m.find("LocalBackupDir") != m.end() && !m["LocalBackupDir"].empty()) {
      localBackupDir = make_shared<string>(boost::any_cast<string>(m["LocalBackupDir"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("InclusiveFileType") != m.end() && !m["InclusiveFileType"].empty()) {
      inclusiveFileType = make_shared<string>(boost::any_cast<string>(m["InclusiveFileType"]));
    }
    if (m.find("ExclusiveFile") != m.end() && !m["ExclusiveFile"].empty()) {
      exclusiveFile = make_shared<string>(boost::any_cast<string>(m["ExclusiveFile"]));
    }
    if (m.find("InclusiveFile") != m.end() && !m["InclusiveFile"].empty()) {
      inclusiveFile = make_shared<string>(boost::any_cast<string>(m["InclusiveFile"]));
    }
    if (m.find("DefenceMode") != m.end() && !m["DefenceMode"].empty()) {
      defenceMode = make_shared<string>(boost::any_cast<string>(m["DefenceMode"]));
    }
  }


  virtual ~ModifyWebLockUpdateConfigRequest() = default;
};
class ModifyWebLockUpdateConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebLockUpdateConfigResponseBody() {}

  explicit ModifyWebLockUpdateConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebLockUpdateConfigResponseBody() = default;
};
class ModifyWebLockUpdateConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyWebLockUpdateConfigResponseBody> body{};

  ModifyWebLockUpdateConfigResponse() {}

  explicit ModifyWebLockUpdateConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebLockUpdateConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebLockUpdateConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebLockUpdateConfigResponse() = default;
};
class OperateSuspiciousTargetConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> lang{};
  shared_ptr<string> type{};
  shared_ptr<string> targetType{};
  shared_ptr<string> targetOperations{};

  OperateSuspiciousTargetConfigRequest() {}

  explicit OperateSuspiciousTargetConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (targetOperations) {
      res["TargetOperations"] = boost::any(*targetOperations);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("TargetOperations") != m.end() && !m["TargetOperations"].empty()) {
      targetOperations = make_shared<string>(boost::any_cast<string>(m["TargetOperations"]));
    }
  }


  virtual ~OperateSuspiciousTargetConfigRequest() = default;
};
class OperateSuspiciousTargetConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  OperateSuspiciousTargetConfigResponseBody() {}

  explicit OperateSuspiciousTargetConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OperateSuspiciousTargetConfigResponseBody() = default;
};
class OperateSuspiciousTargetConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<OperateSuspiciousTargetConfigResponseBody> body{};

  OperateSuspiciousTargetConfigResponse() {}

  explicit OperateSuspiciousTargetConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OperateSuspiciousTargetConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OperateSuspiciousTargetConfigResponseBody>(model1);
      }
    }
  }


  virtual ~OperateSuspiciousTargetConfigResponse() = default;
};
class OperateVulsRequest : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> operateType{};
  shared_ptr<string> reason{};
  shared_ptr<long> precondition{};
  shared_ptr<vector<string>> vulNames{};
  shared_ptr<vector<string>> uuids{};

  OperateVulsRequest() {}

  explicit OperateVulsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (precondition) {
      res["Precondition"] = boost::any(*precondition);
    }
    if (vulNames) {
      res["VulNames"] = boost::any(*vulNames);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<string>(boost::any_cast<string>(m["OperateType"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Precondition") != m.end() && !m["Precondition"].empty()) {
      precondition = make_shared<long>(boost::any_cast<long>(m["Precondition"]));
    }
    if (m.find("VulNames") != m.end() && !m["VulNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VulNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VulNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vulNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Uuids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Uuids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuids = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~OperateVulsRequest() = default;
};
class OperateVulsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  OperateVulsResponseBody() {}

  explicit OperateVulsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OperateVulsResponseBody() = default;
};
class OperateVulsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<OperateVulsResponseBody> body{};

  OperateVulsResponse() {}

  explicit OperateVulsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OperateVulsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OperateVulsResponseBody>(model1);
      }
    }
  }


  virtual ~OperateVulsResponse() = default;
};
class OperationSuspEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> suspiciousEventIds{};
  shared_ptr<string> operation{};
  shared_ptr<string> subOperation{};
  shared_ptr<string> from{};
  shared_ptr<string> warnType{};

  OperationSuspEventsRequest() {}

  explicit OperationSuspEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (suspiciousEventIds) {
      res["SuspiciousEventIds"] = boost::any(*suspiciousEventIds);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (subOperation) {
      res["SubOperation"] = boost::any(*subOperation);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (warnType) {
      res["WarnType"] = boost::any(*warnType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("SuspiciousEventIds") != m.end() && !m["SuspiciousEventIds"].empty()) {
      suspiciousEventIds = make_shared<string>(boost::any_cast<string>(m["SuspiciousEventIds"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("SubOperation") != m.end() && !m["SubOperation"].empty()) {
      subOperation = make_shared<string>(boost::any_cast<string>(m["SubOperation"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("WarnType") != m.end() && !m["WarnType"].empty()) {
      warnType = make_shared<string>(boost::any_cast<string>(m["WarnType"]));
    }
  }


  virtual ~OperationSuspEventsRequest() = default;
};
class OperationSuspEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> accessCode{};
  shared_ptr<bool> success{};

  OperationSuspEventsResponseBody() {}

  explicit OperationSuspEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (accessCode) {
      res["AccessCode"] = boost::any(*accessCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("AccessCode") != m.end() && !m["AccessCode"].empty()) {
      accessCode = make_shared<string>(boost::any_cast<string>(m["AccessCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~OperationSuspEventsResponseBody() = default;
};
class OperationSuspEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<OperationSuspEventsResponseBody> body{};

  OperationSuspEventsResponse() {}

  explicit OperationSuspEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OperationSuspEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OperationSuspEventsResponseBody>(model1);
      }
    }
  }


  virtual ~OperationSuspEventsResponse() = default;
};
class PauseClientRequest : public Darabonba::Model {
public:
  shared_ptr<string> uuids{};
  shared_ptr<string> value{};

  PauseClientRequest() {}

  explicit PauseClientRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PauseClientRequest() = default;
};
class PauseClientResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  PauseClientResponseBody() {}

  explicit PauseClientResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PauseClientResponseBody() = default;
};
class PauseClientResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PauseClientResponseBody> body{};

  PauseClientResponse() {}

  explicit PauseClientResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PauseClientResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PauseClientResponseBody>(model1);
      }
    }
  }


  virtual ~PauseClientResponse() = default;
};
class RefreshContainerAssetsRequest : public Darabonba::Model {
public:
  shared_ptr<string> assetType{};

  RefreshContainerAssetsRequest() {}

  explicit RefreshContainerAssetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetType) {
      res["AssetType"] = boost::any(*assetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetType") != m.end() && !m["AssetType"].empty()) {
      assetType = make_shared<string>(boost::any_cast<string>(m["AssetType"]));
    }
  }


  virtual ~RefreshContainerAssetsRequest() = default;
};
class RefreshContainerAssetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RefreshContainerAssetsResponseBody() {}

  explicit RefreshContainerAssetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RefreshContainerAssetsResponseBody() = default;
};
class RefreshContainerAssetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RefreshContainerAssetsResponseBody> body{};

  RefreshContainerAssetsResponse() {}

  explicit RefreshContainerAssetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefreshContainerAssetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefreshContainerAssetsResponseBody>(model1);
      }
    }
  }


  virtual ~RefreshContainerAssetsResponse() = default;
};
class RollbackSuspEventQuaraFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> quaraFileId{};
  shared_ptr<string> from{};

  RollbackSuspEventQuaraFileRequest() {}

  explicit RollbackSuspEventQuaraFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (quaraFileId) {
      res["QuaraFileId"] = boost::any(*quaraFileId);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("QuaraFileId") != m.end() && !m["QuaraFileId"].empty()) {
      quaraFileId = make_shared<long>(boost::any_cast<long>(m["QuaraFileId"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
  }


  virtual ~RollbackSuspEventQuaraFileRequest() = default;
};
class RollbackSuspEventQuaraFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RollbackSuspEventQuaraFileResponseBody() {}

  explicit RollbackSuspEventQuaraFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RollbackSuspEventQuaraFileResponseBody() = default;
};
class RollbackSuspEventQuaraFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RollbackSuspEventQuaraFileResponseBody> body{};

  RollbackSuspEventQuaraFileResponse() {}

  explicit RollbackSuspEventQuaraFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RollbackSuspEventQuaraFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RollbackSuspEventQuaraFileResponseBody>(model1);
      }
    }
  }


  virtual ~RollbackSuspEventQuaraFileResponse() = default;
};
class SasInstallCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};

  SasInstallCodeRequest() {}

  explicit SasInstallCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~SasInstallCodeRequest() = default;
};
class SasInstallCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  SasInstallCodeResponseBody() {}

  explicit SasInstallCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SasInstallCodeResponseBody() = default;
};
class SasInstallCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SasInstallCodeResponseBody> body{};

  SasInstallCodeResponse() {}

  explicit SasInstallCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SasInstallCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SasInstallCodeResponseBody>(model1);
      }
    }
  }


  virtual ~SasInstallCodeResponse() = default;
};
class StartBaselineSecurityCheckRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> lang{};
  shared_ptr<string> type{};
  shared_ptr<vector<int>> itemIds{};

  StartBaselineSecurityCheckRequest() {}

  explicit StartBaselineSecurityCheckRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (itemIds) {
      res["ItemIds"] = boost::any(*itemIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      vector<int> toVec1;
      if (typeid(vector<boost::any>) == m["ItemIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ItemIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<int>(item));
        }
      }
      itemIds = make_shared<vector<int>>(toVec1);
    }
  }


  virtual ~StartBaselineSecurityCheckRequest() = default;
};
class StartBaselineSecurityCheckResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartBaselineSecurityCheckResponseBody() {}

  explicit StartBaselineSecurityCheckResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartBaselineSecurityCheckResponseBody() = default;
};
class StartBaselineSecurityCheckResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StartBaselineSecurityCheckResponseBody> body{};

  StartBaselineSecurityCheckResponse() {}

  explicit StartBaselineSecurityCheckResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartBaselineSecurityCheckResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartBaselineSecurityCheckResponseBody>(model1);
      }
    }
  }


  virtual ~StartBaselineSecurityCheckResponse() = default;
};
class StartImageVulScanRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> repoRegionId{};
  shared_ptr<string> repoInstanceId{};
  shared_ptr<string> repoId{};
  shared_ptr<string> repName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> imageTag{};
  shared_ptr<string> imageDigest{};
  shared_ptr<string> imageLayer{};
  shared_ptr<vector<string>> registryTypes{};

  StartImageVulScanRequest() {}

  explicit StartImageVulScanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (repoRegionId) {
      res["RepoRegionId"] = boost::any(*repoRegionId);
    }
    if (repoInstanceId) {
      res["RepoInstanceId"] = boost::any(*repoInstanceId);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    if (repName) {
      res["RepName"] = boost::any(*repName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (imageTag) {
      res["ImageTag"] = boost::any(*imageTag);
    }
    if (imageDigest) {
      res["ImageDigest"] = boost::any(*imageDigest);
    }
    if (imageLayer) {
      res["ImageLayer"] = boost::any(*imageLayer);
    }
    if (registryTypes) {
      res["RegistryTypes"] = boost::any(*registryTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RepoRegionId") != m.end() && !m["RepoRegionId"].empty()) {
      repoRegionId = make_shared<string>(boost::any_cast<string>(m["RepoRegionId"]));
    }
    if (m.find("RepoInstanceId") != m.end() && !m["RepoInstanceId"].empty()) {
      repoInstanceId = make_shared<string>(boost::any_cast<string>(m["RepoInstanceId"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
    if (m.find("RepName") != m.end() && !m["RepName"].empty()) {
      repName = make_shared<string>(boost::any_cast<string>(m["RepName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("ImageTag") != m.end() && !m["ImageTag"].empty()) {
      imageTag = make_shared<string>(boost::any_cast<string>(m["ImageTag"]));
    }
    if (m.find("ImageDigest") != m.end() && !m["ImageDigest"].empty()) {
      imageDigest = make_shared<string>(boost::any_cast<string>(m["ImageDigest"]));
    }
    if (m.find("ImageLayer") != m.end() && !m["ImageLayer"].empty()) {
      imageLayer = make_shared<string>(boost::any_cast<string>(m["ImageLayer"]));
    }
    if (m.find("RegistryTypes") != m.end() && !m["RegistryTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RegistryTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RegistryTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      registryTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~StartImageVulScanRequest() = default;
};
class StartImageVulScanResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartImageVulScanResponseBody() {}

  explicit StartImageVulScanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartImageVulScanResponseBody() = default;
};
class StartImageVulScanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StartImageVulScanResponseBody> body{};

  StartImageVulScanResponse() {}

  explicit StartImageVulScanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartImageVulScanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartImageVulScanResponseBody>(model1);
      }
    }
  }


  virtual ~StartImageVulScanResponse() = default;
};
class StartVirusScanTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> targetInfo{};

  StartVirusScanTaskRequest() {}

  explicit StartVirusScanTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetInfo) {
      res["TargetInfo"] = boost::any(*targetInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetInfo") != m.end() && !m["TargetInfo"].empty()) {
      targetInfo = make_shared<string>(boost::any_cast<string>(m["TargetInfo"]));
    }
  }


  virtual ~StartVirusScanTaskRequest() = default;
};
class StartVirusScanTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> scanTaskId{};
  shared_ptr<string> requestId{};

  StartVirusScanTaskResponseBody() {}

  explicit StartVirusScanTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scanTaskId) {
      res["ScanTaskId"] = boost::any(*scanTaskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScanTaskId") != m.end() && !m["ScanTaskId"].empty()) {
      scanTaskId = make_shared<long>(boost::any_cast<long>(m["ScanTaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartVirusScanTaskResponseBody() = default;
};
class StartVirusScanTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StartVirusScanTaskResponseBody> body{};

  StartVirusScanTaskResponse() {}

  explicit StartVirusScanTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartVirusScanTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartVirusScanTaskResponseBody>(model1);
      }
    }
  }


  virtual ~StartVirusScanTaskResponse() = default;
};
class UnbindAegisRequest : public Darabonba::Model {
public:
  shared_ptr<string> uuids{};

  UnbindAegisRequest() {}

  explicit UnbindAegisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~UnbindAegisRequest() = default;
};
class UnbindAegisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnbindAegisResponseBody() {}

  explicit UnbindAegisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnbindAegisResponseBody() = default;
};
class UnbindAegisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UnbindAegisResponseBody> body{};

  UnbindAegisResponse() {}

  explicit UnbindAegisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindAegisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindAegisResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindAegisResponse() = default;
};
class UninstallBackupClientRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> uuid{};
  shared_ptr<string> policyVersion{};
  shared_ptr<vector<string>> uuidList{};

  UninstallBackupClientRequest() {}

  explicit UninstallBackupClientRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UninstallBackupClientRequest() = default;
};
class UninstallBackupClientResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UninstallBackupClientResponseBody() {}

  explicit UninstallBackupClientResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UninstallBackupClientResponseBody() = default;
};
class UninstallBackupClientResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UninstallBackupClientResponseBody> body{};

  UninstallBackupClientResponse() {}

  explicit UninstallBackupClientResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UninstallBackupClientResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UninstallBackupClientResponseBody>(model1);
      }
    }
  }


  virtual ~UninstallBackupClientResponse() = default;
};
class ValidateHcWarningsRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> riskIds{};
  shared_ptr<string> uuids{};

  ValidateHcWarningsRequest() {}

  explicit ValidateHcWarningsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (riskIds) {
      res["RiskIds"] = boost::any(*riskIds);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("RiskIds") != m.end() && !m["RiskIds"].empty()) {
      riskIds = make_shared<string>(boost::any_cast<string>(m["RiskIds"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~ValidateHcWarningsRequest() = default;
};
class ValidateHcWarningsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ValidateHcWarningsResponseBody() {}

  explicit ValidateHcWarningsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ValidateHcWarningsResponseBody() = default;
};
class ValidateHcWarningsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ValidateHcWarningsResponseBody> body{};

  ValidateHcWarningsResponse() {}

  explicit ValidateHcWarningsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ValidateHcWarningsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ValidateHcWarningsResponseBody>(model1);
      }
    }
  }


  virtual ~ValidateHcWarningsResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddVpcHoneyPotResponse addVpcHoneyPotWithOptions(shared_ptr<AddVpcHoneyPotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddVpcHoneyPotResponse addVpcHoneyPot(shared_ptr<AddVpcHoneyPotRequest> request);
  CheckQuaraFileIdResponse checkQuaraFileIdWithOptions(shared_ptr<CheckQuaraFileIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckQuaraFileIdResponse checkQuaraFileId(shared_ptr<CheckQuaraFileIdRequest> request);
  CheckSecurityEventIdResponse checkSecurityEventIdWithOptions(shared_ptr<CheckSecurityEventIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckSecurityEventIdResponse checkSecurityEventId(shared_ptr<CheckSecurityEventIdRequest> request);
  CreateAntiBruteForceRuleResponse createAntiBruteForceRuleWithOptions(shared_ptr<CreateAntiBruteForceRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAntiBruteForceRuleResponse createAntiBruteForceRule(shared_ptr<CreateAntiBruteForceRuleRequest> request);
  CreateAssetResponse createAssetWithOptions(shared_ptr<CreateAssetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAssetResponse createAsset(shared_ptr<CreateAssetRequest> request);
  CreateBackupPolicyResponse createBackupPolicyWithOptions(shared_ptr<CreateBackupPolicyRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBackupPolicyResponse createBackupPolicy(shared_ptr<CreateBackupPolicyRequest> request);
  CreateOrUpdateAssetGroupResponse createOrUpdateAssetGroupWithOptions(shared_ptr<CreateOrUpdateAssetGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrUpdateAssetGroupResponse createOrUpdateAssetGroup(shared_ptr<CreateOrUpdateAssetGroupRequest> request);
  CreateRestoreJobResponse createRestoreJobWithOptions(shared_ptr<CreateRestoreJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRestoreJobResponse createRestoreJob(shared_ptr<CreateRestoreJobRequest> request);
  CreateSasOrderResponse createSasOrderWithOptions(shared_ptr<CreateSasOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSasOrderResponse createSasOrder(shared_ptr<CreateSasOrderRequest> request);
  CreateServiceLinkedRoleResponse createServiceLinkedRoleWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateServiceLinkedRoleResponse createServiceLinkedRole();
  CreateSimilarSecurityEventsQueryTaskResponse createSimilarSecurityEventsQueryTaskWithOptions(shared_ptr<CreateSimilarSecurityEventsQueryTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSimilarSecurityEventsQueryTaskResponse createSimilarSecurityEventsQueryTask(shared_ptr<CreateSimilarSecurityEventsQueryTaskRequest> request);
  DeleteAssetResponse deleteAssetWithOptions(shared_ptr<DeleteAssetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAssetResponse deleteAsset(shared_ptr<DeleteAssetRequest> request);
  DeleteBackupPolicyResponse deleteBackupPolicyWithOptions(shared_ptr<DeleteBackupPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBackupPolicyResponse deleteBackupPolicy(shared_ptr<DeleteBackupPolicyRequest> request);
  DeleteBackupPolicyMachineResponse deleteBackupPolicyMachineWithOptions(shared_ptr<DeleteBackupPolicyMachineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBackupPolicyMachineResponse deleteBackupPolicyMachine(shared_ptr<DeleteBackupPolicyMachineRequest> request);
  DeleteGroupResponse deleteGroupWithOptions(shared_ptr<DeleteGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGroupResponse deleteGroup(shared_ptr<DeleteGroupRequest> request);
  DeleteLoginBaseConfigResponse deleteLoginBaseConfigWithOptions(shared_ptr<DeleteLoginBaseConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLoginBaseConfigResponse deleteLoginBaseConfig(shared_ptr<DeleteLoginBaseConfigRequest> request);
  DeleteStrategyResponse deleteStrategyWithOptions(shared_ptr<DeleteStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteStrategyResponse deleteStrategy(shared_ptr<DeleteStrategyRequest> request);
  DeleteTagWithUuidResponse deleteTagWithUuidWithOptions(shared_ptr<DeleteTagWithUuidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTagWithUuidResponse deleteTagWithUuid(shared_ptr<DeleteTagWithUuidRequest> request);
  DeleteVpcHoneyPotResponse deleteVpcHoneyPotWithOptions(shared_ptr<DeleteVpcHoneyPotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVpcHoneyPotResponse deleteVpcHoneyPot(shared_ptr<DeleteVpcHoneyPotRequest> request);
  DescribeAccesskeyLeakListResponse describeAccesskeyLeakListWithOptions(shared_ptr<DescribeAccesskeyLeakListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAccesskeyLeakListResponse describeAccesskeyLeakList(shared_ptr<DescribeAccesskeyLeakListRequest> request);
  DescribeAffectedMaliciousFileImagesResponse describeAffectedMaliciousFileImagesWithOptions(shared_ptr<DescribeAffectedMaliciousFileImagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAffectedMaliciousFileImagesResponse describeAffectedMaliciousFileImages(shared_ptr<DescribeAffectedMaliciousFileImagesRequest> request);
  DescribeAlarmEventDetailResponse describeAlarmEventDetailWithOptions(shared_ptr<DescribeAlarmEventDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAlarmEventDetailResponse describeAlarmEventDetail(shared_ptr<DescribeAlarmEventDetailRequest> request);
  DescribeAlarmEventListResponse describeAlarmEventListWithOptions(shared_ptr<DescribeAlarmEventListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAlarmEventListResponse describeAlarmEventList(shared_ptr<DescribeAlarmEventListRequest> request);
  DescribeAlarmEventStackInfoResponse describeAlarmEventStackInfoWithOptions(shared_ptr<DescribeAlarmEventStackInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAlarmEventStackInfoResponse describeAlarmEventStackInfo(shared_ptr<DescribeAlarmEventStackInfoRequest> request);
  DescribeAllEntityResponse describeAllEntityWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAllEntityResponse describeAllEntity();
  DescribeAllGroupsResponse describeAllGroupsWithOptions(shared_ptr<DescribeAllGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAllGroupsResponse describeAllGroups(shared_ptr<DescribeAllGroupsRequest> request);
  DescribeAllRegionsStatisticsResponse describeAllRegionsStatisticsWithOptions(shared_ptr<DescribeAllRegionsStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAllRegionsStatisticsResponse describeAllRegionsStatistics(shared_ptr<DescribeAllRegionsStatisticsRequest> request);
  DescribeAntiBruteForceRulesResponse describeAntiBruteForceRulesWithOptions(shared_ptr<DescribeAntiBruteForceRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntiBruteForceRulesResponse describeAntiBruteForceRules(shared_ptr<DescribeAntiBruteForceRulesRequest> request);
  DescribeAssetDetailByUuidResponse describeAssetDetailByUuidWithOptions(shared_ptr<DescribeAssetDetailByUuidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAssetDetailByUuidResponse describeAssetDetailByUuid(shared_ptr<DescribeAssetDetailByUuidRequest> request);
  DescribeAssetDetailByUuidsResponse describeAssetDetailByUuidsWithOptions(shared_ptr<DescribeAssetDetailByUuidsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAssetDetailByUuidsResponse describeAssetDetailByUuids(shared_ptr<DescribeAssetDetailByUuidsRequest> request);
  DescribeAutoDelConfigResponse describeAutoDelConfigWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAutoDelConfigResponse describeAutoDelConfig();
  DescribeBackupClientsResponse describeBackupClientsWithOptions(shared_ptr<DescribeBackupClientsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBackupClientsResponse describeBackupClients(shared_ptr<DescribeBackupClientsRequest> request);
  DescribeBackupDirsResponse describeBackupDirsWithOptions(shared_ptr<DescribeBackupDirsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBackupDirsResponse describeBackupDirs(shared_ptr<DescribeBackupDirsRequest> request);
  DescribeBackupFilesResponse describeBackupFilesWithOptions(shared_ptr<DescribeBackupFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBackupFilesResponse describeBackupFiles(shared_ptr<DescribeBackupFilesRequest> request);
  DescribeBackupMachineStatusResponse describeBackupMachineStatusWithOptions(shared_ptr<DescribeBackupMachineStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBackupMachineStatusResponse describeBackupMachineStatus(shared_ptr<DescribeBackupMachineStatusRequest> request);
  DescribeBackupPoliciesResponse describeBackupPoliciesWithOptions(shared_ptr<DescribeBackupPoliciesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBackupPoliciesResponse describeBackupPolicies(shared_ptr<DescribeBackupPoliciesRequest> request);
  DescribeBackupPolicyResponse describeBackupPolicyWithOptions(shared_ptr<DescribeBackupPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBackupPolicyResponse describeBackupPolicy(shared_ptr<DescribeBackupPolicyRequest> request);
  DescribeBackupRestoreCountResponse describeBackupRestoreCountWithOptions(shared_ptr<DescribeBackupRestoreCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBackupRestoreCountResponse describeBackupRestoreCount(shared_ptr<DescribeBackupRestoreCountRequest> request);
  DescribeBruteForceSummaryResponse describeBruteForceSummaryWithOptions(shared_ptr<DescribeBruteForceSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBruteForceSummaryResponse describeBruteForceSummary(shared_ptr<DescribeBruteForceSummaryRequest> request);
  DescribeCheckEcsWarningsResponse describeCheckEcsWarningsWithOptions(shared_ptr<DescribeCheckEcsWarningsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCheckEcsWarningsResponse describeCheckEcsWarnings(shared_ptr<DescribeCheckEcsWarningsRequest> request);
  DescribeCheckWarningDetailResponse describeCheckWarningDetailWithOptions(shared_ptr<DescribeCheckWarningDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCheckWarningDetailResponse describeCheckWarningDetail(shared_ptr<DescribeCheckWarningDetailRequest> request);
  DescribeCheckWarningsResponse describeCheckWarningsWithOptions(shared_ptr<DescribeCheckWarningsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCheckWarningsResponse describeCheckWarnings(shared_ptr<DescribeCheckWarningsRequest> request);
  DescribeCheckWarningSummaryResponse describeCheckWarningSummaryWithOptions(shared_ptr<DescribeCheckWarningSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCheckWarningSummaryResponse describeCheckWarningSummary(shared_ptr<DescribeCheckWarningSummaryRequest> request);
  DescribeCloudCenterInstancesResponse describeCloudCenterInstancesWithOptions(shared_ptr<DescribeCloudCenterInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudCenterInstancesResponse describeCloudCenterInstances(shared_ptr<DescribeCloudCenterInstancesRequest> request);
  DescribeCloudProductFieldStatisticsResponse describeCloudProductFieldStatisticsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudProductFieldStatisticsResponse describeCloudProductFieldStatistics();
  DescribeConcernNecessityResponse describeConcernNecessityWithOptions(shared_ptr<DescribeConcernNecessityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeConcernNecessityResponse describeConcernNecessity(shared_ptr<DescribeConcernNecessityRequest> request);
  DescribeContainerStatisticsResponse describeContainerStatisticsWithOptions(shared_ptr<DescribeContainerStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeContainerStatisticsResponse describeContainerStatistics(shared_ptr<DescribeContainerStatisticsRequest> request);
  DescribeCriteriaResponse describeCriteriaWithOptions(shared_ptr<DescribeCriteriaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCriteriaResponse describeCriteria(shared_ptr<DescribeCriteriaRequest> request);
  DescribeDialogMessagesResponse describeDialogMessagesWithOptions(shared_ptr<DescribeDialogMessagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDialogMessagesResponse describeDialogMessages(shared_ptr<DescribeDialogMessagesRequest> request);
  DescribeDingTalkResponse describeDingTalkWithOptions(shared_ptr<DescribeDingTalkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDingTalkResponse describeDingTalk(shared_ptr<DescribeDingTalkRequest> request);
  DescribeDomainCountResponse describeDomainCountWithOptions(shared_ptr<DescribeDomainCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainCountResponse describeDomainCount(shared_ptr<DescribeDomainCountRequest> request);
  DescribeDomainDetailResponse describeDomainDetailWithOptions(shared_ptr<DescribeDomainDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainDetailResponse describeDomainDetail(shared_ptr<DescribeDomainDetailRequest> request);
  DescribeDomainListResponse describeDomainListWithOptions(shared_ptr<DescribeDomainListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainListResponse describeDomainList(shared_ptr<DescribeDomainListRequest> request);
  DescribeEmgVulItemResponse describeEmgVulItemWithOptions(shared_ptr<DescribeEmgVulItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEmgVulItemResponse describeEmgVulItem(shared_ptr<DescribeEmgVulItemRequest> request);
  DescribeExcludeSystemPathResponse describeExcludeSystemPathWithOptions(shared_ptr<DescribeExcludeSystemPathRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExcludeSystemPathResponse describeExcludeSystemPath(shared_ptr<DescribeExcludeSystemPathRequest> request);
  DescribeExportInfoResponse describeExportInfoWithOptions(shared_ptr<DescribeExportInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExportInfoResponse describeExportInfo(shared_ptr<DescribeExportInfoRequest> request);
  DescribeExposedInstanceCriteriaResponse describeExposedInstanceCriteriaWithOptions(shared_ptr<DescribeExposedInstanceCriteriaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExposedInstanceCriteriaResponse describeExposedInstanceCriteria(shared_ptr<DescribeExposedInstanceCriteriaRequest> request);
  DescribeExposedInstanceDetailResponse describeExposedInstanceDetailWithOptions(shared_ptr<DescribeExposedInstanceDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExposedInstanceDetailResponse describeExposedInstanceDetail(shared_ptr<DescribeExposedInstanceDetailRequest> request);
  DescribeExposedInstanceListResponse describeExposedInstanceListWithOptions(shared_ptr<DescribeExposedInstanceListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExposedInstanceListResponse describeExposedInstanceList(shared_ptr<DescribeExposedInstanceListRequest> request);
  DescribeExposedStatisticsResponse describeExposedStatisticsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExposedStatisticsResponse describeExposedStatistics();
  DescribeExposedStatisticsDetailResponse describeExposedStatisticsDetailWithOptions(shared_ptr<DescribeExposedStatisticsDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExposedStatisticsDetailResponse describeExposedStatisticsDetail(shared_ptr<DescribeExposedStatisticsDetailRequest> request);
  DescribeFieldStatisticsResponse describeFieldStatisticsWithOptions(shared_ptr<DescribeFieldStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFieldStatisticsResponse describeFieldStatistics(shared_ptr<DescribeFieldStatisticsRequest> request);
  DescribeFrontVulPatchListResponse describeFrontVulPatchListWithOptions(shared_ptr<DescribeFrontVulPatchListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFrontVulPatchListResponse describeFrontVulPatchList(shared_ptr<DescribeFrontVulPatchListRequest> request);
  DescribeGraph4InvestigationOnlineResponse describeGraph4InvestigationOnlineWithOptions(shared_ptr<DescribeGraph4InvestigationOnlineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGraph4InvestigationOnlineResponse describeGraph4InvestigationOnline(shared_ptr<DescribeGraph4InvestigationOnlineRequest> request);
  DescribeGroupedContainerInstancesResponse describeGroupedContainerInstancesWithOptions(shared_ptr<DescribeGroupedContainerInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGroupedContainerInstancesResponse describeGroupedContainerInstances(shared_ptr<DescribeGroupedContainerInstancesRequest> request);
  DescribeGroupedInstancesResponse describeGroupedInstancesWithOptions(shared_ptr<DescribeGroupedInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGroupedInstancesResponse describeGroupedInstances(shared_ptr<DescribeGroupedInstancesRequest> request);
  DescribeGroupedMaliciousFilesResponse describeGroupedMaliciousFilesWithOptions(shared_ptr<DescribeGroupedMaliciousFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGroupedMaliciousFilesResponse describeGroupedMaliciousFiles(shared_ptr<DescribeGroupedMaliciousFilesRequest> request);
  DescribeGroupedTagsResponse describeGroupedTagsWithOptions(shared_ptr<DescribeGroupedTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGroupedTagsResponse describeGroupedTags(shared_ptr<DescribeGroupedTagsRequest> request);
  DescribeGroupedVulResponse describeGroupedVulWithOptions(shared_ptr<DescribeGroupedVulRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGroupedVulResponse describeGroupedVul(shared_ptr<DescribeGroupedVulRequest> request);
  DescribeHoneyPotAuthResponse describeHoneyPotAuthWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHoneyPotAuthResponse describeHoneyPotAuth();
  DescribeHoneyPotSuspStatisticsResponse describeHoneyPotSuspStatisticsWithOptions(shared_ptr<DescribeHoneyPotSuspStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHoneyPotSuspStatisticsResponse describeHoneyPotSuspStatistics(shared_ptr<DescribeHoneyPotSuspStatisticsRequest> request);
  DescribeImageGroupedVulListResponse describeImageGroupedVulListWithOptions(shared_ptr<DescribeImageGroupedVulListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageGroupedVulListResponse describeImageGroupedVulList(shared_ptr<DescribeImageGroupedVulListRequest> request);
  DescribeImageScanAuthCountResponse describeImageScanAuthCountWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageScanAuthCountResponse describeImageScanAuthCount();
  DescribeImageStatisticsResponse describeImageStatisticsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageStatisticsResponse describeImageStatistics();
  DescribeImageVulListResponse describeImageVulListWithOptions(shared_ptr<DescribeImageVulListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageVulListResponse describeImageVulList(shared_ptr<DescribeImageVulListRequest> request);
  DescribeInstallCaptchaResponse describeInstallCaptchaWithOptions(shared_ptr<DescribeInstallCaptchaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstallCaptchaResponse describeInstallCaptcha(shared_ptr<DescribeInstallCaptchaRequest> request);
  DescribeInstanceAntiBruteForceRulesResponse describeInstanceAntiBruteForceRulesWithOptions(shared_ptr<DescribeInstanceAntiBruteForceRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceAntiBruteForceRulesResponse describeInstanceAntiBruteForceRules(shared_ptr<DescribeInstanceAntiBruteForceRulesRequest> request);
  DescribeInstanceStatisticsResponse describeInstanceStatisticsWithOptions(shared_ptr<DescribeInstanceStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceStatisticsResponse describeInstanceStatistics(shared_ptr<DescribeInstanceStatisticsRequest> request);
  DescribeIpInfoResponse describeIpInfoWithOptions(shared_ptr<DescribeIpInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIpInfoResponse describeIpInfo(shared_ptr<DescribeIpInfoRequest> request);
  DescribeLogstoreStorageResponse describeLogstoreStorageWithOptions(shared_ptr<DescribeLogstoreStorageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLogstoreStorageResponse describeLogstoreStorage(shared_ptr<DescribeLogstoreStorageRequest> request);
  DescribeModuleConfigResponse describeModuleConfigWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeModuleConfigResponse describeModuleConfig();
  DescribeNoticeConfigResponse describeNoticeConfigWithOptions(shared_ptr<DescribeNoticeConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNoticeConfigResponse describeNoticeConfig(shared_ptr<DescribeNoticeConfigRequest> request);
  DescribePropertyCountResponse describePropertyCountWithOptions(shared_ptr<DescribePropertyCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyCountResponse describePropertyCount(shared_ptr<DescribePropertyCountRequest> request);
  DescribePropertyCronDetailResponse describePropertyCronDetailWithOptions(shared_ptr<DescribePropertyCronDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyCronDetailResponse describePropertyCronDetail(shared_ptr<DescribePropertyCronDetailRequest> request);
  DescribePropertyPortDetailResponse describePropertyPortDetailWithOptions(shared_ptr<DescribePropertyPortDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyPortDetailResponse describePropertyPortDetail(shared_ptr<DescribePropertyPortDetailRequest> request);
  DescribePropertyPortItemResponse describePropertyPortItemWithOptions(shared_ptr<DescribePropertyPortItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyPortItemResponse describePropertyPortItem(shared_ptr<DescribePropertyPortItemRequest> request);
  DescribePropertyProcDetailResponse describePropertyProcDetailWithOptions(shared_ptr<DescribePropertyProcDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyProcDetailResponse describePropertyProcDetail(shared_ptr<DescribePropertyProcDetailRequest> request);
  DescribePropertyProcItemResponse describePropertyProcItemWithOptions(shared_ptr<DescribePropertyProcItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyProcItemResponse describePropertyProcItem(shared_ptr<DescribePropertyProcItemRequest> request);
  DescribePropertyScaDetailResponse describePropertyScaDetailWithOptions(shared_ptr<DescribePropertyScaDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyScaDetailResponse describePropertyScaDetail(shared_ptr<DescribePropertyScaDetailRequest> request);
  DescribePropertySoftwareDetailResponse describePropertySoftwareDetailWithOptions(shared_ptr<DescribePropertySoftwareDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertySoftwareDetailResponse describePropertySoftwareDetail(shared_ptr<DescribePropertySoftwareDetailRequest> request);
  DescribePropertySoftwareItemResponse describePropertySoftwareItemWithOptions(shared_ptr<DescribePropertySoftwareItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertySoftwareItemResponse describePropertySoftwareItem(shared_ptr<DescribePropertySoftwareItemRequest> request);
  DescribePropertyUsageNewestResponse describePropertyUsageNewestWithOptions(shared_ptr<DescribePropertyUsageNewestRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyUsageNewestResponse describePropertyUsageNewest(shared_ptr<DescribePropertyUsageNewestRequest> request);
  DescribePropertyUserDetailResponse describePropertyUserDetailWithOptions(shared_ptr<DescribePropertyUserDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyUserDetailResponse describePropertyUserDetail(shared_ptr<DescribePropertyUserDetailRequest> request);
  DescribePropertyUserItemResponse describePropertyUserItemWithOptions(shared_ptr<DescribePropertyUserItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyUserItemResponse describePropertyUserItem(shared_ptr<DescribePropertyUserItemRequest> request);
  DescribeQuaraFileDownloadInfoResponse describeQuaraFileDownloadInfoWithOptions(shared_ptr<DescribeQuaraFileDownloadInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeQuaraFileDownloadInfoResponse describeQuaraFileDownloadInfo(shared_ptr<DescribeQuaraFileDownloadInfoRequest> request);
  DescribeRestoreJobsResponse describeRestoreJobsWithOptions(shared_ptr<DescribeRestoreJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRestoreJobsResponse describeRestoreJobs(shared_ptr<DescribeRestoreJobsRequest> request);
  DescribeRiskCheckItemResultResponse describeRiskCheckItemResultWithOptions(shared_ptr<DescribeRiskCheckItemResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRiskCheckItemResultResponse describeRiskCheckItemResult(shared_ptr<DescribeRiskCheckItemResultRequest> request);
  DescribeRiskCheckResultResponse describeRiskCheckResultWithOptions(shared_ptr<DescribeRiskCheckResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRiskCheckResultResponse describeRiskCheckResult(shared_ptr<DescribeRiskCheckResultRequest> request);
  DescribeRiskCheckSummaryResponse describeRiskCheckSummaryWithOptions(shared_ptr<DescribeRiskCheckSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRiskCheckSummaryResponse describeRiskCheckSummary(shared_ptr<DescribeRiskCheckSummaryRequest> request);
  DescribeRiskItemTypeResponse describeRiskItemTypeWithOptions(shared_ptr<DescribeRiskItemTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRiskItemTypeResponse describeRiskItemType(shared_ptr<DescribeRiskItemTypeRequest> request);
  DescribeRiskListCheckResultResponse describeRiskListCheckResultWithOptions(shared_ptr<DescribeRiskListCheckResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRiskListCheckResultResponse describeRiskListCheckResult(shared_ptr<DescribeRiskListCheckResultRequest> request);
  DescribeSasAssetStatisticsColumnResponse describeSasAssetStatisticsColumnWithOptions(shared_ptr<DescribeSasAssetStatisticsColumnRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSasAssetStatisticsColumnResponse describeSasAssetStatisticsColumn(shared_ptr<DescribeSasAssetStatisticsColumnRequest> request);
  DescribeScanTaskProgressResponse describeScanTaskProgressWithOptions(shared_ptr<DescribeScanTaskProgressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScanTaskProgressResponse describeScanTaskProgress(shared_ptr<DescribeScanTaskProgressRequest> request);
  DescribeSearchConditionResponse describeSearchConditionWithOptions(shared_ptr<DescribeSearchConditionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSearchConditionResponse describeSearchCondition(shared_ptr<DescribeSearchConditionRequest> request);
  DescribeSecureSuggestionResponse describeSecureSuggestionWithOptions(shared_ptr<DescribeSecureSuggestionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecureSuggestionResponse describeSecureSuggestion(shared_ptr<DescribeSecureSuggestionRequest> request);
  DescribeSecurityCheckScheduleConfigResponse describeSecurityCheckScheduleConfigWithOptions(shared_ptr<DescribeSecurityCheckScheduleConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecurityCheckScheduleConfigResponse describeSecurityCheckScheduleConfig(shared_ptr<DescribeSecurityCheckScheduleConfigRequest> request);
  DescribeSecurityEventOperationsResponse describeSecurityEventOperationsWithOptions(shared_ptr<DescribeSecurityEventOperationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecurityEventOperationsResponse describeSecurityEventOperations(shared_ptr<DescribeSecurityEventOperationsRequest> request);
  DescribeSecurityEventOperationStatusResponse describeSecurityEventOperationStatusWithOptions(shared_ptr<DescribeSecurityEventOperationStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecurityEventOperationStatusResponse describeSecurityEventOperationStatus(shared_ptr<DescribeSecurityEventOperationStatusRequest> request);
  DescribeSecurityStatInfoResponse describeSecurityStatInfoWithOptions(shared_ptr<DescribeSecurityStatInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecurityStatInfoResponse describeSecurityStatInfo(shared_ptr<DescribeSecurityStatInfoRequest> request);
  DescribeServiceLinkedRoleStatusResponse describeServiceLinkedRoleStatusWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeServiceLinkedRoleStatusResponse describeServiceLinkedRoleStatus();
  DescribeSimilarEventScenariosResponse describeSimilarEventScenariosWithOptions(shared_ptr<DescribeSimilarEventScenariosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSimilarEventScenariosResponse describeSimilarEventScenarios(shared_ptr<DescribeSimilarEventScenariosRequest> request);
  DescribeSimilarSecurityEventsResponse describeSimilarSecurityEventsWithOptions(shared_ptr<DescribeSimilarSecurityEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSimilarSecurityEventsResponse describeSimilarSecurityEvents(shared_ptr<DescribeSimilarSecurityEventsRequest> request);
  DescribeSnapshotsResponse describeSnapshotsWithOptions(shared_ptr<DescribeSnapshotsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSnapshotsResponse describeSnapshots(shared_ptr<DescribeSnapshotsRequest> request);
  DescribeStrategyResponse describeStrategyWithOptions(shared_ptr<DescribeStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStrategyResponse describeStrategy(shared_ptr<DescribeStrategyRequest> request);
  DescribeStrategyExecDetailResponse describeStrategyExecDetailWithOptions(shared_ptr<DescribeStrategyExecDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStrategyExecDetailResponse describeStrategyExecDetail(shared_ptr<DescribeStrategyExecDetailRequest> request);
  DescribeStrategyProcessResponse describeStrategyProcessWithOptions(shared_ptr<DescribeStrategyProcessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStrategyProcessResponse describeStrategyProcess(shared_ptr<DescribeStrategyProcessRequest> request);
  DescribeStrategyTargetResponse describeStrategyTargetWithOptions(shared_ptr<DescribeStrategyTargetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStrategyTargetResponse describeStrategyTarget(shared_ptr<DescribeStrategyTargetRequest> request);
  DescribeSummaryInfoResponse describeSummaryInfoWithOptions(shared_ptr<DescribeSummaryInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSummaryInfoResponse describeSummaryInfo(shared_ptr<DescribeSummaryInfoRequest> request);
  DescribeSupportRegionResponse describeSupportRegionWithOptions(shared_ptr<DescribeSupportRegionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSupportRegionResponse describeSupportRegion(shared_ptr<DescribeSupportRegionRequest> request);
  DescribeSuspEventDetailResponse describeSuspEventDetailWithOptions(shared_ptr<DescribeSuspEventDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSuspEventDetailResponse describeSuspEventDetail(shared_ptr<DescribeSuspEventDetailRequest> request);
  DescribeSuspEventQuaraFilesResponse describeSuspEventQuaraFilesWithOptions(shared_ptr<DescribeSuspEventQuaraFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSuspEventQuaraFilesResponse describeSuspEventQuaraFiles(shared_ptr<DescribeSuspEventQuaraFilesRequest> request);
  DescribeSuspEventsResponse describeSuspEventsWithOptions(shared_ptr<DescribeSuspEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSuspEventsResponse describeSuspEvents(shared_ptr<DescribeSuspEventsRequest> request);
  DescribeUserBackupMachinesResponse describeUserBackupMachinesWithOptions(shared_ptr<DescribeUserBackupMachinesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserBackupMachinesResponse describeUserBackupMachines(shared_ptr<DescribeUserBackupMachinesRequest> request);
  DescribeUserBaselineAuthorizationResponse describeUserBaselineAuthorizationWithOptions(shared_ptr<DescribeUserBaselineAuthorizationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserBaselineAuthorizationResponse describeUserBaselineAuthorization(shared_ptr<DescribeUserBaselineAuthorizationRequest> request);
  DescribeUserLayoutAuthorizationResponse describeUserLayoutAuthorizationWithOptions(shared_ptr<DescribeUserLayoutAuthorizationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserLayoutAuthorizationResponse describeUserLayoutAuthorization(shared_ptr<DescribeUserLayoutAuthorizationRequest> request);
  DescribeUuidsByVulNamesResponse describeUuidsByVulNamesWithOptions(shared_ptr<DescribeUuidsByVulNamesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUuidsByVulNamesResponse describeUuidsByVulNames(shared_ptr<DescribeUuidsByVulNamesRequest> request);
  DescribeVersionConfigResponse describeVersionConfigWithOptions(shared_ptr<DescribeVersionConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVersionConfigResponse describeVersionConfig(shared_ptr<DescribeVersionConfigRequest> request);
  DescribeVolDingdingMessageResponse describeVolDingdingMessageWithOptions(shared_ptr<DescribeVolDingdingMessageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVolDingdingMessageResponse describeVolDingdingMessage(shared_ptr<DescribeVolDingdingMessageRequest> request);
  DescribeVpcHoneyPotCriteriaResponse describeVpcHoneyPotCriteriaWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVpcHoneyPotCriteriaResponse describeVpcHoneyPotCriteria();
  DescribeVpcHoneyPotListResponse describeVpcHoneyPotListWithOptions(shared_ptr<DescribeVpcHoneyPotListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVpcHoneyPotListResponse describeVpcHoneyPotList(shared_ptr<DescribeVpcHoneyPotListRequest> request);
  DescribeVpcListResponse describeVpcListWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVpcListResponse describeVpcList();
  DescribeVulDetailsResponse describeVulDetailsWithOptions(shared_ptr<DescribeVulDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVulDetailsResponse describeVulDetails(shared_ptr<DescribeVulDetailsRequest> request);
  DescribeVulListResponse describeVulListWithOptions(shared_ptr<DescribeVulListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVulListResponse describeVulList(shared_ptr<DescribeVulListRequest> request);
  DescribeVulWhitelistResponse describeVulWhitelistWithOptions(shared_ptr<DescribeVulWhitelistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVulWhitelistResponse describeVulWhitelist(shared_ptr<DescribeVulWhitelistRequest> request);
  DescribeWarningMachinesResponse describeWarningMachinesWithOptions(shared_ptr<DescribeWarningMachinesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWarningMachinesResponse describeWarningMachines(shared_ptr<DescribeWarningMachinesRequest> request);
  DescribeWebLockBindListResponse describeWebLockBindListWithOptions(shared_ptr<DescribeWebLockBindListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebLockBindListResponse describeWebLockBindList(shared_ptr<DescribeWebLockBindListRequest> request);
  DescribeWebLockConfigListResponse describeWebLockConfigListWithOptions(shared_ptr<DescribeWebLockConfigListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebLockConfigListResponse describeWebLockConfigList(shared_ptr<DescribeWebLockConfigListRequest> request);
  ExecStrategyResponse execStrategyWithOptions(shared_ptr<ExecStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecStrategyResponse execStrategy(shared_ptr<ExecStrategyRequest> request);
  ExportRecordResponse exportRecordWithOptions(shared_ptr<ExportRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportRecordResponse exportRecord(shared_ptr<ExportRecordRequest> request);
  FixCheckWarningsResponse fixCheckWarningsWithOptions(shared_ptr<FixCheckWarningsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FixCheckWarningsResponse fixCheckWarnings(shared_ptr<FixCheckWarningsRequest> request);
  GetBackupStorageCountResponse getBackupStorageCountWithOptions(shared_ptr<GetBackupStorageCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBackupStorageCountResponse getBackupStorageCount(shared_ptr<GetBackupStorageCountRequest> request);
  GetIncIOCsResponse getIncIOCsWithOptions(shared_ptr<GetIncIOCsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetIncIOCsResponse getIncIOCs(shared_ptr<GetIncIOCsRequest> request);
  GetIOCsResponse getIOCsWithOptions(shared_ptr<GetIOCsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetIOCsResponse getIOCs(shared_ptr<GetIOCsRequest> request);
  GetLocalInstallScriptResponse getLocalInstallScriptWithOptions(shared_ptr<GetLocalInstallScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLocalInstallScriptResponse getLocalInstallScript(shared_ptr<GetLocalInstallScriptRequest> request);
  GetLocalUninstallScriptResponse getLocalUninstallScriptWithOptions(shared_ptr<GetLocalUninstallScriptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLocalUninstallScriptResponse getLocalUninstallScript(shared_ptr<GetLocalUninstallScriptRequest> request);
  GetSuspiciousStatisticsResponse getSuspiciousStatisticsWithOptions(shared_ptr<GetSuspiciousStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSuspiciousStatisticsResponse getSuspiciousStatistics(shared_ptr<GetSuspiciousStatisticsRequest> request);
  GetVulStatisticsResponse getVulStatisticsWithOptions(shared_ptr<GetVulStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVulStatisticsResponse getVulStatistics(shared_ptr<GetVulStatisticsRequest> request);
  HandleSecurityEventsResponse handleSecurityEventsWithOptions(shared_ptr<HandleSecurityEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HandleSecurityEventsResponse handleSecurityEvents(shared_ptr<HandleSecurityEventsRequest> request);
  HandleSimilarSecurityEventsResponse handleSimilarSecurityEventsWithOptions(shared_ptr<HandleSimilarSecurityEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HandleSimilarSecurityEventsResponse handleSimilarSecurityEvents(shared_ptr<HandleSimilarSecurityEventsRequest> request);
  IgnoreHcCheckWarningsResponse ignoreHcCheckWarningsWithOptions(shared_ptr<IgnoreHcCheckWarningsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  IgnoreHcCheckWarningsResponse ignoreHcCheckWarnings(shared_ptr<IgnoreHcCheckWarningsRequest> request);
  InstallBackupClientResponse installBackupClientWithOptions(shared_ptr<InstallBackupClientRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallBackupClientResponse installBackupClient(shared_ptr<InstallBackupClientRequest> request);
  ModifyAntiBruteForceRuleResponse modifyAntiBruteForceRuleWithOptions(shared_ptr<ModifyAntiBruteForceRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAntiBruteForceRuleResponse modifyAntiBruteForceRule(shared_ptr<ModifyAntiBruteForceRuleRequest> request);
  ModifyAssetGroupResponse modifyAssetGroupWithOptions(shared_ptr<ModifyAssetGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAssetGroupResponse modifyAssetGroup(shared_ptr<ModifyAssetGroupRequest> request);
  ModifyBackupPolicyResponse modifyBackupPolicyWithOptions(shared_ptr<ModifyBackupPolicyRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyBackupPolicyResponse modifyBackupPolicy(shared_ptr<ModifyBackupPolicyRequest> request);
  ModifyBackupPolicyStatusResponse modifyBackupPolicyStatusWithOptions(shared_ptr<ModifyBackupPolicyStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyBackupPolicyStatusResponse modifyBackupPolicyStatus(shared_ptr<ModifyBackupPolicyStatusRequest> request);
  ModifyCreateVulWhitelistResponse modifyCreateVulWhitelistWithOptions(shared_ptr<ModifyCreateVulWhitelistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCreateVulWhitelistResponse modifyCreateVulWhitelist(shared_ptr<ModifyCreateVulWhitelistRequest> request);
  ModifyEmgVulSubmitResponse modifyEmgVulSubmitWithOptions(shared_ptr<ModifyEmgVulSubmitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyEmgVulSubmitResponse modifyEmgVulSubmit(shared_ptr<ModifyEmgVulSubmitRequest> request);
  ModifyGroupPropertyResponse modifyGroupPropertyWithOptions(shared_ptr<ModifyGroupPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyGroupPropertyResponse modifyGroupProperty(shared_ptr<ModifyGroupPropertyRequest> request);
  ModifyInstanceAntiBruteForceRuleResponse modifyInstanceAntiBruteForceRuleWithOptions(shared_ptr<ModifyInstanceAntiBruteForceRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceAntiBruteForceRuleResponse modifyInstanceAntiBruteForceRule(shared_ptr<ModifyInstanceAntiBruteForceRuleRequest> request);
  ModifyLoginBaseConfigResponse modifyLoginBaseConfigWithOptions(shared_ptr<ModifyLoginBaseConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLoginBaseConfigResponse modifyLoginBaseConfig(shared_ptr<ModifyLoginBaseConfigRequest> request);
  ModifyLoginSwitchConfigResponse modifyLoginSwitchConfigWithOptions(shared_ptr<ModifyLoginSwitchConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLoginSwitchConfigResponse modifyLoginSwitchConfig(shared_ptr<ModifyLoginSwitchConfigRequest> request);
  ModifyNoticeConfigResponse modifyNoticeConfigWithOptions(shared_ptr<ModifyNoticeConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyNoticeConfigResponse modifyNoticeConfig(shared_ptr<ModifyNoticeConfigRequest> request);
  ModifyOpenLogShipperResponse modifyOpenLogShipperWithOptions(shared_ptr<ModifyOpenLogShipperRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyOpenLogShipperResponse modifyOpenLogShipper(shared_ptr<ModifyOpenLogShipperRequest> request);
  ModifyOperateVulResponse modifyOperateVulWithOptions(shared_ptr<ModifyOperateVulRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyOperateVulResponse modifyOperateVul(shared_ptr<ModifyOperateVulRequest> request);
  ModifyPushAllTaskResponse modifyPushAllTaskWithOptions(shared_ptr<ModifyPushAllTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPushAllTaskResponse modifyPushAllTask(shared_ptr<ModifyPushAllTaskRequest> request);
  ModifyRiskCheckStatusResponse modifyRiskCheckStatusWithOptions(shared_ptr<ModifyRiskCheckStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyRiskCheckStatusResponse modifyRiskCheckStatus(shared_ptr<ModifyRiskCheckStatusRequest> request);
  ModifyRiskSingleResultStatusResponse modifyRiskSingleResultStatusWithOptions(shared_ptr<ModifyRiskSingleResultStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyRiskSingleResultStatusResponse modifyRiskSingleResultStatus(shared_ptr<ModifyRiskSingleResultStatusRequest> request);
  ModifySecurityCheckScheduleConfigResponse modifySecurityCheckScheduleConfigWithOptions(shared_ptr<ModifySecurityCheckScheduleConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySecurityCheckScheduleConfigResponse modifySecurityCheckScheduleConfig(shared_ptr<ModifySecurityCheckScheduleConfigRequest> request);
  ModifyStartVulScanResponse modifyStartVulScanWithOptions(shared_ptr<ModifyStartVulScanRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyStartVulScanResponse modifyStartVulScan(shared_ptr<ModifyStartVulScanRequest> request);
  ModifyStrategyResponse modifyStrategyWithOptions(shared_ptr<ModifyStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyStrategyResponse modifyStrategy(shared_ptr<ModifyStrategyRequest> request);
  ModifyStrategyTargetResponse modifyStrategyTargetWithOptions(shared_ptr<ModifyStrategyTargetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyStrategyTargetResponse modifyStrategyTarget(shared_ptr<ModifyStrategyTargetRequest> request);
  ModifyTagWithUuidResponse modifyTagWithUuidWithOptions(shared_ptr<ModifyTagWithUuidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTagWithUuidResponse modifyTagWithUuid(shared_ptr<ModifyTagWithUuidRequest> request);
  ModifyVpcHoneyPotResponse modifyVpcHoneyPotWithOptions(shared_ptr<ModifyVpcHoneyPotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVpcHoneyPotResponse modifyVpcHoneyPot(shared_ptr<ModifyVpcHoneyPotRequest> request);
  ModifyVulTargetConfigResponse modifyVulTargetConfigWithOptions(shared_ptr<ModifyVulTargetConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVulTargetConfigResponse modifyVulTargetConfig(shared_ptr<ModifyVulTargetConfigRequest> request);
  ModifyWebLockCreateConfigResponse modifyWebLockCreateConfigWithOptions(shared_ptr<ModifyWebLockCreateConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebLockCreateConfigResponse modifyWebLockCreateConfig(shared_ptr<ModifyWebLockCreateConfigRequest> request);
  ModifyWebLockDeleteConfigResponse modifyWebLockDeleteConfigWithOptions(shared_ptr<ModifyWebLockDeleteConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebLockDeleteConfigResponse modifyWebLockDeleteConfig(shared_ptr<ModifyWebLockDeleteConfigRequest> request);
  ModifyWebLockStartResponse modifyWebLockStartWithOptions(shared_ptr<ModifyWebLockStartRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebLockStartResponse modifyWebLockStart(shared_ptr<ModifyWebLockStartRequest> request);
  ModifyWebLockStatusResponse modifyWebLockStatusWithOptions(shared_ptr<ModifyWebLockStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebLockStatusResponse modifyWebLockStatus(shared_ptr<ModifyWebLockStatusRequest> request);
  ModifyWebLockUnbindResponse modifyWebLockUnbindWithOptions(shared_ptr<ModifyWebLockUnbindRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebLockUnbindResponse modifyWebLockUnbind(shared_ptr<ModifyWebLockUnbindRequest> request);
  ModifyWebLockUpdateConfigResponse modifyWebLockUpdateConfigWithOptions(shared_ptr<ModifyWebLockUpdateConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebLockUpdateConfigResponse modifyWebLockUpdateConfig(shared_ptr<ModifyWebLockUpdateConfigRequest> request);
  OperateSuspiciousTargetConfigResponse operateSuspiciousTargetConfigWithOptions(shared_ptr<OperateSuspiciousTargetConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OperateSuspiciousTargetConfigResponse operateSuspiciousTargetConfig(shared_ptr<OperateSuspiciousTargetConfigRequest> request);
  OperateVulsResponse operateVulsWithOptions(shared_ptr<OperateVulsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OperateVulsResponse operateVuls(shared_ptr<OperateVulsRequest> request);
  OperationSuspEventsResponse operationSuspEventsWithOptions(shared_ptr<OperationSuspEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OperationSuspEventsResponse operationSuspEvents(shared_ptr<OperationSuspEventsRequest> request);
  PauseClientResponse pauseClientWithOptions(shared_ptr<PauseClientRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PauseClientResponse pauseClient(shared_ptr<PauseClientRequest> request);
  RefreshContainerAssetsResponse refreshContainerAssetsWithOptions(shared_ptr<RefreshContainerAssetsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefreshContainerAssetsResponse refreshContainerAssets(shared_ptr<RefreshContainerAssetsRequest> request);
  RollbackSuspEventQuaraFileResponse rollbackSuspEventQuaraFileWithOptions(shared_ptr<RollbackSuspEventQuaraFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RollbackSuspEventQuaraFileResponse rollbackSuspEventQuaraFile(shared_ptr<RollbackSuspEventQuaraFileRequest> request);
  SasInstallCodeResponse sasInstallCodeWithOptions(shared_ptr<SasInstallCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SasInstallCodeResponse sasInstallCode(shared_ptr<SasInstallCodeRequest> request);
  StartBaselineSecurityCheckResponse startBaselineSecurityCheckWithOptions(shared_ptr<StartBaselineSecurityCheckRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartBaselineSecurityCheckResponse startBaselineSecurityCheck(shared_ptr<StartBaselineSecurityCheckRequest> request);
  StartImageVulScanResponse startImageVulScanWithOptions(shared_ptr<StartImageVulScanRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartImageVulScanResponse startImageVulScan(shared_ptr<StartImageVulScanRequest> request);
  StartVirusScanTaskResponse startVirusScanTaskWithOptions(shared_ptr<StartVirusScanTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartVirusScanTaskResponse startVirusScanTask(shared_ptr<StartVirusScanTaskRequest> request);
  UnbindAegisResponse unbindAegisWithOptions(shared_ptr<UnbindAegisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindAegisResponse unbindAegis(shared_ptr<UnbindAegisRequest> request);
  UninstallBackupClientResponse uninstallBackupClientWithOptions(shared_ptr<UninstallBackupClientRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UninstallBackupClientResponse uninstallBackupClient(shared_ptr<UninstallBackupClientRequest> request);
  ValidateHcWarningsResponse validateHcWarningsWithOptions(shared_ptr<ValidateHcWarningsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ValidateHcWarningsResponse validateHcWarnings(shared_ptr<ValidateHcWarningsRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Sas20181203

#endif
